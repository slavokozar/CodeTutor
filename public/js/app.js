/*!
 * jQuery JavaScript Library v2.2.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:23Z
 */

(function( global, factory ) {

    if ( typeof module === "object" && typeof module.exports === "object" ) {
        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ?
            factory( global, true ) :
            function( w ) {
                if ( !w.document ) {
                    throw new Error( "jQuery requires a window with a document" );
                }
                return factory( w );
            };
    } else {
        factory( global );
    }

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//"use strict";
    var arr = [];

    var document = window.document;

    var slice = arr.slice;

    var concat = arr.concat;

    var push = arr.push;

    var indexOf = arr.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var support = {};



    var
        version = "2.2.4",

        // Define a local copy of jQuery
        jQuery = function( selector, context ) {

            // The jQuery object is actually just the init constructor 'enhanced'
            // Need init if jQuery is called (just allow error to be thrown if not included)
            return new jQuery.fn.init( selector, context );
        },

        // Support: Android<4.1
        // Make sure we trim BOM and NBSP
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

        // Matches dashed string for camelizing
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,

        // Used by jQuery.camelCase as callback to replace()
        fcamelCase = function( all, letter ) {
            return letter.toUpperCase();
        };

    jQuery.fn = jQuery.prototype = {

        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // Start with an empty selector
        selector: "",

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function() {
            return slice.call( this );
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function( num ) {
            return num != null ?

                // Return just the one element from the set
                ( num < 0 ? this[ num + this.length ] : this[ num ] ) :

                // Return all the elements in a clean array
                slice.call( this );
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function( elems ) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge( this.constructor(), elems );

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            ret.context = this.context;

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        each: function( callback ) {
            return jQuery.each( this, callback );
        },

        map: function( callback ) {
            return this.pushStack( jQuery.map( this, function( elem, i ) {
                return callback.call( elem, i, elem );
            } ) );
        },

        slice: function() {
            return this.pushStack( slice.apply( this, arguments ) );
        },

        first: function() {
            return this.eq( 0 );
        },

        last: function() {
            return this.eq( -1 );
        },

        eq: function( i ) {
            var len = this.length,
                j = +i + ( i < 0 ? len : 0 );
            return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
        },

        end: function() {
            return this.prevObject || this.constructor();
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[ 0 ] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;

            // Skip the boolean and the target
            target = arguments[ i ] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if ( i === length ) {
            target = this;
            i--;
        }

        for ( ; i < length; i++ ) {

            // Only deal with non-null/undefined values
            if ( ( options = arguments[ i ] ) != null ) {

                // Extend the base object
                for ( name in options ) {
                    src = target[ name ];
                    copy = options[ name ];

                    // Prevent never-ending loop
                    if ( target === copy ) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
                            ( copyIsArray = jQuery.isArray( copy ) ) ) ) {

                        if ( copyIsArray ) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray( src ) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject( src ) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );

                        // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend( {

        // Unique for each copy of jQuery on the page
        expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function( msg ) {
            throw new Error( msg );
        },

        noop: function() {},

        isFunction: function( obj ) {
            return jQuery.type( obj ) === "function";
        },

        isArray: Array.isArray,

        isWindow: function( obj ) {
            return obj != null && obj === obj.window;
        },

        isNumeric: function( obj ) {

            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            // adding 1 corrects loss of precision from parseFloat (#15100)
            var realStringObj = obj && obj.toString();
            return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
        },

        isPlainObject: function( obj ) {
            var key;

            // Not plain objects:
            // - Any object or value whose internal [[Class]] property is not "[object Object]"
            // - DOM nodes
            // - window
            if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                return false;
            }

            // Not own constructor property must be Object
            if ( obj.constructor &&
                !hasOwn.call( obj, "constructor" ) &&
                !hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
                return false;
            }

            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own
            for ( key in obj ) {}

            return key === undefined || hasOwn.call( obj, key );
        },

        isEmptyObject: function( obj ) {
            var name;
            for ( name in obj ) {
                return false;
            }
            return true;
        },

        type: function( obj ) {
            if ( obj == null ) {
                return obj + "";
            }

            // Support: Android<4.0, iOS<6 (functionish RegExp)
            return typeof obj === "object" || typeof obj === "function" ?
                class2type[ toString.call( obj ) ] || "object" :
                typeof obj;
        },

        // Evaluates a script in a global context
        globalEval: function( code ) {
            var script,
                indirect = eval;

            code = jQuery.trim( code );

            if ( code ) {

                // If the code includes a valid, prologue position
                // strict mode pragma, execute code by injecting a
                // script tag into the document.
                if ( code.indexOf( "use strict" ) === 1 ) {
                    script = document.createElement( "script" );
                    script.text = code;
                    document.head.appendChild( script ).parentNode.removeChild( script );
                } else {

                    // Otherwise, avoid the DOM node creation, insertion
                    // and removal by using an indirect global eval

                    indirect( code );
                }
            }
        },

        // Convert dashed to camelCase; used by the css and data modules
        // Support: IE9-11+
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function( string ) {
            return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
        },

        nodeName: function( elem, name ) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },

        each: function( obj, callback ) {
            var length, i = 0;

            if ( isArrayLike( obj ) ) {
                length = obj.length;
                for ( ; i < length; i++ ) {
                    if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                        break;
                    }
                }
            } else {
                for ( i in obj ) {
                    if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                        break;
                    }
                }
            }

            return obj;
        },

        // Support: Android<4.1
        trim: function( text ) {
            return text == null ?
                "" :
                ( text + "" ).replace( rtrim, "" );
        },

        // results is for internal usage only
        makeArray: function( arr, results ) {
            var ret = results || [];

            if ( arr != null ) {
                if ( isArrayLike( Object( arr ) ) ) {
                    jQuery.merge( ret,
                        typeof arr === "string" ?
                            [ arr ] : arr
                    );
                } else {
                    push.call( ret, arr );
                }
            }

            return ret;
        },

        inArray: function( elem, arr, i ) {
            return arr == null ? -1 : indexOf.call( arr, elem, i );
        },

        merge: function( first, second ) {
            var len = +second.length,
                j = 0,
                i = first.length;

            for ( ; j < len; j++ ) {
                first[ i++ ] = second[ j ];
            }

            first.length = i;

            return first;
        },

        grep: function( elems, callback, invert ) {
            var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;

            // Go through the array, only saving the items
            // that pass the validator function
            for ( ; i < length; i++ ) {
                callbackInverse = !callback( elems[ i ], i );
                if ( callbackInverse !== callbackExpect ) {
                    matches.push( elems[ i ] );
                }
            }

            return matches;
        },

        // arg is for internal usage only
        map: function( elems, callback, arg ) {
            var length, value,
                i = 0,
                ret = [];

            // Go through the array, translating each of the items to their new values
            if ( isArrayLike( elems ) ) {
                length = elems.length;
                for ( ; i < length; i++ ) {
                    value = callback( elems[ i ], i, arg );

                    if ( value != null ) {
                        ret.push( value );
                    }
                }

                // Go through every key on the object,
            } else {
                for ( i in elems ) {
                    value = callback( elems[ i ], i, arg );

                    if ( value != null ) {
                        ret.push( value );
                    }
                }
            }

            // Flatten any nested arrays
            return concat.apply( [], ret );
        },

        // A global GUID counter for objects
        guid: 1,

        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function( fn, context ) {
            var tmp, args, proxy;

            if ( typeof context === "string" ) {
                tmp = fn[ context ];
                context = fn;
                fn = tmp;
            }

            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if ( !jQuery.isFunction( fn ) ) {
                return undefined;
            }

            // Simulated bind
            args = slice.call( arguments, 2 );
            proxy = function() {
                return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
            };

            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;

            return proxy;
        },

        now: Date.now,

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    } );

// JSHint would error on this code due to the Symbol not being defined in ES5.
// Defining this global in .jshintrc would create a danger of using the global
// unguarded in another place, it seems safer to just disable JSHint for these
// three lines.
    /* jshint ignore: start */
    if ( typeof Symbol === "function" ) {
        jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
    }
    /* jshint ignore: end */

// Populate the class2type map
    jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
        function( i, name ) {
            class2type[ "[object " + name + "]" ] = name.toLowerCase();
        } );

    function isArrayLike( obj ) {

        // Support: iOS 8.2 (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length,
            type = jQuery.type( obj );

        if ( type === "function" || jQuery.isWindow( obj ) ) {
            return false;
        }

        return type === "array" || length === 0 ||
            typeof length === "number" && length > 0 && ( length - 1 ) in obj;
    }
    var Sizzle =
        /*!
 * Sizzle CSS Selector Engine v2.2.1
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-10-17
 */
        (function( window ) {

            var i,
                support,
                Expr,
                getText,
                isXML,
                tokenize,
                compile,
                select,
                outermostContext,
                sortInput,
                hasDuplicate,

                // Local document vars
                setDocument,
                document,
                docElem,
                documentIsHTML,
                rbuggyQSA,
                rbuggyMatches,
                matches,
                contains,

                // Instance-specific data
                expando = "sizzle" + 1 * new Date(),
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                sortOrder = function( a, b ) {
                    if ( a === b ) {
                        hasDuplicate = true;
                    }
                    return 0;
                },

                // General-purpose constants
                MAX_NEGATIVE = 1 << 31,

                // Instance methods
                hasOwn = ({}).hasOwnProperty,
                arr = [],
                pop = arr.pop,
                push_native = arr.push,
                push = arr.push,
                slice = arr.slice,
                // Use a stripped-down indexOf as it's faster than native
                // http://jsperf.com/thor-indexof-vs-for/5
                indexOf = function( list, elem ) {
                    var i = 0,
                        len = list.length;
                    for ( ; i < len; i++ ) {
                        if ( list[i] === elem ) {
                            return i;
                        }
                    }
                    return -1;
                },

                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                // Regular expressions

                // http://www.w3.org/TR/css3-selectors/#whitespace
                whitespace = "[\\x20\\t\\r\\n\\f]",

                // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

                // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
                    // Operator (capture 2)
                    "*([*^$|!~]?=)" + whitespace +
                    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                    "*\\]",

                pseudos = ":(" + identifier + ")(?:\\((" +
                    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                    // 1. quoted (capture 3; capture 4 or capture 5)
                    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                    // 2. simple (capture 6)
                    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                    // 3. anything else (capture 2)
                    ".*" +
                    ")\\)|)",

                // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                rwhitespace = new RegExp( whitespace + "+", "g" ),
                rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

                rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
                rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

                rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

                rpseudo = new RegExp( pseudos ),
                ridentifier = new RegExp( "^" + identifier + "$" ),

                matchExpr = {
                    "ID": new RegExp( "^#(" + identifier + ")" ),
                    "CLASS": new RegExp( "^\\.(" + identifier + ")" ),
                    "TAG": new RegExp( "^(" + identifier + "|[*])" ),
                    "ATTR": new RegExp( "^" + attributes ),
                    "PSEUDO": new RegExp( "^" + pseudos ),
                    "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                        "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                        "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
                    "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
                    // For use in libraries implementing .is()
                    // We use this for POS matching in `select`
                    "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                        whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
                },

                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,

                rnative = /^[^{]+\{\s*\[native \w/,

                // Easily-parseable/retrievable ID or TAG or CLASS selectors
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                rsibling = /[+~]/,
                rescape = /'|\\/g,

                // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
                funescape = function( _, escaped, escapedWhitespace ) {
                    var high = "0x" + escaped - 0x10000;
                    // NaN means non-codepoint
                    // Support: Firefox<24
                    // Workaround erroneous numeric interpretation of +"0x"
                    return high !== high || escapedWhitespace ?
                        escaped :
                        high < 0 ?
                            // BMP codepoint
                            String.fromCharCode( high + 0x10000 ) :
                            // Supplemental Plane codepoint (surrogate pair)
                            String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
                },

                // Used for iframes
                // See setDocument()
                // Removing the function wrapper causes a "Permission Denied"
                // error in IE
                unloadHandler = function() {
                    setDocument();
                };

// Optimize for push.apply( _, NodeList )
            try {
                push.apply(
                    (arr = slice.call( preferredDoc.childNodes )),
                    preferredDoc.childNodes
                );
                // Support: Android<4.0
                // Detect silently failing push.apply
                arr[ preferredDoc.childNodes.length ].nodeType;
            } catch ( e ) {
                push = { apply: arr.length ?

                        // Leverage slice if possible
                        function( target, els ) {
                            push_native.apply( target, slice.call(els) );
                        } :

                        // Support: IE<9
                        // Otherwise append directly
                        function( target, els ) {
                            var j = target.length,
                                i = 0;
                            // Can't trust NodeList.length
                            while ( (target[j++] = els[i++]) ) {}
                            target.length = j - 1;
                        }
                };
            }

            function Sizzle( selector, context, results, seed ) {
                var m, i, elem, nid, nidselect, match, groups, newSelector,
                    newContext = context && context.ownerDocument,

                    // nodeType defaults to 9, since context defaults to document
                    nodeType = context ? context.nodeType : 9;

                results = results || [];

                // Return early from calls with invalid selector or context
                if ( typeof selector !== "string" || !selector ||
                    nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

                    return results;
                }

                // Try to shortcut find operations (as opposed to filters) in HTML documents
                if ( !seed ) {

                    if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
                        setDocument( context );
                    }
                    context = context || document;

                    if ( documentIsHTML ) {

                        // If the selector is sufficiently simple, try using a "get*By*" DOM method
                        // (excepting DocumentFragment context, where the methods don't exist)
                        if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

                            // ID selector
                            if ( (m = match[1]) ) {

                                // Document context
                                if ( nodeType === 9 ) {
                                    if ( (elem = context.getElementById( m )) ) {

                                        // Support: IE, Opera, Webkit
                                        // TODO: identify versions
                                        // getElementById can match elements by name instead of ID
                                        if ( elem.id === m ) {
                                            results.push( elem );
                                            return results;
                                        }
                                    } else {
                                        return results;
                                    }

                                    // Element context
                                } else {

                                    // Support: IE, Opera, Webkit
                                    // TODO: identify versions
                                    // getElementById can match elements by name instead of ID
                                    if ( newContext && (elem = newContext.getElementById( m )) &&
                                        contains( context, elem ) &&
                                        elem.id === m ) {

                                        results.push( elem );
                                        return results;
                                    }
                                }

                                // Type selector
                            } else if ( match[2] ) {
                                push.apply( results, context.getElementsByTagName( selector ) );
                                return results;

                                // Class selector
                            } else if ( (m = match[3]) && support.getElementsByClassName &&
                                context.getElementsByClassName ) {

                                push.apply( results, context.getElementsByClassName( m ) );
                                return results;
                            }
                        }

                        // Take advantage of querySelectorAll
                        if ( support.qsa &&
                            !compilerCache[ selector + " " ] &&
                            (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

                            if ( nodeType !== 1 ) {
                                newContext = context;
                                newSelector = selector;

                                // qSA looks outside Element context, which is not what we want
                                // Thanks to Andrew Dupont for this workaround technique
                                // Support: IE <=8
                                // Exclude object elements
                            } else if ( context.nodeName.toLowerCase() !== "object" ) {

                                // Capture the context ID, setting it first if necessary
                                if ( (nid = context.getAttribute( "id" )) ) {
                                    nid = nid.replace( rescape, "\\$&" );
                                } else {
                                    context.setAttribute( "id", (nid = expando) );
                                }

                                // Prefix every selector in the list
                                groups = tokenize( selector );
                                i = groups.length;
                                nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
                                while ( i-- ) {
                                    groups[i] = nidselect + " " + toSelector( groups[i] );
                                }
                                newSelector = groups.join( "," );

                                // Expand context for sibling selectors
                                newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
                                    context;
                            }

                            if ( newSelector ) {
                                try {
                                    push.apply( results,
                                        newContext.querySelectorAll( newSelector )
                                    );
                                    return results;
                                } catch ( qsaError ) {
                                } finally {
                                    if ( nid === expando ) {
                                        context.removeAttribute( "id" );
                                    }
                                }
                            }
                        }
                    }
                }

                // All others
                return select( selector.replace( rtrim, "$1" ), context, results, seed );
            }

            /**
             * Create key-value caches of limited size
             * @returns {function(string, object)} Returns the Object data after storing it on itself with
             *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
             *	deleting the oldest entry
             */
            function createCache() {
                var keys = [];

                function cache( key, value ) {
                    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                    if ( keys.push( key + " " ) > Expr.cacheLength ) {
                        // Only keep the most recent entries
                        delete cache[ keys.shift() ];
                    }
                    return (cache[ key + " " ] = value);
                }
                return cache;
            }

            /**
             * Mark a function for special use by Sizzle
             * @param {Function} fn The function to mark
             */
            function markFunction( fn ) {
                fn[ expando ] = true;
                return fn;
            }

            /**
             * Support testing using an element
             * @param {Function} fn Passed the created div and expects a boolean result
             */
            function assert( fn ) {
                var div = document.createElement("div");

                try {
                    return !!fn( div );
                } catch (e) {
                    return false;
                } finally {
                    // Remove from its parent by default
                    if ( div.parentNode ) {
                        div.parentNode.removeChild( div );
                    }
                    // release memory in IE
                    div = null;
                }
            }

            /**
             * Adds the same handler for all of the specified attrs
             * @param {String} attrs Pipe-separated list of attributes
             * @param {Function} handler The method that will be applied
             */
            function addHandle( attrs, handler ) {
                var arr = attrs.split("|"),
                    i = arr.length;

                while ( i-- ) {
                    Expr.attrHandle[ arr[i] ] = handler;
                }
            }

            /**
             * Checks document order of two siblings
             * @param {Element} a
             * @param {Element} b
             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
             */
            function siblingCheck( a, b ) {
                var cur = b && a,
                    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                        ( ~b.sourceIndex || MAX_NEGATIVE ) -
                        ( ~a.sourceIndex || MAX_NEGATIVE );

                // Use IE sourceIndex if available on both nodes
                if ( diff ) {
                    return diff;
                }

                // Check if b follows a
                if ( cur ) {
                    while ( (cur = cur.nextSibling) ) {
                        if ( cur === b ) {
                            return -1;
                        }
                    }
                }

                return a ? 1 : -1;
            }

            /**
             * Returns a function to use in pseudos for input types
             * @param {String} type
             */
            function createInputPseudo( type ) {
                return function( elem ) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for buttons
             * @param {String} type
             */
            function createButtonPseudo( type ) {
                return function( elem ) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for positionals
             * @param {Function} fn
             */
            function createPositionalPseudo( fn ) {
                return markFunction(function( argument ) {
                    argument = +argument;
                    return markFunction(function( seed, matches ) {
                        var j,
                            matchIndexes = fn( [], seed.length, argument ),
                            i = matchIndexes.length;

                        // Match elements found at the specified indexes
                        while ( i-- ) {
                            if ( seed[ (j = matchIndexes[i]) ] ) {
                                seed[j] = !(matches[j] = seed[j]);
                            }
                        }
                    });
                });
            }

            /**
             * Checks a node for validity as a Sizzle context
             * @param {Element|Object=} context
             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
             */
            function testContext( context ) {
                return context && typeof context.getElementsByTagName !== "undefined" && context;
            }

// Expose support vars for convenience
            support = Sizzle.support = {};

            /**
             * Detects XML nodes
             * @param {Element|Object} elem An element or a document
             * @returns {Boolean} True iff elem is a non-HTML XML node
             */
            isXML = Sizzle.isXML = function( elem ) {
                // documentElement is verified for cases where it doesn't yet exist
                // (such as loading iframes in IE - #4833)
                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                return documentElement ? documentElement.nodeName !== "HTML" : false;
            };

            /**
             * Sets document-related variables once based on the current document
             * @param {Element|Object} [doc] An element or document object to use to set the document
             * @returns {Object} Returns the current document
             */
            setDocument = Sizzle.setDocument = function( node ) {
                var hasCompare, parent,
                    doc = node ? node.ownerDocument || node : preferredDoc;

                // Return early if doc is invalid or already selected
                if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
                    return document;
                }

                // Update global variables
                document = doc;
                docElem = document.documentElement;
                documentIsHTML = !isXML( document );

                // Support: IE 9-11, Edge
                // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                if ( (parent = document.defaultView) && parent.top !== parent ) {
                    // Support: IE 11
                    if ( parent.addEventListener ) {
                        parent.addEventListener( "unload", unloadHandler, false );

                        // Support: IE 9 - 10 only
                    } else if ( parent.attachEvent ) {
                        parent.attachEvent( "onunload", unloadHandler );
                    }
                }

                /* Attributes
	---------------------------------------------------------------------- */

                // Support: IE<8
                // Verify that getAttribute really returns attributes and not properties
                // (excepting IE8 booleans)
                support.attributes = assert(function( div ) {
                    div.className = "i";
                    return !div.getAttribute("className");
                });

                /* getElement(s)By*
	---------------------------------------------------------------------- */

                // Check if getElementsByTagName("*") returns only elements
                support.getElementsByTagName = assert(function( div ) {
                    div.appendChild( document.createComment("") );
                    return !div.getElementsByTagName("*").length;
                });

                // Support: IE<9
                support.getElementsByClassName = rnative.test( document.getElementsByClassName );

                // Support: IE<10
                // Check if getElementById returns elements by name
                // The broken getElementById methods don't pick up programatically-set names,
                // so use a roundabout getElementsByName test
                support.getById = assert(function( div ) {
                    docElem.appendChild( div ).id = expando;
                    return !document.getElementsByName || !document.getElementsByName( expando ).length;
                });

                // ID find and filter
                if ( support.getById ) {
                    Expr.find["ID"] = function( id, context ) {
                        if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
                            var m = context.getElementById( id );
                            return m ? [ m ] : [];
                        }
                    };
                    Expr.filter["ID"] = function( id ) {
                        var attrId = id.replace( runescape, funescape );
                        return function( elem ) {
                            return elem.getAttribute("id") === attrId;
                        };
                    };
                } else {
                    // Support: IE6/7
                    // getElementById is not reliable as a find shortcut
                    delete Expr.find["ID"];

                    Expr.filter["ID"] =  function( id ) {
                        var attrId = id.replace( runescape, funescape );
                        return function( elem ) {
                            var node = typeof elem.getAttributeNode !== "undefined" &&
                                elem.getAttributeNode("id");
                            return node && node.value === attrId;
                        };
                    };
                }

                // Tag
                Expr.find["TAG"] = support.getElementsByTagName ?
                    function( tag, context ) {
                        if ( typeof context.getElementsByTagName !== "undefined" ) {
                            return context.getElementsByTagName( tag );

                            // DocumentFragment nodes don't have gEBTN
                        } else if ( support.qsa ) {
                            return context.querySelectorAll( tag );
                        }
                    } :

                    function( tag, context ) {
                        var elem,
                            tmp = [],
                            i = 0,
                            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                            results = context.getElementsByTagName( tag );

                        // Filter out possible comments
                        if ( tag === "*" ) {
                            while ( (elem = results[i++]) ) {
                                if ( elem.nodeType === 1 ) {
                                    tmp.push( elem );
                                }
                            }

                            return tmp;
                        }
                        return results;
                    };

                // Class
                Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
                    if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
                        return context.getElementsByClassName( className );
                    }
                };

                /* QSA/matchesSelector
	---------------------------------------------------------------------- */

                // QSA and matchesSelector support

                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                rbuggyMatches = [];

                // qSa(:focus) reports false when true (Chrome 21)
                // We allow this because of a bug in IE8/9 that throws an error
                // whenever `document.activeElement` is accessed on an iframe
                // So, we allow :focus to pass through QSA all the time to avoid the IE error
                // See http://bugs.jquery.com/ticket/13378
                rbuggyQSA = [];

                if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
                    // Build QSA regex
                    // Regex strategy adopted from Diego Perini
                    assert(function( div ) {
                        // Select is set to empty string on purpose
                        // This is to test IE's treatment of not explicitly
                        // setting a boolean content attribute,
                        // since its presence should be enough
                        // http://bugs.jquery.com/ticket/12359
                        docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
                            "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                            "<option selected=''></option></select>";

                        // Support: IE8, Opera 11-12.16
                        // Nothing should be selected when empty strings follow ^= or $= or *=
                        // The test attribute must be unknown in Opera but "safe" for WinRT
                        // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                        if ( div.querySelectorAll("[msallowcapture^='']").length ) {
                            rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
                        }

                        // Support: IE8
                        // Boolean attributes and "value" are not treated correctly
                        if ( !div.querySelectorAll("[selected]").length ) {
                            rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
                        }

                        // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                        if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
                            rbuggyQSA.push("~=");
                        }

                        // Webkit/Opera - :checked should return selected option elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        // IE8 throws error here and will not see later tests
                        if ( !div.querySelectorAll(":checked").length ) {
                            rbuggyQSA.push(":checked");
                        }

                        // Support: Safari 8+, iOS 8+
                        // https://bugs.webkit.org/show_bug.cgi?id=136851
                        // In-page `selector#id sibing-combinator selector` fails
                        if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
                            rbuggyQSA.push(".#.+[+~]");
                        }
                    });

                    assert(function( div ) {
                        // Support: Windows 8 Native Apps
                        // The type and name attributes are restricted during .innerHTML assignment
                        var input = document.createElement("input");
                        input.setAttribute( "type", "hidden" );
                        div.appendChild( input ).setAttribute( "name", "D" );

                        // Support: IE8
                        // Enforce case-sensitivity of name attribute
                        if ( div.querySelectorAll("[name=d]").length ) {
                            rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
                        }

                        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                        // IE8 throws error here and will not see later tests
                        if ( !div.querySelectorAll(":enabled").length ) {
                            rbuggyQSA.push( ":enabled", ":disabled" );
                        }

                        // Opera 10-11 does not throw on post-comma invalid pseudos
                        div.querySelectorAll("*,:x");
                        rbuggyQSA.push(",.*:");
                    });
                }

                if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
                        docElem.webkitMatchesSelector ||
                        docElem.mozMatchesSelector ||
                        docElem.oMatchesSelector ||
                        docElem.msMatchesSelector) )) ) {

                    assert(function( div ) {
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        support.disconnectedMatch = matches.call( div, "div" );

                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        matches.call( div, "[s!='']:x" );
                        rbuggyMatches.push( "!=", pseudos );
                    });
                }

                rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
                rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

                /* Contains
	---------------------------------------------------------------------- */
                hasCompare = rnative.test( docElem.compareDocumentPosition );

                // Element contains another
                // Purposefully self-exclusive
                // As in, an element does not contain itself
                contains = hasCompare || rnative.test( docElem.contains ) ?
                    function( a, b ) {
                        var adown = a.nodeType === 9 ? a.documentElement : a,
                            bup = b && b.parentNode;
                        return a === bup || !!( bup && bup.nodeType === 1 && (
                            adown.contains ?
                                adown.contains( bup ) :
                                a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                        ));
                    } :
                    function( a, b ) {
                        if ( b ) {
                            while ( (b = b.parentNode) ) {
                                if ( b === a ) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };

                /* Sorting
	---------------------------------------------------------------------- */

                // Document order sorting
                sortOrder = hasCompare ?
                    function( a, b ) {

                        // Flag for duplicate removal
                        if ( a === b ) {
                            hasDuplicate = true;
                            return 0;
                        }

                        // Sort on method existence if only one input has compareDocumentPosition
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        if ( compare ) {
                            return compare;
                        }

                        // Calculate position if both inputs belong to the same document
                        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                            a.compareDocumentPosition( b ) :

                            // Otherwise we know they are disconnected
                            1;

                        // Disconnected nodes
                        if ( compare & 1 ||
                            (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

                            // Choose the first element that is related to our preferred document
                            if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                                return -1;
                            }
                            if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                                return 1;
                            }

                            // Maintain original order
                            return sortInput ?
                                ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                0;
                        }

                        return compare & 4 ? -1 : 1;
                    } :
                    function( a, b ) {
                        // Exit early if the nodes are identical
                        if ( a === b ) {
                            hasDuplicate = true;
                            return 0;
                        }

                        var cur,
                            i = 0,
                            aup = a.parentNode,
                            bup = b.parentNode,
                            ap = [ a ],
                            bp = [ b ];

                        // Parentless nodes are either documents or disconnected
                        if ( !aup || !bup ) {
                            return a === document ? -1 :
                                b === document ? 1 :
                                    aup ? -1 :
                                        bup ? 1 :
                                            sortInput ?
                                                ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                                0;

                            // If the nodes are siblings, we can do a quick check
                        } else if ( aup === bup ) {
                            return siblingCheck( a, b );
                        }

                        // Otherwise we need full lists of their ancestors for comparison
                        cur = a;
                        while ( (cur = cur.parentNode) ) {
                            ap.unshift( cur );
                        }
                        cur = b;
                        while ( (cur = cur.parentNode) ) {
                            bp.unshift( cur );
                        }

                        // Walk down the tree looking for a discrepancy
                        while ( ap[i] === bp[i] ) {
                            i++;
                        }

                        return i ?
                            // Do a sibling check if the nodes have a common ancestor
                            siblingCheck( ap[i], bp[i] ) :

                            // Otherwise nodes in our document sort first
                            ap[i] === preferredDoc ? -1 :
                                bp[i] === preferredDoc ? 1 :
                                    0;
                    };

                return document;
            };

            Sizzle.matches = function( expr, elements ) {
                return Sizzle( expr, null, null, elements );
            };

            Sizzle.matchesSelector = function( elem, expr ) {
                // Set document vars if needed
                if ( ( elem.ownerDocument || elem ) !== document ) {
                    setDocument( elem );
                }

                // Make sure that attribute selectors are quoted
                expr = expr.replace( rattributeQuotes, "='$1']" );

                if ( support.matchesSelector && documentIsHTML &&
                    !compilerCache[ expr + " " ] &&
                    ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
                    ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

                    try {
                        var ret = matches.call( elem, expr );

                        // IE 9's matchesSelector returns false on disconnected nodes
                        if ( ret || support.disconnectedMatch ||
                            // As well, disconnected nodes are said to be in a document
                            // fragment in IE 9
                            elem.document && elem.document.nodeType !== 11 ) {
                            return ret;
                        }
                    } catch (e) {}
                }

                return Sizzle( expr, document, null, [ elem ] ).length > 0;
            };

            Sizzle.contains = function( context, elem ) {
                // Set document vars if needed
                if ( ( context.ownerDocument || context ) !== document ) {
                    setDocument( context );
                }
                return contains( context, elem );
            };

            Sizzle.attr = function( elem, name ) {
                // Set document vars if needed
                if ( ( elem.ownerDocument || elem ) !== document ) {
                    setDocument( elem );
                }

                var fn = Expr.attrHandle[ name.toLowerCase() ],
                    // Don't get fooled by Object.prototype properties (jQuery #13807)
                    val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                        fn( elem, name, !documentIsHTML ) :
                        undefined;

                return val !== undefined ?
                    val :
                    support.attributes || !documentIsHTML ?
                        elem.getAttribute( name ) :
                        (val = elem.getAttributeNode(name)) && val.specified ?
                            val.value :
                            null;
            };

            Sizzle.error = function( msg ) {
                throw new Error( "Syntax error, unrecognized expression: " + msg );
            };

            /**
             * Document sorting and removing duplicates
             * @param {ArrayLike} results
             */
            Sizzle.uniqueSort = function( results ) {
                var elem,
                    duplicates = [],
                    j = 0,
                    i = 0;

                // Unless we *know* we can detect duplicates, assume their presence
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice( 0 );
                results.sort( sortOrder );

                if ( hasDuplicate ) {
                    while ( (elem = results[i++]) ) {
                        if ( elem === results[ i ] ) {
                            j = duplicates.push( i );
                        }
                    }
                    while ( j-- ) {
                        results.splice( duplicates[ j ], 1 );
                    }
                }

                // Clear input after sorting to release objects
                // See https://github.com/jquery/sizzle/pull/225
                sortInput = null;

                return results;
            };

            /**
             * Utility function for retrieving the text value of an array of DOM nodes
             * @param {Array|Element} elem
             */
            getText = Sizzle.getText = function( elem ) {
                var node,
                    ret = "",
                    i = 0,
                    nodeType = elem.nodeType;

                if ( !nodeType ) {
                    // If no nodeType, this is expected to be an array
                    while ( (node = elem[i++]) ) {
                        // Do not traverse comment nodes
                        ret += getText( node );
                    }
                } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
                    // Use textContent for elements
                    // innerText usage removed for consistency of new lines (jQuery #11153)
                    if ( typeof elem.textContent === "string" ) {
                        return elem.textContent;
                    } else {
                        // Traverse its children
                        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                            ret += getText( elem );
                        }
                    }
                } else if ( nodeType === 3 || nodeType === 4 ) {
                    return elem.nodeValue;
                }
                // Do not include comment or processing instruction nodes

                return ret;
            };

            Expr = Sizzle.selectors = {

                // Can be adjusted by the user
                cacheLength: 50,

                createPseudo: markFunction,

                match: matchExpr,

                attrHandle: {},

                find: {},

                relative: {
                    ">": { dir: "parentNode", first: true },
                    " ": { dir: "parentNode" },
                    "+": { dir: "previousSibling", first: true },
                    "~": { dir: "previousSibling" }
                },

                preFilter: {
                    "ATTR": function( match ) {
                        match[1] = match[1].replace( runescape, funescape );

                        // Move the given value to match[3] whether quoted or unquoted
                        match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

                        if ( match[2] === "~=" ) {
                            match[3] = " " + match[3] + " ";
                        }

                        return match.slice( 0, 4 );
                    },

                    "CHILD": function( match ) {
                        /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                        match[1] = match[1].toLowerCase();

                        if ( match[1].slice( 0, 3 ) === "nth" ) {
                            // nth-* requires argument
                            if ( !match[3] ) {
                                Sizzle.error( match[0] );
                            }

                            // numeric x and y parameters for Expr.filter.CHILD
                            // remember that false/true cast respectively to 0/1
                            match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                            match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

                            // other types prohibit arguments
                        } else if ( match[3] ) {
                            Sizzle.error( match[0] );
                        }

                        return match;
                    },

                    "PSEUDO": function( match ) {
                        var excess,
                            unquoted = !match[6] && match[2];

                        if ( matchExpr["CHILD"].test( match[0] ) ) {
                            return null;
                        }

                        // Accept quoted arguments as-is
                        if ( match[3] ) {
                            match[2] = match[4] || match[5] || "";

                            // Strip excess characters from unquoted arguments
                        } else if ( unquoted && rpseudo.test( unquoted ) &&
                            // Get excess from tokenize (recursively)
                            (excess = tokenize( unquoted, true )) &&
                            // advance to the next closing parenthesis
                            (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

                            // excess is a negative index
                            match[0] = match[0].slice( 0, excess );
                            match[2] = unquoted.slice( 0, excess );
                        }

                        // Return only captures needed by the pseudo filter method (type and argument)
                        return match.slice( 0, 3 );
                    }
                },

                filter: {

                    "TAG": function( nodeNameSelector ) {
                        var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                        return nodeNameSelector === "*" ?
                            function() { return true; } :
                            function( elem ) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                            };
                    },

                    "CLASS": function( className ) {
                        var pattern = classCache[ className + " " ];

                        return pattern ||
                            (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                            classCache( className, function( elem ) {
                                return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
                            });
                    },

                    "ATTR": function( name, operator, check ) {
                        return function( elem ) {
                            var result = Sizzle.attr( elem, name );

                            if ( result == null ) {
                                return operator === "!=";
                            }
                            if ( !operator ) {
                                return true;
                            }

                            result += "";

                            return operator === "=" ? result === check :
                                operator === "!=" ? result !== check :
                                    operator === "^=" ? check && result.indexOf( check ) === 0 :
                                        operator === "*=" ? check && result.indexOf( check ) > -1 :
                                            operator === "$=" ? check && result.slice( -check.length ) === check :
                                                operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
                                                    operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                                                        false;
                        };
                    },

                    "CHILD": function( type, what, argument, first, last ) {
                        var simple = type.slice( 0, 3 ) !== "nth",
                            forward = type.slice( -4 ) !== "last",
                            ofType = what === "of-type";

                        return first === 1 && last === 0 ?

                            // Shortcut for :nth-*(n)
                            function( elem ) {
                                return !!elem.parentNode;
                            } :

                            function( elem, context, xml ) {
                                var cache, uniqueCache, outerCache, node, nodeIndex, start,
                                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                                    parent = elem.parentNode,
                                    name = ofType && elem.nodeName.toLowerCase(),
                                    useCache = !xml && !ofType,
                                    diff = false;

                                if ( parent ) {

                                    // :(first|last|only)-(child|of-type)
                                    if ( simple ) {
                                        while ( dir ) {
                                            node = elem;
                                            while ( (node = node[ dir ]) ) {
                                                if ( ofType ?
                                                        node.nodeName.toLowerCase() === name :
                                                        node.nodeType === 1 ) {

                                                    return false;
                                                }
                                            }
                                            // Reverse direction for :only-* (if we haven't yet done so)
                                            start = dir = type === "only" && !start && "nextSibling";
                                        }
                                        return true;
                                    }

                                    start = [ forward ? parent.firstChild : parent.lastChild ];

                                    // non-xml :nth-child(...) stores cache data on `parent`
                                    if ( forward && useCache ) {

                                        // Seek `elem` from a previously-cached index

                                        // ...in a gzip-friendly way
                                        node = parent;
                                        outerCache = node[ expando ] || (node[ expando ] = {});

                                        // Support: IE <9 only
                                        // Defend against cloned attroperties (jQuery gh-1709)
                                        uniqueCache = outerCache[ node.uniqueID ] ||
                                            (outerCache[ node.uniqueID ] = {});

                                        cache = uniqueCache[ type ] || [];
                                        nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                        diff = nodeIndex && cache[ 2 ];
                                        node = nodeIndex && parent.childNodes[ nodeIndex ];

                                        while ( (node = ++nodeIndex && node && node[ dir ] ||

                                            // Fallback to seeking `elem` from the start
                                            (diff = nodeIndex = 0) || start.pop()) ) {

                                            // When found, cache indexes on `parent` and break
                                            if ( node.nodeType === 1 && ++diff && node === elem ) {
                                                uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
                                                break;
                                            }
                                        }

                                    } else {
                                        // Use previously-cached element index if available
                                        if ( useCache ) {
                                            // ...in a gzip-friendly way
                                            node = elem;
                                            outerCache = node[ expando ] || (node[ expando ] = {});

                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            uniqueCache = outerCache[ node.uniqueID ] ||
                                                (outerCache[ node.uniqueID ] = {});

                                            cache = uniqueCache[ type ] || [];
                                            nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                            diff = nodeIndex;
                                        }

                                        // xml :nth-child(...)
                                        // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                        if ( diff === false ) {
                                            // Use the same loop as above to seek `elem` from the start
                                            while ( (node = ++nodeIndex && node && node[ dir ] ||
                                                (diff = nodeIndex = 0) || start.pop()) ) {

                                                if ( ( ofType ?
                                                        node.nodeName.toLowerCase() === name :
                                                        node.nodeType === 1 ) &&
                                                    ++diff ) {

                                                    // Cache the index of each encountered element
                                                    if ( useCache ) {
                                                        outerCache = node[ expando ] || (node[ expando ] = {});

                                                        // Support: IE <9 only
                                                        // Defend against cloned attroperties (jQuery gh-1709)
                                                        uniqueCache = outerCache[ node.uniqueID ] ||
                                                            (outerCache[ node.uniqueID ] = {});

                                                        uniqueCache[ type ] = [ dirruns, diff ];
                                                    }

                                                    if ( node === elem ) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    // Incorporate the offset, then check against cycle size
                                    diff -= last;
                                    return diff === first || ( diff % first === 0 && diff / first >= 0 );
                                }
                            };
                    },

                    "PSEUDO": function( pseudo, argument ) {
                        // pseudo-class names are case-insensitive
                        // http://www.w3.org/TR/selectors/#pseudo-classes
                        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                        // Remember that setFilters inherits from pseudos
                        var args,
                            fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                                Sizzle.error( "unsupported pseudo: " + pseudo );

                        // The user may use createPseudo to indicate that
                        // arguments are needed to create the filter function
                        // just as Sizzle does
                        if ( fn[ expando ] ) {
                            return fn( argument );
                        }

                        // But maintain support for old signatures
                        if ( fn.length > 1 ) {
                            args = [ pseudo, pseudo, "", argument ];
                            return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                                markFunction(function( seed, matches ) {
                                    var idx,
                                        matched = fn( seed, argument ),
                                        i = matched.length;
                                    while ( i-- ) {
                                        idx = indexOf( seed, matched[i] );
                                        seed[ idx ] = !( matches[ idx ] = matched[i] );
                                    }
                                }) :
                                function( elem ) {
                                    return fn( elem, 0, args );
                                };
                        }

                        return fn;
                    }
                },

                pseudos: {
                    // Potentially complex pseudos
                    "not": markFunction(function( selector ) {
                        // Trim the selector passed to compile
                        // to avoid treating leading and trailing
                        // spaces as combinators
                        var input = [],
                            results = [],
                            matcher = compile( selector.replace( rtrim, "$1" ) );

                        return matcher[ expando ] ?
                            markFunction(function( seed, matches, context, xml ) {
                                var elem,
                                    unmatched = matcher( seed, null, xml, [] ),
                                    i = seed.length;

                                // Match elements unmatched by `matcher`
                                while ( i-- ) {
                                    if ( (elem = unmatched[i]) ) {
                                        seed[i] = !(matches[i] = elem);
                                    }
                                }
                            }) :
                            function( elem, context, xml ) {
                                input[0] = elem;
                                matcher( input, null, xml, results );
                                // Don't keep the element (issue #299)
                                input[0] = null;
                                return !results.pop();
                            };
                    }),

                    "has": markFunction(function( selector ) {
                        return function( elem ) {
                            return Sizzle( selector, elem ).length > 0;
                        };
                    }),

                    "contains": markFunction(function( text ) {
                        text = text.replace( runescape, funescape );
                        return function( elem ) {
                            return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
                        };
                    }),

                    // "Whether an element is represented by a :lang() selector
                    // is based solely on the element's language value
                    // being equal to the identifier C,
                    // or beginning with the identifier C immediately followed by "-".
                    // The matching of C against the element's language value is performed case-insensitively.
                    // The identifier C does not have to be a valid language name."
                    // http://www.w3.org/TR/selectors/#lang-pseudo
                    "lang": markFunction( function( lang ) {
                        // lang value must be a valid identifier
                        if ( !ridentifier.test(lang || "") ) {
                            Sizzle.error( "unsupported lang: " + lang );
                        }
                        lang = lang.replace( runescape, funescape ).toLowerCase();
                        return function( elem ) {
                            var elemLang;
                            do {
                                if ( (elemLang = documentIsHTML ?
                                        elem.lang :
                                        elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

                                    elemLang = elemLang.toLowerCase();
                                    return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                                }
                            } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                            return false;
                        };
                    }),

                    // Miscellaneous
                    "target": function( elem ) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice( 1 ) === elem.id;
                    },

                    "root": function( elem ) {
                        return elem === docElem;
                    },

                    "focus": function( elem ) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                    },

                    // Boolean properties
                    "enabled": function( elem ) {
                        return elem.disabled === false;
                    },

                    "disabled": function( elem ) {
                        return elem.disabled === true;
                    },

                    "checked": function( elem ) {
                        // In CSS3, :checked should return both checked and selected elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        var nodeName = elem.nodeName.toLowerCase();
                        return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                    },

                    "selected": function( elem ) {
                        // Accessing this property makes selected-by-default
                        // options in Safari work properly
                        if ( elem.parentNode ) {
                            elem.parentNode.selectedIndex;
                        }

                        return elem.selected === true;
                    },

                    // Contents
                    "empty": function( elem ) {
                        // http://www.w3.org/TR/selectors/#empty-pseudo
                        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                        //   but not by others (comment: 8; processing instruction: 7; etc.)
                        // nodeType < 6 works because attributes (2) do not appear as children
                        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                            if ( elem.nodeType < 6 ) {
                                return false;
                            }
                        }
                        return true;
                    },

                    "parent": function( elem ) {
                        return !Expr.pseudos["empty"]( elem );
                    },

                    // Element/input types
                    "header": function( elem ) {
                        return rheader.test( elem.nodeName );
                    },

                    "input": function( elem ) {
                        return rinputs.test( elem.nodeName );
                    },

                    "button": function( elem ) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === "button" || name === "button";
                    },

                    "text": function( elem ) {
                        var attr;
                        return elem.nodeName.toLowerCase() === "input" &&
                            elem.type === "text" &&

                            // Support: IE<8
                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                            ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
                    },

                    // Position-in-collection
                    "first": createPositionalPseudo(function() {
                        return [ 0 ];
                    }),

                    "last": createPositionalPseudo(function( matchIndexes, length ) {
                        return [ length - 1 ];
                    }),

                    "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
                        return [ argument < 0 ? argument + length : argument ];
                    }),

                    "even": createPositionalPseudo(function( matchIndexes, length ) {
                        var i = 0;
                        for ( ; i < length; i += 2 ) {
                            matchIndexes.push( i );
                        }
                        return matchIndexes;
                    }),

                    "odd": createPositionalPseudo(function( matchIndexes, length ) {
                        var i = 1;
                        for ( ; i < length; i += 2 ) {
                            matchIndexes.push( i );
                        }
                        return matchIndexes;
                    }),

                    "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                        var i = argument < 0 ? argument + length : argument;
                        for ( ; --i >= 0; ) {
                            matchIndexes.push( i );
                        }
                        return matchIndexes;
                    }),

                    "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                        var i = argument < 0 ? argument + length : argument;
                        for ( ; ++i < length; ) {
                            matchIndexes.push( i );
                        }
                        return matchIndexes;
                    })
                }
            };

            Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
            for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
                Expr.pseudos[ i ] = createInputPseudo( i );
            }
            for ( i in { submit: true, reset: true } ) {
                Expr.pseudos[ i ] = createButtonPseudo( i );
            }

// Easy API for creating new setFilters
            function setFilters() {}
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();

            tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
                var matched, match, tokens, type,
                    soFar, groups, preFilters,
                    cached = tokenCache[ selector + " " ];

                if ( cached ) {
                    return parseOnly ? 0 : cached.slice( 0 );
                }

                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;

                while ( soFar ) {

                    // Comma and first run
                    if ( !matched || (match = rcomma.exec( soFar )) ) {
                        if ( match ) {
                            // Don't consume trailing commas as valid
                            soFar = soFar.slice( match[0].length ) || soFar;
                        }
                        groups.push( (tokens = []) );
                    }

                    matched = false;

                    // Combinators
                    if ( (match = rcombinators.exec( soFar )) ) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            // Cast descendant combinators to space
                            type: match[0].replace( rtrim, " " )
                        });
                        soFar = soFar.slice( matched.length );
                    }

                    // Filters
                    for ( type in Expr.filter ) {
                        if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                                (match = preFilters[ type ]( match ))) ) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                            });
                            soFar = soFar.slice( matched.length );
                        }
                    }

                    if ( !matched ) {
                        break;
                    }
                }

                // Return the length of the invalid excess
                // if we're just parsing
                // Otherwise, throw an error or return tokens
                return parseOnly ?
                    soFar.length :
                    soFar ?
                        Sizzle.error( selector ) :
                        // Cache the tokens
                        tokenCache( selector, groups ).slice( 0 );
            };

            function toSelector( tokens ) {
                var i = 0,
                    len = tokens.length,
                    selector = "";
                for ( ; i < len; i++ ) {
                    selector += tokens[i].value;
                }
                return selector;
            }

            function addCombinator( matcher, combinator, base ) {
                var dir = combinator.dir,
                    checkNonElements = base && dir === "parentNode",
                    doneName = done++;

                return combinator.first ?
                    // Check against closest ancestor/preceding element
                    function( elem, context, xml ) {
                        while ( (elem = elem[ dir ]) ) {
                            if ( elem.nodeType === 1 || checkNonElements ) {
                                return matcher( elem, context, xml );
                            }
                        }
                    } :

                    // Check against all ancestor/preceding elements
                    function( elem, context, xml ) {
                        var oldCache, uniqueCache, outerCache,
                            newCache = [ dirruns, doneName ];

                        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                        if ( xml ) {
                            while ( (elem = elem[ dir ]) ) {
                                if ( elem.nodeType === 1 || checkNonElements ) {
                                    if ( matcher( elem, context, xml ) ) {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            while ( (elem = elem[ dir ]) ) {
                                if ( elem.nodeType === 1 || checkNonElements ) {
                                    outerCache = elem[ expando ] || (elem[ expando ] = {});

                                    // Support: IE <9 only
                                    // Defend against cloned attroperties (jQuery gh-1709)
                                    uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

                                    if ( (oldCache = uniqueCache[ dir ]) &&
                                        oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                                        // Assign to newCache so results back-propagate to previous elements
                                        return (newCache[ 2 ] = oldCache[ 2 ]);
                                    } else {
                                        // Reuse newcache so results back-propagate to previous elements
                                        uniqueCache[ dir ] = newCache;

                                        // A match means we're done; a fail means we have to keep checking
                                        if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    };
            }

            function elementMatcher( matchers ) {
                return matchers.length > 1 ?
                    function( elem, context, xml ) {
                        var i = matchers.length;
                        while ( i-- ) {
                            if ( !matchers[i]( elem, context, xml ) ) {
                                return false;
                            }
                        }
                        return true;
                    } :
                    matchers[0];
            }

            function multipleContexts( selector, contexts, results ) {
                var i = 0,
                    len = contexts.length;
                for ( ; i < len; i++ ) {
                    Sizzle( selector, contexts[i], results );
                }
                return results;
            }

            function condense( unmatched, map, filter, context, xml ) {
                var elem,
                    newUnmatched = [],
                    i = 0,
                    len = unmatched.length,
                    mapped = map != null;

                for ( ; i < len; i++ ) {
                    if ( (elem = unmatched[i]) ) {
                        if ( !filter || filter( elem, context, xml ) ) {
                            newUnmatched.push( elem );
                            if ( mapped ) {
                                map.push( i );
                            }
                        }
                    }
                }

                return newUnmatched;
            }

            function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
                if ( postFilter && !postFilter[ expando ] ) {
                    postFilter = setMatcher( postFilter );
                }
                if ( postFinder && !postFinder[ expando ] ) {
                    postFinder = setMatcher( postFinder, postSelector );
                }
                return markFunction(function( seed, results, context, xml ) {
                    var temp, i, elem,
                        preMap = [],
                        postMap = [],
                        preexisting = results.length,

                        // Get initial elements from seed or context
                        elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

                        // Prefilter to get matcher input, preserving a map for seed-results synchronization
                        matcherIn = preFilter && ( seed || !selector ) ?
                            condense( elems, preMap, preFilter, context, xml ) :
                            elems,

                        matcherOut = matcher ?
                            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                            postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                                // ...intermediate processing is necessary
                                [] :

                                // ...otherwise use results directly
                                results :
                            matcherIn;

                    // Find primary matches
                    if ( matcher ) {
                        matcher( matcherIn, matcherOut, context, xml );
                    }

                    // Apply postFilter
                    if ( postFilter ) {
                        temp = condense( matcherOut, postMap );
                        postFilter( temp, [], context, xml );

                        // Un-match failing elements by moving them back to matcherIn
                        i = temp.length;
                        while ( i-- ) {
                            if ( (elem = temp[i]) ) {
                                matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                            }
                        }
                    }

                    if ( seed ) {
                        if ( postFinder || preFilter ) {
                            if ( postFinder ) {
                                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                temp = [];
                                i = matcherOut.length;
                                while ( i-- ) {
                                    if ( (elem = matcherOut[i]) ) {
                                        // Restore matcherIn since elem is not yet a final match
                                        temp.push( (matcherIn[i] = elem) );
                                    }
                                }
                                postFinder( null, (matcherOut = []), temp, xml );
                            }

                            // Move matched elements from seed to results to keep them synchronized
                            i = matcherOut.length;
                            while ( i-- ) {
                                if ( (elem = matcherOut[i]) &&
                                    (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

                                    seed[temp] = !(results[temp] = elem);
                                }
                            }
                        }

                        // Add elements to results, through postFinder if defined
                    } else {
                        matcherOut = condense(
                            matcherOut === results ?
                                matcherOut.splice( preexisting, matcherOut.length ) :
                                matcherOut
                        );
                        if ( postFinder ) {
                            postFinder( null, results, matcherOut, xml );
                        } else {
                            push.apply( results, matcherOut );
                        }
                    }
                });
            }

            function matcherFromTokens( tokens ) {
                var checkContext, matcher, j,
                    len = tokens.length,
                    leadingRelative = Expr.relative[ tokens[0].type ],
                    implicitRelative = leadingRelative || Expr.relative[" "],
                    i = leadingRelative ? 1 : 0,

                    // The foundational matcher ensures that elements are reachable from top-level context(s)
                    matchContext = addCombinator( function( elem ) {
                        return elem === checkContext;
                    }, implicitRelative, true ),
                    matchAnyContext = addCombinator( function( elem ) {
                        return indexOf( checkContext, elem ) > -1;
                    }, implicitRelative, true ),
                    matchers = [ function( elem, context, xml ) {
                        var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                            (checkContext = context).nodeType ?
                                matchContext( elem, context, xml ) :
                                matchAnyContext( elem, context, xml ) );
                        // Avoid hanging onto element (issue #299)
                        checkContext = null;
                        return ret;
                    } ];

                for ( ; i < len; i++ ) {
                    if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
                        matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
                    } else {
                        matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

                        // Return special upon seeing a positional matcher
                        if ( matcher[ expando ] ) {
                            // Find the next relative operator (if any) for proper handling
                            j = ++i;
                            for ( ; j < len; j++ ) {
                                if ( Expr.relative[ tokens[j].type ] ) {
                                    break;
                                }
                            }
                            return setMatcher(
                                i > 1 && elementMatcher( matchers ),
                                i > 1 && toSelector(
                                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                                ).replace( rtrim, "$1" ),
                                matcher,
                                i < j && matcherFromTokens( tokens.slice( i, j ) ),
                                j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                                j < len && toSelector( tokens )
                            );
                        }
                        matchers.push( matcher );
                    }
                }

                return elementMatcher( matchers );
            }

            function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
                var bySet = setMatchers.length > 0,
                    byElement = elementMatchers.length > 0,
                    superMatcher = function( seed, context, xml, results, outermost ) {
                        var elem, j, matcher,
                            matchedCount = 0,
                            i = "0",
                            unmatched = seed && [],
                            setMatched = [],
                            contextBackup = outermostContext,
                            // We must always have either seed elements or outermost context
                            elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                            // Use integer dirruns iff this is the outermost matcher
                            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                            len = elems.length;

                        if ( outermost ) {
                            outermostContext = context === document || context || outermost;
                        }

                        // Add elements passing elementMatchers directly to results
                        // Support: IE<9, Safari
                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                        for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                            if ( byElement && elem ) {
                                j = 0;
                                if ( !context && elem.ownerDocument !== document ) {
                                    setDocument( elem );
                                    xml = !documentIsHTML;
                                }
                                while ( (matcher = elementMatchers[j++]) ) {
                                    if ( matcher( elem, context || document, xml) ) {
                                        results.push( elem );
                                        break;
                                    }
                                }
                                if ( outermost ) {
                                    dirruns = dirrunsUnique;
                                }
                            }

                            // Track unmatched elements for set filters
                            if ( bySet ) {
                                // They will have gone through all possible matchers
                                if ( (elem = !matcher && elem) ) {
                                    matchedCount--;
                                }

                                // Lengthen the array for every element, matched or not
                                if ( seed ) {
                                    unmatched.push( elem );
                                }
                            }
                        }

                        // `i` is now the count of elements visited above, and adding it to `matchedCount`
                        // makes the latter nonnegative.
                        matchedCount += i;

                        // Apply set filters to unmatched elements
                        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                        // no element matchers and no seed.
                        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                        // numerically zero.
                        if ( bySet && i !== matchedCount ) {
                            j = 0;
                            while ( (matcher = setMatchers[j++]) ) {
                                matcher( unmatched, setMatched, context, xml );
                            }

                            if ( seed ) {
                                // Reintegrate element matches to eliminate the need for sorting
                                if ( matchedCount > 0 ) {
                                    while ( i-- ) {
                                        if ( !(unmatched[i] || setMatched[i]) ) {
                                            setMatched[i] = pop.call( results );
                                        }
                                    }
                                }

                                // Discard index placeholder values to get only actual matches
                                setMatched = condense( setMatched );
                            }

                            // Add matches to results
                            push.apply( results, setMatched );

                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                            if ( outermost && !seed && setMatched.length > 0 &&
                                ( matchedCount + setMatchers.length ) > 1 ) {

                                Sizzle.uniqueSort( results );
                            }
                        }

                        // Override manipulation of globals by nested matchers
                        if ( outermost ) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }

                        return unmatched;
                    };

                return bySet ?
                    markFunction( superMatcher ) :
                    superMatcher;
            }

            compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
                var i,
                    setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[ selector + " " ];

                if ( !cached ) {
                    // Generate a function of recursive functions that can be used to check each element
                    if ( !match ) {
                        match = tokenize( selector );
                    }
                    i = match.length;
                    while ( i-- ) {
                        cached = matcherFromTokens( match[i] );
                        if ( cached[ expando ] ) {
                            setMatchers.push( cached );
                        } else {
                            elementMatchers.push( cached );
                        }
                    }

                    // Cache the compiled function
                    cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

                    // Save selector and tokenization
                    cached.selector = selector;
                }
                return cached;
            };

            /**
             * A low-level selection function that works with Sizzle's compiled
             *  selector functions
             * @param {String|Function} selector A selector or a pre-compiled
             *  selector function built with Sizzle.compile
             * @param {Element} context
             * @param {Array} [results]
             * @param {Array} [seed] A set of elements to match against
             */
            select = Sizzle.select = function( selector, context, results, seed ) {
                var i, tokens, token, type, find,
                    compiled = typeof selector === "function" && selector,
                    match = !seed && tokenize( (selector = compiled.selector || selector) );

                results = results || [];

                // Try to minimize operations if there is only one selector in the list and no seed
                // (the latter of which guarantees us context)
                if ( match.length === 1 ) {

                    // Reduce context if the leading compound selector is an ID
                    tokens = match[0] = match[0].slice( 0 );
                    if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                        support.getById && context.nodeType === 9 && documentIsHTML &&
                        Expr.relative[ tokens[1].type ] ) {

                        context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                        if ( !context ) {
                            return results;

                            // Precompiled matchers will still verify ancestry, so step up a level
                        } else if ( compiled ) {
                            context = context.parentNode;
                        }

                        selector = selector.slice( tokens.shift().value.length );
                    }

                    // Fetch a seed set for right-to-left matching
                    i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
                    while ( i-- ) {
                        token = tokens[i];

                        // Abort if we hit a combinator
                        if ( Expr.relative[ (type = token.type) ] ) {
                            break;
                        }
                        if ( (find = Expr.find[ type ]) ) {
                            // Search, expanding context for leading sibling combinators
                            if ( (seed = find(
                                    token.matches[0].replace( runescape, funescape ),
                                    rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                                )) ) {

                                // If seed is empty or no tokens remain, we can return early
                                tokens.splice( i, 1 );
                                selector = seed.length && toSelector( tokens );
                                if ( !selector ) {
                                    push.apply( results, seed );
                                    return results;
                                }

                                break;
                            }
                        }
                    }
                }

                // Compile and execute a filtering function if one is not provided
                // Provide `match` to avoid retokenization if we modified the selector above
                ( compiled || compile( selector, match ) )(
                    seed,
                    context,
                    !documentIsHTML,
                    results,
                    !context || rsibling.test( selector ) && testContext( context.parentNode ) || context
                );
                return results;
            };

// One-time assignments

// Sort stability
            support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
            support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
            setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
            support.sortDetached = assert(function( div1 ) {
                // Should return 1, but returns 4 (following)
                return div1.compareDocumentPosition( document.createElement("div") ) & 1;
            });

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
            if ( !assert(function( div ) {
                    div.innerHTML = "<a href='#'></a>";
                    return div.firstChild.getAttribute("href") === "#" ;
                }) ) {
                addHandle( "type|href|height|width", function( elem, name, isXML ) {
                    if ( !isXML ) {
                        return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
                    }
                });
            }

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
            if ( !support.attributes || !assert(function( div ) {
                    div.innerHTML = "<input/>";
                    div.firstChild.setAttribute( "value", "" );
                    return div.firstChild.getAttribute( "value" ) === "";
                }) ) {
                addHandle( "value", function( elem, name, isXML ) {
                    if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
                        return elem.defaultValue;
                    }
                });
            }

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
            if ( !assert(function( div ) {
                    return div.getAttribute("disabled") == null;
                }) ) {
                addHandle( booleans, function( elem, name, isXML ) {
                    var val;
                    if ( !isXML ) {
                        return elem[ name ] === true ? name.toLowerCase() :
                            (val = elem.getAttributeNode( name )) && val.specified ?
                                val.value :
                                null;
                    }
                });
            }

            return Sizzle;

        })( window );



    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[ ":" ] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;



    var dir = function( elem, dir, until ) {
        var matched = [],
            truncate = until !== undefined;

        while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
            if ( elem.nodeType === 1 ) {
                if ( truncate && jQuery( elem ).is( until ) ) {
                    break;
                }
                matched.push( elem );
            }
        }
        return matched;
    };


    var siblings = function( n, elem ) {
        var matched = [];

        for ( ; n; n = n.nextSibling ) {
            if ( n.nodeType === 1 && n !== elem ) {
                matched.push( n );
            }
        }

        return matched;
    };


    var rneedsContext = jQuery.expr.match.needsContext;

    var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



    var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
    function winnow( elements, qualifier, not ) {
        if ( jQuery.isFunction( qualifier ) ) {
            return jQuery.grep( elements, function( elem, i ) {
                /* jshint -W018 */
                return !!qualifier.call( elem, i, elem ) !== not;
            } );

        }

        if ( qualifier.nodeType ) {
            return jQuery.grep( elements, function( elem ) {
                return ( elem === qualifier ) !== not;
            } );

        }

        if ( typeof qualifier === "string" ) {
            if ( risSimple.test( qualifier ) ) {
                return jQuery.filter( qualifier, elements, not );
            }

            qualifier = jQuery.filter( qualifier, elements );
        }

        return jQuery.grep( elements, function( elem ) {
            return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
        } );
    }

    jQuery.filter = function( expr, elems, not ) {
        var elem = elems[ 0 ];

        if ( not ) {
            expr = ":not(" + expr + ")";
        }

        return elems.length === 1 && elem.nodeType === 1 ?
            jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
            jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                return elem.nodeType === 1;
            } ) );
    };

    jQuery.fn.extend( {
        find: function( selector ) {
            var i,
                len = this.length,
                ret = [],
                self = this;

            if ( typeof selector !== "string" ) {
                return this.pushStack( jQuery( selector ).filter( function() {
                    for ( i = 0; i < len; i++ ) {
                        if ( jQuery.contains( self[ i ], this ) ) {
                            return true;
                        }
                    }
                } ) );
            }

            for ( i = 0; i < len; i++ ) {
                jQuery.find( selector, self[ i ], ret );
            }

            // Needed because $( selector, context ) becomes $( context ).find( selector )
            ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function( selector ) {
            return this.pushStack( winnow( this, selector || [], false ) );
        },
        not: function( selector ) {
            return this.pushStack( winnow( this, selector || [], true ) );
        },
        is: function( selector ) {
            return !!winnow(
                this,

                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === "string" && rneedsContext.test( selector ) ?
                    jQuery( selector ) :
                    selector || [],
                false
            ).length;
        }
    } );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
    var rootjQuery,

        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        // Strict HTML recognition (#11290: must start with <)
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

        init = jQuery.fn.init = function( selector, context, root ) {
            var match, elem;

            // HANDLE: $(""), $(null), $(undefined), $(false)
            if ( !selector ) {
                return this;
            }

            // Method init() accepts an alternate rootjQuery
            // so migrate can support jQuery.sub (gh-2101)
            root = root || rootjQuery;

            // Handle HTML strings
            if ( typeof selector === "string" ) {
                if ( selector[ 0 ] === "<" &&
                    selector[ selector.length - 1 ] === ">" &&
                    selector.length >= 3 ) {

                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [ null, selector, null ];

                } else {
                    match = rquickExpr.exec( selector );
                }

                // Match html or make sure no context is specified for #id
                if ( match && ( match[ 1 ] || !context ) ) {

                    // HANDLE: $(html) -> $(array)
                    if ( match[ 1 ] ) {
                        context = context instanceof jQuery ? context[ 0 ] : context;

                        // Option to run scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        jQuery.merge( this, jQuery.parseHTML(
                            match[ 1 ],
                            context && context.nodeType ? context.ownerDocument || context : document,
                            true
                        ) );

                        // HANDLE: $(html, props)
                        if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
                            for ( match in context ) {

                                // Properties of context are called as methods if possible
                                if ( jQuery.isFunction( this[ match ] ) ) {
                                    this[ match ]( context[ match ] );

                                    // ...and otherwise set as attributes
                                } else {
                                    this.attr( match, context[ match ] );
                                }
                            }
                        }

                        return this;

                        // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById( match[ 2 ] );

                        // Support: Blackberry 4.6
                        // gEBID returns nodes no longer in the document (#6963)
                        if ( elem && elem.parentNode ) {

                            // Inject the element directly into the jQuery object
                            this.length = 1;
                            this[ 0 ] = elem;
                        }

                        this.context = document;
                        this.selector = selector;
                        return this;
                    }

                    // HANDLE: $(expr, $(...))
                } else if ( !context || context.jquery ) {
                    return ( context || root ).find( selector );

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor( context ).find( selector );
                }

                // HANDLE: $(DOMElement)
            } else if ( selector.nodeType ) {
                this.context = this[ 0 ] = selector;
                this.length = 1;
                return this;

                // HANDLE: $(function)
                // Shortcut for document ready
            } else if ( jQuery.isFunction( selector ) ) {
                return root.ready !== undefined ?
                    root.ready( selector ) :

                    // Execute immediately if ready is not present
                    selector( jQuery );
            }

            if ( selector.selector !== undefined ) {
                this.selector = selector.selector;
                this.context = selector.context;
            }

            return jQuery.makeArray( selector, this );
        };

// Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

// Initialize central reference
    rootjQuery = jQuery( document );


    var rparentsprev = /^(?:parents|prev(?:Until|All))/,

        // Methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.fn.extend( {
        has: function( target ) {
            var targets = jQuery( target, this ),
                l = targets.length;

            return this.filter( function() {
                var i = 0;
                for ( ; i < l; i++ ) {
                    if ( jQuery.contains( this, targets[ i ] ) ) {
                        return true;
                    }
                }
            } );
        },

        closest: function( selectors, context ) {
            var cur,
                i = 0,
                l = this.length,
                matched = [],
                pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                    jQuery( selectors, context || this.context ) :
                    0;

            for ( ; i < l; i++ ) {
                for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

                    // Always skip document fragments
                    if ( cur.nodeType < 11 && ( pos ?
                            pos.index( cur ) > -1 :

                            // Don't pass non-elements to Sizzle
                            cur.nodeType === 1 &&
                            jQuery.find.matchesSelector( cur, selectors ) ) ) {

                        matched.push( cur );
                        break;
                    }
                }
            }

            return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
        },

        // Determine the position of an element within the set
        index: function( elem ) {

            // No argument, return index in parent
            if ( !elem ) {
                return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
            }

            // Index in selector
            if ( typeof elem === "string" ) {
                return indexOf.call( jQuery( elem ), this[ 0 ] );
            }

            // Locate the position of the desired element
            return indexOf.call( this,

                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[ 0 ] : elem
            );
        },

        add: function( selector, context ) {
            return this.pushStack(
                jQuery.uniqueSort(
                    jQuery.merge( this.get(), jQuery( selector, context ) )
                )
            );
        },

        addBack: function( selector ) {
            return this.add( selector == null ?
                this.prevObject : this.prevObject.filter( selector )
            );
        }
    } );

    function sibling( cur, dir ) {
        while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
        return cur;
    }

    jQuery.each( {
        parent: function( elem ) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function( elem ) {
            return dir( elem, "parentNode" );
        },
        parentsUntil: function( elem, i, until ) {
            return dir( elem, "parentNode", until );
        },
        next: function( elem ) {
            return sibling( elem, "nextSibling" );
        },
        prev: function( elem ) {
            return sibling( elem, "previousSibling" );
        },
        nextAll: function( elem ) {
            return dir( elem, "nextSibling" );
        },
        prevAll: function( elem ) {
            return dir( elem, "previousSibling" );
        },
        nextUntil: function( elem, i, until ) {
            return dir( elem, "nextSibling", until );
        },
        prevUntil: function( elem, i, until ) {
            return dir( elem, "previousSibling", until );
        },
        siblings: function( elem ) {
            return siblings( ( elem.parentNode || {} ).firstChild, elem );
        },
        children: function( elem ) {
            return siblings( elem.firstChild );
        },
        contents: function( elem ) {
            return elem.contentDocument || jQuery.merge( [], elem.childNodes );
        }
    }, function( name, fn ) {
        jQuery.fn[ name ] = function( until, selector ) {
            var matched = jQuery.map( this, fn, until );

            if ( name.slice( -5 ) !== "Until" ) {
                selector = until;
            }

            if ( selector && typeof selector === "string" ) {
                matched = jQuery.filter( selector, matched );
            }

            if ( this.length > 1 ) {

                // Remove duplicates
                if ( !guaranteedUnique[ name ] ) {
                    jQuery.uniqueSort( matched );
                }

                // Reverse order for parents* and prev-derivatives
                if ( rparentsprev.test( name ) ) {
                    matched.reverse();
                }
            }

            return this.pushStack( matched );
        };
    } );
    var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
    function createOptions( options ) {
        var object = {};
        jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
            object[ flag ] = true;
        } );
        return object;
    }

    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
    jQuery.Callbacks = function( options ) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ?
            createOptions( options ) :
            jQuery.extend( {}, options );

        var // Flag to know if list is currently firing
            firing,

            // Last fire value for non-forgettable lists
            memory,

            // Flag to know if list was already fired
            fired,

            // Flag to prevent firing
            locked,

            // Actual callback list
            list = [],

            // Queue of execution data for repeatable lists
            queue = [],

            // Index of currently firing callback (modified by add/remove as needed)
            firingIndex = -1,

            // Fire callbacks
            fire = function() {

                // Enforce single-firing
                locked = options.once;

                // Execute callbacks for all pending executions,
                // respecting firingIndex overrides and runtime changes
                fired = firing = true;
                for ( ; queue.length; firingIndex = -1 ) {
                    memory = queue.shift();
                    while ( ++firingIndex < list.length ) {

                        // Run callback and check for early termination
                        if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
                            options.stopOnFalse ) {

                            // Jump to end and forget the data so .add doesn't re-fire
                            firingIndex = list.length;
                            memory = false;
                        }
                    }
                }

                // Forget the data if we're done with it
                if ( !options.memory ) {
                    memory = false;
                }

                firing = false;

                // Clean up if we're done firing for good
                if ( locked ) {

                    // Keep an empty list if we have data for future add calls
                    if ( memory ) {
                        list = [];

                        // Otherwise, this object is spent
                    } else {
                        list = "";
                    }
                }
            },

            // Actual Callbacks object
            self = {

                // Add a callback or a collection of callbacks to the list
                add: function() {
                    if ( list ) {

                        // If we have memory from a past run, we should fire after adding
                        if ( memory && !firing ) {
                            firingIndex = list.length - 1;
                            queue.push( memory );
                        }

                        ( function add( args ) {
                            jQuery.each( args, function( _, arg ) {
                                if ( jQuery.isFunction( arg ) ) {
                                    if ( !options.unique || !self.has( arg ) ) {
                                        list.push( arg );
                                    }
                                } else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

                                    // Inspect recursively
                                    add( arg );
                                }
                            } );
                        } )( arguments );

                        if ( memory && !firing ) {
                            fire();
                        }
                    }
                    return this;
                },

                // Remove a callback from the list
                remove: function() {
                    jQuery.each( arguments, function( _, arg ) {
                        var index;
                        while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                            list.splice( index, 1 );

                            // Handle firing indexes
                            if ( index <= firingIndex ) {
                                firingIndex--;
                            }
                        }
                    } );
                    return this;
                },

                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function( fn ) {
                    return fn ?
                        jQuery.inArray( fn, list ) > -1 :
                        list.length > 0;
                },

                // Remove all callbacks from the list
                empty: function() {
                    if ( list ) {
                        list = [];
                    }
                    return this;
                },

                // Disable .fire and .add
                // Abort any current/pending executions
                // Clear all callbacks and values
                disable: function() {
                    locked = queue = [];
                    list = memory = "";
                    return this;
                },
                disabled: function() {
                    return !list;
                },

                // Disable .fire
                // Also disable .add unless we have memory (since it would have no effect)
                // Abort any pending executions
                lock: function() {
                    locked = queue = [];
                    if ( !memory ) {
                        list = memory = "";
                    }
                    return this;
                },
                locked: function() {
                    return !!locked;
                },

                // Call all callbacks with the given context and arguments
                fireWith: function( context, args ) {
                    if ( !locked ) {
                        args = args || [];
                        args = [ context, args.slice ? args.slice() : args ];
                        queue.push( args );
                        if ( !firing ) {
                            fire();
                        }
                    }
                    return this;
                },

                // Call all the callbacks with the given arguments
                fire: function() {
                    self.fireWith( this, arguments );
                    return this;
                },

                // To know if the callbacks have already been called at least once
                fired: function() {
                    return !!fired;
                }
            };

        return self;
    };


    jQuery.extend( {

        Deferred: function( func ) {
            var tuples = [

                    // action, add listener, listener list, final state
                    [ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
                    [ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
                    [ "notify", "progress", jQuery.Callbacks( "memory" ) ]
                ],
                state = "pending",
                promise = {
                    state: function() {
                        return state;
                    },
                    always: function() {
                        deferred.done( arguments ).fail( arguments );
                        return this;
                    },
                    then: function( /* fnDone, fnFail, fnProgress */ ) {
                        var fns = arguments;
                        return jQuery.Deferred( function( newDefer ) {
                            jQuery.each( tuples, function( i, tuple ) {
                                var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

                                // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                deferred[ tuple[ 1 ] ]( function() {
                                    var returned = fn && fn.apply( this, arguments );
                                    if ( returned && jQuery.isFunction( returned.promise ) ) {
                                        returned.promise()
                                            .progress( newDefer.notify )
                                            .done( newDefer.resolve )
                                            .fail( newDefer.reject );
                                    } else {
                                        newDefer[ tuple[ 0 ] + "With" ](
                                            this === promise ? newDefer.promise() : this,
                                            fn ? [ returned ] : arguments
                                        );
                                    }
                                } );
                            } );
                            fns = null;
                        } ).promise();
                    },

                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function( obj ) {
                        return obj != null ? jQuery.extend( obj, promise ) : promise;
                    }
                },
                deferred = {};

            // Keep pipe for back-compat
            promise.pipe = promise.then;

            // Add list-specific methods
            jQuery.each( tuples, function( i, tuple ) {
                var list = tuple[ 2 ],
                    stateString = tuple[ 3 ];

                // promise[ done | fail | progress ] = list.add
                promise[ tuple[ 1 ] ] = list.add;

                // Handle state
                if ( stateString ) {
                    list.add( function() {

                        // state = [ resolved | rejected ]
                        state = stateString;

                        // [ reject_list | resolve_list ].disable; progress_list.lock
                    }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
                }

                // deferred[ resolve | reject | notify ]
                deferred[ tuple[ 0 ] ] = function() {
                    deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
                    return this;
                };
                deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
            } );

            // Make the deferred a promise
            promise.promise( deferred );

            // Call given func if any
            if ( func ) {
                func.call( deferred, deferred );
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function( subordinate /* , ..., subordinateN */ ) {
            var i = 0,
                resolveValues = slice.call( arguments ),
                length = resolveValues.length,

                // the count of uncompleted subordinates
                remaining = length !== 1 ||
                ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

                // the master Deferred.
                // If resolveValues consist of only a single Deferred, just use that.
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                // Update function for both resolve and progress values
                updateFunc = function( i, contexts, values ) {
                    return function( value ) {
                        contexts[ i ] = this;
                        values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                        if ( values === progressValues ) {
                            deferred.notifyWith( contexts, values );
                        } else if ( !( --remaining ) ) {
                            deferred.resolveWith( contexts, values );
                        }
                    };
                },

                progressValues, progressContexts, resolveContexts;

            // Add listeners to Deferred subordinates; treat others as resolved
            if ( length > 1 ) {
                progressValues = new Array( length );
                progressContexts = new Array( length );
                resolveContexts = new Array( length );
                for ( ; i < length; i++ ) {
                    if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                        resolveValues[ i ].promise()
                            .progress( updateFunc( i, progressContexts, progressValues ) )
                            .done( updateFunc( i, resolveContexts, resolveValues ) )
                            .fail( deferred.reject );
                    } else {
                        --remaining;
                    }
                }
            }

            // If we're not waiting on anything, resolve the master
            if ( !remaining ) {
                deferred.resolveWith( resolveContexts, resolveValues );
            }

            return deferred.promise();
        }
    } );


// The deferred used on DOM ready
    var readyList;

    jQuery.fn.ready = function( fn ) {

        // Add the callback
        jQuery.ready.promise().done( fn );

        return this;
    };

    jQuery.extend( {

        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Hold (or release) the ready event
        holdReady: function( hold ) {
            if ( hold ) {
                jQuery.readyWait++;
            } else {
                jQuery.ready( true );
            }
        },

        // Handle when the DOM is ready
        ready: function( wait ) {

            // Abort if there are pending holds or we're already ready
            if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                return;
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if ( wait !== true && --jQuery.readyWait > 0 ) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith( document, [ jQuery ] );

            // Trigger any bound ready events
            if ( jQuery.fn.triggerHandler ) {
                jQuery( document ).triggerHandler( "ready" );
                jQuery( document ).off( "ready" );
            }
        }
    } );

    /**
     * The ready event handler and self cleanup method
     */
    function completed() {
        document.removeEventListener( "DOMContentLoaded", completed );
        window.removeEventListener( "load", completed );
        jQuery.ready();
    }

    jQuery.ready.promise = function( obj ) {
        if ( !readyList ) {

            readyList = jQuery.Deferred();

            // Catch cases where $(document).ready() is called
            // after the browser event has already occurred.
            // Support: IE9-10 only
            // Older IE sometimes signals "interactive" too soon
            if ( document.readyState === "complete" ||
                ( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

                // Handle it asynchronously to allow scripts the opportunity to delay ready
                window.setTimeout( jQuery.ready );

            } else {

                // Use the handy event callback
                document.addEventListener( "DOMContentLoaded", completed );

                // A fallback to window.onload, that will always work
                window.addEventListener( "load", completed );
            }
        }
        return readyList.promise( obj );
    };

// Kick off the DOM ready check even if the user does not
    jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
    var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
        var i = 0,
            len = elems.length,
            bulk = key == null;

        // Sets many values
        if ( jQuery.type( key ) === "object" ) {
            chainable = true;
            for ( i in key ) {
                access( elems, fn, i, key[ i ], true, emptyGet, raw );
            }

            // Sets one value
        } else if ( value !== undefined ) {
            chainable = true;

            if ( !jQuery.isFunction( value ) ) {
                raw = true;
            }

            if ( bulk ) {

                // Bulk operations run against the entire set
                if ( raw ) {
                    fn.call( elems, value );
                    fn = null;

                    // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function( elem, key, value ) {
                        return bulk.call( jQuery( elem ), value );
                    };
                }
            }

            if ( fn ) {
                for ( ; i < len; i++ ) {
                    fn(
                        elems[ i ], key, raw ?
                            value :
                            value.call( elems[ i ], i, fn( elems[ i ], key ) )
                    );
                }
            }
        }

        return chainable ?
            elems :

            // Gets
            bulk ?
                fn.call( elems ) :
                len ? fn( elems[ 0 ], key ) : emptyGet;
    };
    var acceptData = function( owner ) {

        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        /* jshint -W018 */
        return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
    };




    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;

    Data.prototype = {

        register: function( owner, initial ) {
            var value = initial || {};

            // If it is a node unlikely to be stringify-ed or looped over
            // use plain assignment
            if ( owner.nodeType ) {
                owner[ this.expando ] = value;

                // Otherwise secure it in a non-enumerable, non-writable property
                // configurability must be true to allow the property to be
                // deleted with the delete operator
            } else {
                Object.defineProperty( owner, this.expando, {
                    value: value,
                    writable: true,
                    configurable: true
                } );
            }
            return owner[ this.expando ];
        },
        cache: function( owner ) {

            // We can accept data for non-element nodes in modern browsers,
            // but we should not, see #8335.
            // Always return an empty object.
            if ( !acceptData( owner ) ) {
                return {};
            }

            // Check if the owner object already has a cache
            var value = owner[ this.expando ];

            // If not, create one
            if ( !value ) {
                value = {};

                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if ( acceptData( owner ) ) {

                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if ( owner.nodeType ) {
                        owner[ this.expando ] = value;

                        // Otherwise secure it in a non-enumerable property
                        // configurable must be true to allow the property to be
                        // deleted when data is removed
                    } else {
                        Object.defineProperty( owner, this.expando, {
                            value: value,
                            configurable: true
                        } );
                    }
                }
            }

            return value;
        },
        set: function( owner, data, value ) {
            var prop,
                cache = this.cache( owner );

            // Handle: [ owner, key, value ] args
            if ( typeof data === "string" ) {
                cache[ data ] = value;

                // Handle: [ owner, { properties } ] args
            } else {

                // Copy the properties one-by-one to the cache object
                for ( prop in data ) {
                    cache[ prop ] = data[ prop ];
                }
            }
            return cache;
        },
        get: function( owner, key ) {
            return key === undefined ?
                this.cache( owner ) :
                owner[ this.expando ] && owner[ this.expando ][ key ];
        },
        access: function( owner, key, value ) {
            var stored;

            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if ( key === undefined ||
                ( ( key && typeof key === "string" ) && value === undefined ) ) {

                stored = this.get( owner, key );

                return stored !== undefined ?
                    stored : this.get( owner, jQuery.camelCase( key ) );
            }

            // When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set( owner, key, value );

            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function( owner, key ) {
            var i, name, camel,
                cache = owner[ this.expando ];

            if ( cache === undefined ) {
                return;
            }

            if ( key === undefined ) {
                this.register( owner );

            } else {

                // Support array or space separated string of keys
                if ( jQuery.isArray( key ) ) {

                    // If "name" is an array of keys...
                    // When data is initially created, via ("key", "val") signature,
                    // keys will be converted to camelCase.
                    // Since there is no way to tell _how_ a key was added, remove
                    // both plain key and camelCase key. #12786
                    // This will only penalize the array argument path.
                    name = key.concat( key.map( jQuery.camelCase ) );
                } else {
                    camel = jQuery.camelCase( key );

                    // Try the string as a key before any manipulation
                    if ( key in cache ) {
                        name = [ key, camel ];
                    } else {

                        // If a key with the spaces exists, use it.
                        // Otherwise, create an array by matching non-whitespace
                        name = camel;
                        name = name in cache ?
                            [ name ] : ( name.match( rnotwhite ) || [] );
                    }
                }

                i = name.length;

                while ( i-- ) {
                    delete cache[ name[ i ] ];
                }
            }

            // Remove the expando if there's no more data
            if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

                // Support: Chrome <= 35-45+
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://code.google.com/p/chromium/issues/detail?id=378607
                if ( owner.nodeType ) {
                    owner[ this.expando ] = undefined;
                } else {
                    delete owner[ this.expando ];
                }
            }
        },
        hasData: function( owner ) {
            var cache = owner[ this.expando ];
            return cache !== undefined && !jQuery.isEmptyObject( cache );
        }
    };
    var dataPriv = new Data();

    var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;

    function dataAttr( elem, key, data ) {
        var name;

        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if ( data === undefined && elem.nodeType === 1 ) {
            name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
            data = elem.getAttribute( name );

            if ( typeof data === "string" ) {
                try {
                    data = data === "true" ? true :
                        data === "false" ? false :
                            data === "null" ? null :

                                // Only convert to a number if it doesn't change the string
                                +data + "" === data ? +data :
                                    rbrace.test( data ) ? jQuery.parseJSON( data ) :
                                        data;
                } catch ( e ) {}

                // Make sure we set the data so it isn't changed later
                dataUser.set( elem, key, data );
            } else {
                data = undefined;
            }
        }
        return data;
    }

    jQuery.extend( {
        hasData: function( elem ) {
            return dataUser.hasData( elem ) || dataPriv.hasData( elem );
        },

        data: function( elem, name, data ) {
            return dataUser.access( elem, name, data );
        },

        removeData: function( elem, name ) {
            dataUser.remove( elem, name );
        },

        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function( elem, name, data ) {
            return dataPriv.access( elem, name, data );
        },

        _removeData: function( elem, name ) {
            dataPriv.remove( elem, name );
        }
    } );

    jQuery.fn.extend( {
        data: function( key, value ) {
            var i, name, data,
                elem = this[ 0 ],
                attrs = elem && elem.attributes;

            // Gets all values
            if ( key === undefined ) {
                if ( this.length ) {
                    data = dataUser.get( elem );

                    if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
                        i = attrs.length;
                        while ( i-- ) {

                            // Support: IE11+
                            // The attrs elements can be null (#14894)
                            if ( attrs[ i ] ) {
                                name = attrs[ i ].name;
                                if ( name.indexOf( "data-" ) === 0 ) {
                                    name = jQuery.camelCase( name.slice( 5 ) );
                                    dataAttr( elem, name, data[ name ] );
                                }
                            }
                        }
                        dataPriv.set( elem, "hasDataAttrs", true );
                    }
                }

                return data;
            }

            // Sets multiple values
            if ( typeof key === "object" ) {
                return this.each( function() {
                    dataUser.set( this, key );
                } );
            }

            return access( this, function( value ) {
                var data, camelKey;

                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if ( elem && value === undefined ) {

                    // Attempt to get data from the cache
                    // with the key as-is
                    data = dataUser.get( elem, key ) ||

                        // Try to find dashed key if it exists (gh-2779)
                        // This is for 2.2.x only
                        dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

                    if ( data !== undefined ) {
                        return data;
                    }

                    camelKey = jQuery.camelCase( key );

                    // Attempt to get data from the cache
                    // with the key camelized
                    data = dataUser.get( elem, camelKey );
                    if ( data !== undefined ) {
                        return data;
                    }

                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr( elem, camelKey, undefined );
                    if ( data !== undefined ) {
                        return data;
                    }

                    // We tried really hard, but the data doesn't exist.
                    return;
                }

                // Set the data...
                camelKey = jQuery.camelCase( key );
                this.each( function() {

                    // First, attempt to store a copy or reference of any
                    // data that might've been store with a camelCased key.
                    var data = dataUser.get( this, camelKey );

                    // For HTML5 data-* attribute interop, we have to
                    // store property names with dashes in a camelCase form.
                    // This might not apply to all properties...*
                    dataUser.set( this, camelKey, value );

                    // *... In the case of properties that might _actually_
                    // have dashes, we need to also store a copy of that
                    // unchanged property.
                    if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
                        dataUser.set( this, key, value );
                    }
                } );
            }, null, value, arguments.length > 1, null, true );
        },

        removeData: function( key ) {
            return this.each( function() {
                dataUser.remove( this, key );
            } );
        }
    } );


    jQuery.extend( {
        queue: function( elem, type, data ) {
            var queue;

            if ( elem ) {
                type = ( type || "fx" ) + "queue";
                queue = dataPriv.get( elem, type );

                // Speed up dequeue by getting out quickly if this is just a lookup
                if ( data ) {
                    if ( !queue || jQuery.isArray( data ) ) {
                        queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
                    } else {
                        queue.push( data );
                    }
                }
                return queue || [];
            }
        },

        dequeue: function( elem, type ) {
            type = type || "fx";

            var queue = jQuery.queue( elem, type ),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks( elem, type ),
                next = function() {
                    jQuery.dequeue( elem, type );
                };

            // If the fx queue is dequeued, always remove the progress sentinel
            if ( fn === "inprogress" ) {
                fn = queue.shift();
                startLength--;
            }

            if ( fn ) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if ( type === "fx" ) {
                    queue.unshift( "inprogress" );
                }

                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call( elem, next, hooks );
            }

            if ( !startLength && hooks ) {
                hooks.empty.fire();
            }
        },

        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function( elem, type ) {
            var key = type + "queueHooks";
            return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
                empty: jQuery.Callbacks( "once memory" ).add( function() {
                    dataPriv.remove( elem, [ type + "queue", key ] );
                } )
            } );
        }
    } );

    jQuery.fn.extend( {
        queue: function( type, data ) {
            var setter = 2;

            if ( typeof type !== "string" ) {
                data = type;
                type = "fx";
                setter--;
            }

            if ( arguments.length < setter ) {
                return jQuery.queue( this[ 0 ], type );
            }

            return data === undefined ?
                this :
                this.each( function() {
                    var queue = jQuery.queue( this, type, data );

                    // Ensure a hooks for this queue
                    jQuery._queueHooks( this, type );

                    if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
                        jQuery.dequeue( this, type );
                    }
                } );
        },
        dequeue: function( type ) {
            return this.each( function() {
                jQuery.dequeue( this, type );
            } );
        },
        clearQueue: function( type ) {
            return this.queue( type || "fx", [] );
        },

        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function( type, obj ) {
            var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function() {
                    if ( !( --count ) ) {
                        defer.resolveWith( elements, [ elements ] );
                    }
                };

            if ( typeof type !== "string" ) {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while ( i-- ) {
                tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
                if ( tmp && tmp.empty ) {
                    count++;
                    tmp.empty.add( resolve );
                }
            }
            resolve();
            return defer.promise( obj );
        }
    } );
    var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

    var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

    var isHidden = function( elem, el ) {

        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css( elem, "display" ) === "none" ||
            !jQuery.contains( elem.ownerDocument, elem );
    };



    function adjustCSS( elem, prop, valueParts, tween ) {
        var adjusted,
            scale = 1,
            maxIterations = 20,
            currentValue = tween ?
                function() { return tween.cur(); } :
                function() { return jQuery.css( elem, prop, "" ); },
            initial = currentValue(),
            unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

            // Starting value computation is required for potential unit mismatches
            initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
                rcssNum.exec( jQuery.css( elem, prop ) );

        if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

            // Trust units reported by jQuery.css
            unit = unit || initialInUnit[ 3 ];

            // Make sure we update the tween properties later on
            valueParts = valueParts || [];

            // Iteratively approximate from a nonzero starting point
            initialInUnit = +initial || 1;

            do {

                // If previous iteration zeroed out, double until we get *something*.
                // Use string for doubling so we don't accidentally see scale as unchanged below
                scale = scale || ".5";

                // Adjust and apply
                initialInUnit = initialInUnit / scale;
                jQuery.style( elem, prop, initialInUnit + unit );

                // Update scale, tolerating zero or NaN from tween.cur()
                // Break the loop if scale is unchanged or perfect, or if we've just had enough.
            } while (
                scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
                );
        }

        if ( valueParts ) {
            initialInUnit = +initialInUnit || +initial || 0;

            // Apply relative offset (+=/-=) if specified
            adjusted = valueParts[ 1 ] ?
                initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
                +valueParts[ 2 ];
            if ( tween ) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var rcheckableType = ( /^(?:checkbox|radio)$/i );

    var rtagName = ( /<([\w:-]+)/ );

    var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
    var wrapMap = {

        // Support: IE9
        option: [ 1, "<select multiple='multiple'>", "</select>" ],

        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

        _default: [ 0, "", "" ]
    };

// Support: IE9
    wrapMap.optgroup = wrapMap.option;

    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;


    function getAll( context, tag ) {

        // Support: IE9-11+
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret = typeof context.getElementsByTagName !== "undefined" ?
            context.getElementsByTagName( tag || "*" ) :
            typeof context.querySelectorAll !== "undefined" ?
                context.querySelectorAll( tag || "*" ) :
                [];

        return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
            jQuery.merge( [ context ], ret ) :
            ret;
    }


// Mark scripts as having already been evaluated
    function setGlobalEval( elems, refElements ) {
        var i = 0,
            l = elems.length;

        for ( ; i < l; i++ ) {
            dataPriv.set(
                elems[ i ],
                "globalEval",
                !refElements || dataPriv.get( refElements[ i ], "globalEval" )
            );
        }
    }


    var rhtml = /<|&#?\w+;/;

    function buildFragment( elems, context, scripts, selection, ignored ) {
        var elem, tmp, tag, wrap, contains, j,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i = 0,
            l = elems.length;

        for ( ; i < l; i++ ) {
            elem = elems[ i ];

            if ( elem || elem === 0 ) {

                // Add nodes directly
                if ( jQuery.type( elem ) === "object" ) {

                    // Support: Android<4.1, PhantomJS<2
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                    // Convert non-html into a text node
                } else if ( !rhtml.test( elem ) ) {
                    nodes.push( context.createTextNode( elem ) );

                    // Convert html into DOM nodes
                } else {
                    tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

                    // Deserialize a standard representation
                    tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
                    wrap = wrapMap[ tag ] || wrapMap._default;
                    tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

                    // Descend through wrappers to the right content
                    j = wrap[ 0 ];
                    while ( j-- ) {
                        tmp = tmp.lastChild;
                    }

                    // Support: Android<4.1, PhantomJS<2
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge( nodes, tmp.childNodes );

                    // Remember the top-level container
                    tmp = fragment.firstChild;

                    // Ensure the created nodes are orphaned (#12392)
                    tmp.textContent = "";
                }
            }
        }

        // Remove wrapper from fragment
        fragment.textContent = "";

        i = 0;
        while ( ( elem = nodes[ i++ ] ) ) {

            // Skip elements already in the context collection (trac-4087)
            if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
                if ( ignored ) {
                    ignored.push( elem );
                }
                continue;
            }

            contains = jQuery.contains( elem.ownerDocument, elem );

            // Append to fragment
            tmp = getAll( fragment.appendChild( elem ), "script" );

            // Preserve script evaluation history
            if ( contains ) {
                setGlobalEval( tmp );
            }

            // Capture executables
            if ( scripts ) {
                j = 0;
                while ( ( elem = tmp[ j++ ] ) ) {
                    if ( rscriptType.test( elem.type || "" ) ) {
                        scripts.push( elem );
                    }
                }
            }
        }

        return fragment;
    }


    ( function() {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild( document.createElement( "div" ) ),
            input = document.createElement( "input" );

        // Support: Android 4.0-4.3, Safari<=5.1
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute( "type", "radio" );
        input.setAttribute( "checked", "checked" );
        input.setAttribute( "name", "t" );

        div.appendChild( input );

        // Support: Safari<=5.1, Android<4.2
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

        // Support: IE<=11+
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
    } )();


    var
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

// Support: IE9
// See #13393 for more info
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch ( err ) { }
    }

    function on( elem, types, selector, data, fn, one ) {
        var origFn, type;

        // Types can be a map of types/handlers
        if ( typeof types === "object" ) {

            // ( types-Object, selector, data )
            if ( typeof selector !== "string" ) {

                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for ( type in types ) {
                on( elem, type, selector, data, types[ type ], one );
            }
            return elem;
        }

        if ( data == null && fn == null ) {

            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if ( fn == null ) {
            if ( typeof selector === "string" ) {

                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {

                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if ( fn === false ) {
            fn = returnFalse;
        } else if ( !fn ) {
            return elem;
        }

        if ( one === 1 ) {
            origFn = fn;
            fn = function( event ) {

                // Can use an empty set, since event contains the info
                jQuery().off( event );
                return origFn.apply( this, arguments );
            };

            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
        }
        return elem.each( function() {
            jQuery.event.add( this, types, fn, data, selector );
        } );
    }

    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
    jQuery.event = {

        global: {},

        add: function( elem, types, handler, data, selector ) {

            var handleObjIn, eventHandle, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = dataPriv.get( elem );

            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if ( !elemData ) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if ( handler.handler ) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if ( !handler.guid ) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            if ( !( events = elemData.events ) ) {
                events = elemData.events = {};
            }
            if ( !( eventHandle = elemData.handle ) ) {
                eventHandle = elemData.handle = function( e ) {

                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                        jQuery.event.dispatch.apply( elem, arguments ) : undefined;
                };
            }

            // Handle multiple events separated by a space
            types = ( types || "" ).match( rnotwhite ) || [ "" ];
            t = types.length;
            while ( t-- ) {
                tmp = rtypenamespace.exec( types[ t ] ) || [];
                type = origType = tmp[ 1 ];
                namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

                // There *must* be a type, no attaching namespace-only handlers
                if ( !type ) {
                    continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[ type ] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = ( selector ? special.delegateType : special.bindType ) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[ type ] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend( {
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                    namespace: namespaces.join( "." )
                }, handleObjIn );

                // Init the event handler queue if we're the first
                if ( !( handlers = events[ type ] ) ) {
                    handlers = events[ type ] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener if the special events handler returns false
                    if ( !special.setup ||
                        special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

                        if ( elem.addEventListener ) {
                            elem.addEventListener( type, eventHandle );
                        }
                    }
                }

                if ( special.add ) {
                    special.add.call( elem, handleObj );

                    if ( !handleObj.handler.guid ) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if ( selector ) {
                    handlers.splice( handlers.delegateCount++, 0, handleObj );
                } else {
                    handlers.push( handleObj );
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[ type ] = true;
            }

        },

        // Detach an event or set of events from an element
        remove: function( elem, types, handler, selector, mappedTypes ) {

            var j, origCount, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

            if ( !elemData || !( events = elemData.events ) ) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = ( types || "" ).match( rnotwhite ) || [ "" ];
            t = types.length;
            while ( t-- ) {
                tmp = rtypenamespace.exec( types[ t ] ) || [];
                type = origType = tmp[ 1 ];
                namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

                // Unbind all events (on this namespace, if provided) for the element
                if ( !type ) {
                    for ( type in events ) {
                        jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                    }
                    continue;
                }

                special = jQuery.event.special[ type ] || {};
                type = ( selector ? special.delegateType : special.bindType ) || type;
                handlers = events[ type ] || [];
                tmp = tmp[ 2 ] &&
                    new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

                // Remove matching events
                origCount = j = handlers.length;
                while ( j-- ) {
                    handleObj = handlers[ j ];

                    if ( ( mappedTypes || origType === handleObj.origType ) &&
                        ( !handler || handler.guid === handleObj.guid ) &&
                        ( !tmp || tmp.test( handleObj.namespace ) ) &&
                        ( !selector || selector === handleObj.selector ||
                            selector === "**" && handleObj.selector ) ) {
                        handlers.splice( j, 1 );

                        if ( handleObj.selector ) {
                            handlers.delegateCount--;
                        }
                        if ( special.remove ) {
                            special.remove.call( elem, handleObj );
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if ( origCount && !handlers.length ) {
                    if ( !special.teardown ||
                        special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

                        jQuery.removeEvent( elem, type, elemData.handle );
                    }

                    delete events[ type ];
                }
            }

            // Remove data and the expando if it's no longer used
            if ( jQuery.isEmptyObject( events ) ) {
                dataPriv.remove( elem, "handle events" );
            }
        },

        dispatch: function( event ) {

            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix( event );

            var i, j, ret, matched, handleObj,
                handlerQueue = [],
                args = slice.call( arguments ),
                handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
                special = jQuery.event.special[ event.type ] || {};

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[ 0 ] = event;
            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                return;
            }

            // Determine handlers
            handlerQueue = jQuery.event.handlers.call( this, event, handlers );

            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
                event.currentTarget = matched.elem;

                j = 0;
                while ( ( handleObj = matched.handlers[ j++ ] ) &&
                !event.isImmediatePropagationStopped() ) {

                    // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                    // a subset or equal to those in the bound event (both can have no namespace).
                    if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

                        event.handleObj = handleObj;
                        event.data = handleObj.data;

                        ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
                            handleObj.handler ).apply( matched.elem, args );

                        if ( ret !== undefined ) {
                            if ( ( event.result = ret ) === false ) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if ( special.postDispatch ) {
                special.postDispatch.call( this, event );
            }

            return event.result;
        },

        handlers: function( event, handlers ) {
            var i, matches, sel, handleObj,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;

            // Support (at least): Chrome, IE9
            // Find delegate handlers
            // Black-hole SVG <use> instance trees (#13180)
            //
            // Support: Firefox<=42+
            // Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
            if ( delegateCount && cur.nodeType &&
                ( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

                for ( ; cur !== this; cur = cur.parentNode || this ) {

                    // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
                        matches = [];
                        for ( i = 0; i < delegateCount; i++ ) {
                            handleObj = handlers[ i ];

                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";

                            if ( matches[ sel ] === undefined ) {
                                matches[ sel ] = handleObj.needsContext ?
                                    jQuery( sel, this ).index( cur ) > -1 :
                                    jQuery.find( sel, this, null, [ cur ] ).length;
                            }
                            if ( matches[ sel ] ) {
                                matches.push( handleObj );
                            }
                        }
                        if ( matches.length ) {
                            handlerQueue.push( { elem: cur, handlers: matches } );
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            if ( delegateCount < handlers.length ) {
                handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
            }

            return handlerQueue;
        },

        // Includes some event props shared by KeyEvent and MouseEvent
        props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
            "metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

        fixHooks: {},

        keyHooks: {
            props: "char charCode key keyCode".split( " " ),
            filter: function( event, original ) {

                // Add which for key events
                if ( event.which == null ) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
            }
        },

        mouseHooks: {
            props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
                "screenX screenY toElement" ).split( " " ),
            filter: function( event, original ) {
                var eventDoc, doc, body,
                    button = original.button;

                // Calculate pageX/Y if missing and clientX/Y available
                if ( event.pageX == null && original.clientX != null ) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;

                    event.pageX = original.clientX +
                        ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
                        ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                    event.pageY = original.clientY +
                        ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
                        ( doc && doc.clientTop  || body && body.clientTop  || 0 );
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if ( !event.which && button !== undefined ) {
                    event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                }

                return event;
            }
        },

        fix: function( event ) {
            if ( event[ jQuery.expando ] ) {
                return event;
            }

            // Create a writable copy of the event object and normalize some properties
            var i, prop, copy,
                type = event.type,
                originalEvent = event,
                fixHook = this.fixHooks[ type ];

            if ( !fixHook ) {
                this.fixHooks[ type ] = fixHook =
                    rmouseEvent.test( type ) ? this.mouseHooks :
                        rkeyEvent.test( type ) ? this.keyHooks :
                            {};
            }
            copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

            event = new jQuery.Event( originalEvent );

            i = copy.length;
            while ( i-- ) {
                prop = copy[ i ];
                event[ prop ] = originalEvent[ prop ];
            }

            // Support: Cordova 2.5 (WebKit) (#13255)
            // All events should have a target; Cordova deviceready doesn't
            if ( !event.target ) {
                event.target = document;
            }

            // Support: Safari 6.0+, Chrome<28
            // Target should not be a text node (#504, #13143)
            if ( event.target.nodeType === 3 ) {
                event.target = event.target.parentNode;
            }

            return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
        },

        special: {
            load: {

                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {

                // Fire native event if possible so blur/focus sequence is correct
                trigger: function() {
                    if ( this !== safeActiveElement() && this.focus ) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if ( this === safeActiveElement() && this.blur ) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {

                // For checkbox, fire native event so checked state will be right
                trigger: function() {
                    if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
                        this.click();
                        return false;
                    }
                },

                // For cross-browser consistency, don't fire native .click() on links
                _default: function( event ) {
                    return jQuery.nodeName( event.target, "a" );
                }
            },

            beforeunload: {
                postDispatch: function( event ) {

                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if ( event.result !== undefined && event.originalEvent ) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };

    jQuery.removeEvent = function( elem, type, handle ) {

        // This "if" is needed for plain objects
        if ( elem.removeEventListener ) {
            elem.removeEventListener( type, handle );
        }
    };

    jQuery.Event = function( src, props ) {

        // Allow instantiation without the 'new' keyword
        if ( !( this instanceof jQuery.Event ) ) {
            return new jQuery.Event( src, props );
        }

        // Event object
        if ( src && src.type ) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented ||
            src.defaultPrevented === undefined &&

            // Support: Android<4.0
            src.returnValue === false ?
                returnTrue :
                returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if ( props ) {
            jQuery.extend( this, props );
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();

        // Mark it as fixed
        this[ jQuery.expando ] = true;
    };

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,

        preventDefault: function() {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;

            if ( e && !this.isSimulated ) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;

            if ( e && !this.isSimulated ) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;

            this.isImmediatePropagationStopped = returnTrue;

            if ( e && !this.isSimulated ) {
                e.stopImmediatePropagation();
            }

            this.stopPropagation();
        }
    };

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://code.google.com/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each( {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function( orig, fix ) {
        jQuery.event.special[ orig ] = {
            delegateType: fix,
            bindType: fix,

            handle: function( event ) {
                var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;

                // For mouseenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply( this, arguments );
                    event.type = fix;
                }
                return ret;
            }
        };
    } );

    jQuery.fn.extend( {
        on: function( types, selector, data, fn ) {
            return on( this, types, selector, data, fn );
        },
        one: function( types, selector, data, fn ) {
            return on( this, types, selector, data, fn, 1 );
        },
        off: function( types, selector, fn ) {
            var handleObj, type;
            if ( types && types.preventDefault && types.handleObj ) {

                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery( types.delegateTarget ).off(
                    handleObj.namespace ?
                        handleObj.origType + "." + handleObj.namespace :
                        handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                );
                return this;
            }
            if ( typeof types === "object" ) {

                // ( types-object [, selector] )
                for ( type in types ) {
                    this.off( type, selector, types[ type ] );
                }
                return this;
            }
            if ( selector === false || typeof selector === "function" ) {

                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if ( fn === false ) {
                fn = returnFalse;
            }
            return this.each( function() {
                jQuery.event.remove( this, types, fn, selector );
            } );
        }
    } );


    var
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

        // Support: IE 10-11, Edge 10240+
        // In IE/Edge using regex groups here causes severe slowdowns.
        // See https://connect.microsoft.com/IE/feedback/details/1736512/
        rnoInnerhtml = /<script|<style|<link/i,

        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptTypeMasked = /^true\/(.*)/,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Manipulating tables requires a tbody
    function manipulationTarget( elem, content ) {
        return jQuery.nodeName( elem, "table" ) &&
        jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

            elem.getElementsByTagName( "tbody" )[ 0 ] ||
            elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
            elem;
    }

// Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript( elem ) {
        elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
        return elem;
    }
    function restoreScript( elem ) {
        var match = rscriptTypeMasked.exec( elem.type );

        if ( match ) {
            elem.type = match[ 1 ];
        } else {
            elem.removeAttribute( "type" );
        }

        return elem;
    }

    function cloneCopyEvent( src, dest ) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

        if ( dest.nodeType !== 1 ) {
            return;
        }

        // 1. Copy private data: events, handlers, etc.
        if ( dataPriv.hasData( src ) ) {
            pdataOld = dataPriv.access( src );
            pdataCur = dataPriv.set( dest, pdataOld );
            events = pdataOld.events;

            if ( events ) {
                delete pdataCur.handle;
                pdataCur.events = {};

                for ( type in events ) {
                    for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                        jQuery.event.add( dest, type, events[ type ][ i ] );
                    }
                }
            }
        }

        // 2. Copy user data
        if ( dataUser.hasData( src ) ) {
            udataOld = dataUser.access( src );
            udataCur = jQuery.extend( {}, udataOld );

            dataUser.set( dest, udataCur );
        }
    }

// Fix IE bugs, see support tests
    function fixInput( src, dest ) {
        var nodeName = dest.nodeName.toLowerCase();

        // Fails to persist the checked state of a cloned checkbox or radio button.
        if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
            dest.checked = src.checked;

            // Fails to return the selected option to the default selected state when cloning options
        } else if ( nodeName === "input" || nodeName === "textarea" ) {
            dest.defaultValue = src.defaultValue;
        }
    }

    function domManip( collection, args, callback, ignored ) {

        // Flatten any nested arrays
        args = concat.apply( [], args );

        var fragment, first, scripts, hasScripts, node, doc,
            i = 0,
            l = collection.length,
            iNoClone = l - 1,
            value = args[ 0 ],
            isFunction = jQuery.isFunction( value );

        // We can't cloneNode fragments that contain checked, in WebKit
        if ( isFunction ||
            ( l > 1 && typeof value === "string" &&
                !support.checkClone && rchecked.test( value ) ) ) {
            return collection.each( function( index ) {
                var self = collection.eq( index );
                if ( isFunction ) {
                    args[ 0 ] = value.call( this, index, self.html() );
                }
                domManip( self, args, callback, ignored );
            } );
        }

        if ( l ) {
            fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
            first = fragment.firstChild;

            if ( fragment.childNodes.length === 1 ) {
                fragment = first;
            }

            // Require either new content or an interest in ignored elements to invoke the callback
            if ( first || ignored ) {
                scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                hasScripts = scripts.length;

                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for ( ; i < l; i++ ) {
                    node = fragment;

                    if ( i !== iNoClone ) {
                        node = jQuery.clone( node, true, true );

                        // Keep references to cloned scripts for later restoration
                        if ( hasScripts ) {

                            // Support: Android<4.1, PhantomJS<2
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge( scripts, getAll( node, "script" ) );
                        }
                    }

                    callback.call( collection[ i ], node, i );
                }

                if ( hasScripts ) {
                    doc = scripts[ scripts.length - 1 ].ownerDocument;

                    // Reenable scripts
                    jQuery.map( scripts, restoreScript );

                    // Evaluate executable scripts on first document insertion
                    for ( i = 0; i < hasScripts; i++ ) {
                        node = scripts[ i ];
                        if ( rscriptType.test( node.type || "" ) &&
                            !dataPriv.access( node, "globalEval" ) &&
                            jQuery.contains( doc, node ) ) {

                            if ( node.src ) {

                                // Optional AJAX dependency, but won't run scripts if not present
                                if ( jQuery._evalUrl ) {
                                    jQuery._evalUrl( node.src );
                                }
                            } else {
                                jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
                            }
                        }
                    }
                }
            }
        }

        return collection;
    }

    function remove( elem, selector, keepData ) {
        var node,
            nodes = selector ? jQuery.filter( selector, elem ) : elem,
            i = 0;

        for ( ; ( node = nodes[ i ] ) != null; i++ ) {
            if ( !keepData && node.nodeType === 1 ) {
                jQuery.cleanData( getAll( node ) );
            }

            if ( node.parentNode ) {
                if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
                    setGlobalEval( getAll( node, "script" ) );
                }
                node.parentNode.removeChild( node );
            }
        }

        return elem;
    }

    jQuery.extend( {
        htmlPrefilter: function( html ) {
            return html.replace( rxhtmlTag, "<$1></$2>" );
        },

        clone: function( elem, dataAndEvents, deepDataAndEvents ) {
            var i, l, srcElements, destElements,
                clone = elem.cloneNode( true ),
                inPage = jQuery.contains( elem.ownerDocument, elem );

            // Fix IE cloning issues
            if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
                !jQuery.isXMLDoc( elem ) ) {

                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                destElements = getAll( clone );
                srcElements = getAll( elem );

                for ( i = 0, l = srcElements.length; i < l; i++ ) {
                    fixInput( srcElements[ i ], destElements[ i ] );
                }
            }

            // Copy the events from the original to the clone
            if ( dataAndEvents ) {
                if ( deepDataAndEvents ) {
                    srcElements = srcElements || getAll( elem );
                    destElements = destElements || getAll( clone );

                    for ( i = 0, l = srcElements.length; i < l; i++ ) {
                        cloneCopyEvent( srcElements[ i ], destElements[ i ] );
                    }
                } else {
                    cloneCopyEvent( elem, clone );
                }
            }

            // Preserve script evaluation history
            destElements = getAll( clone, "script" );
            if ( destElements.length > 0 ) {
                setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
            }

            // Return the cloned set
            return clone;
        },

        cleanData: function( elems ) {
            var data, elem, type,
                special = jQuery.event.special,
                i = 0;

            for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
                if ( acceptData( elem ) ) {
                    if ( ( data = elem[ dataPriv.expando ] ) ) {
                        if ( data.events ) {
                            for ( type in data.events ) {
                                if ( special[ type ] ) {
                                    jQuery.event.remove( elem, type );

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent( elem, type, data.handle );
                                }
                            }
                        }

                        // Support: Chrome <= 35-45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[ dataPriv.expando ] = undefined;
                    }
                    if ( elem[ dataUser.expando ] ) {

                        // Support: Chrome <= 35-45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[ dataUser.expando ] = undefined;
                    }
                }
            }
        }
    } );

    jQuery.fn.extend( {

        // Keep domManip exposed until 3.0 (gh-2225)
        domManip: domManip,

        detach: function( selector ) {
            return remove( this, selector, true );
        },

        remove: function( selector ) {
            return remove( this, selector );
        },

        text: function( value ) {
            return access( this, function( value ) {
                return value === undefined ?
                    jQuery.text( this ) :
                    this.empty().each( function() {
                        if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                            this.textContent = value;
                        }
                    } );
            }, null, value, arguments.length );
        },

        append: function() {
            return domManip( this, arguments, function( elem ) {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                    var target = manipulationTarget( this, elem );
                    target.appendChild( elem );
                }
            } );
        },

        prepend: function() {
            return domManip( this, arguments, function( elem ) {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                    var target = manipulationTarget( this, elem );
                    target.insertBefore( elem, target.firstChild );
                }
            } );
        },

        before: function() {
            return domManip( this, arguments, function( elem ) {
                if ( this.parentNode ) {
                    this.parentNode.insertBefore( elem, this );
                }
            } );
        },

        after: function() {
            return domManip( this, arguments, function( elem ) {
                if ( this.parentNode ) {
                    this.parentNode.insertBefore( elem, this.nextSibling );
                }
            } );
        },

        empty: function() {
            var elem,
                i = 0;

            for ( ; ( elem = this[ i ] ) != null; i++ ) {
                if ( elem.nodeType === 1 ) {

                    // Prevent memory leaks
                    jQuery.cleanData( getAll( elem, false ) );

                    // Remove any remaining nodes
                    elem.textContent = "";
                }
            }

            return this;
        },

        clone: function( dataAndEvents, deepDataAndEvents ) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map( function() {
                return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
            } );
        },

        html: function( value ) {
            return access( this, function( value ) {
                var elem = this[ 0 ] || {},
                    i = 0,
                    l = this.length;

                if ( value === undefined && elem.nodeType === 1 ) {
                    return elem.innerHTML;
                }

                // See if we can take a shortcut and just use innerHTML
                if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                    !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

                    value = jQuery.htmlPrefilter( value );

                    try {
                        for ( ; i < l; i++ ) {
                            elem = this[ i ] || {};

                            // Remove element nodes and prevent memory leaks
                            if ( elem.nodeType === 1 ) {
                                jQuery.cleanData( getAll( elem, false ) );
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch ( e ) {}
                }

                if ( elem ) {
                    this.empty().append( value );
                }
            }, null, value, arguments.length );
        },

        replaceWith: function() {
            var ignored = [];

            // Make the changes, replacing each non-ignored context element with the new content
            return domManip( this, arguments, function( elem ) {
                var parent = this.parentNode;

                if ( jQuery.inArray( this, ignored ) < 0 ) {
                    jQuery.cleanData( getAll( this ) );
                    if ( parent ) {
                        parent.replaceChild( elem, this );
                    }
                }

                // Force callback invocation
            }, ignored );
        }
    } );

    jQuery.each( {
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function( name, original ) {
        jQuery.fn[ name ] = function( selector ) {
            var elems,
                ret = [],
                insert = jQuery( selector ),
                last = insert.length - 1,
                i = 0;

            for ( ; i <= last; i++ ) {
                elems = i === last ? this : this.clone( true );
                jQuery( insert[ i ] )[ original ]( elems );

                // Support: QtWebKit
                // .get() because push.apply(_, arraylike) throws
                push.apply( ret, elems.get() );
            }

            return this.pushStack( ret );
        };
    } );


    var iframe,
        elemdisplay = {

            // Support: Firefox
            // We have to pre-define these values for FF (#10227)
            HTML: "block",
            BODY: "block"
        };

    /**
     * Retrieve the actual display of a element
     * @param {String} name nodeName of the element
     * @param {Object} doc Document object
     */

// Called only from within defaultDisplay
    function actualDisplay( name, doc ) {
        var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

            display = jQuery.css( elem[ 0 ], "display" );

        // We don't have any data stored on the element,
        // so use "detach" method as fast way to get rid of the element
        elem.detach();

        return display;
    }

    /**
     * Try to determine the default display value of an element
     * @param {String} nodeName
     */
    function defaultDisplay( nodeName ) {
        var doc = document,
            display = elemdisplay[ nodeName ];

        if ( !display ) {
            display = actualDisplay( nodeName, doc );

            // If the simple way fails, read from inside an iframe
            if ( display === "none" || !display ) {

                // Use the already-created iframe if possible
                iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
                    .appendTo( doc.documentElement );

                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                doc = iframe[ 0 ].contentDocument;

                // Support: IE
                doc.write();
                doc.close();

                display = actualDisplay( nodeName, doc );
                iframe.detach();
            }

            // Store the correct default display
            elemdisplay[ nodeName ] = display;
        }

        return display;
    }
    var rmargin = ( /^margin/ );

    var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

    var getStyles = function( elem ) {

        // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if ( !view || !view.opener ) {
            view = window;
        }

        return view.getComputedStyle( elem );
    };

    var swap = function( elem, options, callback, args ) {
        var ret, name,
            old = {};

        // Remember the old values, and insert the new ones
        for ( name in options ) {
            old[ name ] = elem.style[ name ];
            elem.style[ name ] = options[ name ];
        }

        ret = callback.apply( elem, args || [] );

        // Revert the old values
        for ( name in options ) {
            elem.style[ name ] = old[ name ];
        }

        return ret;
    };


    var documentElement = document.documentElement;



    ( function() {
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
            container = document.createElement( "div" ),
            div = document.createElement( "div" );

        // Finish early in limited (non-browser) environments
        if ( !div.style ) {
            return;
        }

        // Support: IE9-11+
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode( true ).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";

        container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
            "padding:0;margin-top:1px;position:absolute";
        container.appendChild( div );

        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {
            div.style.cssText =

                // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
                "position:relative;display:block;" +
                "margin:auto;border:1px;padding:1px;" +
                "top:1%;width:50%";
            div.innerHTML = "";
            documentElement.appendChild( container );

            var divStyle = window.getComputedStyle( div );
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = divStyle.marginLeft === "2px";
            boxSizingReliableVal = divStyle.width === "4px";

            // Support: Android 4.0 - 4.3 only
            // Some styles come back with percentage values, even though they shouldn't
            div.style.marginRight = "50%";
            pixelMarginRightVal = divStyle.marginRight === "4px";

            documentElement.removeChild( container );
        }

        jQuery.extend( support, {
            pixelPosition: function() {

                // This test is executed only once but we still do memoizing
                // since we can use the boxSizingReliable pre-computing.
                // No need to check if the test was already performed, though.
                computeStyleTests();
                return pixelPositionVal;
            },
            boxSizingReliable: function() {
                if ( boxSizingReliableVal == null ) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },
            pixelMarginRight: function() {

                // Support: Android 4.0-4.3
                // We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
                // since that compresses better and they're computed together anyway.
                if ( boxSizingReliableVal == null ) {
                    computeStyleTests();
                }
                return pixelMarginRightVal;
            },
            reliableMarginLeft: function() {

                // Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
                if ( boxSizingReliableVal == null ) {
                    computeStyleTests();
                }
                return reliableMarginLeftVal;
            },
            reliableMarginRight: function() {

                // Support: Android 2.3
                // Check if div with explicit width and no margin-right incorrectly
                // gets computed margin-right based on width of container. (#3333)
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                // This support function is only executed once so no memoizing is needed.
                var ret,
                    marginDiv = div.appendChild( document.createElement( "div" ) );

                // Reset CSS: box-sizing; display; margin; border; padding
                marginDiv.style.cssText = div.style.cssText =

                    // Support: Android 2.3
                    // Vendor-prefix box-sizing
                    "-webkit-box-sizing:content-box;box-sizing:content-box;" +
                    "display:block;margin:0;border:0;padding:0";
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";
                documentElement.appendChild( container );

                ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

                documentElement.removeChild( container );
                div.removeChild( marginDiv );

                return ret;
            }
        } );
    } )();


    function curCSS( elem, name, computed ) {
        var width, minWidth, maxWidth, ret,
            style = elem.style;

        computed = computed || getStyles( elem );
        ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

        // Support: Opera 12.1x only
        // Fall back to style even without computed
        // computed is undefined for elems on document fragments
        if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
            ret = jQuery.style( elem, name );
        }

        // Support: IE9
        // getPropertyValue is only needed for .css('filter') (#12537)
        if ( computed ) {

            // A tribute to the "awesome hack by Dean Edwards"
            // Android Browser returns percentage for some values,
            // but width seems to be reliably pixels.
            // This is against the CSSOM draft spec:
            // http://dev.w3.org/csswg/cssom/#resolved-values
            if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        return ret !== undefined ?

            // Support: IE9-11+
            // IE returns zIndex value as an integer.
            ret + "" :
            ret;
    }


    function addGetHookIf( conditionFn, hookFn ) {

        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                if ( conditionFn() ) {

                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }

                // Hook needed; redefine it so that the support test is not executed again.
                return ( this.get = hookFn ).apply( this, arguments );
            }
        };
    }


    var

        // Swappable if display is none or starts with table
        // except "table", "table-cell", or "table-caption"
        // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,

        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        },

        cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
        emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
    function vendorPropName( name ) {

        // Shortcut for names that are not vendor prefixed
        if ( name in emptyStyle ) {
            return name;
        }

        // Check for vendor prefixed names
        var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
            i = cssPrefixes.length;

        while ( i-- ) {
            name = cssPrefixes[ i ] + capName;
            if ( name in emptyStyle ) {
                return name;
            }
        }
    }

    function setPositiveNumber( elem, value, subtract ) {

        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec( value );
        return matches ?

            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
            value;
    }

    function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
        var i = extra === ( isBorderBox ? "border" : "content" ) ?

            // If we already have the right measurement, avoid augmentation
            4 :

            // Otherwise initialize for horizontal or vertical properties
            name === "width" ? 1 : 0,

            val = 0;

        for ( ; i < 4; i += 2 ) {

            // Both box models exclude margin, so add it if we want it
            if ( extra === "margin" ) {
                val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
            }

            if ( isBorderBox ) {

                // border-box includes padding, so remove it if we want content
                if ( extra === "content" ) {
                    val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
                }

                // At this point, extra isn't border nor margin, so remove border
                if ( extra !== "margin" ) {
                    val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                }
            } else {

                // At this point, extra isn't content, so add padding
                val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

                // At this point, extra isn't content nor padding, so add border
                if ( extra !== "padding" ) {
                    val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                }
            }
        }

        return val;
    }

    function getWidthOrHeight( elem, name, extra ) {

        // Start with offset property, which is equivalent to the border-box value
        var valueIsBorderBox = true,
            val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles( elem ),
            isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

        // Some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if ( val <= 0 || val == null ) {

            // Fall back to computed then uncomputed css if necessary
            val = curCSS( elem, name, styles );
            if ( val < 0 || val == null ) {
                val = elem.style[ name ];
            }

            // Computed unit is not pixels. Stop here and return.
            if ( rnumnonpx.test( val ) ) {
                return val;
            }

            // Check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox &&
                ( support.boxSizingReliable() || val === elem.style[ name ] );

            // Normalize "", auto, and prepare for extra
            val = parseFloat( val ) || 0;
        }

        // Use the active box-sizing model to add/subtract irrelevant styles
        return ( val +
            augmentWidthOrHeight(
                elem,
                name,
                extra || ( isBorderBox ? "border" : "content" ),
                valueIsBorderBox,
                styles
            )
        ) + "px";
    }

    function showHide( elements, show ) {
        var display, elem, hidden,
            values = [],
            index = 0,
            length = elements.length;

        for ( ; index < length; index++ ) {
            elem = elements[ index ];
            if ( !elem.style ) {
                continue;
            }

            values[ index ] = dataPriv.get( elem, "olddisplay" );
            display = elem.style.display;
            if ( show ) {

                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if ( !values[ index ] && display === "none" ) {
                    elem.style.display = "";
                }

                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if ( elem.style.display === "" && isHidden( elem ) ) {
                    values[ index ] = dataPriv.access(
                        elem,
                        "olddisplay",
                        defaultDisplay( elem.nodeName )
                    );
                }
            } else {
                hidden = isHidden( elem );

                if ( display !== "none" || !hidden ) {
                    dataPriv.set(
                        elem,
                        "olddisplay",
                        hidden ? display : jQuery.css( elem, "display" )
                    );
                }
            }
        }

        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for ( index = 0; index < length; index++ ) {
            elem = elements[ index ];
            if ( !elem.style ) {
                continue;
            }
            if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
                elem.style.display = show ? values[ index ] || "" : "none";
            }
        }

        return elements;
    }

    jQuery.extend( {

        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function( elem, computed ) {
                    if ( computed ) {

                        // We should always get a number back from opacity
                        var ret = curCSS( elem, "opacity" );
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            "float": "cssFloat"
        },

        // Get and set the style property on a DOM Node
        style: function( elem, name, value, extra ) {

            // Don't set styles on text and comment nodes
            if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, hooks,
                origName = jQuery.camelCase( name ),
                style = elem.style;

            name = jQuery.cssProps[ origName ] ||
                ( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

            // Check if we're setting a value
            if ( value !== undefined ) {
                type = typeof value;

                // Convert "+=" or "-=" to relative numbers (#7345)
                if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
                    value = adjustCSS( elem, name, ret );

                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that null and NaN values aren't set (#7116)
                if ( value == null || value !== value ) {
                    return;
                }

                // If a number was passed in, add the unit (except for certain CSS properties)
                if ( type === "number" ) {
                    value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
                }

                // Support: IE9-11+
                // background-* props affect original clone's values
                if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
                    style[ name ] = "inherit";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if ( !hooks || !( "set" in hooks ) ||
                    ( value = hooks.set( elem, value, extra ) ) !== undefined ) {

                    style[ name ] = value;
                }

            } else {

                // If a hook was provided get the non-computed value from there
                if ( hooks && "get" in hooks &&
                    ( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[ name ];
            }
        },

        css: function( elem, name, extra, styles ) {
            var val, num, hooks,
                origName = jQuery.camelCase( name );

            // Make sure that we're working with the right name
            name = jQuery.cssProps[ origName ] ||
                ( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

            // If a hook was provided get the computed value from there
            if ( hooks && "get" in hooks ) {
                val = hooks.get( elem, true, extra );
            }

            // Otherwise, if a way to get the computed value exists, use that
            if ( val === undefined ) {
                val = curCSS( elem, name, styles );
            }

            // Convert "normal" to computed value
            if ( val === "normal" && name in cssNormalTransform ) {
                val = cssNormalTransform[ name ];
            }

            // Make numeric if forced or a qualifier was provided and val looks numeric
            if ( extra === "" || extra ) {
                num = parseFloat( val );
                return extra === true || isFinite( num ) ? num || 0 : val;
            }
            return val;
        }
    } );

    jQuery.each( [ "height", "width" ], function( i, name ) {
        jQuery.cssHooks[ name ] = {
            get: function( elem, computed, extra ) {
                if ( computed ) {

                    // Certain elements can have dimension info if we invisibly show them
                    // but it must have a current display style that would benefit
                    return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
                    elem.offsetWidth === 0 ?
                        swap( elem, cssShow, function() {
                            return getWidthOrHeight( elem, name, extra );
                        } ) :
                        getWidthOrHeight( elem, name, extra );
                }
            },

            set: function( elem, value, extra ) {
                var matches,
                    styles = extra && getStyles( elem ),
                    subtract = extra && augmentWidthOrHeight(
                        elem,
                        name,
                        extra,
                        jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                        styles
                    );

                // Convert to pixels if value adjustment is needed
                if ( subtract && ( matches = rcssNum.exec( value ) ) &&
                    ( matches[ 3 ] || "px" ) !== "px" ) {

                    elem.style[ name ] = value;
                    value = jQuery.css( elem, name );
                }

                return setPositiveNumber( elem, value, subtract );
            }
        };
    } );

    jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
        function( elem, computed ) {
            if ( computed ) {
                return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
                    elem.getBoundingClientRect().left -
                    swap( elem, { marginLeft: 0 }, function() {
                        return elem.getBoundingClientRect().left;
                    } )
                ) + "px";
            }
        }
    );

// Support: Android 2.3
    jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
        function( elem, computed ) {
            if ( computed ) {
                return swap( elem, { "display": "inline-block" },
                    curCSS, [ elem, "marginRight" ] );
            }
        }
    );

// These hooks are used by animate to expand properties
    jQuery.each( {
        margin: "",
        padding: "",
        border: "Width"
    }, function( prefix, suffix ) {
        jQuery.cssHooks[ prefix + suffix ] = {
            expand: function( value ) {
                var i = 0,
                    expanded = {},

                    // Assumes a single number if not a string
                    parts = typeof value === "string" ? value.split( " " ) : [ value ];

                for ( ; i < 4; i++ ) {
                    expanded[ prefix + cssExpand[ i ] + suffix ] =
                        parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                }

                return expanded;
            }
        };

        if ( !rmargin.test( prefix ) ) {
            jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
        }
    } );

    jQuery.fn.extend( {
        css: function( name, value ) {
            return access( this, function( elem, name, value ) {
                var styles, len,
                    map = {},
                    i = 0;

                if ( jQuery.isArray( name ) ) {
                    styles = getStyles( elem );
                    len = name.length;

                    for ( ; i < len; i++ ) {
                        map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                    }

                    return map;
                }

                return value !== undefined ?
                    jQuery.style( elem, name, value ) :
                    jQuery.css( elem, name );
            }, name, value, arguments.length > 1 );
        },
        show: function() {
            return showHide( this, true );
        },
        hide: function() {
            return showHide( this );
        },
        toggle: function( state ) {
            if ( typeof state === "boolean" ) {
                return state ? this.show() : this.hide();
            }

            return this.each( function() {
                if ( isHidden( this ) ) {
                    jQuery( this ).show();
                } else {
                    jQuery( this ).hide();
                }
            } );
        }
    } );


    function Tween( elem, options, prop, end, easing ) {
        return new Tween.prototype.init( elem, options, prop, end, easing );
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function( elem, options, prop, end, easing, unit ) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
        },
        cur: function() {
            var hooks = Tween.propHooks[ this.prop ];

            return hooks && hooks.get ?
                hooks.get( this ) :
                Tween.propHooks._default.get( this );
        },
        run: function( percent ) {
            var eased,
                hooks = Tween.propHooks[ this.prop ];

            if ( this.options.duration ) {
                this.pos = eased = jQuery.easing[ this.easing ](
                    percent, this.options.duration * percent, 0, 1, this.options.duration
                );
            } else {
                this.pos = eased = percent;
            }
            this.now = ( this.end - this.start ) * eased + this.start;

            if ( this.options.step ) {
                this.options.step.call( this.elem, this.now, this );
            }

            if ( hooks && hooks.set ) {
                hooks.set( this );
            } else {
                Tween.propHooks._default.set( this );
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function( tween ) {
                var result;

                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if ( tween.elem.nodeType !== 1 ||
                    tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
                    return tween.elem[ tween.prop ];
                }

                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css( tween.elem, tween.prop, "" );

                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function( tween ) {

                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if ( jQuery.fx.step[ tween.prop ] ) {
                    jQuery.fx.step[ tween.prop ]( tween );
                } else if ( tween.elem.nodeType === 1 &&
                    ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
                        jQuery.cssHooks[ tween.prop ] ) ) {
                    jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                } else {
                    tween.elem[ tween.prop ] = tween.now;
                }
            }
        }
    };

// Support: IE9
// Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function( tween ) {
            if ( tween.elem.nodeType && tween.elem.parentNode ) {
                tween.elem[ tween.prop ] = tween.now;
            }
        }
    };

    jQuery.easing = {
        linear: function( p ) {
            return p;
        },
        swing: function( p ) {
            return 0.5 - Math.cos( p * Math.PI ) / 2;
        },
        _default: "swing"
    };

    jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
    jQuery.fx.step = {};




    var
        fxNow, timerId,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rrun = /queueHooks$/;

// Animations created synchronously will run synchronously
    function createFxNow() {
        window.setTimeout( function() {
            fxNow = undefined;
        } );
        return ( fxNow = jQuery.now() );
    }

// Generate parameters to create a standard animation
    function genFx( type, includeWidth ) {
        var which,
            i = 0,
            attrs = { height: type };

        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for ( ; i < 4 ; i += 2 - includeWidth ) {
            which = cssExpand[ i ];
            attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
        }

        if ( includeWidth ) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    function createTween( value, prop, animation ) {
        var tween,
            collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
            index = 0,
            length = collection.length;
        for ( ; index < length; index++ ) {
            if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

                // We're done with this property
                return tween;
            }
        }
    }

    function defaultPrefilter( elem, props, opts ) {
        /* jshint validthis: true */
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHidden( elem ),
            dataShow = dataPriv.get( elem, "fxshow" );

        // Handle queue: false promises
        if ( !opts.queue ) {
            hooks = jQuery._queueHooks( elem, "fx" );
            if ( hooks.unqueued == null ) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if ( !hooks.unqueued ) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always( function() {

                // Ensure the complete handler is called before this completes
                anim.always( function() {
                    hooks.unqueued--;
                    if ( !jQuery.queue( elem, "fx" ).length ) {
                        hooks.empty.fire();
                    }
                } );
            } );
        }

        // Height/width overflow pass
        if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

            // Make sure that nothing sneaks out
            // Record all 3 overflow attributes because IE9-10 do not
            // change the overflow attribute when overflowX and
            // overflowY are set to the same value
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

            // Set display property to inline-block for height/width
            // animations on inline elements that are having width/height animated
            display = jQuery.css( elem, "display" );

            // Test default display if display is currently "none"
            checkDisplay = display === "none" ?
                dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

            if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
                style.display = "inline-block";
            }
        }

        if ( opts.overflow ) {
            style.overflow = "hidden";
            anim.always( function() {
                style.overflow = opts.overflow[ 0 ];
                style.overflowX = opts.overflow[ 1 ];
                style.overflowY = opts.overflow[ 2 ];
            } );
        }

        // show/hide pass
        for ( prop in props ) {
            value = props[ prop ];
            if ( rfxtypes.exec( value ) ) {
                delete props[ prop ];
                toggle = toggle || value === "toggle";
                if ( value === ( hidden ? "hide" : "show" ) ) {

                    // If there is dataShow left over from a stopped hide or show
                    // and we are going to proceed with show, we should pretend to be hidden
                    if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

                // Any non-fx value stops us from restoring the original display value
            } else {
                display = undefined;
            }
        }

        if ( !jQuery.isEmptyObject( orig ) ) {
            if ( dataShow ) {
                if ( "hidden" in dataShow ) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = dataPriv.access( elem, "fxshow", {} );
            }

            // Store state if its toggle - enables .stop().toggle() to "reverse"
            if ( toggle ) {
                dataShow.hidden = !hidden;
            }
            if ( hidden ) {
                jQuery( elem ).show();
            } else {
                anim.done( function() {
                    jQuery( elem ).hide();
                } );
            }
            anim.done( function() {
                var prop;

                dataPriv.remove( elem, "fxshow" );
                for ( prop in orig ) {
                    jQuery.style( elem, prop, orig[ prop ] );
                }
            } );
            for ( prop in orig ) {
                tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

                if ( !( prop in dataShow ) ) {
                    dataShow[ prop ] = tween.start;
                    if ( hidden ) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }

            // If this is a noop like .hide().hide(), restore an overwritten display value
        } else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
            style.display = display;
        }
    }

    function propFilter( props, specialEasing ) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for ( index in props ) {
            name = jQuery.camelCase( index );
            easing = specialEasing[ name ];
            value = props[ index ];
            if ( jQuery.isArray( value ) ) {
                easing = value[ 1 ];
                value = props[ index ] = value[ 0 ];
            }

            if ( index !== name ) {
                props[ name ] = value;
                delete props[ index ];
            }

            hooks = jQuery.cssHooks[ name ];
            if ( hooks && "expand" in hooks ) {
                value = hooks.expand( value );
                delete props[ name ];

                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for ( index in value ) {
                    if ( !( index in props ) ) {
                        props[ index ] = value[ index ];
                        specialEasing[ index ] = easing;
                    }
                }
            } else {
                specialEasing[ name ] = easing;
            }
        }
    }

    function Animation( elem, properties, options ) {
        var result,
            stopped,
            index = 0,
            length = Animation.prefilters.length,
            deferred = jQuery.Deferred().always( function() {

                // Don't match elem in the :animated selector
                delete tick.elem;
            } ),
            tick = function() {
                if ( stopped ) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

                    // Support: Android 2.3
                    // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                for ( ; index < length ; index++ ) {
                    animation.tweens[ index ].run( percent );
                }

                deferred.notifyWith( elem, [ animation, percent, remaining ] );

                if ( percent < 1 && length ) {
                    return remaining;
                } else {
                    deferred.resolveWith( elem, [ animation ] );
                    return false;
                }
            },
            animation = deferred.promise( {
                elem: elem,
                props: jQuery.extend( {}, properties ),
                opts: jQuery.extend( true, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options ),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function( prop, end ) {
                    var tween = jQuery.Tween( elem, animation.opts, prop, end,
                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
                    animation.tweens.push( tween );
                    return tween;
                },
                stop: function( gotoEnd ) {
                    var index = 0,

                        // If we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;
                    if ( stopped ) {
                        return this;
                    }
                    stopped = true;
                    for ( ; index < length ; index++ ) {
                        animation.tweens[ index ].run( 1 );
                    }

                    // Resolve when we played the last frame; otherwise, reject
                    if ( gotoEnd ) {
                        deferred.notifyWith( elem, [ animation, 1, 0 ] );
                        deferred.resolveWith( elem, [ animation, gotoEnd ] );
                    } else {
                        deferred.rejectWith( elem, [ animation, gotoEnd ] );
                    }
                    return this;
                }
            } ),
            props = animation.props;

        propFilter( props, animation.opts.specialEasing );

        for ( ; index < length ; index++ ) {
            result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
            if ( result ) {
                if ( jQuery.isFunction( result.stop ) ) {
                    jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
                        jQuery.proxy( result.stop, result );
                }
                return result;
            }
        }

        jQuery.map( props, createTween, animation );

        if ( jQuery.isFunction( animation.opts.start ) ) {
            animation.opts.start.call( elem, animation );
        }

        jQuery.fx.timer(
            jQuery.extend( tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            } )
        );

        // attach callbacks from options
        return animation.progress( animation.opts.progress )
            .done( animation.opts.done, animation.opts.complete )
            .fail( animation.opts.fail )
            .always( animation.opts.always );
    }

    jQuery.Animation = jQuery.extend( Animation, {
        tweeners: {
            "*": [ function( prop, value ) {
                var tween = this.createTween( prop, value );
                adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
                return tween;
            } ]
        },

        tweener: function( props, callback ) {
            if ( jQuery.isFunction( props ) ) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.match( rnotwhite );
            }

            var prop,
                index = 0,
                length = props.length;

            for ( ; index < length ; index++ ) {
                prop = props[ index ];
                Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
                Animation.tweeners[ prop ].unshift( callback );
            }
        },

        prefilters: [ defaultPrefilter ],

        prefilter: function( callback, prepend ) {
            if ( prepend ) {
                Animation.prefilters.unshift( callback );
            } else {
                Animation.prefilters.push( callback );
            }
        }
    } );

    jQuery.speed = function( speed, easing, fn ) {
        var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
            complete: fn || !fn && easing ||
            jQuery.isFunction( speed ) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
        };

        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
            opt.duration : opt.duration in jQuery.fx.speeds ?
                jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

        // Normalize opt.queue - true/undefined/null -> "fx"
        if ( opt.queue == null || opt.queue === true ) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function() {
            if ( jQuery.isFunction( opt.old ) ) {
                opt.old.call( this );
            }

            if ( opt.queue ) {
                jQuery.dequeue( this, opt.queue );
            }
        };

        return opt;
    };

    jQuery.fn.extend( {
        fadeTo: function( speed, to, easing, callback ) {

            // Show any hidden elements after setting opacity to 0
            return this.filter( isHidden ).css( "opacity", 0 ).show()

            // Animate to the value specified
                .end().animate( { opacity: to }, speed, easing, callback );
        },
        animate: function( prop, speed, easing, callback ) {
            var empty = jQuery.isEmptyObject( prop ),
                optall = jQuery.speed( speed, easing, callback ),
                doAnimation = function() {

                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                    // Empty animations, or finishing resolves immediately
                    if ( empty || dataPriv.get( this, "finish" ) ) {
                        anim.stop( true );
                    }
                };
            doAnimation.finish = doAnimation;

            return empty || optall.queue === false ?
                this.each( doAnimation ) :
                this.queue( optall.queue, doAnimation );
        },
        stop: function( type, clearQueue, gotoEnd ) {
            var stopQueue = function( hooks ) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop( gotoEnd );
            };

            if ( typeof type !== "string" ) {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if ( clearQueue && type !== false ) {
                this.queue( type || "fx", [] );
            }

            return this.each( function() {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = dataPriv.get( this );

                if ( index ) {
                    if ( data[ index ] && data[ index ].stop ) {
                        stopQueue( data[ index ] );
                    }
                } else {
                    for ( index in data ) {
                        if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                            stopQueue( data[ index ] );
                        }
                    }
                }

                for ( index = timers.length; index--; ) {
                    if ( timers[ index ].elem === this &&
                        ( type == null || timers[ index ].queue === type ) ) {

                        timers[ index ].anim.stop( gotoEnd );
                        dequeue = false;
                        timers.splice( index, 1 );
                    }
                }

                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if ( dequeue || !gotoEnd ) {
                    jQuery.dequeue( this, type );
                }
            } );
        },
        finish: function( type ) {
            if ( type !== false ) {
                type = type || "fx";
            }
            return this.each( function() {
                var index,
                    data = dataPriv.get( this ),
                    queue = data[ type + "queue" ],
                    hooks = data[ type + "queueHooks" ],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;

                // Enable finishing flag on private data
                data.finish = true;

                // Empty the queue first
                jQuery.queue( this, type, [] );

                if ( hooks && hooks.stop ) {
                    hooks.stop.call( this, true );
                }

                // Look for any active animations, and finish them
                for ( index = timers.length; index--; ) {
                    if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                        timers[ index ].anim.stop( true );
                        timers.splice( index, 1 );
                    }
                }

                // Look for any animations in the old queue and finish them
                for ( index = 0; index < length; index++ ) {
                    if ( queue[ index ] && queue[ index ].finish ) {
                        queue[ index ].finish.call( this );
                    }
                }

                // Turn off finishing flag
                delete data.finish;
            } );
        }
    } );

    jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
        var cssFn = jQuery.fn[ name ];
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return speed == null || typeof speed === "boolean" ?
                cssFn.apply( this, arguments ) :
                this.animate( genFx( name, true ), speed, easing, callback );
        };
    } );

// Generate shortcuts for custom animations
    jQuery.each( {
        slideDown: genFx( "show" ),
        slideUp: genFx( "hide" ),
        slideToggle: genFx( "toggle" ),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function( name, props ) {
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return this.animate( props, speed, easing, callback );
        };
    } );

    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer,
            i = 0,
            timers = jQuery.timers;

        fxNow = jQuery.now();

        for ( ; i < timers.length; i++ ) {
            timer = timers[ i ];

            // Checks the timer has not already been removed
            if ( !timer() && timers[ i ] === timer ) {
                timers.splice( i--, 1 );
            }
        }

        if ( !timers.length ) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function( timer ) {
        jQuery.timers.push( timer );
        if ( timer() ) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };

    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if ( !timerId ) {
            timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
        }
    };

    jQuery.fx.stop = function() {
        window.clearInterval( timerId );

        timerId = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,

        // Default speed
        _default: 400
    };


// Based off of the plugin by Clint Helfers, with permission.
// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function( time, type ) {
        time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
        type = type || "fx";

        return this.queue( type, function( next, hooks ) {
            var timeout = window.setTimeout( next, time );
            hooks.stop = function() {
                window.clearTimeout( timeout );
            };
        } );
    };


    ( function() {
        var input = document.createElement( "input" ),
            select = document.createElement( "select" ),
            opt = select.appendChild( document.createElement( "option" ) );

        input.type = "checkbox";

        // Support: iOS<=5.1, Android<=4.2+
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";

        // Support: IE<=11+
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;

        // Support: Android<=2.3
        // Options inside disabled selects are incorrectly marked as disabled
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Support: IE<=11+
        // An input loses its value after becoming a radio
        input = document.createElement( "input" );
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    } )();


    var boolHook,
        attrHandle = jQuery.expr.attrHandle;

    jQuery.fn.extend( {
        attr: function( name, value ) {
            return access( this, jQuery.attr, name, value, arguments.length > 1 );
        },

        removeAttr: function( name ) {
            return this.each( function() {
                jQuery.removeAttr( this, name );
            } );
        }
    } );

    jQuery.extend( {
        attr: function( elem, name, value ) {
            var ret, hooks,
                nType = elem.nodeType;

            // Don't get/set attributes on text, comment and attribute nodes
            if ( nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }

            // Fallback to prop when attributes are not supported
            if ( typeof elem.getAttribute === "undefined" ) {
                return jQuery.prop( elem, name, value );
            }

            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[ name ] ||
                    ( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
            }

            if ( value !== undefined ) {
                if ( value === null ) {
                    jQuery.removeAttr( elem, name );
                    return;
                }

                if ( hooks && "set" in hooks &&
                    ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                    return ret;
                }

                elem.setAttribute( name, value + "" );
                return value;
            }

            if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
                return ret;
            }

            ret = jQuery.find.attr( elem, name );

            // Non-existent attributes return null, we normalize to undefined
            return ret == null ? undefined : ret;
        },

        attrHooks: {
            type: {
                set: function( elem, value ) {
                    if ( !support.radioValue && value === "radio" &&
                        jQuery.nodeName( elem, "input" ) ) {
                        var val = elem.value;
                        elem.setAttribute( "type", value );
                        if ( val ) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },

        removeAttr: function( elem, value ) {
            var name, propName,
                i = 0,
                attrNames = value && value.match( rnotwhite );

            if ( attrNames && elem.nodeType === 1 ) {
                while ( ( name = attrNames[ i++ ] ) ) {
                    propName = jQuery.propFix[ name ] || name;

                    // Boolean attributes get special treatment (#10870)
                    if ( jQuery.expr.match.bool.test( name ) ) {

                        // Set corresponding property to false
                        elem[ propName ] = false;
                    }

                    elem.removeAttribute( name );
                }
            }
        }
    } );

// Hooks for boolean attributes
    boolHook = {
        set: function( elem, value, name ) {
            if ( value === false ) {

                // Remove boolean attributes when set to false
                jQuery.removeAttr( elem, name );
            } else {
                elem.setAttribute( name, name );
            }
            return name;
        }
    };
    jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
        var getter = attrHandle[ name ] || jQuery.find.attr;

        attrHandle[ name ] = function( elem, name, isXML ) {
            var ret, handle;
            if ( !isXML ) {

                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[ name ];
                attrHandle[ name ] = ret;
                ret = getter( elem, name, isXML ) != null ?
                    name.toLowerCase() :
                    null;
                attrHandle[ name ] = handle;
            }
            return ret;
        };
    } );




    var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;

    jQuery.fn.extend( {
        prop: function( name, value ) {
            return access( this, jQuery.prop, name, value, arguments.length > 1 );
        },

        removeProp: function( name ) {
            return this.each( function() {
                delete this[ jQuery.propFix[ name ] || name ];
            } );
        }
    } );

    jQuery.extend( {
        prop: function( elem, name, value ) {
            var ret, hooks,
                nType = elem.nodeType;

            // Don't get/set properties on text, comment and attribute nodes
            if ( nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }

            if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

                // Fix name and attach hooks
                name = jQuery.propFix[ name ] || name;
                hooks = jQuery.propHooks[ name ];
            }

            if ( value !== undefined ) {
                if ( hooks && "set" in hooks &&
                    ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                    return ret;
                }

                return ( elem[ name ] = value );
            }

            if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
                return ret;
            }

            return elem[ name ];
        },

        propHooks: {
            tabIndex: {
                get: function( elem ) {

                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr( elem, "tabindex" );

                    return tabindex ?
                        parseInt( tabindex, 10 ) :
                        rfocusable.test( elem.nodeName ) ||
                        rclickable.test( elem.nodeName ) && elem.href ?
                            0 :
                            -1;
                }
            }
        },

        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    } );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
    if ( !support.optSelected ) {
        jQuery.propHooks.selected = {
            get: function( elem ) {
                var parent = elem.parentNode;
                if ( parent && parent.parentNode ) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function( elem ) {
                var parent = elem.parentNode;
                if ( parent ) {
                    parent.selectedIndex;

                    if ( parent.parentNode ) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }

    jQuery.each( [
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function() {
        jQuery.propFix[ this.toLowerCase() ] = this;
    } );




    var rclass = /[\t\r\n\f]/g;

    function getClass( elem ) {
        return elem.getAttribute && elem.getAttribute( "class" ) || "";
    }

    jQuery.fn.extend( {
        addClass: function( value ) {
            var classes, elem, cur, curValue, clazz, j, finalValue,
                i = 0;

            if ( jQuery.isFunction( value ) ) {
                return this.each( function( j ) {
                    jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
                } );
            }

            if ( typeof value === "string" && value ) {
                classes = value.match( rnotwhite ) || [];

                while ( ( elem = this[ i++ ] ) ) {
                    curValue = getClass( elem );
                    cur = elem.nodeType === 1 &&
                        ( " " + curValue + " " ).replace( rclass, " " );

                    if ( cur ) {
                        j = 0;
                        while ( ( clazz = classes[ j++ ] ) ) {
                            if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                                cur += clazz + " ";
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim( cur );
                        if ( curValue !== finalValue ) {
                            elem.setAttribute( "class", finalValue );
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function( value ) {
            var classes, elem, cur, curValue, clazz, j, finalValue,
                i = 0;

            if ( jQuery.isFunction( value ) ) {
                return this.each( function( j ) {
                    jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
                } );
            }

            if ( !arguments.length ) {
                return this.attr( "class", "" );
            }

            if ( typeof value === "string" && value ) {
                classes = value.match( rnotwhite ) || [];

                while ( ( elem = this[ i++ ] ) ) {
                    curValue = getClass( elem );

                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 &&
                        ( " " + curValue + " " ).replace( rclass, " " );

                    if ( cur ) {
                        j = 0;
                        while ( ( clazz = classes[ j++ ] ) ) {

                            // Remove *all* instances
                            while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
                                cur = cur.replace( " " + clazz + " ", " " );
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim( cur );
                        if ( curValue !== finalValue ) {
                            elem.setAttribute( "class", finalValue );
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function( value, stateVal ) {
            var type = typeof value;

            if ( typeof stateVal === "boolean" && type === "string" ) {
                return stateVal ? this.addClass( value ) : this.removeClass( value );
            }

            if ( jQuery.isFunction( value ) ) {
                return this.each( function( i ) {
                    jQuery( this ).toggleClass(
                        value.call( this, i, getClass( this ), stateVal ),
                        stateVal
                    );
                } );
            }

            return this.each( function() {
                var className, i, self, classNames;

                if ( type === "string" ) {

                    // Toggle individual class names
                    i = 0;
                    self = jQuery( this );
                    classNames = value.match( rnotwhite ) || [];

                    while ( ( className = classNames[ i++ ] ) ) {

                        // Check each className given, space separated list
                        if ( self.hasClass( className ) ) {
                            self.removeClass( className );
                        } else {
                            self.addClass( className );
                        }
                    }

                    // Toggle whole class name
                } else if ( value === undefined || type === "boolean" ) {
                    className = getClass( this );
                    if ( className ) {

                        // Store className if set
                        dataPriv.set( this, "__className__", className );
                    }

                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if ( this.setAttribute ) {
                        this.setAttribute( "class",
                            className || value === false ?
                                "" :
                                dataPriv.get( this, "__className__" ) || ""
                        );
                    }
                }
            } );
        },

        hasClass: function( selector ) {
            var className, elem,
                i = 0;

            className = " " + selector + " ";
            while ( ( elem = this[ i++ ] ) ) {
                if ( elem.nodeType === 1 &&
                    ( " " + getClass( elem ) + " " ).replace( rclass, " " )
                        .indexOf( className ) > -1
                ) {
                    return true;
                }
            }

            return false;
        }
    } );




    var rreturn = /\r/g,
        rspaces = /[\x20\t\r\n\f]+/g;

    jQuery.fn.extend( {
        val: function( value ) {
            var hooks, ret, isFunction,
                elem = this[ 0 ];

            if ( !arguments.length ) {
                if ( elem ) {
                    hooks = jQuery.valHooks[ elem.type ] ||
                        jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                    if ( hooks &&
                        "get" in hooks &&
                        ( ret = hooks.get( elem, "value" ) ) !== undefined
                    ) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?

                        // Handle most common string cases
                        ret.replace( rreturn, "" ) :

                        // Handle cases where value is null/undef or number
                        ret == null ? "" : ret;
                }

                return;
            }

            isFunction = jQuery.isFunction( value );

            return this.each( function( i ) {
                var val;

                if ( this.nodeType !== 1 ) {
                    return;
                }

                if ( isFunction ) {
                    val = value.call( this, i, jQuery( this ).val() );
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if ( val == null ) {
                    val = "";

                } else if ( typeof val === "number" ) {
                    val += "";

                } else if ( jQuery.isArray( val ) ) {
                    val = jQuery.map( val, function( value ) {
                        return value == null ? "" : value + "";
                    } );
                }

                hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                // If set returns undefined, fall back to normal setting
                if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
                    this.value = val;
                }
            } );
        }
    } );

    jQuery.extend( {
        valHooks: {
            option: {
                get: function( elem ) {

                    var val = jQuery.find.attr( elem, "value" );
                    return val != null ?
                        val :

                        // Support: IE10-11+
                        // option.text throws exceptions (#14686, #14858)
                        // Strip and collapse whitespace
                        // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                        jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
                }
            },
            select: {
                get: function( elem ) {
                    var value, option,
                        options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one" || index < 0,
                        values = one ? null : [],
                        max = one ? index + 1 : options.length,
                        i = index < 0 ?
                            max :
                            one ? index : 0;

                    // Loop through all the selected options
                    for ( ; i < max; i++ ) {
                        option = options[ i ];

                        // IE8-9 doesn't update selected after form reset (#2551)
                        if ( ( option.selected || i === index ) &&

                            // Don't return options that are disabled or in a disabled optgroup
                            ( support.optDisabled ?
                                !option.disabled : option.getAttribute( "disabled" ) === null ) &&
                            ( !option.parentNode.disabled ||
                                !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

                            // Get the specific value for the option
                            value = jQuery( option ).val();

                            // We don't need an array for one selects
                            if ( one ) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push( value );
                        }
                    }

                    return values;
                },

                set: function( elem, value ) {
                    var optionSet, option,
                        options = elem.options,
                        values = jQuery.makeArray( value ),
                        i = options.length;

                    while ( i-- ) {
                        option = options[ i ];
                        if ( option.selected =
                                jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
                        ) {
                            optionSet = true;
                        }
                    }

                    // Force browsers to behave consistently when non-matching value is set
                    if ( !optionSet ) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    } );

// Radios and checkboxes getter/setter
    jQuery.each( [ "radio", "checkbox" ], function() {
        jQuery.valHooks[ this ] = {
            set: function( elem, value ) {
                if ( jQuery.isArray( value ) ) {
                    return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
                }
            }
        };
        if ( !support.checkOn ) {
            jQuery.valHooks[ this ].get = function( elem ) {
                return elem.getAttribute( "value" ) === null ? "on" : elem.value;
            };
        }
    } );




// Return jQuery for attributes-only inclusion


    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

    jQuery.extend( jQuery.event, {

        trigger: function( event, data, elem, onlyHandlers ) {

            var i, cur, tmp, bubbleType, ontype, handle, special,
                eventPath = [ elem || document ],
                type = hasOwn.call( event, "type" ) ? event.type : event,
                namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

            cur = tmp = elem = elem || document;

            // Don't do events on text and comment nodes
            if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                return;
            }

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                return;
            }

            if ( type.indexOf( "." ) > -1 ) {

                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split( "." );
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf( ":" ) < 0 && "on" + type;

            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[ jQuery.expando ] ?
                event :
                new jQuery.Event( type, typeof event === "object" && event );

            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join( "." );
            event.rnamespace = event.namespace ?
                new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
                null;

            // Clean up the event in case it is being reused
            event.result = undefined;
            if ( !event.target ) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ?
                [ event ] :
                jQuery.makeArray( data, [ event ] );

            // Allow special events to draw outside the lines
            special = jQuery.event.special[ type ] || {};
            if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

                bubbleType = special.delegateType || type;
                if ( !rfocusMorph.test( bubbleType + type ) ) {
                    cur = cur.parentNode;
                }
                for ( ; cur; cur = cur.parentNode ) {
                    eventPath.push( cur );
                    tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if ( tmp === ( elem.ownerDocument || document ) ) {
                    eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                }
            }

            // Fire handlers on the event path
            i = 0;
            while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

                event.type = i > 1 ?
                    bubbleType :
                    special.bindType || type;

                // jQuery handler
                handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
                    dataPriv.get( cur, "handle" );
                if ( handle ) {
                    handle.apply( cur, data );
                }

                // Native handler
                handle = ontype && cur[ ontype ];
                if ( handle && handle.apply && acceptData( cur ) ) {
                    event.result = handle.apply( cur, data );
                    if ( event.result === false ) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if ( !onlyHandlers && !event.isDefaultPrevented() ) {

                if ( ( !special._default ||
                        special._default.apply( eventPath.pop(), data ) === false ) &&
                    acceptData( elem ) ) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ ontype ];

                        if ( tmp ) {
                            elem[ ontype ] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[ type ]();
                        jQuery.event.triggered = undefined;

                        if ( tmp ) {
                            elem[ ontype ] = tmp;
                        }
                    }
                }
            }

            return event.result;
        },

        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function( type, elem, event ) {
            var e = jQuery.extend(
                new jQuery.Event(),
                event,
                {
                    type: type,
                    isSimulated: true
                }
            );

            jQuery.event.trigger( e, null, elem );
        }

    } );

    jQuery.fn.extend( {

        trigger: function( type, data ) {
            return this.each( function() {
                jQuery.event.trigger( type, data, this );
            } );
        },
        triggerHandler: function( type, data ) {
            var elem = this[ 0 ];
            if ( elem ) {
                return jQuery.event.trigger( type, data, elem, true );
            }
        }
    } );


    jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error contextmenu" ).split( " " ),
        function( i, name ) {

            // Handle event binding
            jQuery.fn[ name ] = function( data, fn ) {
                return arguments.length > 0 ?
                    this.on( name, null, data, fn ) :
                    this.trigger( name );
            };
        } );

    jQuery.fn.extend( {
        hover: function( fnOver, fnOut ) {
            return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
        }
    } );




    support.focusin = "onfocusin" in window;


// Support: Firefox
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome, Safari
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
    if ( !support.focusin ) {
        jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function( event ) {
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
            };

            jQuery.event.special[ fix ] = {
                setup: function() {
                    var doc = this.ownerDocument || this,
                        attaches = dataPriv.access( doc, fix );

                    if ( !attaches ) {
                        doc.addEventListener( orig, handler, true );
                    }
                    dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
                },
                teardown: function() {
                    var doc = this.ownerDocument || this,
                        attaches = dataPriv.access( doc, fix ) - 1;

                    if ( !attaches ) {
                        doc.removeEventListener( orig, handler, true );
                        dataPriv.remove( doc, fix );

                    } else {
                        dataPriv.access( doc, fix, attaches );
                    }
                }
            };
        } );
    }
    var location = window.location;

    var nonce = jQuery.now();

    var rquery = ( /\?/ );



// Support: Android 2.3
// Workaround failure to string-cast null input
    jQuery.parseJSON = function( data ) {
        return JSON.parse( data + "" );
    };


// Cross-browser xml parsing
    jQuery.parseXML = function( data ) {
        var xml;
        if ( !data || typeof data !== "string" ) {
            return null;
        }

        // Support: IE9
        try {
            xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
        } catch ( e ) {
            xml = undefined;
        }

        if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
            jQuery.error( "Invalid XML: " + data );
        }
        return xml;
    };


    var
        rhash = /#.*$/,
        rts = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,

        /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
        prefilters = {},

        /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
        transports = {},

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = "*/".concat( "*" ),

        // Anchor tag for parsing the document origin
        originAnchor = document.createElement( "a" );
    originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports( structure ) {

        // dataTypeExpression is optional and defaults to "*"
        return function( dataTypeExpression, func ) {

            if ( typeof dataTypeExpression !== "string" ) {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

            if ( jQuery.isFunction( func ) ) {

                // For each dataType in the dataTypeExpression
                while ( ( dataType = dataTypes[ i++ ] ) ) {

                    // Prepend if requested
                    if ( dataType[ 0 ] === "+" ) {
                        dataType = dataType.slice( 1 ) || "*";
                        ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

                        // Otherwise append
                    } else {
                        ( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
                    }
                }
            }
        };
    }

// Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

        var inspected = {},
            seekingTransport = ( structure === transports );

        function inspect( dataType ) {
            var selected;
            inspected[ dataType ] = true;
            jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                if ( typeof dataTypeOrTransport === "string" &&
                    !seekingTransport && !inspected[ dataTypeOrTransport ] ) {

                    options.dataTypes.unshift( dataTypeOrTransport );
                    inspect( dataTypeOrTransport );
                    return false;
                } else if ( seekingTransport ) {
                    return !( selected = dataTypeOrTransport );
                }
            } );
            return selected;
        }

        return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
    }

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
    function ajaxExtend( target, src ) {
        var key, deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for ( key in src ) {
            if ( src[ key ] !== undefined ) {
                ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
            }
        }
        if ( deep ) {
            jQuery.extend( true, target, deep );
        }

        return target;
    }

    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
    function ajaxHandleResponses( s, jqXHR, responses ) {

        var ct, type, finalDataType, firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while ( dataTypes[ 0 ] === "*" ) {
            dataTypes.shift();
            if ( ct === undefined ) {
                ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
            }
        }

        // Check if we're dealing with a known content-type
        if ( ct ) {
            for ( type in contents ) {
                if ( contents[ type ] && contents[ type ].test( ct ) ) {
                    dataTypes.unshift( type );
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if ( dataTypes[ 0 ] in responses ) {
            finalDataType = dataTypes[ 0 ];
        } else {

            // Try convertible dataTypes
            for ( type in responses ) {
                if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
                    finalDataType = type;
                    break;
                }
                if ( !firstDataType ) {
                    firstDataType = type;
                }
            }

            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if ( finalDataType ) {
            if ( finalDataType !== dataTypes[ 0 ] ) {
                dataTypes.unshift( finalDataType );
            }
            return responses[ finalDataType ];
        }
    }

    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
    function ajaxConvert( s, response, jqXHR, isSuccess ) {
        var conv2, current, conv, tmp, prev,
            converters = {},

            // Work with a copy of dataTypes in case we need to modify it for conversion
            dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if ( dataTypes[ 1 ] ) {
            for ( conv in s.converters ) {
                converters[ conv.toLowerCase() ] = s.converters[ conv ];
            }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while ( current ) {

            if ( s.responseFields[ current ] ) {
                jqXHR[ s.responseFields[ current ] ] = response;
            }

            // Apply the dataFilter if provided
            if ( !prev && isSuccess && s.dataFilter ) {
                response = s.dataFilter( response, s.dataType );
            }

            prev = current;
            current = dataTypes.shift();

            if ( current ) {

                // There's only work to do if current dataType is non-auto
                if ( current === "*" ) {

                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                } else if ( prev !== "*" && prev !== current ) {

                    // Seek a direct converter
                    conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                    // If none found, seek a pair
                    if ( !conv ) {
                        for ( conv2 in converters ) {

                            // If conv2 outputs current
                            tmp = conv2.split( " " );
                            if ( tmp[ 1 ] === current ) {

                                // If prev can be converted to accepted input
                                conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                    converters[ "* " + tmp[ 0 ] ];
                                if ( conv ) {

                                    // Condense equivalence converters
                                    if ( conv === true ) {
                                        conv = converters[ conv2 ];

                                        // Otherwise, insert the intermediate dataType
                                    } else if ( converters[ conv2 ] !== true ) {
                                        current = tmp[ 0 ];
                                        dataTypes.unshift( tmp[ 1 ] );
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if ( conv !== true ) {

                        // Unless errors are allowed to bubble, catch and return them
                        if ( conv && s.throws ) {
                            response = conv( response );
                        } else {
                            try {
                                response = conv( response );
                            } catch ( e ) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }

        return { state: "success", data: response };
    }

    jQuery.extend( {

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test( location.protocol ),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },

            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },

            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {

                // Convert anything to text
                "* text": String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function( target, settings ) {
            return settings ?

                // Building a settings object
                ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

                // Extending ajaxSettings
                ajaxExtend( jQuery.ajaxSettings, target );
        },

        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
        ajaxTransport: addToPrefiltersOrTransports( transports ),

        // Main method
        ajax: function( url, options ) {

            // If url is an object, simulate pre-1.5 signature
            if ( typeof url === "object" ) {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var transport,

                // URL without anti-cache param
                cacheURL,

                // Response headers
                responseHeadersString,
                responseHeaders,

                // timeout handle
                timeoutTimer,

                // Url cleanup var
                urlAnchor,

                // To know if global events are to be dispatched
                fireGlobals,

                // Loop variable
                i,

                // Create the final options object
                s = jQuery.ajaxSetup( {}, options ),

                // Callbacks context
                callbackContext = s.context || s,

                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext = s.context &&
                ( callbackContext.nodeType || callbackContext.jquery ) ?
                    jQuery( callbackContext ) :
                    jQuery.event,

                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks( "once memory" ),

                // Status-dependent callbacks
                statusCode = s.statusCode || {},

                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},

                // The jqXHR state
                state = 0,

                // Default abort message
                strAbort = "canceled",

                // Fake xhr
                jqXHR = {
                    readyState: 0,

                    // Builds headers hashtable if needed
                    getResponseHeader: function( key ) {
                        var match;
                        if ( state === 2 ) {
                            if ( !responseHeaders ) {
                                responseHeaders = {};
                                while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                    responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
                                }
                            }
                            match = responseHeaders[ key.toLowerCase() ];
                        }
                        return match == null ? null : match;
                    },

                    // Raw string
                    getAllResponseHeaders: function() {
                        return state === 2 ? responseHeadersString : null;
                    },

                    // Caches the header
                    setRequestHeader: function( name, value ) {
                        var lname = name.toLowerCase();
                        if ( !state ) {
                            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                            requestHeaders[ name ] = value;
                        }
                        return this;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function( type ) {
                        if ( !state ) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Status-dependent callbacks
                    statusCode: function( map ) {
                        var code;
                        if ( map ) {
                            if ( state < 2 ) {
                                for ( code in map ) {

                                    // Lazy-add the new callback in a way that preserves old ones
                                    statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                                }
                            } else {

                                // Execute the appropriate callbacks
                                jqXHR.always( map[ jqXHR.status ] );
                            }
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function( statusText ) {
                        var finalText = statusText || strAbort;
                        if ( transport ) {
                            transport.abort( finalText );
                        }
                        done( 0, finalText );
                        return this;
                    }
                };

            // Attach deferreds
            deferred.promise( jqXHR ).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
                .replace( rprotocol, location.protocol + "//" );

            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;

            // Extract dataTypes list
            s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

            // A cross-domain request is in order when the origin doesn't match the current origin.
            if ( s.crossDomain == null ) {
                urlAnchor = document.createElement( "a" );

                // Support: IE8-11+
                // IE throws exception if url is malformed, e.g. http://example.com:80x/
                try {
                    urlAnchor.href = s.url;

                    // Support: IE8-11+
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
                        urlAnchor.protocol + "//" + urlAnchor.host;
                } catch ( e ) {

                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                }
            }

            // Convert data if not already a string
            if ( s.data && s.processData && typeof s.data !== "string" ) {
                s.data = jQuery.param( s.data, s.traditional );
            }

            // Apply prefilters
            inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

            // If request was aborted inside a prefilter, stop there
            if ( state === 2 ) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;

            // Watch for a new set of requests
            if ( fireGlobals && jQuery.active++ === 0 ) {
                jQuery.event.trigger( "ajaxStart" );
            }

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test( s.type );

            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            cacheURL = s.url;

            // More options handling for requests with no content
            if ( !s.hasContent ) {

                // If data is available, append data to url
                if ( s.data ) {
                    cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Add anti-cache in url if needed
                if ( s.cache === false ) {
                    s.url = rts.test( cacheURL ) ?

                        // If there is already a '_' parameter, set its value
                        cacheURL.replace( rts, "$1_=" + nonce++ ) :

                        // Otherwise add one to the end
                        cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
                }
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if ( s.ifModified ) {
                if ( jQuery.lastModified[ cacheURL ] ) {
                    jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
                }
                if ( jQuery.etag[ cacheURL ] ) {
                    jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
                }
            }

            // Set the correct header, if data is being sent
            if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                jqXHR.setRequestHeader( "Content-Type", s.contentType );
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
                    s.accepts[ s.dataTypes[ 0 ] ] +
                    ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                    s.accepts[ "*" ]
            );

            // Check for headers option
            for ( i in s.headers ) {
                jqXHR.setRequestHeader( i, s.headers[ i ] );
            }

            // Allow custom headers/mimetypes and early abort
            if ( s.beforeSend &&
                ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

                // Abort if not done already and return
                return jqXHR.abort();
            }

            // Aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            for ( i in { success: 1, error: 1, complete: 1 } ) {
                jqXHR[ i ]( s[ i ] );
            }

            // Get transport
            transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

            // If no transport, we auto-abort
            if ( !transport ) {
                done( -1, "No Transport" );
            } else {
                jqXHR.readyState = 1;

                // Send global event
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                }

                // If request was aborted inside ajaxSend, stop there
                if ( state === 2 ) {
                    return jqXHR;
                }

                // Timeout
                if ( s.async && s.timeout > 0 ) {
                    timeoutTimer = window.setTimeout( function() {
                        jqXHR.abort( "timeout" );
                    }, s.timeout );
                }

                try {
                    state = 1;
                    transport.send( requestHeaders, done );
                } catch ( e ) {

                    // Propagate exception as error if not done
                    if ( state < 2 ) {
                        done( -1, e );

                        // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }

            // Callback for when everything is done
            function done( status, nativeStatusText, responses, headers ) {
                var isSuccess, success, error, response, modified,
                    statusText = nativeStatusText;

                // Called once
                if ( state === 2 ) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if ( timeoutTimer ) {
                    window.clearTimeout( timeoutTimer );
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;

                // Get response data
                if ( responses ) {
                    response = ajaxHandleResponses( s, jqXHR, responses );
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert( s, response, jqXHR, isSuccess );

                // If successful, handle type chaining
                if ( isSuccess ) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if ( s.ifModified ) {
                        modified = jqXHR.getResponseHeader( "Last-Modified" );
                        if ( modified ) {
                            jQuery.lastModified[ cacheURL ] = modified;
                        }
                        modified = jqXHR.getResponseHeader( "etag" );
                        if ( modified ) {
                            jQuery.etag[ cacheURL ] = modified;
                        }
                    }

                    // if no content
                    if ( status === 204 || s.type === "HEAD" ) {
                        statusText = "nocontent";

                        // if not modified
                    } else if ( status === 304 ) {
                        statusText = "notmodified";

                        // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {

                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if ( status || !statusText ) {
                        statusText = "error";
                        if ( status < 0 ) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                // Success/Error
                if ( isSuccess ) {
                    deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                } else {
                    deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                }

                // Status-dependent callbacks
                jqXHR.statusCode( statusCode );
                statusCode = undefined;

                if ( fireGlobals ) {
                    globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                        [ jqXHR, s, isSuccess ? success : error ] );
                }

                // Complete
                completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

                    // Handle the global AJAX counter
                    if ( !( --jQuery.active ) ) {
                        jQuery.event.trigger( "ajaxStop" );
                    }
                }
            }

            return jqXHR;
        },

        getJSON: function( url, data, callback ) {
            return jQuery.get( url, data, callback, "json" );
        },

        getScript: function( url, callback ) {
            return jQuery.get( url, undefined, callback, "script" );
        }
    } );

    jQuery.each( [ "get", "post" ], function( i, method ) {
        jQuery[ method ] = function( url, data, callback, type ) {

            // Shift arguments if data argument was omitted
            if ( jQuery.isFunction( data ) ) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            // The url can be an options object (which then must have .url)
            return jQuery.ajax( jQuery.extend( {
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject( url ) && url ) );
        };
    } );


    jQuery._evalUrl = function( url ) {
        return jQuery.ajax( {
            url: url,

            // Make this explicit, since user can override this through ajaxSetup (#11264)
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        } );
    };


    jQuery.fn.extend( {
        wrapAll: function( html ) {
            var wrap;

            if ( jQuery.isFunction( html ) ) {
                return this.each( function( i ) {
                    jQuery( this ).wrapAll( html.call( this, i ) );
                } );
            }

            if ( this[ 0 ] ) {

                // The elements to wrap the target around
                wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

                if ( this[ 0 ].parentNode ) {
                    wrap.insertBefore( this[ 0 ] );
                }

                wrap.map( function() {
                    var elem = this;

                    while ( elem.firstElementChild ) {
                        elem = elem.firstElementChild;
                    }

                    return elem;
                } ).append( this );
            }

            return this;
        },

        wrapInner: function( html ) {
            if ( jQuery.isFunction( html ) ) {
                return this.each( function( i ) {
                    jQuery( this ).wrapInner( html.call( this, i ) );
                } );
            }

            return this.each( function() {
                var self = jQuery( this ),
                    contents = self.contents();

                if ( contents.length ) {
                    contents.wrapAll( html );

                } else {
                    self.append( html );
                }
            } );
        },

        wrap: function( html ) {
            var isFunction = jQuery.isFunction( html );

            return this.each( function( i ) {
                jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
            } );
        },

        unwrap: function() {
            return this.parent().each( function() {
                if ( !jQuery.nodeName( this, "body" ) ) {
                    jQuery( this ).replaceWith( this.childNodes );
                }
            } ).end();
        }
    } );


    jQuery.expr.filters.hidden = function( elem ) {
        return !jQuery.expr.filters.visible( elem );
    };
    jQuery.expr.filters.visible = function( elem ) {

        // Support: Opera <= 12.12
        // Opera reports offsetWidths and offsetHeights less than zero on some elements
        // Use OR instead of AND as the element is not visible if either is true
        // See tickets #10406 and #13132
        return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
    };




    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams( prefix, obj, traditional, add ) {
        var name;

        if ( jQuery.isArray( obj ) ) {

            // Serialize array item.
            jQuery.each( obj, function( i, v ) {
                if ( traditional || rbracket.test( prefix ) ) {

                    // Treat each array item as a scalar.
                    add( prefix, v );

                } else {

                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(
                        prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
                        v,
                        traditional,
                        add
                    );
                }
            } );

        } else if ( !traditional && jQuery.type( obj ) === "object" ) {

            // Serialize object item.
            for ( name in obj ) {
                buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
            }

        } else {

            // Serialize scalar item.
            add( prefix, obj );
        }
    }

// Serialize an array of form elements or a set of
// key/values into a query string
    jQuery.param = function( a, traditional ) {
        var prefix,
            s = [],
            add = function( key, value ) {

                // If value is a function, invoke it and return its value
                value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
                s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
            };

        // Set traditional to true for jQuery <= 1.3.2 behavior.
        if ( traditional === undefined ) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }

        // If an array was passed in, assume that it is an array of form elements.
        if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

            // Serialize the form elements
            jQuery.each( a, function() {
                add( this.name, this.value );
            } );

        } else {

            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for ( prefix in a ) {
                buildParams( prefix, a[ prefix ], traditional, add );
            }
        }

        // Return the resulting serialization
        return s.join( "&" ).replace( r20, "+" );
    };

    jQuery.fn.extend( {
        serialize: function() {
            return jQuery.param( this.serializeArray() );
        },
        serializeArray: function() {
            return this.map( function() {

                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop( this, "elements" );
                return elements ? jQuery.makeArray( elements ) : this;
            } )
                .filter( function() {
                    var type = this.type;

                    // Use .is( ":disabled" ) so that fieldset[disabled] works
                    return this.name && !jQuery( this ).is( ":disabled" ) &&
                        rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                        ( this.checked || !rcheckableType.test( type ) );
                } )
                .map( function( i, elem ) {
                    var val = jQuery( this ).val();

                    return val == null ?
                        null :
                        jQuery.isArray( val ) ?
                            jQuery.map( val, function( val ) {
                                return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                            } ) :
                            { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                } ).get();
        }
    } );


    jQuery.ajaxSettings.xhr = function() {
        try {
            return new window.XMLHttpRequest();
        } catch ( e ) {}
    };

    var xhrSuccessStatus = {

            // File protocol always yields status code 0, assume 200
            0: 200,

            // Support: IE9
            // #1450: sometimes IE returns 1223 when it should be 204
            1223: 204
        },
        xhrSupported = jQuery.ajaxSettings.xhr();

    support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
    support.ajax = xhrSupported = !!xhrSupported;

    jQuery.ajaxTransport( function( options ) {
        var callback, errorCallback;

        // Cross domain only allowed if supported through XMLHttpRequest
        if ( support.cors || xhrSupported && !options.crossDomain ) {
            return {
                send: function( headers, complete ) {
                    var i,
                        xhr = options.xhr();

                    xhr.open(
                        options.type,
                        options.url,
                        options.async,
                        options.username,
                        options.password
                    );

                    // Apply custom fields if provided
                    if ( options.xhrFields ) {
                        for ( i in options.xhrFields ) {
                            xhr[ i ] = options.xhrFields[ i ];
                        }
                    }

                    // Override mime type if needed
                    if ( options.mimeType && xhr.overrideMimeType ) {
                        xhr.overrideMimeType( options.mimeType );
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
                        headers[ "X-Requested-With" ] = "XMLHttpRequest";
                    }

                    // Set headers
                    for ( i in headers ) {
                        xhr.setRequestHeader( i, headers[ i ] );
                    }

                    // Callback
                    callback = function( type ) {
                        return function() {
                            if ( callback ) {
                                callback = errorCallback = xhr.onload =
                                    xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

                                if ( type === "abort" ) {
                                    xhr.abort();
                                } else if ( type === "error" ) {

                                    // Support: IE9
                                    // On a manual native abort, IE9 throws
                                    // errors on any property access that is not readyState
                                    if ( typeof xhr.status !== "number" ) {
                                        complete( 0, "error" );
                                    } else {
                                        complete(

                                            // File: protocol always yields status 0; see #8605, #14207
                                            xhr.status,
                                            xhr.statusText
                                        );
                                    }
                                } else {
                                    complete(
                                        xhrSuccessStatus[ xhr.status ] || xhr.status,
                                        xhr.statusText,

                                        // Support: IE9 only
                                        // IE9 has no XHR2 but throws on binary (trac-11426)
                                        // For XHR2 non-text, let the caller handle it (gh-2498)
                                        ( xhr.responseType || "text" ) !== "text"  ||
                                        typeof xhr.responseText !== "string" ?
                                            { binary: xhr.response } :
                                            { text: xhr.responseText },
                                        xhr.getAllResponseHeaders()
                                    );
                                }
                            }
                        };
                    };

                    // Listen to events
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = callback( "error" );

                    // Support: IE9
                    // Use onreadystatechange to replace onabort
                    // to handle uncaught aborts
                    if ( xhr.onabort !== undefined ) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function() {

                            // Check readyState before timeout as it changes
                            if ( xhr.readyState === 4 ) {

                                // Allow onerror to be called first,
                                // but that will not handle a native abort
                                // Also, save errorCallback to a variable
                                // as xhr.onerror cannot be accessed
                                window.setTimeout( function() {
                                    if ( callback ) {
                                        errorCallback();
                                    }
                                } );
                            }
                        };
                    }

                    // Create the abort callback
                    callback = callback( "abort" );

                    try {

                        // Do send the request (this may raise an exception)
                        xhr.send( options.hasContent && options.data || null );
                    } catch ( e ) {

                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if ( callback ) {
                            throw e;
                        }
                    }
                },

                abort: function() {
                    if ( callback ) {
                        callback();
                    }
                }
            };
        }
    } );




// Install script dataType
    jQuery.ajaxSetup( {
        accepts: {
            script: "text/javascript, application/javascript, " +
            "application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function( text ) {
                jQuery.globalEval( text );
                return text;
            }
        }
    } );

// Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter( "script", function( s ) {
        if ( s.cache === undefined ) {
            s.cache = false;
        }
        if ( s.crossDomain ) {
            s.type = "GET";
        }
    } );

// Bind script tag hack transport
    jQuery.ajaxTransport( "script", function( s ) {

        // This transport only deals with cross domain requests
        if ( s.crossDomain ) {
            var script, callback;
            return {
                send: function( _, complete ) {
                    script = jQuery( "<script>" ).prop( {
                        charset: s.scriptCharset,
                        src: s.url
                    } ).on(
                        "load error",
                        callback = function( evt ) {
                            script.remove();
                            callback = null;
                            if ( evt ) {
                                complete( evt.type === "error" ? 404 : 200, evt.type );
                            }
                        }
                    );

                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document.head.appendChild( script[ 0 ] );
                },
                abort: function() {
                    if ( callback ) {
                        callback();
                    }
                }
            };
        }
    } );




    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
    jQuery.ajaxSetup( {
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
            this[ callback ] = true;
            return callback;
        }
    } );

// Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

        var callbackName, overwritten, responseContainer,
            jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
                    "url" :
                    typeof s.data === "string" &&
                    ( s.contentType || "" )
                        .indexOf( "application/x-www-form-urlencoded" ) === 0 &&
                    rjsonp.test( s.data ) && "data"
            );

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
                s.jsonpCallback() :
                s.jsonpCallback;

            // Insert callback into url or form data
            if ( jsonProp ) {
                s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
            } else if ( s.jsonp !== false ) {
                s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters[ "script json" ] = function() {
                if ( !responseContainer ) {
                    jQuery.error( callbackName + " was not called" );
                }
                return responseContainer[ 0 ];
            };

            // Force json dataType
            s.dataTypes[ 0 ] = "json";

            // Install callback
            overwritten = window[ callbackName ];
            window[ callbackName ] = function() {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always( function() {

                // If previous value didn't exist - remove it
                if ( overwritten === undefined ) {
                    jQuery( window ).removeProp( callbackName );

                    // Otherwise restore preexisting value
                } else {
                    window[ callbackName ] = overwritten;
                }

                // Save back as free
                if ( s[ callbackName ] ) {

                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // Save the callback name for future use
                    oldCallbacks.push( callbackName );
                }

                // Call if it was a function and we have a response
                if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                    overwritten( responseContainer[ 0 ] );
                }

                responseContainer = overwritten = undefined;
            } );

            // Delegate to script
            return "script";
        }
    } );




// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function( data, context, keepScripts ) {
        if ( !data || typeof data !== "string" ) {
            return null;
        }
        if ( typeof context === "boolean" ) {
            keepScripts = context;
            context = false;
        }
        context = context || document;

        var parsed = rsingleTag.exec( data ),
            scripts = !keepScripts && [];

        // Single tag
        if ( parsed ) {
            return [ context.createElement( parsed[ 1 ] ) ];
        }

        parsed = buildFragment( [ data ], context, scripts );

        if ( scripts && scripts.length ) {
            jQuery( scripts ).remove();
        }

        return jQuery.merge( [], parsed.childNodes );
    };


// Keep a copy of the old load method
    var _load = jQuery.fn.load;

    /**
     * Load a url into a page
     */
    jQuery.fn.load = function( url, params, callback ) {
        if ( typeof url !== "string" && _load ) {
            return _load.apply( this, arguments );
        }

        var selector, type, response,
            self = this,
            off = url.indexOf( " " );

        if ( off > -1 ) {
            selector = jQuery.trim( url.slice( off ) );
            url = url.slice( 0, off );
        }

        // If it's a function
        if ( jQuery.isFunction( params ) ) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if ( params && typeof params === "object" ) {
            type = "POST";
        }

        // If we have elements to modify, make the request
        if ( self.length > 0 ) {
            jQuery.ajax( {
                url: url,

                // If "type" variable is undefined, then "GET" method will be used.
                // Make value of this field explicit since
                // user can override it through ajaxSetup method
                type: type || "GET",
                dataType: "html",
                data: params
            } ).done( function( responseText ) {

                // Save response for use in complete callback
                response = arguments;

                self.html( selector ?

                    // If a selector was specified, locate the right elements in a dummy div
                    // Exclude scripts to avoid IE 'Permission Denied' errors
                    jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

                    // Otherwise use the full result
                    responseText );

                // If the request succeeds, this function gets "data", "status", "jqXHR"
                // but they are ignored because response was set above.
                // If it fails, this function gets "jqXHR", "status", "error"
            } ).always( callback && function( jqXHR, status ) {
                self.each( function() {
                    callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
                } );
            } );
        }

        return this;
    };




// Attach a bunch of functions for handling common AJAX events
    jQuery.each( [
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function( i, type ) {
        jQuery.fn[ type ] = function( fn ) {
            return this.on( type, fn );
        };
    } );




    jQuery.expr.filters.animated = function( elem ) {
        return jQuery.grep( jQuery.timers, function( fn ) {
            return elem === fn.elem;
        } ).length;
    };




    /**
     * Gets a window from an element
     */
    function getWindow( elem ) {
        return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
    }

    jQuery.offset = {
        setOffset: function( elem, options, i ) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                position = jQuery.css( elem, "position" ),
                curElem = jQuery( elem ),
                props = {};

            // Set position first, in-case top/left are set even on static elem
            if ( position === "static" ) {
                elem.style.position = "relative";
            }

            curOffset = curElem.offset();
            curCSSTop = jQuery.css( elem, "top" );
            curCSSLeft = jQuery.css( elem, "left" );
            calculatePosition = ( position === "absolute" || position === "fixed" ) &&
                ( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if ( calculatePosition ) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;

            } else {
                curTop = parseFloat( curCSSTop ) || 0;
                curLeft = parseFloat( curCSSLeft ) || 0;
            }

            if ( jQuery.isFunction( options ) ) {

                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
            }

            if ( options.top != null ) {
                props.top = ( options.top - curOffset.top ) + curTop;
            }
            if ( options.left != null ) {
                props.left = ( options.left - curOffset.left ) + curLeft;
            }

            if ( "using" in options ) {
                options.using.call( elem, props );

            } else {
                curElem.css( props );
            }
        }
    };

    jQuery.fn.extend( {
        offset: function( options ) {
            if ( arguments.length ) {
                return options === undefined ?
                    this :
                    this.each( function( i ) {
                        jQuery.offset.setOffset( this, options, i );
                    } );
            }

            var docElem, win,
                elem = this[ 0 ],
                box = { top: 0, left: 0 },
                doc = elem && elem.ownerDocument;

            if ( !doc ) {
                return;
            }

            docElem = doc.documentElement;

            // Make sure it's not a disconnected DOM node
            if ( !jQuery.contains( docElem, elem ) ) {
                return box;
            }

            box = elem.getBoundingClientRect();
            win = getWindow( doc );
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },

        position: function() {
            if ( !this[ 0 ] ) {
                return;
            }

            var offsetParent, offset,
                elem = this[ 0 ],
                parentOffset = { top: 0, left: 0 };

            // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
            // because it is its only offset parent
            if ( jQuery.css( elem, "position" ) === "fixed" ) {

                // Assume getBoundingClientRect is there when computed position is fixed
                offset = elem.getBoundingClientRect();

            } else {

                // Get *real* offsetParent
                offsetParent = this.offsetParent();

                // Get correct offsets
                offset = this.offset();
                if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                    parentOffset = offsetParent.offset();
                }

                // Add offsetParent borders
                parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
                parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
            }

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
                left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
            };
        },

        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
            return this.map( function() {
                var offsetParent = this.offsetParent;

                while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
                    offsetParent = offsetParent.offsetParent;
                }

                return offsetParent || documentElement;
            } );
        }
    } );

// Create scrollLeft and scrollTop methods
    jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
        var top = "pageYOffset" === prop;

        jQuery.fn[ method ] = function( val ) {
            return access( this, function( elem, method, val ) {
                var win = getWindow( elem );

                if ( val === undefined ) {
                    return win ? win[ prop ] : elem[ method ];
                }

                if ( win ) {
                    win.scrollTo(
                        !top ? val : win.pageXOffset,
                        top ? val : win.pageYOffset
                    );

                } else {
                    elem[ method ] = val;
                }
            }, method, val, arguments.length );
        };
    } );

// Support: Safari<7-8+, Chrome<37-44+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
    jQuery.each( [ "top", "left" ], function( i, prop ) {
        jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
            function( elem, computed ) {
                if ( computed ) {
                    computed = curCSS( elem, prop );

                    // If curCSS returns percentage, fallback to offset
                    return rnumnonpx.test( computed ) ?
                        jQuery( elem ).position()[ prop ] + "px" :
                        computed;
                }
            }
        );
    } );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
        jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
            function( defaultExtra, funcName ) {

                // Margin is only for outerHeight, outerWidth
                jQuery.fn[ funcName ] = function( margin, value ) {
                    var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                        extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

                    return access( this, function( elem, type, value ) {
                        var doc;

                        if ( jQuery.isWindow( elem ) ) {

                            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                            // isn't a whole lot we can do. See pull request at this URL for discussion:
                            // https://github.com/jquery/jquery/pull/764
                            return elem.document.documentElement[ "client" + name ];
                        }

                        // Get document width or height
                        if ( elem.nodeType === 9 ) {
                            doc = elem.documentElement;

                            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                            // whichever is greatest
                            return Math.max(
                                elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                                elem.body[ "offset" + name ], doc[ "offset" + name ],
                                doc[ "client" + name ]
                            );
                        }

                        return value === undefined ?

                            // Get width or height on the element, requesting but not forcing parseFloat
                            jQuery.css( elem, type, extra ) :

                            // Set width or height on the element
                            jQuery.style( elem, type, value, extra );
                    }, type, chainable ? margin : undefined, chainable, null );
                };
            } );
    } );


    jQuery.fn.extend( {

        bind: function( types, data, fn ) {
            return this.on( types, null, data, fn );
        },
        unbind: function( types, fn ) {
            return this.off( types, null, fn );
        },

        delegate: function( selector, types, data, fn ) {
            return this.on( types, selector, data, fn );
        },
        undelegate: function( selector, types, fn ) {

            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ?
                this.off( selector, "**" ) :
                this.off( types, selector || "**", fn );
        },
        size: function() {
            return this.length;
        }
    } );

    jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if ( typeof define === "function" && define.amd ) {
        define( "jquery", [], function() {
            return jQuery;
        } );
    }



    var

        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,

        // Map over the $ in case of overwrite
        _$ = window.$;

    jQuery.noConflict = function( deep ) {
        if ( window.$ === jQuery ) {
            window.$ = _$;
        }

        if ( deep && window.jQuery === jQuery ) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    };

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
    if ( !noGlobal ) {
        window.jQuery = window.$ = jQuery;
    }

    return jQuery;
}));
/*! jQuery UI - v1.12.1 - 2018-04-26
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.ui = $.ui || {};

var version = $.ui.version = "1.12.1";


/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/



var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

var widget = $.widget;


/*!
 * jQuery UI Position 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

//>>label: Position
//>>group: Core
//>>description: Positions elements relative to other elements.
//>>docs: http://api.jqueryui.com/position/
//>>demos: http://jqueryui.com/position/


( function() {
var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[ 0 ];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div " +
				"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
				"<div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[ 0 ];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[ 0 ].clientWidth;
		}

		div.remove();

		return ( cachedScrollbarWidth = w1 - w2 );
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[ 0 ] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
			hasOffset = !isWindow && !isDocument;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: withinElement.outerWidth(),
			height: withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// Make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[ 0 ].preventDefault ) {

		// Force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;

	// Clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// Force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1 ) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// Calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// Reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	} );

	// Normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each( function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
				scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
				scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				} );
			}
		} );

		if ( options.using ) {

			// Adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	} );
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// Element is wider than within
			if ( data.collisionWidth > outerWidth ) {

				// Element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
						withinOffset;
					position.left += overLeft - newOverRight;

				// Element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;

				// Element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}

			// Too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;

			// Too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;

			// Adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// Element is taller than within
			if ( data.collisionHeight > outerHeight ) {

				// Element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
						withinOffset;
					position.top += overTop - newOverBottom;

				// Element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;

				// Element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}

			// Too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;

			// Too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;

			// Adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
					outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
					atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
					outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
					offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

} )();

var position = $.ui.position;


/*!
 * jQuery UI :data 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :data Selector
//>>group: Core
//>>description: Selects elements which have data stored under the specified key.
//>>docs: http://api.jqueryui.com/data-selector/


var data = $.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo( function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		} ) :

		// Support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		}
} );

/*!
 * jQuery UI Disable Selection 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: disableSelection
//>>group: Core
//>>description: Disable selection of text content within the set of matched elements.
//>>docs: http://api.jqueryui.com/disableSelection/

// This file is deprecated


var disableSelection = $.fn.extend( {
	disableSelection: ( function() {
		var eventType = "onselectstart" in document.createElement( "div" ) ?
			"selectstart" :
			"mousedown";

		return function() {
			return this.on( eventType + ".ui-disableSelection", function( event ) {
				event.preventDefault();
			} );
		};
	} )(),

	enableSelection: function() {
		return this.off( ".ui-disableSelection" );
	}
} );


/*!
 * jQuery UI Focusable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :focusable Selector
//>>group: Core
//>>description: Selects elements which can be focused.
//>>docs: http://api.jqueryui.com/focusable-selector/



// Selectors
$.ui.focusable = function( element, hasTabindex ) {
	var map, mapName, img, focusableIfVisible, fieldset,
		nodeName = element.nodeName.toLowerCase();

	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap='#" + mapName + "']" );
		return img.length > 0 && img.is( ":visible" );
	}

	if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {
		focusableIfVisible = !element.disabled;

		if ( focusableIfVisible ) {

			// Form controls within a disabled fieldset are disabled.
			// However, controls within the fieldset's legend do not get disabled.
			// Since controls generally aren't placed inside legends, we skip
			// this portion of the check.
			fieldset = $( element ).closest( "fieldset" )[ 0 ];
			if ( fieldset ) {
				focusableIfVisible = !fieldset.disabled;
			}
		}
	} else if ( "a" === nodeName ) {
		focusableIfVisible = element.href || hasTabindex;
	} else {
		focusableIfVisible = hasTabindex;
	}

	return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );
};

// Support: IE 8 only
// IE 8 doesn't resolve inherit to visible/hidden for computed values
function visible( element ) {
	var visibility = element.css( "visibility" );
	while ( visibility === "inherit" ) {
		element = element.parent();
		visibility = element.css( "visibility" );
	}
	return visibility !== "hidden";
}

$.extend( $.expr[ ":" ], {
	focusable: function( element ) {
		return $.ui.focusable( element, $.attr( element, "tabindex" ) != null );
	}
} );

var focusable = $.ui.focusable;




// Support: IE8 Only
// IE8 does not support the form attribute and when it is supplied. It overwrites the form prop
// with a string, so we need to find the proper form.
var form = $.fn.form = function() {
	return typeof this[ 0 ].form === "string" ? this.closest( "form" ) : $( this[ 0 ].form );
};


/*!
 * jQuery UI Form Reset Mixin 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Form Reset Mixin
//>>group: Core
//>>description: Refresh input widgets when their form is reset
//>>docs: http://api.jqueryui.com/form-reset-mixin/



var formResetMixin = $.ui.formResetMixin = {
	_formResetHandler: function() {
		var form = $( this );

		// Wait for the form reset to actually happen before refreshing
		setTimeout( function() {
			var instances = form.data( "ui-form-reset-instances" );
			$.each( instances, function() {
				this.refresh();
			} );
		} );
	},

	_bindFormResetHandler: function() {
		this.form = this.element.form();
		if ( !this.form.length ) {
			return;
		}

		var instances = this.form.data( "ui-form-reset-instances" ) || [];
		if ( !instances.length ) {

			// We don't use _on() here because we use a single event handler per form
			this.form.on( "reset.ui-form-reset", this._formResetHandler );
		}
		instances.push( this );
		this.form.data( "ui-form-reset-instances", instances );
	},

	_unbindFormResetHandler: function() {
		if ( !this.form.length ) {
			return;
		}

		var instances = this.form.data( "ui-form-reset-instances" );
		instances.splice( $.inArray( this, instances ), 1 );
		if ( instances.length ) {
			this.form.data( "ui-form-reset-instances", instances );
		} else {
			this.form
				.removeData( "ui-form-reset-instances" )
				.off( "reset.ui-form-reset" );
		}
	}
};


/*!
 * jQuery UI Support for jQuery core 1.7.x 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 */

//>>label: jQuery 1.7 Support
//>>group: Core
//>>description: Support version 1.7.x of jQuery core



// Support: jQuery 1.7 only
// Not a great way to check versions, but since we only support 1.7+ and only
// need to detect <1.8, this is a simple check that should suffice. Checking
// for "1.7." would be a bit safer, but the version string is 1.7, not 1.7.0
// and we'll never reach 1.70.0 (if we do, we certainly won't be supporting
// 1.7 anymore). See #11197 for why we're not using feature detection.
if ( $.fn.jquery.substring( 0, 3 ) === "1.7" ) {

	// Setters for .innerWidth(), .innerHeight(), .outerWidth(), .outerHeight()
	// Unlike jQuery Core 1.8+, these only support numeric values to set the
	// dimensions in pixels
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			} );
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each( function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			} );
		};

		$.fn[ "outer" + name ] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each( function() {
				$( this ).css( type, reduce( this, size, true, margin ) + "px" );
			} );
		};
	} );

	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

;
/*!
 * jQuery UI Keycode 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Keycode
//>>group: Core
//>>description: Provide keycodes as keynames
//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/


var keycode = $.ui.keyCode = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	END: 35,
	ENTER: 13,
	ESCAPE: 27,
	HOME: 36,
	LEFT: 37,
	PAGE_DOWN: 34,
	PAGE_UP: 33,
	PERIOD: 190,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};




// Internal use only
var escapeSelector = $.ui.escapeSelector = ( function() {
	var selectorEscape = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;
	return function( selector ) {
		return selector.replace( selectorEscape, "\\$1" );
	};
} )();


/*!
 * jQuery UI Labels 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: labels
//>>group: Core
//>>description: Find all the labels associated with a given input
//>>docs: http://api.jqueryui.com/labels/



var labels = $.fn.labels = function() {
	var ancestor, selector, id, labels, ancestors;

	// Check control.labels first
	if ( this[ 0 ].labels && this[ 0 ].labels.length ) {
		return this.pushStack( this[ 0 ].labels );
	}

	// Support: IE <= 11, FF <= 37, Android <= 2.3 only
	// Above browsers do not support control.labels. Everything below is to support them
	// as well as document fragments. control.labels does not work on document fragments
	labels = this.eq( 0 ).parents( "label" );

	// Look for the label based on the id
	id = this.attr( "id" );
	if ( id ) {

		// We don't search against the document in case the element
		// is disconnected from the DOM
		ancestor = this.eq( 0 ).parents().last();

		// Get a full set of top level ancestors
		ancestors = ancestor.add( ancestor.length ? ancestor.siblings() : this.siblings() );

		// Create a selector for the label based on the id
		selector = "label[for='" + $.ui.escapeSelector( id ) + "']";

		labels = labels.add( ancestors.find( selector ).addBack( selector ) );

	}

	// Return whatever we have found for labels
	return this.pushStack( labels );
};


/*!
 * jQuery UI Scroll Parent 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: scrollParent
//>>group: Core
//>>description: Get the closest ancestor element that is scrollable.
//>>docs: http://api.jqueryui.com/scrollParent/



var scrollParent = $.fn.scrollParent = function( includeHidden ) {
	var position = this.css( "position" ),
		excludeStaticParent = position === "absolute",
		overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
		scrollParent = this.parents().filter( function() {
			var parent = $( this );
			if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
				return false;
			}
			return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
				parent.css( "overflow-x" ) );
		} ).eq( 0 );

	return position === "fixed" || !scrollParent.length ?
		$( this[ 0 ].ownerDocument || document ) :
		scrollParent;
};


/*!
 * jQuery UI Tabbable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :tabbable Selector
//>>group: Core
//>>description: Selects elements which can be tabbed to.
//>>docs: http://api.jqueryui.com/tabbable-selector/



var tabbable = $.extend( $.expr[ ":" ], {
	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			hasTabindex = tabIndex != null;
		return ( !hasTabindex || tabIndex >= 0 ) && $.ui.focusable( element, hasTabindex );
	}
} );


/*!
 * jQuery UI Unique ID 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: uniqueId
//>>group: Core
//>>description: Functions to generate and remove uniqueId's
//>>docs: http://api.jqueryui.com/uniqueId/



var uniqueId = $.fn.extend( {
	uniqueId: ( function() {
		var uuid = 0;

		return function() {
			return this.each( function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			} );
		};
	} )(),

	removeUniqueId: function() {
		return this.each( function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		} );
	}
} );




}));
/*!
 * Bootstrap v3.3.7 (http://getbootstrap.com)
 * Copyright 2011-2018 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

/*!
 * Generated using the Bootstrap Customizer (<none>)
 * Config saved to config.json and <none>
 */
if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
}
+function ($) {
  'use strict';
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 3)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4')
  }
}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.3.7
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.7'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector === '#' ? [] : selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.7
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.7'

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
    })
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $(document.createElement('div'))
          .addClass('dropdown-backdrop')
          .insertAfter($(this))
          .on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger($.Event('shown.bs.dropdown', relatedTarget))
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive && e.which != 27 || isActive && e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('.dropdown-menu' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--         // up
    if (e.which == 40 && index < $items.length - 1) index++         // down
    if (!~index)                                    index = 0

    $items.eq(index).trigger('focus')
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.7
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options             = options
    this.$body               = $(document.body)
    this.$element            = $(element)
    this.$dialog             = this.$element.find('.modal-dialog')
    this.$backdrop           = null
    this.isShown             = null
    this.originalBodyPad     = null
    this.scrollbarWidth      = 0
    this.ignoreBackdropClick = false

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.7'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')

    this.escape()
    this.resize()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      that.adjustDialog()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element.addClass('in')

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()
    this.resize()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')

    this.$dialog.off('mousedown.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (document !== e.target &&
            this.$element[0] !== e.target &&
            !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $(document.createElement('div'))
        .addClass('modal-backdrop ' + animate)
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus()
          : this.hide()
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    this.adjustDialog()
  }

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad)
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.7
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

/*!
 * Select2 4.0.3
 * https://select2.github.io
 *
 * Released under the MIT license
 * https://github.com/select2/select2/blob/master/LICENSE.md
 */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], factory);
  } else if (typeof exports === 'object') {
    // Node/CommonJS
    factory(require('jquery'));
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function (jQuery) {
  // This is needed so we can catch the AMD loader configuration and use it
  // The inner file should be wrapped (by `banner.start.js`) in a function that
  // returns the AMD loader references.
  var S2 =
(function () {
  // Restore the Select2 AMD loader so it can be used
  // Needed mostly in the language files, where the loader is not inserted
  if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
    var S2 = jQuery.fn.select2.amd;
  }
var S2;(function () { if (!S2 || !S2.requirejs) {
if (!S2) { S2 = {}; } else { require = S2; }
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

S2.requirejs = requirejs;S2.require = require;S2.define = define;
}
}());
S2.define("almond", function(){});

/* global jQuery:false, $:false */
S2.define('jquery',[],function () {
  var _$ = jQuery || $;

  if (_$ == null && console && console.error) {
    console.error(
      'Select2: An instance of jQuery or a jQuery-compatible library was not ' +
      'found. Make sure that you are including jQuery before Select2 on your ' +
      'web page.'
    );
  }

  return _$;
});

S2.define('select2/utils',[
  'jquery'
], function ($) {
  var Utils = {};

  Utils.Extend = function (ChildClass, SuperClass) {
    var __hasProp = {}.hasOwnProperty;

    function BaseConstructor () {
      this.constructor = ChildClass;
    }

    for (var key in SuperClass) {
      if (__hasProp.call(SuperClass, key)) {
        ChildClass[key] = SuperClass[key];
      }
    }

    BaseConstructor.prototype = SuperClass.prototype;
    ChildClass.prototype = new BaseConstructor();
    ChildClass.__super__ = SuperClass.prototype;

    return ChildClass;
  };

  function getMethods (theClass) {
    var proto = theClass.prototype;

    var methods = [];

    for (var methodName in proto) {
      var m = proto[methodName];

      if (typeof m !== 'function') {
        continue;
      }

      if (methodName === 'constructor') {
        continue;
      }

      methods.push(methodName);
    }

    return methods;
  }

  Utils.Decorate = function (SuperClass, DecoratorClass) {
    var decoratedMethods = getMethods(DecoratorClass);
    var superMethods = getMethods(SuperClass);

    function DecoratedClass () {
      var unshift = Array.prototype.unshift;

      var argCount = DecoratorClass.prototype.constructor.length;

      var calledConstructor = SuperClass.prototype.constructor;

      if (argCount > 0) {
        unshift.call(arguments, SuperClass.prototype.constructor);

        calledConstructor = DecoratorClass.prototype.constructor;
      }

      calledConstructor.apply(this, arguments);
    }

    DecoratorClass.displayName = SuperClass.displayName;

    function ctr () {
      this.constructor = DecoratedClass;
    }

    DecoratedClass.prototype = new ctr();

    for (var m = 0; m < superMethods.length; m++) {
        var superMethod = superMethods[m];

        DecoratedClass.prototype[superMethod] =
          SuperClass.prototype[superMethod];
    }

    var calledMethod = function (methodName) {
      // Stub out the original method if it's not decorating an actual method
      var originalMethod = function () {};

      if (methodName in DecoratedClass.prototype) {
        originalMethod = DecoratedClass.prototype[methodName];
      }

      var decoratedMethod = DecoratorClass.prototype[methodName];

      return function () {
        var unshift = Array.prototype.unshift;

        unshift.call(arguments, originalMethod);

        return decoratedMethod.apply(this, arguments);
      };
    };

    for (var d = 0; d < decoratedMethods.length; d++) {
      var decoratedMethod = decoratedMethods[d];

      DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
    }

    return DecoratedClass;
  };

  var Observable = function () {
    this.listeners = {};
  };

  Observable.prototype.on = function (event, callback) {
    this.listeners = this.listeners || {};

    if (event in this.listeners) {
      this.listeners[event].push(callback);
    } else {
      this.listeners[event] = [callback];
    }
  };

  Observable.prototype.trigger = function (event) {
    var slice = Array.prototype.slice;
    var params = slice.call(arguments, 1);

    this.listeners = this.listeners || {};

    // Params should always come in as an array
    if (params == null) {
      params = [];
    }

    // If there are no arguments to the event, use a temporary object
    if (params.length === 0) {
      params.push({});
    }

    // Set the `_type` of the first object to the event
    params[0]._type = event;

    if (event in this.listeners) {
      this.invoke(this.listeners[event], slice.call(arguments, 1));
    }

    if ('*' in this.listeners) {
      this.invoke(this.listeners['*'], arguments);
    }
  };

  Observable.prototype.invoke = function (listeners, params) {
    for (var i = 0, len = listeners.length; i < len; i++) {
      listeners[i].apply(this, params);
    }
  };

  Utils.Observable = Observable;

  Utils.generateChars = function (length) {
    var chars = '';

    for (var i = 0; i < length; i++) {
      var randomChar = Math.floor(Math.random() * 36);
      chars += randomChar.toString(36);
    }

    return chars;
  };

  Utils.bind = function (func, context) {
    return function () {
      func.apply(context, arguments);
    };
  };

  Utils._convertData = function (data) {
    for (var originalKey in data) {
      var keys = originalKey.split('-');

      var dataLevel = data;

      if (keys.length === 1) {
        continue;
      }

      for (var k = 0; k < keys.length; k++) {
        var key = keys[k];

        // Lowercase the first letter
        // By default, dash-separated becomes camelCase
        key = key.substring(0, 1).toLowerCase() + key.substring(1);

        if (!(key in dataLevel)) {
          dataLevel[key] = {};
        }

        if (k == keys.length - 1) {
          dataLevel[key] = data[originalKey];
        }

        dataLevel = dataLevel[key];
      }

      delete data[originalKey];
    }

    return data;
  };

  Utils.hasScroll = function (index, el) {
    // Adapted from the function created by @ShadowScripter
    // and adapted by @BillBarry on the Stack Exchange Code Review website.
    // The original code can be found at
    // http://codereview.stackexchange.com/q/13338
    // and was designed to be used with the Sizzle selector engine.

    var $el = $(el);
    var overflowX = el.style.overflowX;
    var overflowY = el.style.overflowY;

    //Check both x and y declarations
    if (overflowX === overflowY &&
        (overflowY === 'hidden' || overflowY === 'visible')) {
      return false;
    }

    if (overflowX === 'scroll' || overflowY === 'scroll') {
      return true;
    }

    return ($el.innerHeight() < el.scrollHeight ||
      $el.innerWidth() < el.scrollWidth);
  };

  Utils.escapeMarkup = function (markup) {
    var replaceMap = {
      '\\': '&#92;',
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      '\'': '&#39;',
      '/': '&#47;'
    };

    // Do not try to escape the markup if it's not a string
    if (typeof markup !== 'string') {
      return markup;
    }

    return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
      return replaceMap[match];
    });
  };

  // Append an array of jQuery nodes to a given element.
  Utils.appendMany = function ($element, $nodes) {
    // jQuery 1.7.x does not support $.fn.append() with an array
    // Fall back to a jQuery object collection using $.fn.add()
    if ($.fn.jquery.substr(0, 3) === '1.7') {
      var $jqNodes = $();

      $.map($nodes, function (node) {
        $jqNodes = $jqNodes.add(node);
      });

      $nodes = $jqNodes;
    }

    $element.append($nodes);
  };

  return Utils;
});

S2.define('select2/results',[
  'jquery',
  './utils'
], function ($, Utils) {
  function Results ($element, options, dataAdapter) {
    this.$element = $element;
    this.data = dataAdapter;
    this.options = options;

    Results.__super__.constructor.call(this);
  }

  Utils.Extend(Results, Utils.Observable);

  Results.prototype.render = function () {
    var $results = $(
      '<ul class="select2-results__options" role="tree"></ul>'
    );

    if (this.options.get('multiple')) {
      $results.attr('aria-multiselectable', 'true');
    }

    this.$results = $results;

    return $results;
  };

  Results.prototype.clear = function () {
    this.$results.empty();
  };

  Results.prototype.displayMessage = function (params) {
    var escapeMarkup = this.options.get('escapeMarkup');

    this.clear();
    this.hideLoading();

    var $message = $(
      '<li role="treeitem" aria-live="assertive"' +
      ' class="select2-results__option"></li>'
    );

    var message = this.options.get('translations').get(params.message);

    $message.append(
      escapeMarkup(
        message(params.args)
      )
    );

    $message[0].className += ' select2-results__message';

    this.$results.append($message);
  };

  Results.prototype.hideMessages = function () {
    this.$results.find('.select2-results__message').remove();
  };

  Results.prototype.append = function (data) {
    this.hideLoading();

    var $options = [];

    if (data.results == null || data.results.length === 0) {
      if (this.$results.children().length === 0) {
        this.trigger('results:message', {
          message: 'noResults'
        });
      }

      return;
    }

    data.results = this.sort(data.results);

    for (var d = 0; d < data.results.length; d++) {
      var item = data.results[d];

      var $option = this.option(item);

      $options.push($option);
    }

    this.$results.append($options);
  };

  Results.prototype.position = function ($results, $dropdown) {
    var $resultsContainer = $dropdown.find('.select2-results');
    $resultsContainer.append($results);
  };

  Results.prototype.sort = function (data) {
    var sorter = this.options.get('sorter');

    return sorter(data);
  };

  Results.prototype.highlightFirstItem = function () {
    var $options = this.$results
      .find('.select2-results__option[aria-selected]');

    var $selected = $options.filter('[aria-selected=true]');

    // Check if there are any selected options
    if ($selected.length > 0) {
      // If there are selected options, highlight the first
      $selected.first().trigger('mouseenter');
    } else {
      // If there are no selected options, highlight the first option
      // in the dropdown
      $options.first().trigger('mouseenter');
    }

    this.ensureHighlightVisible();
  };

  Results.prototype.setClasses = function () {
    var self = this;

    this.data.current(function (selected) {
      var selectedIds = $.map(selected, function (s) {
        return s.id.toString();
      });

      var $options = self.$results
        .find('.select2-results__option[aria-selected]');

      $options.each(function () {
        var $option = $(this);

        var item = $.data(this, 'data');

        // id needs to be converted to a string when comparing
        var id = '' + item.id;

        if ((item.element != null && item.element.selected) ||
            (item.element == null && $.inArray(id, selectedIds) > -1)) {
          $option.attr('aria-selected', 'true');
        } else {
          $option.attr('aria-selected', 'false');
        }
      });

    });
  };

  Results.prototype.showLoading = function (params) {
    this.hideLoading();

    var loadingMore = this.options.get('translations').get('searching');

    var loading = {
      disabled: true,
      loading: true,
      text: loadingMore(params)
    };
    var $loading = this.option(loading);
    $loading.className += ' loading-results';

    this.$results.prepend($loading);
  };

  Results.prototype.hideLoading = function () {
    this.$results.find('.loading-results').remove();
  };

  Results.prototype.option = function (data) {
    var option = document.createElement('li');
    option.className = 'select2-results__option';

    var attrs = {
      'role': 'treeitem',
      'aria-selected': 'false'
    };

    if (data.disabled) {
      delete attrs['aria-selected'];
      attrs['aria-disabled'] = 'true';
    }

    if (data.id == null) {
      delete attrs['aria-selected'];
    }

    if (data._resultId != null) {
      option.id = data._resultId;
    }

    if (data.title) {
      option.title = data.title;
    }

    if (data.children) {
      attrs.role = 'group';
      attrs['aria-label'] = data.text;
      delete attrs['aria-selected'];
    }

    for (var attr in attrs) {
      var val = attrs[attr];

      option.setAttribute(attr, val);
    }

    if (data.children) {
      var $option = $(option);

      var label = document.createElement('strong');
      label.className = 'select2-results__group';

      var $label = $(label);
      this.template(data, label);

      var $children = [];

      for (var c = 0; c < data.children.length; c++) {
        var child = data.children[c];

        var $child = this.option(child);

        $children.push($child);
      }

      var $childrenContainer = $('<ul></ul>', {
        'class': 'select2-results__options select2-results__options--nested'
      });

      $childrenContainer.append($children);

      $option.append(label);
      $option.append($childrenContainer);
    } else {
      this.template(data, option);
    }

    $.data(option, 'data', data);

    return option;
  };

  Results.prototype.bind = function (container, $container) {
    var self = this;

    var id = container.id + '-results';

    this.$results.attr('id', id);

    container.on('results:all', function (params) {
      self.clear();
      self.append(params.data);

      if (container.isOpen()) {
        self.setClasses();
        self.highlightFirstItem();
      }
    });

    container.on('results:append', function (params) {
      self.append(params.data);

      if (container.isOpen()) {
        self.setClasses();
      }
    });

    container.on('query', function (params) {
      self.hideMessages();
      self.showLoading(params);
    });

    container.on('select', function () {
      if (!container.isOpen()) {
        return;
      }

      self.setClasses();
      self.highlightFirstItem();
    });

    container.on('unselect', function () {
      if (!container.isOpen()) {
        return;
      }

      self.setClasses();
      self.highlightFirstItem();
    });

    container.on('open', function () {
      // When the dropdown is open, aria-expended="true"
      self.$results.attr('aria-expanded', 'true');
      self.$results.attr('aria-hidden', 'false');

      self.setClasses();
      self.ensureHighlightVisible();
    });

    container.on('close', function () {
      // When the dropdown is closed, aria-expended="false"
      self.$results.attr('aria-expanded', 'false');
      self.$results.attr('aria-hidden', 'true');
      self.$results.removeAttr('aria-activedescendant');
    });

    container.on('results:toggle', function () {
      var $highlighted = self.getHighlightedResults();

      if ($highlighted.length === 0) {
        return;
      }

      $highlighted.trigger('mouseup');
    });

    container.on('results:select', function () {
      var $highlighted = self.getHighlightedResults();

      if ($highlighted.length === 0) {
        return;
      }

      var data = $highlighted.data('data');

      if ($highlighted.attr('aria-selected') == 'true') {
        self.trigger('close', {});
      } else {
        self.trigger('select', {
          data: data
        });
      }
    });

    container.on('results:previous', function () {
      var $highlighted = self.getHighlightedResults();

      var $options = self.$results.find('[aria-selected]');

      var currentIndex = $options.index($highlighted);

      // If we are already at te top, don't move further
      if (currentIndex === 0) {
        return;
      }

      var nextIndex = currentIndex - 1;

      // If none are highlighted, highlight the first
      if ($highlighted.length === 0) {
        nextIndex = 0;
      }

      var $next = $options.eq(nextIndex);

      $next.trigger('mouseenter');

      var currentOffset = self.$results.offset().top;
      var nextTop = $next.offset().top;
      var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);

      if (nextIndex === 0) {
        self.$results.scrollTop(0);
      } else if (nextTop - currentOffset < 0) {
        self.$results.scrollTop(nextOffset);
      }
    });

    container.on('results:next', function () {
      var $highlighted = self.getHighlightedResults();

      var $options = self.$results.find('[aria-selected]');

      var currentIndex = $options.index($highlighted);

      var nextIndex = currentIndex + 1;

      // If we are at the last option, stay there
      if (nextIndex >= $options.length) {
        return;
      }

      var $next = $options.eq(nextIndex);

      $next.trigger('mouseenter');

      var currentOffset = self.$results.offset().top +
        self.$results.outerHeight(false);
      var nextBottom = $next.offset().top + $next.outerHeight(false);
      var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;

      if (nextIndex === 0) {
        self.$results.scrollTop(0);
      } else if (nextBottom > currentOffset) {
        self.$results.scrollTop(nextOffset);
      }
    });

    container.on('results:focus', function (params) {
      params.element.addClass('select2-results__option--highlighted');
    });

    container.on('results:message', function (params) {
      self.displayMessage(params);
    });

    if ($.fn.mousewheel) {
      this.$results.on('mousewheel', function (e) {
        var top = self.$results.scrollTop();

        var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;

        var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
        var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();

        if (isAtTop) {
          self.$results.scrollTop(0);

          e.preventDefault();
          e.stopPropagation();
        } else if (isAtBottom) {
          self.$results.scrollTop(
            self.$results.get(0).scrollHeight - self.$results.height()
          );

          e.preventDefault();
          e.stopPropagation();
        }
      });
    }

    this.$results.on('mouseup', '.select2-results__option[aria-selected]',
      function (evt) {
      var $this = $(this);

      var data = $this.data('data');

      if ($this.attr('aria-selected') === 'true') {
        if (self.options.get('multiple')) {
          self.trigger('unselect', {
            originalEvent: evt,
            data: data
          });
        } else {
          self.trigger('close', {});
        }

        return;
      }

      self.trigger('select', {
        originalEvent: evt,
        data: data
      });
    });

    this.$results.on('mouseenter', '.select2-results__option[aria-selected]',
      function (evt) {
      var data = $(this).data('data');

      self.getHighlightedResults()
          .removeClass('select2-results__option--highlighted');

      self.trigger('results:focus', {
        data: data,
        element: $(this)
      });
    });
  };

  Results.prototype.getHighlightedResults = function () {
    var $highlighted = this.$results
    .find('.select2-results__option--highlighted');

    return $highlighted;
  };

  Results.prototype.destroy = function () {
    this.$results.remove();
  };

  Results.prototype.ensureHighlightVisible = function () {
    var $highlighted = this.getHighlightedResults();

    if ($highlighted.length === 0) {
      return;
    }

    var $options = this.$results.find('[aria-selected]');

    var currentIndex = $options.index($highlighted);

    var currentOffset = this.$results.offset().top;
    var nextTop = $highlighted.offset().top;
    var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);

    var offsetDelta = nextTop - currentOffset;
    nextOffset -= $highlighted.outerHeight(false) * 2;

    if (currentIndex <= 2) {
      this.$results.scrollTop(0);
    } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
      this.$results.scrollTop(nextOffset);
    }
  };

  Results.prototype.template = function (result, container) {
    var template = this.options.get('templateResult');
    var escapeMarkup = this.options.get('escapeMarkup');

    var content = template(result, container);

    if (content == null) {
      container.style.display = 'none';
    } else if (typeof content === 'string') {
      container.innerHTML = escapeMarkup(content);
    } else {
      $(container).append(content);
    }
  };

  return Results;
});

S2.define('select2/keys',[

], function () {
  var KEYS = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    DELETE: 46
  };

  return KEYS;
});

S2.define('select2/selection/base',[
  'jquery',
  '../utils',
  '../keys'
], function ($, Utils, KEYS) {
  function BaseSelection ($element, options) {
    this.$element = $element;
    this.options = options;

    BaseSelection.__super__.constructor.call(this);
  }

  Utils.Extend(BaseSelection, Utils.Observable);

  BaseSelection.prototype.render = function () {
    var $selection = $(
      '<span class="select2-selection" role="combobox" ' +
      ' aria-haspopup="true" aria-expanded="false">' +
      '</span>'
    );

    this._tabindex = 0;

    if (this.$element.data('old-tabindex') != null) {
      this._tabindex = this.$element.data('old-tabindex');
    } else if (this.$element.attr('tabindex') != null) {
      this._tabindex = this.$element.attr('tabindex');
    }

    $selection.attr('title', this.$element.attr('title'));
    $selection.attr('tabindex', this._tabindex);

    this.$selection = $selection;

    return $selection;
  };

  BaseSelection.prototype.bind = function (container, $container) {
    var self = this;

    var id = container.id + '-container';
    var resultsId = container.id + '-results';

    this.container = container;

    this.$selection.on('focus', function (evt) {
      self.trigger('focus', evt);
    });

    this.$selection.on('blur', function (evt) {
      self._handleBlur(evt);
    });

    this.$selection.on('keydown', function (evt) {
      self.trigger('keypress', evt);

      if (evt.which === KEYS.SPACE) {
        evt.preventDefault();
      }
    });

    container.on('results:focus', function (params) {
      self.$selection.attr('aria-activedescendant', params.data._resultId);
    });

    container.on('selection:update', function (params) {
      self.update(params.data);
    });

    container.on('open', function () {
      // When the dropdown is open, aria-expanded="true"
      self.$selection.attr('aria-expanded', 'true');
      self.$selection.attr('aria-owns', resultsId);

      self._attachCloseHandler(container);
    });

    container.on('close', function () {
      // When the dropdown is closed, aria-expanded="false"
      self.$selection.attr('aria-expanded', 'false');
      self.$selection.removeAttr('aria-activedescendant');
      self.$selection.removeAttr('aria-owns');

      self.$selection.focus();

      self._detachCloseHandler(container);
    });

    container.on('enable', function () {
      self.$selection.attr('tabindex', self._tabindex);
    });

    container.on('disable', function () {
      self.$selection.attr('tabindex', '-1');
    });
  };

  BaseSelection.prototype._handleBlur = function (evt) {
    var self = this;

    // This needs to be delayed as the active element is the body when the tab
    // key is pressed, possibly along with others.
    window.setTimeout(function () {
      // Don't trigger `blur` if the focus is still in the selection
      if (
        (document.activeElement == self.$selection[0]) ||
        ($.contains(self.$selection[0], document.activeElement))
      ) {
        return;
      }

      self.trigger('blur', evt);
    }, 1);
  };

  BaseSelection.prototype._attachCloseHandler = function (container) {
    var self = this;

    $(document.body).on('mousedown.select2.' + container.id, function (e) {
      var $target = $(e.target);

      var $select = $target.closest('.select2');

      var $all = $('.select2.select2-container--open');

      $all.each(function () {
        var $this = $(this);

        if (this == $select[0]) {
          return;
        }

        var $element = $this.data('element');

        $element.select2('close');
      });
    });
  };

  BaseSelection.prototype._detachCloseHandler = function (container) {
    $(document.body).off('mousedown.select2.' + container.id);
  };

  BaseSelection.prototype.position = function ($selection, $container) {
    var $selectionContainer = $container.find('.selection');
    $selectionContainer.append($selection);
  };

  BaseSelection.prototype.destroy = function () {
    this._detachCloseHandler(this.container);
  };

  BaseSelection.prototype.update = function (data) {
    throw new Error('The `update` method must be defined in child classes.');
  };

  return BaseSelection;
});

S2.define('select2/selection/single',[
  'jquery',
  './base',
  '../utils',
  '../keys'
], function ($, BaseSelection, Utils, KEYS) {
  function SingleSelection () {
    SingleSelection.__super__.constructor.apply(this, arguments);
  }

  Utils.Extend(SingleSelection, BaseSelection);

  SingleSelection.prototype.render = function () {
    var $selection = SingleSelection.__super__.render.call(this);

    $selection.addClass('select2-selection--single');

    $selection.html(
      '<span class="select2-selection__rendered"></span>' +
      '<span class="select2-selection__arrow" role="presentation">' +
        '<b role="presentation"></b>' +
      '</span>'
    );

    return $selection;
  };

  SingleSelection.prototype.bind = function (container, $container) {
    var self = this;

    SingleSelection.__super__.bind.apply(this, arguments);

    var id = container.id + '-container';

    this.$selection.find('.select2-selection__rendered').attr('id', id);
    this.$selection.attr('aria-labelledby', id);

    this.$selection.on('mousedown', function (evt) {
      // Only respond to left clicks
      if (evt.which !== 1) {
        return;
      }

      self.trigger('toggle', {
        originalEvent: evt
      });
    });

    this.$selection.on('focus', function (evt) {
      // User focuses on the container
    });

    this.$selection.on('blur', function (evt) {
      // User exits the container
    });

    container.on('focus', function (evt) {
      if (!container.isOpen()) {
        self.$selection.focus();
      }
    });

    container.on('selection:update', function (params) {
      self.update(params.data);
    });
  };

  SingleSelection.prototype.clear = function () {
    this.$selection.find('.select2-selection__rendered').empty();
  };

  SingleSelection.prototype.display = function (data, container) {
    var template = this.options.get('templateSelection');
    var escapeMarkup = this.options.get('escapeMarkup');

    return escapeMarkup(template(data, container));
  };

  SingleSelection.prototype.selectionContainer = function () {
    return $('<span></span>');
  };

  SingleSelection.prototype.update = function (data) {
    if (data.length === 0) {
      this.clear();
      return;
    }

    var selection = data[0];

    var $rendered = this.$selection.find('.select2-selection__rendered');
    var formatted = this.display(selection, $rendered);

    $rendered.empty().append(formatted);
    $rendered.prop('title', selection.title || selection.text);
  };

  return SingleSelection;
});

S2.define('select2/selection/multiple',[
  'jquery',
  './base',
  '../utils'
], function ($, BaseSelection, Utils) {
  function MultipleSelection ($element, options) {
    MultipleSelection.__super__.constructor.apply(this, arguments);
  }

  Utils.Extend(MultipleSelection, BaseSelection);

  MultipleSelection.prototype.render = function () {
    var $selection = MultipleSelection.__super__.render.call(this);

    $selection.addClass('select2-selection--multiple');

    $selection.html(
      '<ul class="select2-selection__rendered"></ul>'
    );

    return $selection;
  };

  MultipleSelection.prototype.bind = function (container, $container) {
    var self = this;

    MultipleSelection.__super__.bind.apply(this, arguments);

    this.$selection.on('click', function (evt) {
      self.trigger('toggle', {
        originalEvent: evt
      });
    });

    this.$selection.on(
      'click',
      '.select2-selection__choice__remove',
      function (evt) {
        // Ignore the event if it is disabled
        if (self.options.get('disabled')) {
          return;
        }

        var $remove = $(this);
        var $selection = $remove.parent();

        var data = $selection.data('data');

        self.trigger('unselect', {
          originalEvent: evt,
          data: data
        });
      }
    );
  };

  MultipleSelection.prototype.clear = function () {
    this.$selection.find('.select2-selection__rendered').empty();
  };

  MultipleSelection.prototype.display = function (data, container) {
    var template = this.options.get('templateSelection');
    var escapeMarkup = this.options.get('escapeMarkup');

    return escapeMarkup(template(data, container));
  };

  MultipleSelection.prototype.selectionContainer = function () {
    var $container = $(
      '<li class="select2-selection__choice">' +
        '<span class="select2-selection__choice__remove" role="presentation">' +
          '&times;' +
        '</span>' +
      '</li>'
    );

    return $container;
  };

  MultipleSelection.prototype.update = function (data) {
    this.clear();

    if (data.length === 0) {
      return;
    }

    var $selections = [];

    for (var d = 0; d < data.length; d++) {
      var selection = data[d];

      var $selection = this.selectionContainer();
      var formatted = this.display(selection, $selection);

      $selection.append(formatted);
      $selection.prop('title', selection.title || selection.text);

      $selection.data('data', selection);

      $selections.push($selection);
    }

    var $rendered = this.$selection.find('.select2-selection__rendered');

    Utils.appendMany($rendered, $selections);
  };

  return MultipleSelection;
});

S2.define('select2/selection/placeholder',[
  '../utils'
], function (Utils) {
  function Placeholder (decorated, $element, options) {
    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

    decorated.call(this, $element, options);
  }

  Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
    if (typeof placeholder === 'string') {
      placeholder = {
        id: '',
        text: placeholder
      };
    }

    return placeholder;
  };

  Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
    var $placeholder = this.selectionContainer();

    $placeholder.html(this.display(placeholder));
    $placeholder.addClass('select2-selection__placeholder')
                .removeClass('select2-selection__choice');

    return $placeholder;
  };

  Placeholder.prototype.update = function (decorated, data) {
    var singlePlaceholder = (
      data.length == 1 && data[0].id != this.placeholder.id
    );
    var multipleSelections = data.length > 1;

    if (multipleSelections || singlePlaceholder) {
      return decorated.call(this, data);
    }

    this.clear();

    var $placeholder = this.createPlaceholder(this.placeholder);

    this.$selection.find('.select2-selection__rendered').append($placeholder);
  };

  return Placeholder;
});

S2.define('select2/selection/allowClear',[
  'jquery',
  '../keys'
], function ($, KEYS) {
  function AllowClear () { }

  AllowClear.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    if (this.placeholder == null) {
      if (this.options.get('debug') && window.console && console.error) {
        console.error(
          'Select2: The `allowClear` option should be used in combination ' +
          'with the `placeholder` option.'
        );
      }
    }

    this.$selection.on('mousedown', '.select2-selection__clear',
      function (evt) {
        self._handleClear(evt);
    });

    container.on('keypress', function (evt) {
      self._handleKeyboardClear(evt, container);
    });
  };

  AllowClear.prototype._handleClear = function (_, evt) {
    // Ignore the event if it is disabled
    if (this.options.get('disabled')) {
      return;
    }

    var $clear = this.$selection.find('.select2-selection__clear');

    // Ignore the event if nothing has been selected
    if ($clear.length === 0) {
      return;
    }

    evt.stopPropagation();

    var data = $clear.data('data');

    for (var d = 0; d < data.length; d++) {
      var unselectData = {
        data: data[d]
      };

      // Trigger the `unselect` event, so people can prevent it from being
      // cleared.
      this.trigger('unselect', unselectData);

      // If the event was prevented, don't clear it out.
      if (unselectData.prevented) {
        return;
      }
    }

    this.$element.val(this.placeholder.id).trigger('change');

    this.trigger('toggle', {});
  };

  AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
    if (container.isOpen()) {
      return;
    }

    if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
      this._handleClear(evt);
    }
  };

  AllowClear.prototype.update = function (decorated, data) {
    decorated.call(this, data);

    if (this.$selection.find('.select2-selection__placeholder').length > 0 ||
        data.length === 0) {
      return;
    }

    var $remove = $(
      '<span class="select2-selection__clear">' +
        '&times;' +
      '</span>'
    );
    $remove.data('data', data);

    this.$selection.find('.select2-selection__rendered').prepend($remove);
  };

  return AllowClear;
});

S2.define('select2/selection/search',[
  'jquery',
  '../utils',
  '../keys'
], function ($, Utils, KEYS) {
  function Search (decorated, $element, options) {
    decorated.call(this, $element, options);
  }

  Search.prototype.render = function (decorated) {
    var $search = $(
      '<li class="select2-search select2-search--inline">' +
        '<input class="select2-search__field" type="search" tabindex="-1"' +
        ' autocomplete="off" autocorrect="off" autocapitalize="off"' +
        ' spellcheck="false" role="textbox" aria-autocomplete="list" />' +
      '</li>'
    );

    this.$searchContainer = $search;
    this.$search = $search.find('input');

    var $rendered = decorated.call(this);

    this._transferTabIndex();

    return $rendered;
  };

  Search.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('open', function () {
      self.$search.trigger('focus');
    });

    container.on('close', function () {
      self.$search.val('');
      self.$search.removeAttr('aria-activedescendant');
      self.$search.trigger('focus');
    });

    container.on('enable', function () {
      self.$search.prop('disabled', false);

      self._transferTabIndex();
    });

    container.on('disable', function () {
      self.$search.prop('disabled', true);
    });

    container.on('focus', function (evt) {
      self.$search.trigger('focus');
    });

    container.on('results:focus', function (params) {
      self.$search.attr('aria-activedescendant', params.id);
    });

    this.$selection.on('focusin', '.select2-search--inline', function (evt) {
      self.trigger('focus', evt);
    });

    this.$selection.on('focusout', '.select2-search--inline', function (evt) {
      self._handleBlur(evt);
    });

    this.$selection.on('keydown', '.select2-search--inline', function (evt) {
      evt.stopPropagation();

      self.trigger('keypress', evt);

      self._keyUpPrevented = evt.isDefaultPrevented();

      var key = evt.which;

      if (key === KEYS.BACKSPACE && self.$search.val() === '') {
        var $previousChoice = self.$searchContainer
          .prev('.select2-selection__choice');

        if ($previousChoice.length > 0) {
          var item = $previousChoice.data('data');

          self.searchRemoveChoice(item);

          evt.preventDefault();
        }
      }
    });

    // Try to detect the IE version should the `documentMode` property that
    // is stored on the document. This is only implemented in IE and is
    // slightly cleaner than doing a profile agent check.
    // This property is not available in Edge, but Edge also doesn't have
    // this bug.
    var msie = document.documentMode;
    var disableInputEvents = msie && msie <= 11;

    // Workaround for browsers which do not support the `input` event
    // This will prevent double-triggering of events for browsers which support
    // both the `keyup` and `input` events.
    this.$selection.on(
      'input.searchcheck',
      '.select2-search--inline',
      function (evt) {
        // IE will trigger the `input` event when a placeholder is used on a
        // search box. To get around this issue, we are forced to ignore all
        // `input` events in IE and keep using `keyup`.
        if (disableInputEvents) {
          self.$selection.off('input.search input.searchcheck');
          return;
        }

        // Unbind the duplicated `keyup` event
        self.$selection.off('keyup.search');
      }
    );

    this.$selection.on(
      'keyup.search input.search',
      '.select2-search--inline',
      function (evt) {
        // IE will trigger the `input` event when a placeholder is used on a
        // search box. To get around this issue, we are forced to ignore all
        // `input` events in IE and keep using `keyup`.
        if (disableInputEvents && evt.type === 'input') {
          self.$selection.off('input.search input.searchcheck');
          return;
        }

        var key = evt.which;

        // We can freely ignore events from modifier keys
        if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
          return;
        }

        // Tabbing will be handled during the `keydown` phase
        if (key == KEYS.TAB) {
          return;
        }

        self.handleSearch(evt);
      }
    );
  };

  /**
   * This method will transfer the tabindex attribute from the rendered
   * selection to the search box. This allows for the search box to be used as
   * the primary focus instead of the selection container.
   *
   * @private
   */
  Search.prototype._transferTabIndex = function (decorated) {
    this.$search.attr('tabindex', this.$selection.attr('tabindex'));
    this.$selection.attr('tabindex', '-1');
  };

  Search.prototype.createPlaceholder = function (decorated, placeholder) {
    this.$search.attr('placeholder', placeholder.text);
  };

  Search.prototype.update = function (decorated, data) {
    var searchHadFocus = this.$search[0] == document.activeElement;

    this.$search.attr('placeholder', '');

    decorated.call(this, data);

    this.$selection.find('.select2-selection__rendered')
                   .append(this.$searchContainer);

    this.resizeSearch();
    if (searchHadFocus) {
      this.$search.focus();
    }
  };

  Search.prototype.handleSearch = function () {
    this.resizeSearch();

    if (!this._keyUpPrevented) {
      var input = this.$search.val();

      this.trigger('query', {
        term: input
      });
    }

    this._keyUpPrevented = false;
  };

  Search.prototype.searchRemoveChoice = function (decorated, item) {
    this.trigger('unselect', {
      data: item
    });

    this.$search.val(item.text);
    this.handleSearch();
  };

  Search.prototype.resizeSearch = function () {
    this.$search.css('width', '25px');

    var width = '';

    if (this.$search.attr('placeholder') !== '') {
      width = this.$selection.find('.select2-selection__rendered').innerWidth();
    } else {
      var minimumWidth = this.$search.val().length + 1;

      width = (minimumWidth * 0.75) + 'em';
    }

    this.$search.css('width', width);
  };

  return Search;
});

S2.define('select2/selection/eventRelay',[
  'jquery'
], function ($) {
  function EventRelay () { }

  EventRelay.prototype.bind = function (decorated, container, $container) {
    var self = this;
    var relayEvents = [
      'open', 'opening',
      'close', 'closing',
      'select', 'selecting',
      'unselect', 'unselecting'
    ];

    var preventableEvents = ['opening', 'closing', 'selecting', 'unselecting'];

    decorated.call(this, container, $container);

    container.on('*', function (name, params) {
      // Ignore events that should not be relayed
      if ($.inArray(name, relayEvents) === -1) {
        return;
      }

      // The parameters should always be an object
      params = params || {};

      // Generate the jQuery event for the Select2 event
      var evt = $.Event('select2:' + name, {
        params: params
      });

      self.$element.trigger(evt);

      // Only handle preventable events if it was one
      if ($.inArray(name, preventableEvents) === -1) {
        return;
      }

      params.prevented = evt.isDefaultPrevented();
    });
  };

  return EventRelay;
});

S2.define('select2/translation',[
  'jquery',
  'require'
], function ($, require) {
  function Translation (dict) {
    this.dict = dict || {};
  }

  Translation.prototype.all = function () {
    return this.dict;
  };

  Translation.prototype.get = function (key) {
    return this.dict[key];
  };

  Translation.prototype.extend = function (translation) {
    this.dict = $.extend({}, translation.all(), this.dict);
  };

  // Static functions

  Translation._cache = {};

  Translation.loadPath = function (path) {
    if (!(path in Translation._cache)) {
      var translations = require(path);

      Translation._cache[path] = translations;
    }

    return new Translation(Translation._cache[path]);
  };

  return Translation;
});

S2.define('select2/diacritics',[

], function () {
  var diacritics = {
    '\u24B6': 'A',
    '\uFF21': 'A',
    '\u00C0': 'A',
    '\u00C1': 'A',
    '\u00C2': 'A',
    '\u1EA6': 'A',
    '\u1EA4': 'A',
    '\u1EAA': 'A',
    '\u1EA8': 'A',
    '\u00C3': 'A',
    '\u0100': 'A',
    '\u0102': 'A',
    '\u1EB0': 'A',
    '\u1EAE': 'A',
    '\u1EB4': 'A',
    '\u1EB2': 'A',
    '\u0226': 'A',
    '\u01E0': 'A',
    '\u00C4': 'A',
    '\u01DE': 'A',
    '\u1EA2': 'A',
    '\u00C5': 'A',
    '\u01FA': 'A',
    '\u01CD': 'A',
    '\u0200': 'A',
    '\u0202': 'A',
    '\u1EA0': 'A',
    '\u1EAC': 'A',
    '\u1EB6': 'A',
    '\u1E00': 'A',
    '\u0104': 'A',
    '\u023A': 'A',
    '\u2C6F': 'A',
    '\uA732': 'AA',
    '\u00C6': 'AE',
    '\u01FC': 'AE',
    '\u01E2': 'AE',
    '\uA734': 'AO',
    '\uA736': 'AU',
    '\uA738': 'AV',
    '\uA73A': 'AV',
    '\uA73C': 'AY',
    '\u24B7': 'B',
    '\uFF22': 'B',
    '\u1E02': 'B',
    '\u1E04': 'B',
    '\u1E06': 'B',
    '\u0243': 'B',
    '\u0182': 'B',
    '\u0181': 'B',
    '\u24B8': 'C',
    '\uFF23': 'C',
    '\u0106': 'C',
    '\u0108': 'C',
    '\u010A': 'C',
    '\u010C': 'C',
    '\u00C7': 'C',
    '\u1E08': 'C',
    '\u0187': 'C',
    '\u023B': 'C',
    '\uA73E': 'C',
    '\u24B9': 'D',
    '\uFF24': 'D',
    '\u1E0A': 'D',
    '\u010E': 'D',
    '\u1E0C': 'D',
    '\u1E10': 'D',
    '\u1E12': 'D',
    '\u1E0E': 'D',
    '\u0110': 'D',
    '\u018B': 'D',
    '\u018A': 'D',
    '\u0189': 'D',
    '\uA779': 'D',
    '\u01F1': 'DZ',
    '\u01C4': 'DZ',
    '\u01F2': 'Dz',
    '\u01C5': 'Dz',
    '\u24BA': 'E',
    '\uFF25': 'E',
    '\u00C8': 'E',
    '\u00C9': 'E',
    '\u00CA': 'E',
    '\u1EC0': 'E',
    '\u1EBE': 'E',
    '\u1EC4': 'E',
    '\u1EC2': 'E',
    '\u1EBC': 'E',
    '\u0112': 'E',
    '\u1E14': 'E',
    '\u1E16': 'E',
    '\u0114': 'E',
    '\u0116': 'E',
    '\u00CB': 'E',
    '\u1EBA': 'E',
    '\u011A': 'E',
    '\u0204': 'E',
    '\u0206': 'E',
    '\u1EB8': 'E',
    '\u1EC6': 'E',
    '\u0228': 'E',
    '\u1E1C': 'E',
    '\u0118': 'E',
    '\u1E18': 'E',
    '\u1E1A': 'E',
    '\u0190': 'E',
    '\u018E': 'E',
    '\u24BB': 'F',
    '\uFF26': 'F',
    '\u1E1E': 'F',
    '\u0191': 'F',
    '\uA77B': 'F',
    '\u24BC': 'G',
    '\uFF27': 'G',
    '\u01F4': 'G',
    '\u011C': 'G',
    '\u1E20': 'G',
    '\u011E': 'G',
    '\u0120': 'G',
    '\u01E6': 'G',
    '\u0122': 'G',
    '\u01E4': 'G',
    '\u0193': 'G',
    '\uA7A0': 'G',
    '\uA77D': 'G',
    '\uA77E': 'G',
    '\u24BD': 'H',
    '\uFF28': 'H',
    '\u0124': 'H',
    '\u1E22': 'H',
    '\u1E26': 'H',
    '\u021E': 'H',
    '\u1E24': 'H',
    '\u1E28': 'H',
    '\u1E2A': 'H',
    '\u0126': 'H',
    '\u2C67': 'H',
    '\u2C75': 'H',
    '\uA78D': 'H',
    '\u24BE': 'I',
    '\uFF29': 'I',
    '\u00CC': 'I',
    '\u00CD': 'I',
    '\u00CE': 'I',
    '\u0128': 'I',
    '\u012A': 'I',
    '\u012C': 'I',
    '\u0130': 'I',
    '\u00CF': 'I',
    '\u1E2E': 'I',
    '\u1EC8': 'I',
    '\u01CF': 'I',
    '\u0208': 'I',
    '\u020A': 'I',
    '\u1ECA': 'I',
    '\u012E': 'I',
    '\u1E2C': 'I',
    '\u0197': 'I',
    '\u24BF': 'J',
    '\uFF2A': 'J',
    '\u0134': 'J',
    '\u0248': 'J',
    '\u24C0': 'K',
    '\uFF2B': 'K',
    '\u1E30': 'K',
    '\u01E8': 'K',
    '\u1E32': 'K',
    '\u0136': 'K',
    '\u1E34': 'K',
    '\u0198': 'K',
    '\u2C69': 'K',
    '\uA740': 'K',
    '\uA742': 'K',
    '\uA744': 'K',
    '\uA7A2': 'K',
    '\u24C1': 'L',
    '\uFF2C': 'L',
    '\u013F': 'L',
    '\u0139': 'L',
    '\u013D': 'L',
    '\u1E36': 'L',
    '\u1E38': 'L',
    '\u013B': 'L',
    '\u1E3C': 'L',
    '\u1E3A': 'L',
    '\u0141': 'L',
    '\u023D': 'L',
    '\u2C62': 'L',
    '\u2C60': 'L',
    '\uA748': 'L',
    '\uA746': 'L',
    '\uA780': 'L',
    '\u01C7': 'LJ',
    '\u01C8': 'Lj',
    '\u24C2': 'M',
    '\uFF2D': 'M',
    '\u1E3E': 'M',
    '\u1E40': 'M',
    '\u1E42': 'M',
    '\u2C6E': 'M',
    '\u019C': 'M',
    '\u24C3': 'N',
    '\uFF2E': 'N',
    '\u01F8': 'N',
    '\u0143': 'N',
    '\u00D1': 'N',
    '\u1E44': 'N',
    '\u0147': 'N',
    '\u1E46': 'N',
    '\u0145': 'N',
    '\u1E4A': 'N',
    '\u1E48': 'N',
    '\u0220': 'N',
    '\u019D': 'N',
    '\uA790': 'N',
    '\uA7A4': 'N',
    '\u01CA': 'NJ',
    '\u01CB': 'Nj',
    '\u24C4': 'O',
    '\uFF2F': 'O',
    '\u00D2': 'O',
    '\u00D3': 'O',
    '\u00D4': 'O',
    '\u1ED2': 'O',
    '\u1ED0': 'O',
    '\u1ED6': 'O',
    '\u1ED4': 'O',
    '\u00D5': 'O',
    '\u1E4C': 'O',
    '\u022C': 'O',
    '\u1E4E': 'O',
    '\u014C': 'O',
    '\u1E50': 'O',
    '\u1E52': 'O',
    '\u014E': 'O',
    '\u022E': 'O',
    '\u0230': 'O',
    '\u00D6': 'O',
    '\u022A': 'O',
    '\u1ECE': 'O',
    '\u0150': 'O',
    '\u01D1': 'O',
    '\u020C': 'O',
    '\u020E': 'O',
    '\u01A0': 'O',
    '\u1EDC': 'O',
    '\u1EDA': 'O',
    '\u1EE0': 'O',
    '\u1EDE': 'O',
    '\u1EE2': 'O',
    '\u1ECC': 'O',
    '\u1ED8': 'O',
    '\u01EA': 'O',
    '\u01EC': 'O',
    '\u00D8': 'O',
    '\u01FE': 'O',
    '\u0186': 'O',
    '\u019F': 'O',
    '\uA74A': 'O',
    '\uA74C': 'O',
    '\u01A2': 'OI',
    '\uA74E': 'OO',
    '\u0222': 'OU',
    '\u24C5': 'P',
    '\uFF30': 'P',
    '\u1E54': 'P',
    '\u1E56': 'P',
    '\u01A4': 'P',
    '\u2C63': 'P',
    '\uA750': 'P',
    '\uA752': 'P',
    '\uA754': 'P',
    '\u24C6': 'Q',
    '\uFF31': 'Q',
    '\uA756': 'Q',
    '\uA758': 'Q',
    '\u024A': 'Q',
    '\u24C7': 'R',
    '\uFF32': 'R',
    '\u0154': 'R',
    '\u1E58': 'R',
    '\u0158': 'R',
    '\u0210': 'R',
    '\u0212': 'R',
    '\u1E5A': 'R',
    '\u1E5C': 'R',
    '\u0156': 'R',
    '\u1E5E': 'R',
    '\u024C': 'R',
    '\u2C64': 'R',
    '\uA75A': 'R',
    '\uA7A6': 'R',
    '\uA782': 'R',
    '\u24C8': 'S',
    '\uFF33': 'S',
    '\u1E9E': 'S',
    '\u015A': 'S',
    '\u1E64': 'S',
    '\u015C': 'S',
    '\u1E60': 'S',
    '\u0160': 'S',
    '\u1E66': 'S',
    '\u1E62': 'S',
    '\u1E68': 'S',
    '\u0218': 'S',
    '\u015E': 'S',
    '\u2C7E': 'S',
    '\uA7A8': 'S',
    '\uA784': 'S',
    '\u24C9': 'T',
    '\uFF34': 'T',
    '\u1E6A': 'T',
    '\u0164': 'T',
    '\u1E6C': 'T',
    '\u021A': 'T',
    '\u0162': 'T',
    '\u1E70': 'T',
    '\u1E6E': 'T',
    '\u0166': 'T',
    '\u01AC': 'T',
    '\u01AE': 'T',
    '\u023E': 'T',
    '\uA786': 'T',
    '\uA728': 'TZ',
    '\u24CA': 'U',
    '\uFF35': 'U',
    '\u00D9': 'U',
    '\u00DA': 'U',
    '\u00DB': 'U',
    '\u0168': 'U',
    '\u1E78': 'U',
    '\u016A': 'U',
    '\u1E7A': 'U',
    '\u016C': 'U',
    '\u00DC': 'U',
    '\u01DB': 'U',
    '\u01D7': 'U',
    '\u01D5': 'U',
    '\u01D9': 'U',
    '\u1EE6': 'U',
    '\u016E': 'U',
    '\u0170': 'U',
    '\u01D3': 'U',
    '\u0214': 'U',
    '\u0216': 'U',
    '\u01AF': 'U',
    '\u1EEA': 'U',
    '\u1EE8': 'U',
    '\u1EEE': 'U',
    '\u1EEC': 'U',
    '\u1EF0': 'U',
    '\u1EE4': 'U',
    '\u1E72': 'U',
    '\u0172': 'U',
    '\u1E76': 'U',
    '\u1E74': 'U',
    '\u0244': 'U',
    '\u24CB': 'V',
    '\uFF36': 'V',
    '\u1E7C': 'V',
    '\u1E7E': 'V',
    '\u01B2': 'V',
    '\uA75E': 'V',
    '\u0245': 'V',
    '\uA760': 'VY',
    '\u24CC': 'W',
    '\uFF37': 'W',
    '\u1E80': 'W',
    '\u1E82': 'W',
    '\u0174': 'W',
    '\u1E86': 'W',
    '\u1E84': 'W',
    '\u1E88': 'W',
    '\u2C72': 'W',
    '\u24CD': 'X',
    '\uFF38': 'X',
    '\u1E8A': 'X',
    '\u1E8C': 'X',
    '\u24CE': 'Y',
    '\uFF39': 'Y',
    '\u1EF2': 'Y',
    '\u00DD': 'Y',
    '\u0176': 'Y',
    '\u1EF8': 'Y',
    '\u0232': 'Y',
    '\u1E8E': 'Y',
    '\u0178': 'Y',
    '\u1EF6': 'Y',
    '\u1EF4': 'Y',
    '\u01B3': 'Y',
    '\u024E': 'Y',
    '\u1EFE': 'Y',
    '\u24CF': 'Z',
    '\uFF3A': 'Z',
    '\u0179': 'Z',
    '\u1E90': 'Z',
    '\u017B': 'Z',
    '\u017D': 'Z',
    '\u1E92': 'Z',
    '\u1E94': 'Z',
    '\u01B5': 'Z',
    '\u0224': 'Z',
    '\u2C7F': 'Z',
    '\u2C6B': 'Z',
    '\uA762': 'Z',
    '\u24D0': 'a',
    '\uFF41': 'a',
    '\u1E9A': 'a',
    '\u00E0': 'a',
    '\u00E1': 'a',
    '\u00E2': 'a',
    '\u1EA7': 'a',
    '\u1EA5': 'a',
    '\u1EAB': 'a',
    '\u1EA9': 'a',
    '\u00E3': 'a',
    '\u0101': 'a',
    '\u0103': 'a',
    '\u1EB1': 'a',
    '\u1EAF': 'a',
    '\u1EB5': 'a',
    '\u1EB3': 'a',
    '\u0227': 'a',
    '\u01E1': 'a',
    '\u00E4': 'a',
    '\u01DF': 'a',
    '\u1EA3': 'a',
    '\u00E5': 'a',
    '\u01FB': 'a',
    '\u01CE': 'a',
    '\u0201': 'a',
    '\u0203': 'a',
    '\u1EA1': 'a',
    '\u1EAD': 'a',
    '\u1EB7': 'a',
    '\u1E01': 'a',
    '\u0105': 'a',
    '\u2C65': 'a',
    '\u0250': 'a',
    '\uA733': 'aa',
    '\u00E6': 'ae',
    '\u01FD': 'ae',
    '\u01E3': 'ae',
    '\uA735': 'ao',
    '\uA737': 'au',
    '\uA739': 'av',
    '\uA73B': 'av',
    '\uA73D': 'ay',
    '\u24D1': 'b',
    '\uFF42': 'b',
    '\u1E03': 'b',
    '\u1E05': 'b',
    '\u1E07': 'b',
    '\u0180': 'b',
    '\u0183': 'b',
    '\u0253': 'b',
    '\u24D2': 'c',
    '\uFF43': 'c',
    '\u0107': 'c',
    '\u0109': 'c',
    '\u010B': 'c',
    '\u010D': 'c',
    '\u00E7': 'c',
    '\u1E09': 'c',
    '\u0188': 'c',
    '\u023C': 'c',
    '\uA73F': 'c',
    '\u2184': 'c',
    '\u24D3': 'd',
    '\uFF44': 'd',
    '\u1E0B': 'd',
    '\u010F': 'd',
    '\u1E0D': 'd',
    '\u1E11': 'd',
    '\u1E13': 'd',
    '\u1E0F': 'd',
    '\u0111': 'd',
    '\u018C': 'd',
    '\u0256': 'd',
    '\u0257': 'd',
    '\uA77A': 'd',
    '\u01F3': 'dz',
    '\u01C6': 'dz',
    '\u24D4': 'e',
    '\uFF45': 'e',
    '\u00E8': 'e',
    '\u00E9': 'e',
    '\u00EA': 'e',
    '\u1EC1': 'e',
    '\u1EBF': 'e',
    '\u1EC5': 'e',
    '\u1EC3': 'e',
    '\u1EBD': 'e',
    '\u0113': 'e',
    '\u1E15': 'e',
    '\u1E17': 'e',
    '\u0115': 'e',
    '\u0117': 'e',
    '\u00EB': 'e',
    '\u1EBB': 'e',
    '\u011B': 'e',
    '\u0205': 'e',
    '\u0207': 'e',
    '\u1EB9': 'e',
    '\u1EC7': 'e',
    '\u0229': 'e',
    '\u1E1D': 'e',
    '\u0119': 'e',
    '\u1E19': 'e',
    '\u1E1B': 'e',
    '\u0247': 'e',
    '\u025B': 'e',
    '\u01DD': 'e',
    '\u24D5': 'f',
    '\uFF46': 'f',
    '\u1E1F': 'f',
    '\u0192': 'f',
    '\uA77C': 'f',
    '\u24D6': 'g',
    '\uFF47': 'g',
    '\u01F5': 'g',
    '\u011D': 'g',
    '\u1E21': 'g',
    '\u011F': 'g',
    '\u0121': 'g',
    '\u01E7': 'g',
    '\u0123': 'g',
    '\u01E5': 'g',
    '\u0260': 'g',
    '\uA7A1': 'g',
    '\u1D79': 'g',
    '\uA77F': 'g',
    '\u24D7': 'h',
    '\uFF48': 'h',
    '\u0125': 'h',
    '\u1E23': 'h',
    '\u1E27': 'h',
    '\u021F': 'h',
    '\u1E25': 'h',
    '\u1E29': 'h',
    '\u1E2B': 'h',
    '\u1E96': 'h',
    '\u0127': 'h',
    '\u2C68': 'h',
    '\u2C76': 'h',
    '\u0265': 'h',
    '\u0195': 'hv',
    '\u24D8': 'i',
    '\uFF49': 'i',
    '\u00EC': 'i',
    '\u00ED': 'i',
    '\u00EE': 'i',
    '\u0129': 'i',
    '\u012B': 'i',
    '\u012D': 'i',
    '\u00EF': 'i',
    '\u1E2F': 'i',
    '\u1EC9': 'i',
    '\u01D0': 'i',
    '\u0209': 'i',
    '\u020B': 'i',
    '\u1ECB': 'i',
    '\u012F': 'i',
    '\u1E2D': 'i',
    '\u0268': 'i',
    '\u0131': 'i',
    '\u24D9': 'j',
    '\uFF4A': 'j',
    '\u0135': 'j',
    '\u01F0': 'j',
    '\u0249': 'j',
    '\u24DA': 'k',
    '\uFF4B': 'k',
    '\u1E31': 'k',
    '\u01E9': 'k',
    '\u1E33': 'k',
    '\u0137': 'k',
    '\u1E35': 'k',
    '\u0199': 'k',
    '\u2C6A': 'k',
    '\uA741': 'k',
    '\uA743': 'k',
    '\uA745': 'k',
    '\uA7A3': 'k',
    '\u24DB': 'l',
    '\uFF4C': 'l',
    '\u0140': 'l',
    '\u013A': 'l',
    '\u013E': 'l',
    '\u1E37': 'l',
    '\u1E39': 'l',
    '\u013C': 'l',
    '\u1E3D': 'l',
    '\u1E3B': 'l',
    '\u017F': 'l',
    '\u0142': 'l',
    '\u019A': 'l',
    '\u026B': 'l',
    '\u2C61': 'l',
    '\uA749': 'l',
    '\uA781': 'l',
    '\uA747': 'l',
    '\u01C9': 'lj',
    '\u24DC': 'm',
    '\uFF4D': 'm',
    '\u1E3F': 'm',
    '\u1E41': 'm',
    '\u1E43': 'm',
    '\u0271': 'm',
    '\u026F': 'm',
    '\u24DD': 'n',
    '\uFF4E': 'n',
    '\u01F9': 'n',
    '\u0144': 'n',
    '\u00F1': 'n',
    '\u1E45': 'n',
    '\u0148': 'n',
    '\u1E47': 'n',
    '\u0146': 'n',
    '\u1E4B': 'n',
    '\u1E49': 'n',
    '\u019E': 'n',
    '\u0272': 'n',
    '\u0149': 'n',
    '\uA791': 'n',
    '\uA7A5': 'n',
    '\u01CC': 'nj',
    '\u24DE': 'o',
    '\uFF4F': 'o',
    '\u00F2': 'o',
    '\u00F3': 'o',
    '\u00F4': 'o',
    '\u1ED3': 'o',
    '\u1ED1': 'o',
    '\u1ED7': 'o',
    '\u1ED5': 'o',
    '\u00F5': 'o',
    '\u1E4D': 'o',
    '\u022D': 'o',
    '\u1E4F': 'o',
    '\u014D': 'o',
    '\u1E51': 'o',
    '\u1E53': 'o',
    '\u014F': 'o',
    '\u022F': 'o',
    '\u0231': 'o',
    '\u00F6': 'o',
    '\u022B': 'o',
    '\u1ECF': 'o',
    '\u0151': 'o',
    '\u01D2': 'o',
    '\u020D': 'o',
    '\u020F': 'o',
    '\u01A1': 'o',
    '\u1EDD': 'o',
    '\u1EDB': 'o',
    '\u1EE1': 'o',
    '\u1EDF': 'o',
    '\u1EE3': 'o',
    '\u1ECD': 'o',
    '\u1ED9': 'o',
    '\u01EB': 'o',
    '\u01ED': 'o',
    '\u00F8': 'o',
    '\u01FF': 'o',
    '\u0254': 'o',
    '\uA74B': 'o',
    '\uA74D': 'o',
    '\u0275': 'o',
    '\u01A3': 'oi',
    '\u0223': 'ou',
    '\uA74F': 'oo',
    '\u24DF': 'p',
    '\uFF50': 'p',
    '\u1E55': 'p',
    '\u1E57': 'p',
    '\u01A5': 'p',
    '\u1D7D': 'p',
    '\uA751': 'p',
    '\uA753': 'p',
    '\uA755': 'p',
    '\u24E0': 'q',
    '\uFF51': 'q',
    '\u024B': 'q',
    '\uA757': 'q',
    '\uA759': 'q',
    '\u24E1': 'r',
    '\uFF52': 'r',
    '\u0155': 'r',
    '\u1E59': 'r',
    '\u0159': 'r',
    '\u0211': 'r',
    '\u0213': 'r',
    '\u1E5B': 'r',
    '\u1E5D': 'r',
    '\u0157': 'r',
    '\u1E5F': 'r',
    '\u024D': 'r',
    '\u027D': 'r',
    '\uA75B': 'r',
    '\uA7A7': 'r',
    '\uA783': 'r',
    '\u24E2': 's',
    '\uFF53': 's',
    '\u00DF': 's',
    '\u015B': 's',
    '\u1E65': 's',
    '\u015D': 's',
    '\u1E61': 's',
    '\u0161': 's',
    '\u1E67': 's',
    '\u1E63': 's',
    '\u1E69': 's',
    '\u0219': 's',
    '\u015F': 's',
    '\u023F': 's',
    '\uA7A9': 's',
    '\uA785': 's',
    '\u1E9B': 's',
    '\u24E3': 't',
    '\uFF54': 't',
    '\u1E6B': 't',
    '\u1E97': 't',
    '\u0165': 't',
    '\u1E6D': 't',
    '\u021B': 't',
    '\u0163': 't',
    '\u1E71': 't',
    '\u1E6F': 't',
    '\u0167': 't',
    '\u01AD': 't',
    '\u0288': 't',
    '\u2C66': 't',
    '\uA787': 't',
    '\uA729': 'tz',
    '\u24E4': 'u',
    '\uFF55': 'u',
    '\u00F9': 'u',
    '\u00FA': 'u',
    '\u00FB': 'u',
    '\u0169': 'u',
    '\u1E79': 'u',
    '\u016B': 'u',
    '\u1E7B': 'u',
    '\u016D': 'u',
    '\u00FC': 'u',
    '\u01DC': 'u',
    '\u01D8': 'u',
    '\u01D6': 'u',
    '\u01DA': 'u',
    '\u1EE7': 'u',
    '\u016F': 'u',
    '\u0171': 'u',
    '\u01D4': 'u',
    '\u0215': 'u',
    '\u0217': 'u',
    '\u01B0': 'u',
    '\u1EEB': 'u',
    '\u1EE9': 'u',
    '\u1EEF': 'u',
    '\u1EED': 'u',
    '\u1EF1': 'u',
    '\u1EE5': 'u',
    '\u1E73': 'u',
    '\u0173': 'u',
    '\u1E77': 'u',
    '\u1E75': 'u',
    '\u0289': 'u',
    '\u24E5': 'v',
    '\uFF56': 'v',
    '\u1E7D': 'v',
    '\u1E7F': 'v',
    '\u028B': 'v',
    '\uA75F': 'v',
    '\u028C': 'v',
    '\uA761': 'vy',
    '\u24E6': 'w',
    '\uFF57': 'w',
    '\u1E81': 'w',
    '\u1E83': 'w',
    '\u0175': 'w',
    '\u1E87': 'w',
    '\u1E85': 'w',
    '\u1E98': 'w',
    '\u1E89': 'w',
    '\u2C73': 'w',
    '\u24E7': 'x',
    '\uFF58': 'x',
    '\u1E8B': 'x',
    '\u1E8D': 'x',
    '\u24E8': 'y',
    '\uFF59': 'y',
    '\u1EF3': 'y',
    '\u00FD': 'y',
    '\u0177': 'y',
    '\u1EF9': 'y',
    '\u0233': 'y',
    '\u1E8F': 'y',
    '\u00FF': 'y',
    '\u1EF7': 'y',
    '\u1E99': 'y',
    '\u1EF5': 'y',
    '\u01B4': 'y',
    '\u024F': 'y',
    '\u1EFF': 'y',
    '\u24E9': 'z',
    '\uFF5A': 'z',
    '\u017A': 'z',
    '\u1E91': 'z',
    '\u017C': 'z',
    '\u017E': 'z',
    '\u1E93': 'z',
    '\u1E95': 'z',
    '\u01B6': 'z',
    '\u0225': 'z',
    '\u0240': 'z',
    '\u2C6C': 'z',
    '\uA763': 'z',
    '\u0386': '\u0391',
    '\u0388': '\u0395',
    '\u0389': '\u0397',
    '\u038A': '\u0399',
    '\u03AA': '\u0399',
    '\u038C': '\u039F',
    '\u038E': '\u03A5',
    '\u03AB': '\u03A5',
    '\u038F': '\u03A9',
    '\u03AC': '\u03B1',
    '\u03AD': '\u03B5',
    '\u03AE': '\u03B7',
    '\u03AF': '\u03B9',
    '\u03CA': '\u03B9',
    '\u0390': '\u03B9',
    '\u03CC': '\u03BF',
    '\u03CD': '\u03C5',
    '\u03CB': '\u03C5',
    '\u03B0': '\u03C5',
    '\u03C9': '\u03C9',
    '\u03C2': '\u03C3'
  };

  return diacritics;
});

S2.define('select2/data/base',[
  '../utils'
], function (Utils) {
  function BaseAdapter ($element, options) {
    BaseAdapter.__super__.constructor.call(this);
  }

  Utils.Extend(BaseAdapter, Utils.Observable);

  BaseAdapter.prototype.current = function (callback) {
    throw new Error('The `current` method must be defined in child classes.');
  };

  BaseAdapter.prototype.query = function (params, callback) {
    throw new Error('The `query` method must be defined in child classes.');
  };

  BaseAdapter.prototype.bind = function (container, $container) {
    // Can be implemented in subclasses
  };

  BaseAdapter.prototype.destroy = function () {
    // Can be implemented in subclasses
  };

  BaseAdapter.prototype.generateResultId = function (container, data) {
    var id = container.id + '-result-';

    id += Utils.generateChars(4);

    if (data.id != null) {
      id += '-' + data.id.toString();
    } else {
      id += '-' + Utils.generateChars(4);
    }
    return id;
  };

  return BaseAdapter;
});

S2.define('select2/data/select',[
  './base',
  '../utils',
  'jquery'
], function (BaseAdapter, Utils, $) {
  function SelectAdapter ($element, options) {
    this.$element = $element;
    this.options = options;

    SelectAdapter.__super__.constructor.call(this);
  }

  Utils.Extend(SelectAdapter, BaseAdapter);

  SelectAdapter.prototype.current = function (callback) {
    var data = [];
    var self = this;

    this.$element.find(':selected').each(function () {
      var $option = $(this);

      var option = self.item($option);

      data.push(option);
    });

    callback(data);
  };

  SelectAdapter.prototype.select = function (data) {
    var self = this;

    data.selected = true;

    // If data.element is a DOM node, use it instead
    if ($(data.element).is('option')) {
      data.element.selected = true;

      this.$element.trigger('change');

      return;
    }

    if (this.$element.prop('multiple')) {
      this.current(function (currentData) {
        var val = [];

        data = [data];
        data.push.apply(data, currentData);

        for (var d = 0; d < data.length; d++) {
          var id = data[d].id;

          if ($.inArray(id, val) === -1) {
            val.push(id);
          }
        }

        self.$element.val(val);
        self.$element.trigger('change');
      });
    } else {
      var val = data.id;

      this.$element.val(val);
      this.$element.trigger('change');
    }
  };

  SelectAdapter.prototype.unselect = function (data) {
    var self = this;

    if (!this.$element.prop('multiple')) {
      return;
    }

    data.selected = false;

    if ($(data.element).is('option')) {
      data.element.selected = false;

      this.$element.trigger('change');

      return;
    }

    this.current(function (currentData) {
      var val = [];

      for (var d = 0; d < currentData.length; d++) {
        var id = currentData[d].id;

        if (id !== data.id && $.inArray(id, val) === -1) {
          val.push(id);
        }
      }

      self.$element.val(val);

      self.$element.trigger('change');
    });
  };

  SelectAdapter.prototype.bind = function (container, $container) {
    var self = this;

    this.container = container;

    container.on('select', function (params) {
      self.select(params.data);
    });

    container.on('unselect', function (params) {
      self.unselect(params.data);
    });
  };

  SelectAdapter.prototype.destroy = function () {
    // Remove anything added to child elements
    this.$element.find('*').each(function () {
      // Remove any custom data set by Select2
      $.removeData(this, 'data');
    });
  };

  SelectAdapter.prototype.query = function (params, callback) {
    var data = [];
    var self = this;

    var $options = this.$element.children();

    $options.each(function () {
      var $option = $(this);

      if (!$option.is('option') && !$option.is('optgroup')) {
        return;
      }

      var option = self.item($option);

      var matches = self.matches(params, option);

      if (matches !== null) {
        data.push(matches);
      }
    });

    callback({
      results: data
    });
  };

  SelectAdapter.prototype.addOptions = function ($options) {
    Utils.appendMany(this.$element, $options);
  };

  SelectAdapter.prototype.option = function (data) {
    var option;

    if (data.children) {
      option = document.createElement('optgroup');
      option.label = data.text;
    } else {
      option = document.createElement('option');

      if (option.textContent !== undefined) {
        option.textContent = data.text;
      } else {
        option.innerText = data.text;
      }
    }

    if (data.id) {
      option.value = data.id;
    }

    if (data.disabled) {
      option.disabled = true;
    }

    if (data.selected) {
      option.selected = true;
    }

    if (data.title) {
      option.title = data.title;
    }

    var $option = $(option);

    var normalizedData = this._normalizeItem(data);
    normalizedData.element = option;

    // Override the option's data with the combined data
    $.data(option, 'data', normalizedData);

    return $option;
  };

  SelectAdapter.prototype.item = function ($option) {
    var data = {};

    data = $.data($option[0], 'data');

    if (data != null) {
      return data;
    }

    if ($option.is('option')) {
      data = {
        id: $option.val(),
        text: $option.text(),
        disabled: $option.prop('disabled'),
        selected: $option.prop('selected'),
        title: $option.prop('title')
      };
    } else if ($option.is('optgroup')) {
      data = {
        text: $option.prop('label'),
        children: [],
        title: $option.prop('title')
      };

      var $children = $option.children('option');
      var children = [];

      for (var c = 0; c < $children.length; c++) {
        var $child = $($children[c]);

        var child = this.item($child);

        children.push(child);
      }

      data.children = children;
    }

    data = this._normalizeItem(data);
    data.element = $option[0];

    $.data($option[0], 'data', data);

    return data;
  };

  SelectAdapter.prototype._normalizeItem = function (item) {
    if (!$.isPlainObject(item)) {
      item = {
        id: item,
        text: item
      };
    }

    item = $.extend({}, {
      text: ''
    }, item);

    var defaults = {
      selected: false,
      disabled: false
    };

    if (item.id != null) {
      item.id = item.id.toString();
    }

    if (item.text != null) {
      item.text = item.text.toString();
    }

    if (item._resultId == null && item.id && this.container != null) {
      item._resultId = this.generateResultId(this.container, item);
    }

    return $.extend({}, defaults, item);
  };

  SelectAdapter.prototype.matches = function (params, data) {
    var matcher = this.options.get('matcher');

    return matcher(params, data);
  };

  return SelectAdapter;
});

S2.define('select2/data/array',[
  './select',
  '../utils',
  'jquery'
], function (SelectAdapter, Utils, $) {
  function ArrayAdapter ($element, options) {
    var data = options.get('data') || [];

    ArrayAdapter.__super__.constructor.call(this, $element, options);

    this.addOptions(this.convertToOptions(data));
  }

  Utils.Extend(ArrayAdapter, SelectAdapter);

  ArrayAdapter.prototype.select = function (data) {
    var $option = this.$element.find('option').filter(function (i, elm) {
      return elm.value == data.id.toString();
    });

    if ($option.length === 0) {
      $option = this.option(data);

      this.addOptions($option);
    }

    ArrayAdapter.__super__.select.call(this, data);
  };

  ArrayAdapter.prototype.convertToOptions = function (data) {
    var self = this;

    var $existing = this.$element.find('option');
    var existingIds = $existing.map(function () {
      return self.item($(this)).id;
    }).get();

    var $options = [];

    // Filter out all items except for the one passed in the argument
    function onlyItem (item) {
      return function () {
        return $(this).val() == item.id;
      };
    }

    for (var d = 0; d < data.length; d++) {
      var item = this._normalizeItem(data[d]);

      // Skip items which were pre-loaded, only merge the data
      if ($.inArray(item.id, existingIds) >= 0) {
        var $existingOption = $existing.filter(onlyItem(item));

        var existingData = this.item($existingOption);
        var newData = $.extend(true, {}, item, existingData);

        var $newOption = this.option(newData);

        $existingOption.replaceWith($newOption);

        continue;
      }

      var $option = this.option(item);

      if (item.children) {
        var $children = this.convertToOptions(item.children);

        Utils.appendMany($option, $children);
      }

      $options.push($option);
    }

    return $options;
  };

  return ArrayAdapter;
});

S2.define('select2/data/ajax',[
  './array',
  '../utils',
  'jquery'
], function (ArrayAdapter, Utils, $) {
  function AjaxAdapter ($element, options) {
    this.ajaxOptions = this._applyDefaults(options.get('ajax'));

    if (this.ajaxOptions.processResults != null) {
      this.processResults = this.ajaxOptions.processResults;
    }

    AjaxAdapter.__super__.constructor.call(this, $element, options);
  }

  Utils.Extend(AjaxAdapter, ArrayAdapter);

  AjaxAdapter.prototype._applyDefaults = function (options) {
    var defaults = {
      data: function (params) {
        return $.extend({}, params, {
          q: params.term
        });
      },
      transport: function (params, success, failure) {
        var $request = $.ajax(params);

        $request.then(success);
        $request.fail(failure);

        return $request;
      }
    };

    return $.extend({}, defaults, options, true);
  };

  AjaxAdapter.prototype.processResults = function (results) {
    return results;
  };

  AjaxAdapter.prototype.query = function (params, callback) {
    var matches = [];
    var self = this;

    if (this._request != null) {
      // JSONP requests cannot always be aborted
      if ($.isFunction(this._request.abort)) {
        this._request.abort();
      }

      this._request = null;
    }

    var options = $.extend({
      type: 'GET'
    }, this.ajaxOptions);

    if (typeof options.url === 'function') {
      options.url = options.url.call(this.$element, params);
    }

    if (typeof options.data === 'function') {
      options.data = options.data.call(this.$element, params);
    }

    function request () {
      var $request = options.transport(options, function (data) {
        var results = self.processResults(data, params);

        if (self.options.get('debug') && window.console && console.error) {
          // Check to make sure that the response included a `results` key.
          if (!results || !results.results || !$.isArray(results.results)) {
            console.error(
              'Select2: The AJAX results did not return an array in the ' +
              '`results` key of the response.'
            );
          }
        }

        callback(results);
      }, function () {
        // Attempt to detect if a request was aborted
        // Only works if the transport exposes a status property
        if ($request.status && $request.status === '0') {
          return;
        }

        self.trigger('results:message', {
          message: 'errorLoading'
        });
      });

      self._request = $request;
    }

    if (this.ajaxOptions.delay && params.term != null) {
      if (this._queryTimeout) {
        window.clearTimeout(this._queryTimeout);
      }

      this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
    } else {
      request();
    }
  };

  return AjaxAdapter;
});

S2.define('select2/data/tags',[
  'jquery'
], function ($) {
  function Tags (decorated, $element, options) {
    var tags = options.get('tags');

    var createTag = options.get('createTag');

    if (createTag !== undefined) {
      this.createTag = createTag;
    }

    var insertTag = options.get('insertTag');

    if (insertTag !== undefined) {
        this.insertTag = insertTag;
    }

    decorated.call(this, $element, options);

    if ($.isArray(tags)) {
      for (var t = 0; t < tags.length; t++) {
        var tag = tags[t];
        var item = this._normalizeItem(tag);

        var $option = this.option(item);

        this.$element.append($option);
      }
    }
  }

  Tags.prototype.query = function (decorated, params, callback) {
    var self = this;

    this._removeOldTags();

    if (params.term == null || params.page != null) {
      decorated.call(this, params, callback);
      return;
    }

    function wrapper (obj, child) {
      var data = obj.results;

      for (var i = 0; i < data.length; i++) {
        var option = data[i];

        var checkChildren = (
          option.children != null &&
          !wrapper({
            results: option.children
          }, true)
        );

        var checkText = option.text === params.term;

        if (checkText || checkChildren) {
          if (child) {
            return false;
          }

          obj.data = data;
          callback(obj);

          return;
        }
      }

      if (child) {
        return true;
      }

      var tag = self.createTag(params);

      if (tag != null) {
        var $option = self.option(tag);
        $option.attr('data-select2-tag', true);

        self.addOptions([$option]);

        self.insertTag(data, tag);
      }

      obj.results = data;

      callback(obj);
    }

    decorated.call(this, params, wrapper);
  };

  Tags.prototype.createTag = function (decorated, params) {
    var term = $.trim(params.term);

    if (term === '') {
      return null;
    }

    return {
      id: term,
      text: term
    };
  };

  Tags.prototype.insertTag = function (_, data, tag) {
    data.unshift(tag);
  };

  Tags.prototype._removeOldTags = function (_) {
    var tag = this._lastTag;

    var $options = this.$element.find('option[data-select2-tag]');

    $options.each(function () {
      if (this.selected) {
        return;
      }

      $(this).remove();
    });
  };

  return Tags;
});

S2.define('select2/data/tokenizer',[
  'jquery'
], function ($) {
  function Tokenizer (decorated, $element, options) {
    var tokenizer = options.get('tokenizer');

    if (tokenizer !== undefined) {
      this.tokenizer = tokenizer;
    }

    decorated.call(this, $element, options);
  }

  Tokenizer.prototype.bind = function (decorated, container, $container) {
    decorated.call(this, container, $container);

    this.$search =  container.dropdown.$search || container.selection.$search ||
      $container.find('.select2-search__field');
  };

  Tokenizer.prototype.query = function (decorated, params, callback) {
    var self = this;

    function createAndSelect (data) {
      // Normalize the data object so we can use it for checks
      var item = self._normalizeItem(data);

      // Check if the data object already exists as a tag
      // Select it if it doesn't
      var $existingOptions = self.$element.find('option').filter(function () {
        return $(this).val() === item.id;
      });

      // If an existing option wasn't found for it, create the option
      if (!$existingOptions.length) {
        var $option = self.option(item);
        $option.attr('data-select2-tag', true);

        self._removeOldTags();
        self.addOptions([$option]);
      }

      // Select the item, now that we know there is an option for it
      select(item);
    }

    function select (data) {
      self.trigger('select', {
        data: data
      });
    }

    params.term = params.term || '';

    var tokenData = this.tokenizer(params, this.options, createAndSelect);

    if (tokenData.term !== params.term) {
      // Replace the search term if we have the search box
      if (this.$search.length) {
        this.$search.val(tokenData.term);
        this.$search.focus();
      }

      params.term = tokenData.term;
    }

    decorated.call(this, params, callback);
  };

  Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
    var separators = options.get('tokenSeparators') || [];
    var term = params.term;
    var i = 0;

    var createTag = this.createTag || function (params) {
      return {
        id: params.term,
        text: params.term
      };
    };

    while (i < term.length) {
      var termChar = term[i];

      if ($.inArray(termChar, separators) === -1) {
        i++;

        continue;
      }

      var part = term.substr(0, i);
      var partParams = $.extend({}, params, {
        term: part
      });

      var data = createTag(partParams);

      if (data == null) {
        i++;
        continue;
      }

      callback(data);

      // Reset the term to not include the tokenized portion
      term = term.substr(i + 1) || '';
      i = 0;
    }

    return {
      term: term
    };
  };

  return Tokenizer;
});

S2.define('select2/data/minimumInputLength',[

], function () {
  function MinimumInputLength (decorated, $e, options) {
    this.minimumInputLength = options.get('minimumInputLength');

    decorated.call(this, $e, options);
  }

  MinimumInputLength.prototype.query = function (decorated, params, callback) {
    params.term = params.term || '';

    if (params.term.length < this.minimumInputLength) {
      this.trigger('results:message', {
        message: 'inputTooShort',
        args: {
          minimum: this.minimumInputLength,
          input: params.term,
          params: params
        }
      });

      return;
    }

    decorated.call(this, params, callback);
  };

  return MinimumInputLength;
});

S2.define('select2/data/maximumInputLength',[

], function () {
  function MaximumInputLength (decorated, $e, options) {
    this.maximumInputLength = options.get('maximumInputLength');

    decorated.call(this, $e, options);
  }

  MaximumInputLength.prototype.query = function (decorated, params, callback) {
    params.term = params.term || '';

    if (this.maximumInputLength > 0 &&
        params.term.length > this.maximumInputLength) {
      this.trigger('results:message', {
        message: 'inputTooLong',
        args: {
          maximum: this.maximumInputLength,
          input: params.term,
          params: params
        }
      });

      return;
    }

    decorated.call(this, params, callback);
  };

  return MaximumInputLength;
});

S2.define('select2/data/maximumSelectionLength',[

], function (){
  function MaximumSelectionLength (decorated, $e, options) {
    this.maximumSelectionLength = options.get('maximumSelectionLength');

    decorated.call(this, $e, options);
  }

  MaximumSelectionLength.prototype.query =
    function (decorated, params, callback) {
      var self = this;

      this.current(function (currentData) {
        var count = currentData != null ? currentData.length : 0;
        if (self.maximumSelectionLength > 0 &&
          count >= self.maximumSelectionLength) {
          self.trigger('results:message', {
            message: 'maximumSelected',
            args: {
              maximum: self.maximumSelectionLength
            }
          });
          return;
        }
        decorated.call(self, params, callback);
      });
  };

  return MaximumSelectionLength;
});

S2.define('select2/dropdown',[
  'jquery',
  './utils'
], function ($, Utils) {
  function Dropdown ($element, options) {
    this.$element = $element;
    this.options = options;

    Dropdown.__super__.constructor.call(this);
  }

  Utils.Extend(Dropdown, Utils.Observable);

  Dropdown.prototype.render = function () {
    var $dropdown = $(
      '<span class="select2-dropdown">' +
        '<span class="select2-results"></span>' +
      '</span>'
    );

    $dropdown.attr('dir', this.options.get('dir'));

    this.$dropdown = $dropdown;

    return $dropdown;
  };

  Dropdown.prototype.bind = function () {
    // Should be implemented in subclasses
  };

  Dropdown.prototype.position = function ($dropdown, $container) {
    // Should be implmented in subclasses
  };

  Dropdown.prototype.destroy = function () {
    // Remove the dropdown from the DOM
    this.$dropdown.remove();
  };

  return Dropdown;
});

S2.define('select2/dropdown/search',[
  'jquery',
  '../utils'
], function ($, Utils) {
  function Search () { }

  Search.prototype.render = function (decorated) {
    var $rendered = decorated.call(this);

    var $search = $(
      '<span class="select2-search select2-search--dropdown">' +
        '<input class="select2-search__field" type="search" tabindex="-1"' +
        ' autocomplete="off" autocorrect="off" autocapitalize="off"' +
        ' spellcheck="false" role="textbox" />' +
      '</span>'
    );

    this.$searchContainer = $search;
    this.$search = $search.find('input');

    $rendered.prepend($search);

    return $rendered;
  };

  Search.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    this.$search.on('keydown', function (evt) {
      self.trigger('keypress', evt);

      self._keyUpPrevented = evt.isDefaultPrevented();
    });

    // Workaround for browsers which do not support the `input` event
    // This will prevent double-triggering of events for browsers which support
    // both the `keyup` and `input` events.
    this.$search.on('input', function (evt) {
      // Unbind the duplicated `keyup` event
      $(this).off('keyup');
    });

    this.$search.on('keyup input', function (evt) {
      self.handleSearch(evt);
    });

    container.on('open', function () {
      self.$search.attr('tabindex', 0);

      self.$search.focus();

      window.setTimeout(function () {
        self.$search.focus();
      }, 0);
    });

    container.on('close', function () {
      self.$search.attr('tabindex', -1);

      self.$search.val('');
    });

    container.on('focus', function () {
      if (container.isOpen()) {
        self.$search.focus();
      }
    });

    container.on('results:all', function (params) {
      if (params.query.term == null || params.query.term === '') {
        var showSearch = self.showSearch(params);

        if (showSearch) {
          self.$searchContainer.removeClass('select2-search--hide');
        } else {
          self.$searchContainer.addClass('select2-search--hide');
        }
      }
    });
  };

  Search.prototype.handleSearch = function (evt) {
    if (!this._keyUpPrevented) {
      var input = this.$search.val();

      this.trigger('query', {
        term: input
      });
    }

    this._keyUpPrevented = false;
  };

  Search.prototype.showSearch = function (_, params) {
    return true;
  };

  return Search;
});

S2.define('select2/dropdown/hidePlaceholder',[

], function () {
  function HidePlaceholder (decorated, $element, options, dataAdapter) {
    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

    decorated.call(this, $element, options, dataAdapter);
  }

  HidePlaceholder.prototype.append = function (decorated, data) {
    data.results = this.removePlaceholder(data.results);

    decorated.call(this, data);
  };

  HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
    if (typeof placeholder === 'string') {
      placeholder = {
        id: '',
        text: placeholder
      };
    }

    return placeholder;
  };

  HidePlaceholder.prototype.removePlaceholder = function (_, data) {
    var modifiedData = data.slice(0);

    for (var d = data.length - 1; d >= 0; d--) {
      var item = data[d];

      if (this.placeholder.id === item.id) {
        modifiedData.splice(d, 1);
      }
    }

    return modifiedData;
  };

  return HidePlaceholder;
});

S2.define('select2/dropdown/infiniteScroll',[
  'jquery'
], function ($) {
  function InfiniteScroll (decorated, $element, options, dataAdapter) {
    this.lastParams = {};

    decorated.call(this, $element, options, dataAdapter);

    this.$loadingMore = this.createLoadingMore();
    this.loading = false;
  }

  InfiniteScroll.prototype.append = function (decorated, data) {
    this.$loadingMore.remove();
    this.loading = false;

    decorated.call(this, data);

    if (this.showLoadingMore(data)) {
      this.$results.append(this.$loadingMore);
    }
  };

  InfiniteScroll.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('query', function (params) {
      self.lastParams = params;
      self.loading = true;
    });

    container.on('query:append', function (params) {
      self.lastParams = params;
      self.loading = true;
    });

    this.$results.on('scroll', function () {
      var isLoadMoreVisible = $.contains(
        document.documentElement,
        self.$loadingMore[0]
      );

      if (self.loading || !isLoadMoreVisible) {
        return;
      }

      var currentOffset = self.$results.offset().top +
        self.$results.outerHeight(false);
      var loadingMoreOffset = self.$loadingMore.offset().top +
        self.$loadingMore.outerHeight(false);

      if (currentOffset + 50 >= loadingMoreOffset) {
        self.loadMore();
      }
    });
  };

  InfiniteScroll.prototype.loadMore = function () {
    this.loading = true;

    var params = $.extend({}, {page: 1}, this.lastParams);

    params.page++;

    this.trigger('query:append', params);
  };

  InfiniteScroll.prototype.showLoadingMore = function (_, data) {
    return data.pagination && data.pagination.more;
  };

  InfiniteScroll.prototype.createLoadingMore = function () {
    var $option = $(
      '<li ' +
      'class="select2-results__option select2-results__option--load-more"' +
      'role="treeitem" aria-disabled="true"></li>'
    );

    var message = this.options.get('translations').get('loadingMore');

    $option.html(message(this.lastParams));

    return $option;
  };

  return InfiniteScroll;
});

S2.define('select2/dropdown/attachBody',[
  'jquery',
  '../utils'
], function ($, Utils) {
  function AttachBody (decorated, $element, options) {
    this.$dropdownParent = options.get('dropdownParent') || $(document.body);

    decorated.call(this, $element, options);
  }

  AttachBody.prototype.bind = function (decorated, container, $container) {
    var self = this;

    var setupResultsEvents = false;

    decorated.call(this, container, $container);

    container.on('open', function () {
      self._showDropdown();
      self._attachPositioningHandler(container);

      if (!setupResultsEvents) {
        setupResultsEvents = true;

        container.on('results:all', function () {
          self._positionDropdown();
          self._resizeDropdown();
        });

        container.on('results:append', function () {
          self._positionDropdown();
          self._resizeDropdown();
        });
      }
    });

    container.on('close', function () {
      self._hideDropdown();
      self._detachPositioningHandler(container);
    });

    this.$dropdownContainer.on('mousedown', function (evt) {
      evt.stopPropagation();
    });
  };

  AttachBody.prototype.destroy = function (decorated) {
    decorated.call(this);

    this.$dropdownContainer.remove();
  };

  AttachBody.prototype.position = function (decorated, $dropdown, $container) {
    // Clone all of the container classes
    $dropdown.attr('class', $container.attr('class'));

    $dropdown.removeClass('select2');
    $dropdown.addClass('select2-container--open');

    $dropdown.css({
      position: 'absolute',
      top: -999999
    });

    this.$container = $container;
  };

  AttachBody.prototype.render = function (decorated) {
    var $container = $('<span></span>');

    var $dropdown = decorated.call(this);
    $container.append($dropdown);

    this.$dropdownContainer = $container;

    return $container;
  };

  AttachBody.prototype._hideDropdown = function (decorated) {
    this.$dropdownContainer.detach();
  };

  AttachBody.prototype._attachPositioningHandler =
      function (decorated, container) {
    var self = this;

    var scrollEvent = 'scroll.select2.' + container.id;
    var resizeEvent = 'resize.select2.' + container.id;
    var orientationEvent = 'orientationchange.select2.' + container.id;

    var $watchers = this.$container.parents().filter(Utils.hasScroll);
    $watchers.each(function () {
      $(this).data('select2-scroll-position', {
        x: $(this).scrollLeft(),
        y: $(this).scrollTop()
      });
    });

    $watchers.on(scrollEvent, function (ev) {
      var position = $(this).data('select2-scroll-position');
      $(this).scrollTop(position.y);
    });

    $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,
      function (e) {
      self._positionDropdown();
      self._resizeDropdown();
    });
  };

  AttachBody.prototype._detachPositioningHandler =
      function (decorated, container) {
    var scrollEvent = 'scroll.select2.' + container.id;
    var resizeEvent = 'resize.select2.' + container.id;
    var orientationEvent = 'orientationchange.select2.' + container.id;

    var $watchers = this.$container.parents().filter(Utils.hasScroll);
    $watchers.off(scrollEvent);

    $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
  };

  AttachBody.prototype._positionDropdown = function () {
    var $window = $(window);

    var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');
    var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');

    var newDirection = null;

    var offset = this.$container.offset();

    offset.bottom = offset.top + this.$container.outerHeight(false);

    var container = {
      height: this.$container.outerHeight(false)
    };

    container.top = offset.top;
    container.bottom = offset.top + container.height;

    var dropdown = {
      height: this.$dropdown.outerHeight(false)
    };

    var viewport = {
      top: $window.scrollTop(),
      bottom: $window.scrollTop() + $window.height()
    };

    var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);
    var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);

    var css = {
      left: offset.left,
      top: container.bottom
    };

    // Determine what the parent element is to use for calciulating the offset
    var $offsetParent = this.$dropdownParent;

    // For statically positoned elements, we need to get the element
    // that is determining the offset
    if ($offsetParent.css('position') === 'static') {
      $offsetParent = $offsetParent.offsetParent();
    }

    var parentOffset = $offsetParent.offset();

    css.top -= parentOffset.top;
    css.left -= parentOffset.left;

    if (!isCurrentlyAbove && !isCurrentlyBelow) {
      newDirection = 'below';
    }

    if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
      newDirection = 'above';
    } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
      newDirection = 'below';
    }

    if (newDirection == 'above' ||
      (isCurrentlyAbove && newDirection !== 'below')) {
      css.top = container.top - parentOffset.top - dropdown.height;
    }

    if (newDirection != null) {
      this.$dropdown
        .removeClass('select2-dropdown--below select2-dropdown--above')
        .addClass('select2-dropdown--' + newDirection);
      this.$container
        .removeClass('select2-container--below select2-container--above')
        .addClass('select2-container--' + newDirection);
    }

    this.$dropdownContainer.css(css);
  };

  AttachBody.prototype._resizeDropdown = function () {
    var css = {
      width: this.$container.outerWidth(false) + 'px'
    };

    if (this.options.get('dropdownAutoWidth')) {
      css.minWidth = css.width;
      css.position = 'relative';
      css.width = 'auto';
    }

    this.$dropdown.css(css);
  };

  AttachBody.prototype._showDropdown = function (decorated) {
    this.$dropdownContainer.appendTo(this.$dropdownParent);

    this._positionDropdown();
    this._resizeDropdown();
  };

  return AttachBody;
});

S2.define('select2/dropdown/minimumResultsForSearch',[

], function () {
  function countResults (data) {
    var count = 0;

    for (var d = 0; d < data.length; d++) {
      var item = data[d];

      if (item.children) {
        count += countResults(item.children);
      } else {
        count++;
      }
    }

    return count;
  }

  function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {
    this.minimumResultsForSearch = options.get('minimumResultsForSearch');

    if (this.minimumResultsForSearch < 0) {
      this.minimumResultsForSearch = Infinity;
    }

    decorated.call(this, $element, options, dataAdapter);
  }

  MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
    if (countResults(params.data.results) < this.minimumResultsForSearch) {
      return false;
    }

    return decorated.call(this, params);
  };

  return MinimumResultsForSearch;
});

S2.define('select2/dropdown/selectOnClose',[

], function () {
  function SelectOnClose () { }

  SelectOnClose.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('close', function (params) {
      self._handleSelectOnClose(params);
    });
  };

  SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
    if (params && params.originalSelect2Event != null) {
      var event = params.originalSelect2Event;

      // Don't select an item if the close event was triggered from a select or
      // unselect event
      if (event._type === 'select' || event._type === 'unselect') {
        return;
      }
    }

    var $highlightedResults = this.getHighlightedResults();

    // Only select highlighted results
    if ($highlightedResults.length < 1) {
      return;
    }

    var data = $highlightedResults.data('data');

    // Don't re-select already selected resulte
    if (
      (data.element != null && data.element.selected) ||
      (data.element == null && data.selected)
    ) {
      return;
    }

    this.trigger('select', {
        data: data
    });
  };

  return SelectOnClose;
});

S2.define('select2/dropdown/closeOnSelect',[

], function () {
  function CloseOnSelect () { }

  CloseOnSelect.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('select', function (evt) {
      self._selectTriggered(evt);
    });

    container.on('unselect', function (evt) {
      self._selectTriggered(evt);
    });
  };

  CloseOnSelect.prototype._selectTriggered = function (_, evt) {
    var originalEvent = evt.originalEvent;

    // Don't close if the control key is being held
    if (originalEvent && originalEvent.ctrlKey) {
      return;
    }

    this.trigger('close', {
      originalEvent: originalEvent,
      originalSelect2Event: evt
    });
  };

  return CloseOnSelect;
});

S2.define('select2/i18n/en',[],function () {
  // English
  return {
    errorLoading: function () {
      return 'The results could not be loaded.';
    },
    inputTooLong: function (args) {
      var overChars = args.input.length - args.maximum;

      var message = 'Please delete ' + overChars + ' character';

      if (overChars != 1) {
        message += 's';
      }

      return message;
    },
    inputTooShort: function (args) {
      var remainingChars = args.minimum - args.input.length;

      var message = 'Please enter ' + remainingChars + ' or more characters';

      return message;
    },
    loadingMore: function () {
      return 'Loading more results';
    },
    maximumSelected: function (args) {
      var message = 'You can only select ' + args.maximum + ' item';

      if (args.maximum != 1) {
        message += 's';
      }

      return message;
    },
    noResults: function () {
      return 'No results found';
    },
    searching: function () {
      return 'Searching';
    }
  };
});

S2.define('select2/defaults',[
  'jquery',
  'require',

  './results',

  './selection/single',
  './selection/multiple',
  './selection/placeholder',
  './selection/allowClear',
  './selection/search',
  './selection/eventRelay',

  './utils',
  './translation',
  './diacritics',

  './data/select',
  './data/array',
  './data/ajax',
  './data/tags',
  './data/tokenizer',
  './data/minimumInputLength',
  './data/maximumInputLength',
  './data/maximumSelectionLength',

  './dropdown',
  './dropdown/search',
  './dropdown/hidePlaceholder',
  './dropdown/infiniteScroll',
  './dropdown/attachBody',
  './dropdown/minimumResultsForSearch',
  './dropdown/selectOnClose',
  './dropdown/closeOnSelect',

  './i18n/en'
], function ($, require,

             ResultsList,

             SingleSelection, MultipleSelection, Placeholder, AllowClear,
             SelectionSearch, EventRelay,

             Utils, Translation, DIACRITICS,

             SelectData, ArrayData, AjaxData, Tags, Tokenizer,
             MinimumInputLength, MaximumInputLength, MaximumSelectionLength,

             Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,
             AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,

             EnglishTranslation) {
  function Defaults () {
    this.reset();
  }

  Defaults.prototype.apply = function (options) {
    options = $.extend(true, {}, this.defaults, options);

    if (options.dataAdapter == null) {
      if (options.ajax != null) {
        options.dataAdapter = AjaxData;
      } else if (options.data != null) {
        options.dataAdapter = ArrayData;
      } else {
        options.dataAdapter = SelectData;
      }

      if (options.minimumInputLength > 0) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          MinimumInputLength
        );
      }

      if (options.maximumInputLength > 0) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          MaximumInputLength
        );
      }

      if (options.maximumSelectionLength > 0) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          MaximumSelectionLength
        );
      }

      if (options.tags) {
        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
      }

      if (options.tokenSeparators != null || options.tokenizer != null) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          Tokenizer
        );
      }

      if (options.query != null) {
        var Query = require(options.amdBase + 'compat/query');

        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          Query
        );
      }

      if (options.initSelection != null) {
        var InitSelection = require(options.amdBase + 'compat/initSelection');

        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          InitSelection
        );
      }
    }

    if (options.resultsAdapter == null) {
      options.resultsAdapter = ResultsList;

      if (options.ajax != null) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          InfiniteScroll
        );
      }

      if (options.placeholder != null) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          HidePlaceholder
        );
      }

      if (options.selectOnClose) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          SelectOnClose
        );
      }
    }

    if (options.dropdownAdapter == null) {
      if (options.multiple) {
        options.dropdownAdapter = Dropdown;
      } else {
        var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);

        options.dropdownAdapter = SearchableDropdown;
      }

      if (options.minimumResultsForSearch !== 0) {
        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          MinimumResultsForSearch
        );
      }

      if (options.closeOnSelect) {
        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          CloseOnSelect
        );
      }

      if (
        options.dropdownCssClass != null ||
        options.dropdownCss != null ||
        options.adaptDropdownCssClass != null
      ) {
        var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');

        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          DropdownCSS
        );
      }

      options.dropdownAdapter = Utils.Decorate(
        options.dropdownAdapter,
        AttachBody
      );
    }

    if (options.selectionAdapter == null) {
      if (options.multiple) {
        options.selectionAdapter = MultipleSelection;
      } else {
        options.selectionAdapter = SingleSelection;
      }

      // Add the placeholder mixin if a placeholder was specified
      if (options.placeholder != null) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          Placeholder
        );
      }

      if (options.allowClear) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          AllowClear
        );
      }

      if (options.multiple) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          SelectionSearch
        );
      }

      if (
        options.containerCssClass != null ||
        options.containerCss != null ||
        options.adaptContainerCssClass != null
      ) {
        var ContainerCSS = require(options.amdBase + 'compat/containerCss');

        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          ContainerCSS
        );
      }

      options.selectionAdapter = Utils.Decorate(
        options.selectionAdapter,
        EventRelay
      );
    }

    if (typeof options.language === 'string') {
      // Check if the language is specified with a region
      if (options.language.indexOf('-') > 0) {
        // Extract the region information if it is included
        var languageParts = options.language.split('-');
        var baseLanguage = languageParts[0];

        options.language = [options.language, baseLanguage];
      } else {
        options.language = [options.language];
      }
    }

    if ($.isArray(options.language)) {
      var languages = new Translation();
      options.language.push('en');

      var languageNames = options.language;

      for (var l = 0; l < languageNames.length; l++) {
        var name = languageNames[l];
        var language = {};

        try {
          // Try to load it with the original name
          language = Translation.loadPath(name);
        } catch (e) {
          try {
            // If we couldn't load it, check if it wasn't the full path
            name = this.defaults.amdLanguageBase + name;
            language = Translation.loadPath(name);
          } catch (ex) {
            // The translation could not be loaded at all. Sometimes this is
            // because of a configuration problem, other times this can be
            // because of how Select2 helps load all possible translation files.
            if (options.debug && window.console && console.warn) {
              console.warn(
                'Select2: The language file for "' + name + '" could not be ' +
                'automatically loaded. A fallback will be used instead.'
              );
            }

            continue;
          }
        }

        languages.extend(language);
      }

      options.translations = languages;
    } else {
      var baseTranslation = Translation.loadPath(
        this.defaults.amdLanguageBase + 'en'
      );
      var customTranslation = new Translation(options.language);

      customTranslation.extend(baseTranslation);

      options.translations = customTranslation;
    }

    return options;
  };

  Defaults.prototype.reset = function () {
    function stripDiacritics (text) {
      // Used 'uni range + named function' from http://jsperf.com/diacritics/18
      function match(a) {
        return DIACRITICS[a] || a;
      }

      return text.replace(/[^\u0000-\u007E]/g, match);
    }

    function matcher (params, data) {
      // Always return the object if there is nothing to compare
      if ($.trim(params.term) === '') {
        return data;
      }

      // Do a recursive check for options with children
      if (data.children && data.children.length > 0) {
        // Clone the data object if there are children
        // This is required as we modify the object to remove any non-matches
        var match = $.extend(true, {}, data);

        // Check each child of the option
        for (var c = data.children.length - 1; c >= 0; c--) {
          var child = data.children[c];

          var matches = matcher(params, child);

          // If there wasn't a match, remove the object in the array
          if (matches == null) {
            match.children.splice(c, 1);
          }
        }

        // If any children matched, return the new object
        if (match.children.length > 0) {
          return match;
        }

        // If there were no matching children, check just the plain object
        return matcher(params, match);
      }

      var original = stripDiacritics(data.text).toUpperCase();
      var term = stripDiacritics(params.term).toUpperCase();

      // Check if the text contains the term
      if (original.indexOf(term) > -1) {
        return data;
      }

      // If it doesn't contain the term, don't return anything
      return null;
    }

    this.defaults = {
      amdBase: './',
      amdLanguageBase: './i18n/',
      closeOnSelect: true,
      debug: false,
      dropdownAutoWidth: false,
      escapeMarkup: Utils.escapeMarkup,
      language: EnglishTranslation,
      matcher: matcher,
      minimumInputLength: 0,
      maximumInputLength: 0,
      maximumSelectionLength: 0,
      minimumResultsForSearch: 0,
      selectOnClose: false,
      sorter: function (data) {
        return data;
      },
      templateResult: function (result) {
        return result.text;
      },
      templateSelection: function (selection) {
        return selection.text;
      },
      theme: 'default',
      width: 'resolve'
    };
  };

  Defaults.prototype.set = function (key, value) {
    var camelKey = $.camelCase(key);

    var data = {};
    data[camelKey] = value;

    var convertedData = Utils._convertData(data);

    $.extend(this.defaults, convertedData);
  };

  var defaults = new Defaults();

  return defaults;
});

S2.define('select2/options',[
  'require',
  'jquery',
  './defaults',
  './utils'
], function (require, $, Defaults, Utils) {
  function Options (options, $element) {
    this.options = options;

    if ($element != null) {
      this.fromElement($element);
    }

    this.options = Defaults.apply(this.options);

    if ($element && $element.is('input')) {
      var InputCompat = require(this.get('amdBase') + 'compat/inputData');

      this.options.dataAdapter = Utils.Decorate(
        this.options.dataAdapter,
        InputCompat
      );
    }
  }

  Options.prototype.fromElement = function ($e) {
    var excludedData = ['select2'];

    if (this.options.multiple == null) {
      this.options.multiple = $e.prop('multiple');
    }

    if (this.options.disabled == null) {
      this.options.disabled = $e.prop('disabled');
    }

    if (this.options.language == null) {
      if ($e.prop('lang')) {
        this.options.language = $e.prop('lang').toLowerCase();
      } else if ($e.closest('[lang]').prop('lang')) {
        this.options.language = $e.closest('[lang]').prop('lang');
      }
    }

    if (this.options.dir == null) {
      if ($e.prop('dir')) {
        this.options.dir = $e.prop('dir');
      } else if ($e.closest('[dir]').prop('dir')) {
        this.options.dir = $e.closest('[dir]').prop('dir');
      } else {
        this.options.dir = 'ltr';
      }
    }

    $e.prop('disabled', this.options.disabled);
    $e.prop('multiple', this.options.multiple);

    if ($e.data('select2Tags')) {
      if (this.options.debug && window.console && console.warn) {
        console.warn(
          'Select2: The `data-select2-tags` attribute has been changed to ' +
          'use the `data-data` and `data-tags="true"` attributes and will be ' +
          'removed in future versions of Select2.'
        );
      }

      $e.data('data', $e.data('select2Tags'));
      $e.data('tags', true);
    }

    if ($e.data('ajaxUrl')) {
      if (this.options.debug && window.console && console.warn) {
        console.warn(
          'Select2: The `data-ajax-url` attribute has been changed to ' +
          '`data-ajax--url` and support for the old attribute will be removed' +
          ' in future versions of Select2.'
        );
      }

      $e.attr('ajax--url', $e.data('ajaxUrl'));
      $e.data('ajax--url', $e.data('ajaxUrl'));
    }

    var dataset = {};

    // Prefer the element's `dataset` attribute if it exists
    // jQuery 1.x does not correctly handle data attributes with multiple dashes
    if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
      dataset = $.extend(true, {}, $e[0].dataset, $e.data());
    } else {
      dataset = $e.data();
    }

    var data = $.extend(true, {}, dataset);

    data = Utils._convertData(data);

    for (var key in data) {
      if ($.inArray(key, excludedData) > -1) {
        continue;
      }

      if ($.isPlainObject(this.options[key])) {
        $.extend(this.options[key], data[key]);
      } else {
        this.options[key] = data[key];
      }
    }

    return this;
  };

  Options.prototype.get = function (key) {
    return this.options[key];
  };

  Options.prototype.set = function (key, val) {
    this.options[key] = val;
  };

  return Options;
});

S2.define('select2/core',[
  'jquery',
  './options',
  './utils',
  './keys'
], function ($, Options, Utils, KEYS) {
  var Select2 = function ($element, options) {
    if ($element.data('select2') != null) {
      $element.data('select2').destroy();
    }

    this.$element = $element;

    this.id = this._generateId($element);

    options = options || {};

    this.options = new Options(options, $element);

    Select2.__super__.constructor.call(this);

    // Set up the tabindex

    var tabindex = $element.attr('tabindex') || 0;
    $element.data('old-tabindex', tabindex);
    $element.attr('tabindex', '-1');

    // Set up containers and adapters

    var DataAdapter = this.options.get('dataAdapter');
    this.dataAdapter = new DataAdapter($element, this.options);

    var $container = this.render();

    this._placeContainer($container);

    var SelectionAdapter = this.options.get('selectionAdapter');
    this.selection = new SelectionAdapter($element, this.options);
    this.$selection = this.selection.render();

    this.selection.position(this.$selection, $container);

    var DropdownAdapter = this.options.get('dropdownAdapter');
    this.dropdown = new DropdownAdapter($element, this.options);
    this.$dropdown = this.dropdown.render();

    this.dropdown.position(this.$dropdown, $container);

    var ResultsAdapter = this.options.get('resultsAdapter');
    this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
    this.$results = this.results.render();

    this.results.position(this.$results, this.$dropdown);

    // Bind events

    var self = this;

    // Bind the container to all of the adapters
    this._bindAdapters();

    // Register any DOM event handlers
    this._registerDomEvents();

    // Register any internal event handlers
    this._registerDataEvents();
    this._registerSelectionEvents();
    this._registerDropdownEvents();
    this._registerResultsEvents();
    this._registerEvents();

    // Set the initial state
    this.dataAdapter.current(function (initialData) {
      self.trigger('selection:update', {
        data: initialData
      });
    });

    // Hide the original select
    $element.addClass('select2-hidden-accessible');
    $element.attr('aria-hidden', 'true');

    // Synchronize any monitored attributes
    this._syncAttributes();

    $element.data('select2', this);
  };

  Utils.Extend(Select2, Utils.Observable);

  Select2.prototype._generateId = function ($element) {
    var id = '';

    if ($element.attr('id') != null) {
      id = $element.attr('id');
    } else if ($element.attr('name') != null) {
      id = $element.attr('name') + '-' + Utils.generateChars(2);
    } else {
      id = Utils.generateChars(4);
    }

    id = id.replace(/(:|\.|\[|\]|,)/g, '');
    id = 'select2-' + id;

    return id;
  };

  Select2.prototype._placeContainer = function ($container) {
    $container.insertAfter(this.$element);

    var width = this._resolveWidth(this.$element, this.options.get('width'));

    if (width != null) {
      $container.css('width', '100%');
    }
  };

  Select2.prototype._resolveWidth = function ($element, method) {
    var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;

    if (method == 'resolve') {
      var styleWidth = this._resolveWidth($element, 'style');

      if (styleWidth != null) {
        return styleWidth;
      }

      return this._resolveWidth($element, 'element');
    }

    if (method == 'element') {
      var elementWidth = $element.outerWidth(false);

      if (elementWidth <= 0) {
        return 'auto';
      }

      return elementWidth + 'px';
    }

    if (method == 'style') {
      var style = $element.attr('style');

      if (typeof(style) !== 'string') {
        return null;
      }

      var attrs = style.split(';');

      for (var i = 0, l = attrs.length; i < l; i = i + 1) {
        var attr = attrs[i].replace(/\s/g, '');
        var matches = attr.match(WIDTH);

        if (matches !== null && matches.length >= 1) {
          return matches[1];
        }
      }

      return null;
    }

    return method;
  };

  Select2.prototype._bindAdapters = function () {
    this.dataAdapter.bind(this, this.$container);
    this.selection.bind(this, this.$container);

    this.dropdown.bind(this, this.$container);
    this.results.bind(this, this.$container);
  };

  Select2.prototype._registerDomEvents = function () {
    var self = this;

    this.$element.on('change.select2', function () {
      self.dataAdapter.current(function (data) {
        self.trigger('selection:update', {
          data: data
        });
      });
    });

    this.$element.on('focus.select2', function (evt) {
      self.trigger('focus', evt);
    });

    this._syncA = Utils.bind(this._syncAttributes, this);
    this._syncS = Utils.bind(this._syncSubtree, this);

    if (this.$element[0].attachEvent) {
      this.$element[0].attachEvent('onpropertychange', this._syncA);
    }

    var observer = window.MutationObserver ||
      window.WebKitMutationObserver ||
      window.MozMutationObserver
    ;

    if (observer != null) {
      this._observer = new observer(function (mutations) {
        $.each(mutations, self._syncA);
        $.each(mutations, self._syncS);
      });
      this._observer.observe(this.$element[0], {
        attributes: true,
        childList: true,
        subtree: false
      });
    } else if (this.$element[0].addEventListener) {
      this.$element[0].addEventListener(
        'DOMAttrModified',
        self._syncA,
        false
      );
      this.$element[0].addEventListener(
        'DOMNodeInserted',
        self._syncS,
        false
      );
      this.$element[0].addEventListener(
        'DOMNodeRemoved',
        self._syncS,
        false
      );
    }
  };

  Select2.prototype._registerDataEvents = function () {
    var self = this;

    this.dataAdapter.on('*', function (name, params) {
      self.trigger(name, params);
    });
  };

  Select2.prototype._registerSelectionEvents = function () {
    var self = this;
    var nonRelayEvents = ['toggle', 'focus'];

    this.selection.on('toggle', function () {
      self.toggleDropdown();
    });

    this.selection.on('focus', function (params) {
      self.focus(params);
    });

    this.selection.on('*', function (name, params) {
      if ($.inArray(name, nonRelayEvents) !== -1) {
        return;
      }

      self.trigger(name, params);
    });
  };

  Select2.prototype._registerDropdownEvents = function () {
    var self = this;

    this.dropdown.on('*', function (name, params) {
      self.trigger(name, params);
    });
  };

  Select2.prototype._registerResultsEvents = function () {
    var self = this;

    this.results.on('*', function (name, params) {
      self.trigger(name, params);
    });
  };

  Select2.prototype._registerEvents = function () {
    var self = this;

    this.on('open', function () {
      self.$container.addClass('select2-container--open');
    });

    this.on('close', function () {
      self.$container.removeClass('select2-container--open');
    });

    this.on('enable', function () {
      self.$container.removeClass('select2-container--disabled');
    });

    this.on('disable', function () {
      self.$container.addClass('select2-container--disabled');
    });

    this.on('blur', function () {
      self.$container.removeClass('select2-container--focus');
    });

    this.on('query', function (params) {
      if (!self.isOpen()) {
        self.trigger('open', {});
      }

      this.dataAdapter.query(params, function (data) {
        self.trigger('results:all', {
          data: data,
          query: params
        });
      });
    });

    this.on('query:append', function (params) {
      this.dataAdapter.query(params, function (data) {
        self.trigger('results:append', {
          data: data,
          query: params
        });
      });
    });

    this.on('keypress', function (evt) {
      var key = evt.which;

      if (self.isOpen()) {
        if (key === KEYS.ESC || key === KEYS.TAB ||
            (key === KEYS.UP && evt.altKey)) {
          self.close();

          evt.preventDefault();
        } else if (key === KEYS.ENTER) {
          self.trigger('results:select', {});

          evt.preventDefault();
        } else if ((key === KEYS.SPACE && evt.ctrlKey)) {
          self.trigger('results:toggle', {});

          evt.preventDefault();
        } else if (key === KEYS.UP) {
          self.trigger('results:previous', {});

          evt.preventDefault();
        } else if (key === KEYS.DOWN) {
          self.trigger('results:next', {});

          evt.preventDefault();
        }
      } else {
        if (key === KEYS.ENTER || key === KEYS.SPACE ||
            (key === KEYS.DOWN && evt.altKey)) {
          self.open();

          evt.preventDefault();
        }
      }
    });
  };

  Select2.prototype._syncAttributes = function () {
    this.options.set('disabled', this.$element.prop('disabled'));

    if (this.options.get('disabled')) {
      if (this.isOpen()) {
        this.close();
      }

      this.trigger('disable', {});
    } else {
      this.trigger('enable', {});
    }
  };

  Select2.prototype._syncSubtree = function (evt, mutations) {
    var changed = false;
    var self = this;

    // Ignore any mutation events raised for elements that aren't options or
    // optgroups. This handles the case when the select element is destroyed
    if (
      evt && evt.target && (
        evt.target.nodeName !== 'OPTION' && evt.target.nodeName !== 'OPTGROUP'
      )
    ) {
      return;
    }

    if (!mutations) {
      // If mutation events aren't supported, then we can only assume that the
      // change affected the selections
      changed = true;
    } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
      for (var n = 0; n < mutations.addedNodes.length; n++) {
        var node = mutations.addedNodes[n];

        if (node.selected) {
          changed = true;
        }
      }
    } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
      changed = true;
    }

    // Only re-pull the data if we think there is a change
    if (changed) {
      this.dataAdapter.current(function (currentData) {
        self.trigger('selection:update', {
          data: currentData
        });
      });
    }
  };

  /**
   * Override the trigger method to automatically trigger pre-events when
   * there are events that can be prevented.
   */
  Select2.prototype.trigger = function (name, args) {
    var actualTrigger = Select2.__super__.trigger;
    var preTriggerMap = {
      'open': 'opening',
      'close': 'closing',
      'select': 'selecting',
      'unselect': 'unselecting'
    };

    if (args === undefined) {
      args = {};
    }

    if (name in preTriggerMap) {
      var preTriggerName = preTriggerMap[name];
      var preTriggerArgs = {
        prevented: false,
        name: name,
        args: args
      };

      actualTrigger.call(this, preTriggerName, preTriggerArgs);

      if (preTriggerArgs.prevented) {
        args.prevented = true;

        return;
      }
    }

    actualTrigger.call(this, name, args);
  };

  Select2.prototype.toggleDropdown = function () {
    if (this.options.get('disabled')) {
      return;
    }

    if (this.isOpen()) {
      this.close();
    } else {
      this.open();
    }
  };

  Select2.prototype.open = function () {
    if (this.isOpen()) {
      return;
    }

    this.trigger('query', {});
  };

  Select2.prototype.close = function () {
    if (!this.isOpen()) {
      return;
    }

    this.trigger('close', {});
  };

  Select2.prototype.isOpen = function () {
    return this.$container.hasClass('select2-container--open');
  };

  Select2.prototype.hasFocus = function () {
    return this.$container.hasClass('select2-container--focus');
  };

  Select2.prototype.focus = function (data) {
    // No need to re-trigger focus events if we are already focused
    if (this.hasFocus()) {
      return;
    }

    this.$container.addClass('select2-container--focus');
    this.trigger('focus', {});
  };

  Select2.prototype.enable = function (args) {
    if (this.options.get('debug') && window.console && console.warn) {
      console.warn(
        'Select2: The `select2("enable")` method has been deprecated and will' +
        ' be removed in later Select2 versions. Use $element.prop("disabled")' +
        ' instead.'
      );
    }

    if (args == null || args.length === 0) {
      args = [true];
    }

    var disabled = !args[0];

    this.$element.prop('disabled', disabled);
  };

  Select2.prototype.data = function () {
    if (this.options.get('debug') &&
        arguments.length > 0 && window.console && console.warn) {
      console.warn(
        'Select2: Data can no longer be set using `select2("data")`. You ' +
        'should consider setting the value instead using `$element.val()`.'
      );
    }

    var data = [];

    this.dataAdapter.current(function (currentData) {
      data = currentData;
    });

    return data;
  };

  Select2.prototype.val = function (args) {
    if (this.options.get('debug') && window.console && console.warn) {
      console.warn(
        'Select2: The `select2("val")` method has been deprecated and will be' +
        ' removed in later Select2 versions. Use $element.val() instead.'
      );
    }

    if (args == null || args.length === 0) {
      return this.$element.val();
    }

    var newVal = args[0];

    if ($.isArray(newVal)) {
      newVal = $.map(newVal, function (obj) {
        return obj.toString();
      });
    }

    this.$element.val(newVal).trigger('change');
  };

  Select2.prototype.destroy = function () {
    this.$container.remove();

    if (this.$element[0].detachEvent) {
      this.$element[0].detachEvent('onpropertychange', this._syncA);
    }

    if (this._observer != null) {
      this._observer.disconnect();
      this._observer = null;
    } else if (this.$element[0].removeEventListener) {
      this.$element[0]
        .removeEventListener('DOMAttrModified', this._syncA, false);
      this.$element[0]
        .removeEventListener('DOMNodeInserted', this._syncS, false);
      this.$element[0]
        .removeEventListener('DOMNodeRemoved', this._syncS, false);
    }

    this._syncA = null;
    this._syncS = null;

    this.$element.off('.select2');
    this.$element.attr('tabindex', this.$element.data('old-tabindex'));

    this.$element.removeClass('select2-hidden-accessible');
    this.$element.attr('aria-hidden', 'false');
    this.$element.removeData('select2');

    this.dataAdapter.destroy();
    this.selection.destroy();
    this.dropdown.destroy();
    this.results.destroy();

    this.dataAdapter = null;
    this.selection = null;
    this.dropdown = null;
    this.results = null;
  };

  Select2.prototype.render = function () {
    var $container = $(
      '<span class="select2 select2-container">' +
        '<span class="selection"></span>' +
        '<span class="dropdown-wrapper" aria-hidden="true"></span>' +
      '</span>'
    );

    $container.attr('dir', this.options.get('dir'));

    this.$container = $container;

    this.$container.addClass('select2-container--' + this.options.get('theme'));

    $container.data('element', this.$element);

    return $container;
  };

  return Select2;
});

S2.define('select2/compat/utils',[
  'jquery'
], function ($) {
  function syncCssClasses ($dest, $src, adapter) {
    var classes, replacements = [], adapted;

    classes = $.trim($dest.attr('class'));

    if (classes) {
      classes = '' + classes; // for IE which returns object

      $(classes.split(/\s+/)).each(function () {
        // Save all Select2 classes
        if (this.indexOf('select2-') === 0) {
          replacements.push(this);
        }
      });
    }

    classes = $.trim($src.attr('class'));

    if (classes) {
      classes = '' + classes; // for IE which returns object

      $(classes.split(/\s+/)).each(function () {
        // Only adapt non-Select2 classes
        if (this.indexOf('select2-') !== 0) {
          adapted = adapter(this);

          if (adapted != null) {
            replacements.push(adapted);
          }
        }
      });
    }

    $dest.attr('class', replacements.join(' '));
  }

  return {
    syncCssClasses: syncCssClasses
  };
});

S2.define('select2/compat/containerCss',[
  'jquery',
  './utils'
], function ($, CompatUtils) {
  // No-op CSS adapter that discards all classes by default
  function _containerAdapter (clazz) {
    return null;
  }

  function ContainerCSS () { }

  ContainerCSS.prototype.render = function (decorated) {
    var $container = decorated.call(this);

    var containerCssClass = this.options.get('containerCssClass') || '';

    if ($.isFunction(containerCssClass)) {
      containerCssClass = containerCssClass(this.$element);
    }

    var containerCssAdapter = this.options.get('adaptContainerCssClass');
    containerCssAdapter = containerCssAdapter || _containerAdapter;

    if (containerCssClass.indexOf(':all:') !== -1) {
      containerCssClass = containerCssClass.replace(':all:', '');

      var _cssAdapter = containerCssAdapter;

      containerCssAdapter = function (clazz) {
        var adapted = _cssAdapter(clazz);

        if (adapted != null) {
          // Append the old one along with the adapted one
          return adapted + ' ' + clazz;
        }

        return clazz;
      };
    }

    var containerCss = this.options.get('containerCss') || {};

    if ($.isFunction(containerCss)) {
      containerCss = containerCss(this.$element);
    }

    CompatUtils.syncCssClasses($container, this.$element, containerCssAdapter);

    $container.css(containerCss);
    $container.addClass(containerCssClass);

    return $container;
  };

  return ContainerCSS;
});

S2.define('select2/compat/dropdownCss',[
  'jquery',
  './utils'
], function ($, CompatUtils) {
  // No-op CSS adapter that discards all classes by default
  function _dropdownAdapter (clazz) {
    return null;
  }

  function DropdownCSS () { }

  DropdownCSS.prototype.render = function (decorated) {
    var $dropdown = decorated.call(this);

    var dropdownCssClass = this.options.get('dropdownCssClass') || '';

    if ($.isFunction(dropdownCssClass)) {
      dropdownCssClass = dropdownCssClass(this.$element);
    }

    var dropdownCssAdapter = this.options.get('adaptDropdownCssClass');
    dropdownCssAdapter = dropdownCssAdapter || _dropdownAdapter;

    if (dropdownCssClass.indexOf(':all:') !== -1) {
      dropdownCssClass = dropdownCssClass.replace(':all:', '');

      var _cssAdapter = dropdownCssAdapter;

      dropdownCssAdapter = function (clazz) {
        var adapted = _cssAdapter(clazz);

        if (adapted != null) {
          // Append the old one along with the adapted one
          return adapted + ' ' + clazz;
        }

        return clazz;
      };
    }

    var dropdownCss = this.options.get('dropdownCss') || {};

    if ($.isFunction(dropdownCss)) {
      dropdownCss = dropdownCss(this.$element);
    }

    CompatUtils.syncCssClasses($dropdown, this.$element, dropdownCssAdapter);

    $dropdown.css(dropdownCss);
    $dropdown.addClass(dropdownCssClass);

    return $dropdown;
  };

  return DropdownCSS;
});

S2.define('select2/compat/initSelection',[
  'jquery'
], function ($) {
  function InitSelection (decorated, $element, options) {
    if (options.get('debug') && window.console && console.warn) {
      console.warn(
        'Select2: The `initSelection` option has been deprecated in favor' +
        ' of a custom data adapter that overrides the `current` method. ' +
        'This method is now called multiple times instead of a single ' +
        'time when the instance is initialized. Support will be removed ' +
        'for the `initSelection` option in future versions of Select2'
      );
    }

    this.initSelection = options.get('initSelection');
    this._isInitialized = false;

    decorated.call(this, $element, options);
  }

  InitSelection.prototype.current = function (decorated, callback) {
    var self = this;

    if (this._isInitialized) {
      decorated.call(this, callback);

      return;
    }

    this.initSelection.call(null, this.$element, function (data) {
      self._isInitialized = true;

      if (!$.isArray(data)) {
        data = [data];
      }

      callback(data);
    });
  };

  return InitSelection;
});

S2.define('select2/compat/inputData',[
  'jquery'
], function ($) {
  function InputData (decorated, $element, options) {
    this._currentData = [];
    this._valueSeparator = options.get('valueSeparator') || ',';

    if ($element.prop('type') === 'hidden') {
      if (options.get('debug') && console && console.warn) {
        console.warn(
          'Select2: Using a hidden input with Select2 is no longer ' +
          'supported and may stop working in the future. It is recommended ' +
          'to use a `<select>` element instead.'
        );
      }
    }

    decorated.call(this, $element, options);
  }

  InputData.prototype.current = function (_, callback) {
    function getSelected (data, selectedIds) {
      var selected = [];

      if (data.selected || $.inArray(data.id, selectedIds) !== -1) {
        data.selected = true;
        selected.push(data);
      } else {
        data.selected = false;
      }

      if (data.children) {
        selected.push.apply(selected, getSelected(data.children, selectedIds));
      }

      return selected;
    }

    var selected = [];

    for (var d = 0; d < this._currentData.length; d++) {
      var data = this._currentData[d];

      selected.push.apply(
        selected,
        getSelected(
          data,
          this.$element.val().split(
            this._valueSeparator
          )
        )
      );
    }

    callback(selected);
  };

  InputData.prototype.select = function (_, data) {
    if (!this.options.get('multiple')) {
      this.current(function (allData) {
        $.map(allData, function (data) {
          data.selected = false;
        });
      });

      this.$element.val(data.id);
      this.$element.trigger('change');
    } else {
      var value = this.$element.val();
      value += this._valueSeparator + data.id;

      this.$element.val(value);
      this.$element.trigger('change');
    }
  };

  InputData.prototype.unselect = function (_, data) {
    var self = this;

    data.selected = false;

    this.current(function (allData) {
      var values = [];

      for (var d = 0; d < allData.length; d++) {
        var item = allData[d];

        if (data.id == item.id) {
          continue;
        }

        values.push(item.id);
      }

      self.$element.val(values.join(self._valueSeparator));
      self.$element.trigger('change');
    });
  };

  InputData.prototype.query = function (_, params, callback) {
    var results = [];

    for (var d = 0; d < this._currentData.length; d++) {
      var data = this._currentData[d];

      var matches = this.matches(params, data);

      if (matches !== null) {
        results.push(matches);
      }
    }

    callback({
      results: results
    });
  };

  InputData.prototype.addOptions = function (_, $options) {
    var options = $.map($options, function ($option) {
      return $.data($option[0], 'data');
    });

    this._currentData.push.apply(this._currentData, options);
  };

  return InputData;
});

S2.define('select2/compat/matcher',[
  'jquery'
], function ($) {
  function oldMatcher (matcher) {
    function wrappedMatcher (params, data) {
      var match = $.extend(true, {}, data);

      if (params.term == null || $.trim(params.term) === '') {
        return match;
      }

      if (data.children) {
        for (var c = data.children.length - 1; c >= 0; c--) {
          var child = data.children[c];

          // Check if the child object matches
          // The old matcher returned a boolean true or false
          var doesMatch = matcher(params.term, child.text, child);

          // If the child didn't match, pop it off
          if (!doesMatch) {
            match.children.splice(c, 1);
          }
        }

        if (match.children.length > 0) {
          return match;
        }
      }

      if (matcher(params.term, data.text, data)) {
        return match;
      }

      return null;
    }

    return wrappedMatcher;
  }

  return oldMatcher;
});

S2.define('select2/compat/query',[

], function () {
  function Query (decorated, $element, options) {
    if (options.get('debug') && window.console && console.warn) {
      console.warn(
        'Select2: The `query` option has been deprecated in favor of a ' +
        'custom data adapter that overrides the `query` method. Support ' +
        'will be removed for the `query` option in future versions of ' +
        'Select2.'
      );
    }

    decorated.call(this, $element, options);
  }

  Query.prototype.query = function (_, params, callback) {
    params.callback = callback;

    var query = this.options.get('query');

    query.call(null, params);
  };

  return Query;
});

S2.define('select2/dropdown/attachContainer',[

], function () {
  function AttachContainer (decorated, $element, options) {
    decorated.call(this, $element, options);
  }

  AttachContainer.prototype.position =
    function (decorated, $dropdown, $container) {
    var $dropdownContainer = $container.find('.dropdown-wrapper');
    $dropdownContainer.append($dropdown);

    $dropdown.addClass('select2-dropdown--below');
    $container.addClass('select2-container--below');
  };

  return AttachContainer;
});

S2.define('select2/dropdown/stopPropagation',[

], function () {
  function StopPropagation () { }

  StopPropagation.prototype.bind = function (decorated, container, $container) {
    decorated.call(this, container, $container);

    var stoppedEvents = [
    'blur',
    'change',
    'click',
    'dblclick',
    'focus',
    'focusin',
    'focusout',
    'input',
    'keydown',
    'keyup',
    'keypress',
    'mousedown',
    'mouseenter',
    'mouseleave',
    'mousemove',
    'mouseover',
    'mouseup',
    'search',
    'touchend',
    'touchstart'
    ];

    this.$dropdown.on(stoppedEvents.join(' '), function (evt) {
      evt.stopPropagation();
    });
  };

  return StopPropagation;
});

S2.define('select2/selection/stopPropagation',[

], function () {
  function StopPropagation () { }

  StopPropagation.prototype.bind = function (decorated, container, $container) {
    decorated.call(this, container, $container);

    var stoppedEvents = [
      'blur',
      'change',
      'click',
      'dblclick',
      'focus',
      'focusin',
      'focusout',
      'input',
      'keydown',
      'keyup',
      'keypress',
      'mousedown',
      'mouseenter',
      'mouseleave',
      'mousemove',
      'mouseover',
      'mouseup',
      'search',
      'touchend',
      'touchstart'
    ];

    this.$selection.on(stoppedEvents.join(' '), function (evt) {
      evt.stopPropagation();
    });
  };

  return StopPropagation;
});

/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */

(function (factory) {
    if ( typeof S2.define === 'function' && S2.define.amd ) {
        // AMD. Register as an anonymous module.
        S2.define('jquery-mousewheel',['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

S2.define('jquery.select2',[
  'jquery',
  'jquery-mousewheel',

  './select2/core',
  './select2/defaults'
], function ($, _, Select2, Defaults) {
  if ($.fn.select2 == null) {
    // All methods that should return the element
    var thisMethods = ['open', 'close', 'destroy'];

    $.fn.select2 = function (options) {
      options = options || {};

      if (typeof options === 'object') {
        this.each(function () {
          var instanceOptions = $.extend(true, {}, options);

          var instance = new Select2($(this), instanceOptions);
        });

        return this;
      } else if (typeof options === 'string') {
        var ret;
        var args = Array.prototype.slice.call(arguments, 1);

        this.each(function () {
          var instance = $(this).data('select2');

          if (instance == null && window.console && console.error) {
            console.error(
              'The select2(\'' + options + '\') method was called on an ' +
              'element that is not using Select2.'
            );
          }

          ret = instance[options].apply(instance, args);
        });

        // Check if we should be returning `this`
        if ($.inArray(options, thisMethods) > -1) {
          return this;
        }

        return ret;
      } else {
        throw new Error('Invalid arguments for Select2: ' + options);
      }
    };
  }

  if ($.fn.select2.defaults == null) {
    $.fn.select2.defaults = Defaults;
  }

  return Select2;
});

  // Return the AMD loader configuration so it can be used outside of this file
  return {
    define: S2.define,
    require: S2.require
  };
}());

  // Autoload the jQuery bindings
  // We know that all of the modules exist above this, so we're safe
  var select2 = S2.require('jquery.select2');

  // Hold the AMD module references on the jQuery function that was just loaded
  // This allows Select2 to use the internal loader outside of this file, such
  // as in the language files.
  jQuery.fn.select2.amd = S2;

  // Return the Select2 instance for anyone who is importing it.
  return select2;
}));

/**
 * simplemde v1.11.2
 * Copyright Next Step Webs, Inc.
 * @link https://github.com/NextStepWebs/simplemde-markdown-editor
 * @license MIT
 */
!function (e) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else {
        var t;
        t = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, t.SimpleMDE = e()
    }
}(function () {
    var e;
    return function t(e, n, r) {
        function i(a, l) {
            if (!n[a]) {
                if (!e[a]) {
                    var s = "function" == typeof require && require;
                    if (!l && s)return s(a, !0);
                    if (o)return o(a, !0);
                    var c = new Error("Cannot find module '" + a + "'");
                    throw c.code = "MODULE_NOT_FOUND", c
                }
                var u = n[a] = {exports: {}};
                e[a][0].call(u.exports, function (t) {
                    var n = e[a][1][t];
                    return i(n ? n : t)
                }, u, u.exports, t, e, n, r)
            }
            return n[a].exports
        }

        for (var o = "function" == typeof require && require, a = 0; a < r.length; a++)i(r[a]);
        return i
    }({
        1: [function (e, t, n) {
            "use strict";
            function r() {
                for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0,
                         n = e.length; n > t; ++t)s[t] = e[t], c[e.charCodeAt(t)] = t;
                c["-".charCodeAt(0)] = 62, c["_".charCodeAt(0)] = 63
            }

            function i(e) {
                var t, n, r, i, o, a, l = e.length;
                if (l % 4 > 0)throw new Error("Invalid string. Length must be a multiple of 4");
                o = "=" === e[l - 2] ? 2 : "=" === e[l - 1] ? 1 : 0, a = new u(3 * l / 4 - o), r = o > 0 ? l - 4 : l;
                var s = 0;
                for (t = 0, n = 0; r > t; t += 4, n += 3)i = c[e.charCodeAt(t)] << 18 | c[e.charCodeAt(t + 1)] << 12 | c[e.charCodeAt(t + 2)] << 6 | c[e.charCodeAt(t + 3)], a[s++] = i >> 16 & 255, a[s++] = i >> 8 & 255, a[s++] = 255 & i;
                return 2 === o ? (i = c[e.charCodeAt(t)] << 2 | c[e.charCodeAt(t + 1)] >> 4, a[s++] = 255 & i) : 1 === o && (i = c[e.charCodeAt(t)] << 10 | c[e.charCodeAt(t + 1)] << 4 | c[e.charCodeAt(t + 2)] >> 2, a[s++] = i >> 8 & 255, a[s++] = 255 & i), a
            }

            function o(e) {
                return s[e >> 18 & 63] + s[e >> 12 & 63] + s[e >> 6 & 63] + s[63 & e]
            }

            function a(e, t, n) {
                for (var r, i = [], a = t; n > a; a += 3)r = (e[a] << 16) + (e[a + 1] << 8) + e[a + 2], i.push(o(r));
                return i.join("")
            }

            function l(e) {
                for (var t, n = e.length, r = n % 3, i = "", o = [], l = 16383, c = 0,
                         u = n - r; u > c; c += l)o.push(a(e, c, c + l > u ? u : c + l));
                return 1 === r ? (t = e[n - 1], i += s[t >> 2], i += s[t << 4 & 63], i += "==") : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], i += s[t >> 10], i += s[t >> 4 & 63], i += s[t << 2 & 63], i += "="), o.push(i), o.join("")
            }

            n.toByteArray = i, n.fromByteArray = l;
            var s = [], c = [], u = "undefined" != typeof Uint8Array ? Uint8Array : Array;
            r()
        }, {}],
        2: [function (e, t, n) {
        }, {}],
        3: [function (e, t, n) {
            (function (t) {
                "use strict";
                function r() {
                    try {
                        var e = new Uint8Array(1);
                        return e.foo = function () {
                            return 42
                        }, 42 === e.foo() && "function" == typeof e.subarray && 0 === e.subarray(1, 1).byteLength
                    } catch (t) {
                        return !1
                    }
                }

                function i() {
                    return a.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
                }

                function o(e, t) {
                    if (i() < t)throw new RangeError("Invalid typed array length");
                    return a.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t), e.__proto__ = a.prototype) : (null === e && (e = new a(t)), e.length = t), e
                }

                function a(e, t, n) {
                    if (!(a.TYPED_ARRAY_SUPPORT || this instanceof a))return new a(e, t, n);
                    if ("number" == typeof e) {
                        if ("string" == typeof t)throw new Error("If encoding is specified then the first argument must be a string");
                        return u(this, e)
                    }
                    return l(this, e, t, n)
                }

                function l(e, t, n, r) {
                    if ("number" == typeof t)throw new TypeError('"value" argument must not be a number');
                    return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? d(e, t, n, r) : "string" == typeof t ? f(e, t, n) : p(e, t)
                }

                function s(e) {
                    if ("number" != typeof e)throw new TypeError('"size" argument must be a number')
                }

                function c(e, t, n, r) {
                    return s(t), 0 >= t ? o(e, t) : void 0 !== n ? "string" == typeof r ? o(e, t).fill(n, r) : o(e, t).fill(n) : o(e, t)
                }

                function u(e, t) {
                    if (s(t), e = o(e, 0 > t ? 0 : 0 | m(t)), !a.TYPED_ARRAY_SUPPORT)for (var n = 0; t > n; n++)e[n] = 0;
                    return e
                }

                function f(e, t, n) {
                    if ("string" == typeof n && "" !== n || (n = "utf8"), !a.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');
                    var r = 0 | v(t, n);
                    return e = o(e, r), e.write(t, n), e
                }

                function h(e, t) {
                    var n = 0 | m(t.length);
                    e = o(e, n);
                    for (var r = 0; n > r; r += 1)e[r] = 255 & t[r];
                    return e
                }

                function d(e, t, n, r) {
                    if (t.byteLength, 0 > n || t.byteLength < n)throw new RangeError("'offset' is out of bounds");
                    if (t.byteLength < n + (r || 0))throw new RangeError("'length' is out of bounds");
                    return t = void 0 === r ? new Uint8Array(t, n) : new Uint8Array(t, n, r), a.TYPED_ARRAY_SUPPORT ? (e = t, e.__proto__ = a.prototype) : e = h(e, t), e
                }

                function p(e, t) {
                    if (a.isBuffer(t)) {
                        var n = 0 | m(t.length);
                        return e = o(e, n), 0 === e.length ? e : (t.copy(e, 0, 0, n), e)
                    }
                    if (t) {
                        if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t)return "number" != typeof t.length || K(t.length) ? o(e, 0) : h(e, t);
                        if ("Buffer" === t.type && J(t.data))return h(e, t.data)
                    }
                    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
                }

                function m(e) {
                    if (e >= i())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i().toString(16) + " bytes");
                    return 0 | e
                }

                function g(e) {
                    return +e != e && (e = 0), a.alloc(+e)
                }

                function v(e, t) {
                    if (a.isBuffer(e))return e.length;
                    if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer))return e.byteLength;
                    "string" != typeof e && (e = "" + e);
                    var n = e.length;
                    if (0 === n)return 0;
                    for (var r = !1; ;)switch (t) {
                        case"ascii":
                        case"binary":
                        case"raw":
                        case"raws":
                            return n;
                        case"utf8":
                        case"utf-8":
                        case void 0:
                            return q(e).length;
                        case"ucs2":
                        case"ucs-2":
                        case"utf16le":
                        case"utf-16le":
                            return 2 * n;
                        case"hex":
                            return n >>> 1;
                        case"base64":
                            return $(e).length;
                        default:
                            if (r)return q(e).length;
                            t = ("" + t).toLowerCase(), r = !0
                    }
                }

                function y(e, t, n) {
                    var r = !1;
                    if ((void 0 === t || 0 > t) && (t = 0), t > this.length)return "";
                    if ((void 0 === n || n > this.length) && (n = this.length), 0 >= n)return "";
                    if (n >>>= 0, t >>>= 0, t >= n)return "";
                    for (e || (e = "utf8"); ;)switch (e) {
                        case"hex":
                            return I(this, t, n);
                        case"utf8":
                        case"utf-8":
                            return N(this, t, n);
                        case"ascii":
                            return E(this, t, n);
                        case"binary":
                            return O(this, t, n);
                        case"base64":
                            return M(this, t, n);
                        case"ucs2":
                        case"ucs-2":
                        case"utf16le":
                        case"utf-16le":
                            return P(this, t, n);
                        default:
                            if (r)throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase(), r = !0
                    }
                }

                function x(e, t, n) {
                    var r = e[t];
                    e[t] = e[n], e[n] = r
                }

                function b(e, t, n, r) {
                    function i(e, t) {
                        return 1 === o ? e[t] : e.readUInt16BE(t * o)
                    }

                    var o = 1, a = e.length, l = t.length;
                    if (void 0 !== r && (r = String(r).toLowerCase(), "ucs2" === r || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                        if (e.length < 2 || t.length < 2)return -1;
                        o = 2, a /= 2, l /= 2, n /= 2
                    }
                    for (var s = -1, c = 0; a > n + c; c++)if (i(e, n + c) === i(t, -1 === s ? 0 : c - s)) {
                        if (-1 === s && (s = c), c - s + 1 === l)return (n + s) * o
                    } else-1 !== s && (c -= c - s), s = -1;
                    return -1
                }

                function w(e, t, n, r) {
                    n = Number(n) || 0;
                    var i = e.length - n;
                    r ? (r = Number(r), r > i && (r = i)) : r = i;
                    var o = t.length;
                    if (o % 2 !== 0)throw new Error("Invalid hex string");
                    r > o / 2 && (r = o / 2);
                    for (var a = 0; r > a; a++) {
                        var l = parseInt(t.substr(2 * a, 2), 16);
                        if (isNaN(l))return a;
                        e[n + a] = l
                    }
                    return a
                }

                function k(e, t, n, r) {
                    return V(q(t, e.length - n), e, n, r)
                }

                function S(e, t, n, r) {
                    return V(G(t), e, n, r)
                }

                function C(e, t, n, r) {
                    return S(e, t, n, r)
                }

                function L(e, t, n, r) {
                    return V($(t), e, n, r)
                }

                function T(e, t, n, r) {
                    return V(Y(t, e.length - n), e, n, r)
                }

                function M(e, t, n) {
                    return 0 === t && n === e.length ? X.fromByteArray(e) : X.fromByteArray(e.slice(t, n))
                }

                function N(e, t, n) {
                    n = Math.min(e.length, n);
                    for (var r = [], i = t; n > i;) {
                        var o = e[i], a = null, l = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
                        if (n >= i + l) {
                            var s, c, u, f;
                            switch (l) {
                                case 1:
                                    128 > o && (a = o);
                                    break;
                                case 2:
                                    s = e[i + 1], 128 === (192 & s) && (f = (31 & o) << 6 | 63 & s, f > 127 && (a = f));
                                    break;
                                case 3:
                                    s = e[i + 1], c = e[i + 2], 128 === (192 & s) && 128 === (192 & c) && (f = (15 & o) << 12 | (63 & s) << 6 | 63 & c, f > 2047 && (55296 > f || f > 57343) && (a = f));
                                    break;
                                case 4:
                                    s = e[i + 1], c = e[i + 2], u = e[i + 3], 128 === (192 & s) && 128 === (192 & c) && 128 === (192 & u) && (f = (15 & o) << 18 | (63 & s) << 12 | (63 & c) << 6 | 63 & u, f > 65535 && 1114112 > f && (a = f))
                            }
                        }
                        null === a ? (a = 65533, l = 1) : a > 65535 && (a -= 65536, r.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), r.push(a), i += l
                    }
                    return A(r)
                }

                function A(e) {
                    var t = e.length;
                    if (Q >= t)return String.fromCharCode.apply(String, e);
                    for (var n = "", r = 0; t > r;)n += String.fromCharCode.apply(String, e.slice(r, r += Q));
                    return n
                }

                function E(e, t, n) {
                    var r = "";
                    n = Math.min(e.length, n);
                    for (var i = t; n > i; i++)r += String.fromCharCode(127 & e[i]);
                    return r
                }

                function O(e, t, n) {
                    var r = "";
                    n = Math.min(e.length, n);
                    for (var i = t; n > i; i++)r += String.fromCharCode(e[i]);
                    return r
                }

                function I(e, t, n) {
                    var r = e.length;
                    (!t || 0 > t) && (t = 0), (!n || 0 > n || n > r) && (n = r);
                    for (var i = "", o = t; n > o; o++)i += U(e[o]);
                    return i
                }

                function P(e, t, n) {
                    for (var r = e.slice(t, n), i = "",
                             o = 0; o < r.length; o += 2)i += String.fromCharCode(r[o] + 256 * r[o + 1]);
                    return i
                }

                function R(e, t, n) {
                    if (e % 1 !== 0 || 0 > e)throw new RangeError("offset is not uint");
                    if (e + t > n)throw new RangeError("Trying to access beyond buffer length")
                }

                function D(e, t, n, r, i, o) {
                    if (!a.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (t > i || o > t)throw new RangeError('"value" argument is out of bounds');
                    if (n + r > e.length)throw new RangeError("Index out of range")
                }

                function H(e, t, n, r) {
                    0 > t && (t = 65535 + t + 1);
                    for (var i = 0,
                             o = Math.min(e.length - n, 2); o > i; i++)e[n + i] = (t & 255 << 8 * (r ? i : 1 - i)) >>> 8 * (r ? i : 1 - i)
                }

                function W(e, t, n, r) {
                    0 > t && (t = 4294967295 + t + 1);
                    for (var i = 0, o = Math.min(e.length - n, 4); o > i; i++)e[n + i] = t >>> 8 * (r ? i : 3 - i) & 255
                }

                function B(e, t, n, r, i, o) {
                    if (n + r > e.length)throw new RangeError("Index out of range");
                    if (0 > n)throw new RangeError("Index out of range")
                }

                function _(e, t, n, r, i) {
                    return i || B(e, t, n, 4, 3.4028234663852886e38, -3.4028234663852886e38), Z.write(e, t, n, r, 23, 4), n + 4
                }

                function F(e, t, n, r, i) {
                    return i || B(e, t, n, 8, 1.7976931348623157e308, -1.7976931348623157e308), Z.write(e, t, n, r, 52, 8), n + 8
                }

                function z(e) {
                    if (e = j(e).replace(ee, ""), e.length < 2)return "";
                    for (; e.length % 4 !== 0;)e += "=";
                    return e
                }

                function j(e) {
                    return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "")
                }

                function U(e) {
                    return 16 > e ? "0" + e.toString(16) : e.toString(16)
                }

                function q(e, t) {
                    t = t || 1 / 0;
                    for (var n, r = e.length, i = null, o = [], a = 0; r > a; a++) {
                        if (n = e.charCodeAt(a), n > 55295 && 57344 > n) {
                            if (!i) {
                                if (n > 56319) {
                                    (t -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                if (a + 1 === r) {
                                    (t -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                i = n;
                                continue
                            }
                            if (56320 > n) {
                                (t -= 3) > -1 && o.push(239, 191, 189), i = n;
                                continue
                            }
                            n = (i - 55296 << 10 | n - 56320) + 65536
                        } else i && (t -= 3) > -1 && o.push(239, 191, 189);
                        if (i = null, 128 > n) {
                            if ((t -= 1) < 0)break;
                            o.push(n)
                        } else if (2048 > n) {
                            if ((t -= 2) < 0)break;
                            o.push(n >> 6 | 192, 63 & n | 128)
                        } else if (65536 > n) {
                            if ((t -= 3) < 0)break;
                            o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
                        } else {
                            if (!(1114112 > n))throw new Error("Invalid code point");
                            if ((t -= 4) < 0)break;
                            o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
                        }
                    }
                    return o
                }

                function G(e) {
                    for (var t = [], n = 0; n < e.length; n++)t.push(255 & e.charCodeAt(n));
                    return t
                }

                function Y(e, t) {
                    for (var n, r, i, o = [],
                             a = 0; a < e.length && !((t -= 2) < 0); a++)n = e.charCodeAt(a), r = n >> 8, i = n % 256, o.push(i), o.push(r);
                    return o
                }

                function $(e) {
                    return X.toByteArray(z(e))
                }

                function V(e, t, n, r) {
                    for (var i = 0; r > i && !(i + n >= t.length || i >= e.length); i++)t[i + n] = e[i];
                    return i
                }

                function K(e) {
                    return e !== e
                }

                var X = e("base64-js"), Z = e("ieee754"), J = e("isarray");
                n.Buffer = a, n.SlowBuffer = g, n.INSPECT_MAX_BYTES = 50, a.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : r(), n.kMaxLength = i(), a.poolSize = 8192, a._augment = function (e) {
                    return e.__proto__ = a.prototype, e
                }, a.from = function (e, t, n) {
                    return l(null, e, t, n)
                }, a.TYPED_ARRAY_SUPPORT && (a.prototype.__proto__ = Uint8Array.prototype, a.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && a[Symbol.species] === a && Object.defineProperty(a, Symbol.species, {
                    value: null,
                    configurable: !0
                })), a.alloc = function (e, t, n) {
                    return c(null, e, t, n)
                }, a.allocUnsafe = function (e) {
                    return u(null, e)
                }, a.allocUnsafeSlow = function (e) {
                    return u(null, e)
                }, a.isBuffer = function (e) {
                    return !(null == e || !e._isBuffer)
                }, a.compare = function (e, t) {
                    if (!a.isBuffer(e) || !a.isBuffer(t))throw new TypeError("Arguments must be Buffers");
                    if (e === t)return 0;
                    for (var n = e.length, r = t.length, i = 0, o = Math.min(n, r); o > i; ++i)if (e[i] !== t[i]) {
                        n = e[i], r = t[i];
                        break
                    }
                    return r > n ? -1 : n > r ? 1 : 0
                }, a.isEncoding = function (e) {
                    switch (String(e).toLowerCase()) {
                        case"hex":
                        case"utf8":
                        case"utf-8":
                        case"ascii":
                        case"binary":
                        case"base64":
                        case"raw":
                        case"ucs2":
                        case"ucs-2":
                        case"utf16le":
                        case"utf-16le":
                            return !0;
                        default:
                            return !1
                    }
                }, a.concat = function (e, t) {
                    if (!J(e))throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === e.length)return a.alloc(0);
                    var n;
                    if (void 0 === t)for (t = 0, n = 0; n < e.length; n++)t += e[n].length;
                    var r = a.allocUnsafe(t), i = 0;
                    for (n = 0; n < e.length; n++) {
                        var o = e[n];
                        if (!a.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');
                        o.copy(r, i), i += o.length
                    }
                    return r
                }, a.byteLength = v, a.prototype._isBuffer = !0, a.prototype.swap16 = function () {
                    var e = this.length;
                    if (e % 2 !== 0)throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (var t = 0; e > t; t += 2)x(this, t, t + 1);
                    return this
                }, a.prototype.swap32 = function () {
                    var e = this.length;
                    if (e % 4 !== 0)throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (var t = 0; e > t; t += 4)x(this, t, t + 3), x(this, t + 1, t + 2);
                    return this
                }, a.prototype.toString = function () {
                    var e = 0 | this.length;
                    return 0 === e ? "" : 0 === arguments.length ? N(this, 0, e) : y.apply(this, arguments)
                }, a.prototype.equals = function (e) {
                    if (!a.isBuffer(e))throw new TypeError("Argument must be a Buffer");
                    return this === e ? !0 : 0 === a.compare(this, e)
                }, a.prototype.inspect = function () {
                    var e = "", t = n.INSPECT_MAX_BYTES;
                    return this.length > 0 && (e = this.toString("hex", 0, t).match(/.{2}/g).join(" "), this.length > t && (e += " ... ")), "<Buffer " + e + ">"
                }, a.prototype.compare = function (e, t, n, r, i) {
                    if (!a.isBuffer(e))throw new TypeError("Argument must be a Buffer");
                    if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), 0 > t || n > e.length || 0 > r || i > this.length)throw new RangeError("out of range index");
                    if (r >= i && t >= n)return 0;
                    if (r >= i)return -1;
                    if (t >= n)return 1;
                    if (t >>>= 0, n >>>= 0, r >>>= 0, i >>>= 0, this === e)return 0;
                    for (var o = i - r, l = n - t, s = Math.min(o, l), c = this.slice(r, i), u = e.slice(t, n),
                             f = 0; s > f; ++f)if (c[f] !== u[f]) {
                        o = c[f], l = u[f];
                        break
                    }
                    return l > o ? -1 : o > l ? 1 : 0
                }, a.prototype.indexOf = function (e, t, n) {
                    if ("string" == typeof t ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : -2147483648 > t && (t = -2147483648), t >>= 0, 0 === this.length)return -1;
                    if (t >= this.length)return -1;
                    if (0 > t && (t = Math.max(this.length + t, 0)), "string" == typeof e && (e = a.from(e, n)), a.isBuffer(e))return 0 === e.length ? -1 : b(this, e, t, n);
                    if ("number" == typeof e)return a.TYPED_ARRAY_SUPPORT && "function" === Uint8Array.prototype.indexOf ? Uint8Array.prototype.indexOf.call(this, e, t) : b(this, [e], t, n);
                    throw new TypeError("val must be string, number or Buffer")
                }, a.prototype.includes = function (e, t, n) {
                    return -1 !== this.indexOf(e, t, n)
                }, a.prototype.write = function (e, t, n, r) {
                    if (void 0 === t) r = "utf8", n = this.length, t = 0; else if (void 0 === n && "string" == typeof t) r = t, n = this.length, t = 0; else {
                        if (!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        t = 0 | t, isFinite(n) ? (n = 0 | n, void 0 === r && (r = "utf8")) : (r = n, n = void 0)
                    }
                    var i = this.length - t;
                    if ((void 0 === n || n > i) && (n = i), e.length > 0 && (0 > n || 0 > t) || t > this.length)throw new RangeError("Attempt to write outside buffer bounds");
                    r || (r = "utf8");
                    for (var o = !1; ;)switch (r) {
                        case"hex":
                            return w(this, e, t, n);
                        case"utf8":
                        case"utf-8":
                            return k(this, e, t, n);
                        case"ascii":
                            return S(this, e, t, n);
                        case"binary":
                            return C(this, e, t, n);
                        case"base64":
                            return L(this, e, t, n);
                        case"ucs2":
                        case"ucs-2":
                        case"utf16le":
                        case"utf-16le":
                            return T(this, e, t, n);
                        default:
                            if (o)throw new TypeError("Unknown encoding: " + r);
                            r = ("" + r).toLowerCase(), o = !0
                    }
                }, a.prototype.toJSON = function () {
                    return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)}
                };
                var Q = 4096;
                a.prototype.slice = function (e, t) {
                    var n = this.length;
                    e = ~~e, t = void 0 === t ? n : ~~t, 0 > e ? (e += n, 0 > e && (e = 0)) : e > n && (e = n), 0 > t ? (t += n, 0 > t && (t = 0)) : t > n && (t = n), e > t && (t = e);
                    var r;
                    if (a.TYPED_ARRAY_SUPPORT) r = this.subarray(e, t), r.__proto__ = a.prototype; else {
                        var i = t - e;
                        r = new a(i, void 0);
                        for (var o = 0; i > o; o++)r[o] = this[o + e]
                    }
                    return r
                }, a.prototype.readUIntLE = function (e, t, n) {
                    e = 0 | e, t = 0 | t, n || R(e, t, this.length);
                    for (var r = this[e], i = 1, o = 0; ++o < t && (i *= 256);)r += this[e + o] * i;
                    return r
                }, a.prototype.readUIntBE = function (e, t, n) {
                    e = 0 | e, t = 0 | t, n || R(e, t, this.length);
                    for (var r = this[e + --t], i = 1; t > 0 && (i *= 256);)r += this[e + --t] * i;
                    return r
                }, a.prototype.readUInt8 = function (e, t) {
                    return t || R(e, 1, this.length), this[e]
                }, a.prototype.readUInt16LE = function (e, t) {
                    return t || R(e, 2, this.length), this[e] | this[e + 1] << 8
                }, a.prototype.readUInt16BE = function (e, t) {
                    return t || R(e, 2, this.length), this[e] << 8 | this[e + 1]
                }, a.prototype.readUInt32LE = function (e, t) {
                    return t || R(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
                }, a.prototype.readUInt32BE = function (e, t) {
                    return t || R(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
                }, a.prototype.readIntLE = function (e, t, n) {
                    e = 0 | e, t = 0 | t, n || R(e, t, this.length);
                    for (var r = this[e], i = 1, o = 0; ++o < t && (i *= 256);)r += this[e + o] * i;
                    return i *= 128, r >= i && (r -= Math.pow(2, 8 * t)), r
                }, a.prototype.readIntBE = function (e, t, n) {
                    e = 0 | e, t = 0 | t, n || R(e, t, this.length);
                    for (var r = t, i = 1, o = this[e + --r]; r > 0 && (i *= 256);)o += this[e + --r] * i;
                    return i *= 128, o >= i && (o -= Math.pow(2, 8 * t)), o
                }, a.prototype.readInt8 = function (e, t) {
                    return t || R(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
                }, a.prototype.readInt16LE = function (e, t) {
                    t || R(e, 2, this.length);
                    var n = this[e] | this[e + 1] << 8;
                    return 32768 & n ? 4294901760 | n : n
                }, a.prototype.readInt16BE = function (e, t) {
                    t || R(e, 2, this.length);
                    var n = this[e + 1] | this[e] << 8;
                    return 32768 & n ? 4294901760 | n : n
                }, a.prototype.readInt32LE = function (e, t) {
                    return t || R(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
                }, a.prototype.readInt32BE = function (e, t) {
                    return t || R(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
                }, a.prototype.readFloatLE = function (e, t) {
                    return t || R(e, 4, this.length), Z.read(this, e, !0, 23, 4)
                }, a.prototype.readFloatBE = function (e, t) {
                    return t || R(e, 4, this.length), Z.read(this, e, !1, 23, 4)
                }, a.prototype.readDoubleLE = function (e, t) {
                    return t || R(e, 8, this.length), Z.read(this, e, !0, 52, 8)
                }, a.prototype.readDoubleBE = function (e, t) {
                    return t || R(e, 8, this.length), Z.read(this, e, !1, 52, 8)
                }, a.prototype.writeUIntLE = function (e, t, n, r) {
                    if (e = +e, t = 0 | t, n = 0 | n, !r) {
                        var i = Math.pow(2, 8 * n) - 1;
                        D(this, e, t, n, i, 0)
                    }
                    var o = 1, a = 0;
                    for (this[t] = 255 & e; ++a < n && (o *= 256);)this[t + a] = e / o & 255;
                    return t + n
                }, a.prototype.writeUIntBE = function (e, t, n, r) {
                    if (e = +e, t = 0 | t, n = 0 | n, !r) {
                        var i = Math.pow(2, 8 * n) - 1;
                        D(this, e, t, n, i, 0)
                    }
                    var o = n - 1, a = 1;
                    for (this[t + o] = 255 & e; --o >= 0 && (a *= 256);)this[t + o] = e / a & 255;
                    return t + n
                }, a.prototype.writeUInt8 = function (e, t, n) {
                    return e = +e, t = 0 | t, n || D(this, e, t, 1, 255, 0), a.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1
                }, a.prototype.writeUInt16LE = function (e, t, n) {
                    return e = +e, t = 0 | t, n || D(this, e, t, 2, 65535, 0), a.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : H(this, e, t, !0), t + 2
                }, a.prototype.writeUInt16BE = function (e, t, n) {
                    return e = +e, t = 0 | t, n || D(this, e, t, 2, 65535, 0), a.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : H(this, e, t, !1), t + 2
                }, a.prototype.writeUInt32LE = function (e, t, n) {
                    return e = +e, t = 0 | t, n || D(this, e, t, 4, 4294967295, 0), a.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : W(this, e, t, !0), t + 4
                }, a.prototype.writeUInt32BE = function (e, t, n) {
                    return e = +e, t = 0 | t, n || D(this, e, t, 4, 4294967295, 0), a.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : W(this, e, t, !1), t + 4
                }, a.prototype.writeIntLE = function (e, t, n, r) {
                    if (e = +e, t = 0 | t, !r) {
                        var i = Math.pow(2, 8 * n - 1);
                        D(this, e, t, n, i - 1, -i)
                    }
                    var o = 0, a = 1, l = 0;
                    for (this[t] = 255 & e; ++o < n && (a *= 256);)0 > e && 0 === l && 0 !== this[t + o - 1] && (l = 1), this[t + o] = (e / a >> 0) - l & 255;
                    return t + n
                }, a.prototype.writeIntBE = function (e, t, n, r) {
                    if (e = +e, t = 0 | t, !r) {
                        var i = Math.pow(2, 8 * n - 1);
                        D(this, e, t, n, i - 1, -i)
                    }
                    var o = n - 1, a = 1, l = 0;
                    for (this[t + o] = 255 & e; --o >= 0 && (a *= 256);)0 > e && 0 === l && 0 !== this[t + o + 1] && (l = 1), this[t + o] = (e / a >> 0) - l & 255;
                    return t + n
                }, a.prototype.writeInt8 = function (e, t, n) {
                    return e = +e, t = 0 | t, n || D(this, e, t, 1, 127, -128), a.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), 0 > e && (e = 255 + e + 1), this[t] = 255 & e, t + 1
                }, a.prototype.writeInt16LE = function (e, t, n) {
                    return e = +e, t = 0 | t, n || D(this, e, t, 2, 32767, -32768), a.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : H(this, e, t, !0), t + 2
                }, a.prototype.writeInt16BE = function (e, t, n) {
                    return e = +e, t = 0 | t, n || D(this, e, t, 2, 32767, -32768), a.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : H(this, e, t, !1), t + 2
                }, a.prototype.writeInt32LE = function (e, t, n) {
                    return e = +e, t = 0 | t, n || D(this, e, t, 4, 2147483647, -2147483648), a.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : W(this, e, t, !0), t + 4
                }, a.prototype.writeInt32BE = function (e, t, n) {
                    return e = +e, t = 0 | t, n || D(this, e, t, 4, 2147483647, -2147483648), 0 > e && (e = 4294967295 + e + 1), a.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : W(this, e, t, !1), t + 4
                }, a.prototype.writeFloatLE = function (e, t, n) {
                    return _(this, e, t, !0, n)
                }, a.prototype.writeFloatBE = function (e, t, n) {
                    return _(this, e, t, !1, n)
                }, a.prototype.writeDoubleLE = function (e, t, n) {
                    return F(this, e, t, !0, n)
                }, a.prototype.writeDoubleBE = function (e, t, n) {
                    return F(this, e, t, !1, n)
                }, a.prototype.copy = function (e, t, n, r) {
                    if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && n > r && (r = n), r === n)return 0;
                    if (0 === e.length || 0 === this.length)return 0;
                    if (0 > t)throw new RangeError("targetStart out of bounds");
                    if (0 > n || n >= this.length)throw new RangeError("sourceStart out of bounds");
                    if (0 > r)throw new RangeError("sourceEnd out of bounds");
                    r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
                    var i, o = r - n;
                    if (this === e && t > n && r > t)for (i = o - 1; i >= 0; i--)e[i + t] = this[i + n]; else if (1e3 > o || !a.TYPED_ARRAY_SUPPORT)for (i = 0; o > i; i++)e[i + t] = this[i + n]; else Uint8Array.prototype.set.call(e, this.subarray(n, n + o), t);
                    return o
                }, a.prototype.fill = function (e, t, n, r) {
                    if ("string" == typeof e) {
                        if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === e.length) {
                            var i = e.charCodeAt(0);
                            256 > i && (e = i)
                        }
                        if (void 0 !== r && "string" != typeof r)throw new TypeError("encoding must be a string");
                        if ("string" == typeof r && !a.isEncoding(r))throw new TypeError("Unknown encoding: " + r)
                    } else"number" == typeof e && (e = 255 & e);
                    if (0 > t || this.length < t || this.length < n)throw new RangeError("Out of range index");
                    if (t >= n)return this;
                    t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0);
                    var o;
                    if ("number" == typeof e)for (o = t; n > o; o++)this[o] = e; else {
                        var l = a.isBuffer(e) ? e : q(new a(e, r).toString()), s = l.length;
                        for (o = 0; n - t > o; o++)this[o + t] = l[o % s]
                    }
                    return this
                };
                var ee = /[^+\/0-9A-Za-z-_]/g
            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
        }, {"base64-js": 1, ieee754: 15, isarray: 16}],
        4: [function (e, t, n) {
            "use strict";
            function r(e) {
                return e = e || {}, "function" != typeof e.codeMirrorInstance || "function" != typeof e.codeMirrorInstance.defineMode ? void console.log("CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`") : (String.prototype.includes || (String.prototype.includes = function () {
                    return -1 !== String.prototype.indexOf.apply(this, arguments)
                }), void e.codeMirrorInstance.defineMode("spell-checker", function (t) {
                    if (!r.aff_loading) {
                        r.aff_loading = !0;
                        var n = new XMLHttpRequest;
                        n.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff", !0), n.onload = function () {
                            4 === n.readyState && 200 === n.status && (r.aff_data = n.responseText, r.num_loaded++, 2 == r.num_loaded && (r.typo = new i("en_US", r.aff_data, r.dic_data, {platform: "any"})))
                        }, n.send(null)
                    }
                    if (!r.dic_loading) {
                        r.dic_loading = !0;
                        var o = new XMLHttpRequest;
                        o.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic", !0), o.onload = function () {
                            4 === o.readyState && 200 === o.status && (r.dic_data = o.responseText, r.num_loaded++, 2 == r.num_loaded && (r.typo = new i("en_US", r.aff_data, r.dic_data, {platform: "any"})))
                        }, o.send(null)
                    }
                    var a = '!"#$%&()*+,-./:;<=>?@[\\]^_`{|}~ ', l = {
                        token: function (e) {
                            var t = e.peek(), n = "";
                            if (a.includes(t))return e.next(), null;
                            for (; null != (t = e.peek()) && !a.includes(t);)n += t, e.next();
                            return r.typo && !r.typo.check(n) ? "spell-error" : null
                        }
                    }, s = e.codeMirrorInstance.getMode(t, t.backdrop || "text/plain");
                    return e.codeMirrorInstance.overlayMode(s, l, !0)
                }))
            }

            var i = e("typo-js");
            r.num_loaded = 0, r.aff_loading = !1, r.dic_loading = !1, r.aff_data = "", r.dic_data = "", r.typo, t.exports = r
        }, {"typo-js": 18}],
        5: [function (t, n, r) {
            !function (i) {
                "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror"], i) : i(CodeMirror)
            }(function (e) {
                "use strict";
                function t(e) {
                    var t = e.getWrapperElement();
                    e.state.fullScreenRestore = {
                        scrollTop: window.pageYOffset,
                        scrollLeft: window.pageXOffset,
                        width: t.style.width,
                        height: t.style.height
                    }, t.style.width = "", t.style.height = "auto", t.className += " CodeMirror-fullscreen", document.documentElement.style.overflow = "hidden", e.refresh()
                }

                function n(e) {
                    var t = e.getWrapperElement();
                    t.className = t.className.replace(/\s*CodeMirror-fullscreen\b/, ""), document.documentElement.style.overflow = "";
                    var n = e.state.fullScreenRestore;
                    t.style.width = n.width, t.style.height = n.height, window.scrollTo(n.scrollLeft, n.scrollTop), e.refresh()
                }

                e.defineOption("fullScreen", !1, function (r, i, o) {
                    o == e.Init && (o = !1), !o != !i && (i ? t(r) : n(r))
                })
            })
        }, {"../../lib/codemirror": 10}],
        6: [function (t, n, r) {
            !function (i) {
                "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror"], i) : i(CodeMirror)
            }(function (e) {
                function t(e) {
                    e.state.placeholder && (e.state.placeholder.parentNode.removeChild(e.state.placeholder), e.state.placeholder = null)
                }

                function n(e) {
                    t(e);
                    var n = e.state.placeholder = document.createElement("pre");
                    n.style.cssText = "height: 0; overflow: visible", n.className = "CodeMirror-placeholder";
                    var r = e.getOption("placeholder");
                    "string" == typeof r && (r = document.createTextNode(r)), n.appendChild(r), e.display.lineSpace.insertBefore(n, e.display.lineSpace.firstChild)
                }

                function r(e) {
                    o(e) && n(e)
                }

                function i(e) {
                    var r = e.getWrapperElement(), i = o(e);
                    r.className = r.className.replace(" CodeMirror-empty", "") + (i ? " CodeMirror-empty" : ""), i ? n(e) : t(e)
                }

                function o(e) {
                    return 1 === e.lineCount() && "" === e.getLine(0)
                }

                e.defineOption("placeholder", "", function (n, o, a) {
                    var l = a && a != e.Init;
                    if (o && !l) n.on("blur", r), n.on("change", i), n.on("swapDoc", i), i(n); else if (!o && l) {
                        n.off("blur", r), n.off("change", i), n.off("swapDoc", i), t(n);
                        var s = n.getWrapperElement();
                        s.className = s.className.replace(" CodeMirror-empty", "")
                    }
                    o && !n.hasFocus() && r(n)
                })
            })
        }, {"../../lib/codemirror": 10}],
        7: [function (t, n, r) {
            !function (i) {
                "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror"], i) : i(CodeMirror)
            }(function (e) {
                "use strict";
                var t = /^(\s*)(>[> ]*|[*+-]\s|(\d+)([.)]))(\s*)/, n = /^(\s*)(>[> ]*|[*+-]|(\d+)[.)])(\s*)$/,
                    r = /[*+-]\s/;
                e.commands.newlineAndIndentContinueMarkdownList = function (i) {
                    if (i.getOption("disableInput"))return e.Pass;
                    for (var o = i.listSelections(), a = [], l = 0; l < o.length; l++) {
                        var s = o[l].head, c = i.getStateAfter(s.line), u = c.list !== !1, f = 0 !== c.quote,
                            h = i.getLine(s.line), d = t.exec(h);
                        if (!o[l].empty() || !u && !f || !d)return void i.execCommand("newlineAndIndent");
                        if (n.test(h)) i.replaceRange("", {line: s.line, ch: 0}, {
                            line: s.line,
                            ch: s.ch + 1
                        }), a[l] = "\n"; else {
                            var p = d[1], m = d[5],
                                g = r.test(d[2]) || d[2].indexOf(">") >= 0 ? d[2] : parseInt(d[3], 10) + 1 + d[4];
                            a[l] = "\n" + p + g + m
                        }
                    }
                    i.replaceSelections(a)
                }
            })
        }, {"../../lib/codemirror": 10}],
        8: [function (t, n, r) {
            !function (i) {
                "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror"], i) : i(CodeMirror)
            }(function (e) {
                "use strict";
                e.overlayMode = function (t, n, r) {
                    return {
                        startState: function () {
                            return {
                                base: e.startState(t),
                                overlay: e.startState(n),
                                basePos: 0,
                                baseCur: null,
                                overlayPos: 0,
                                overlayCur: null,
                                streamSeen: null
                            }
                        }, copyState: function (r) {
                            return {
                                base: e.copyState(t, r.base),
                                overlay: e.copyState(n, r.overlay),
                                basePos: r.basePos,
                                baseCur: null,
                                overlayPos: r.overlayPos,
                                overlayCur: null
                            }
                        }, token: function (e, i) {
                            return (e != i.streamSeen || Math.min(i.basePos, i.overlayPos) < e.start) && (i.streamSeen = e, i.basePos = i.overlayPos = e.start), e.start == i.basePos && (i.baseCur = t.token(e, i.base), i.basePos = e.pos), e.start == i.overlayPos && (e.pos = e.start, i.overlayCur = n.token(e, i.overlay), i.overlayPos = e.pos), e.pos = Math.min(i.basePos, i.overlayPos), null == i.overlayCur ? i.baseCur : null != i.baseCur && i.overlay.combineTokens || r && null == i.overlay.combineTokens ? i.baseCur + " " + i.overlayCur : i.overlayCur
                        }, indent: t.indent && function (e, n) {
                            return t.indent(e.base, n)
                        }, electricChars: t.electricChars, innerMode: function (e) {
                            return {state: e.base, mode: t}
                        }, blankLine: function (e) {
                            t.blankLine && t.blankLine(e.base), n.blankLine && n.blankLine(e.overlay)
                        }
                    }
                }
            })
        }, {"../../lib/codemirror": 10}],
        9: [function (t, n, r) {
            !function (i) {
                "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror"], i) : i(CodeMirror)
            }(function (e) {
                "use strict";
                function t(e) {
                    e.operation(function () {
                        a(e)
                    })
                }

                function n(e) {
                    e.state.markedSelection.length && e.operation(function () {
                        i(e)
                    })
                }

                function r(e, t, n, r) {
                    if (0 != c(t, n))for (var i = e.state.markedSelection, o = e.state.markedSelectionStyle,
                                              a = t.line; ;) {
                        var u = a == t.line ? t : s(a, 0), f = a + l, h = f >= n.line, d = h ? n : s(f, 0),
                            p = e.markText(u, d, {className: o});
                        if (null == r ? i.push(p) : i.splice(r++, 0, p), h)break;
                        a = f
                    }
                }

                function i(e) {
                    for (var t = e.state.markedSelection, n = 0; n < t.length; ++n)t[n].clear();
                    t.length = 0
                }

                function o(e) {
                    i(e);
                    for (var t = e.listSelections(), n = 0; n < t.length; n++)r(e, t[n].from(), t[n].to())
                }

                function a(e) {
                    if (!e.somethingSelected())return i(e);
                    if (e.listSelections().length > 1)return o(e);
                    var t = e.getCursor("start"), n = e.getCursor("end"), a = e.state.markedSelection;
                    if (!a.length)return r(e, t, n);
                    var s = a[0].find(), u = a[a.length - 1].find();
                    if (!s || !u || n.line - t.line < l || c(t, u.to) >= 0 || c(n, s.from) <= 0)return o(e);
                    for (; c(t, s.from) > 0;)a.shift().clear(), s = a[0].find();
                    for (c(t, s.from) < 0 && (s.to.line - t.line < l ? (a.shift().clear(), r(e, t, s.to, 0)) : r(e, t, s.from, 0)); c(n, u.to) < 0;)a.pop().clear(), u = a[a.length - 1].find();
                    c(n, u.to) > 0 && (n.line - u.from.line < l ? (a.pop().clear(), r(e, u.from, n)) : r(e, u.to, n))
                }

                e.defineOption("styleSelectedText", !1, function (r, a, l) {
                    var s = l && l != e.Init;
                    a && !s ? (r.state.markedSelection = [], r.state.markedSelectionStyle = "string" == typeof a ? a : "CodeMirror-selectedtext", o(r), r.on("cursorActivity", t), r.on("change", n)) : !a && s && (r.off("cursorActivity", t), r.off("change", n), i(r), r.state.markedSelection = r.state.markedSelectionStyle = null)
                });
                var l = 8, s = e.Pos, c = e.cmpPos
            })
        }, {"../../lib/codemirror": 10}],
        10: [function (t, n, r) {
            !function (t) {
                if ("object" == typeof r && "object" == typeof n) n.exports = t(); else {
                    if ("function" == typeof e && e.amd)return e([], t);
                    (this || window).CodeMirror = t()
                }
            }(function () {
                "use strict";
                function e(n, r) {
                    if (!(this instanceof e))return new e(n, r);
                    this.options = r = r ? Wi(r) : {}, Wi(ea, r, !1), d(r);
                    var i = r.value;
                    "string" == typeof i && (i = new Ca(i, r.mode, null, r.lineSeparator)), this.doc = i;
                    var o = new e.inputStyles[r.inputStyle](this), a = this.display = new t(n, i, o);
                    a.wrapper.CodeMirror = this, c(this), l(this), r.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), r.autofocus && !Ao && a.input.focus(), v(this), this.state = {
                        keyMaps: [],
                        overlays: [],
                        modeGen: 0,
                        overwrite: !1,
                        delayingBlurEvent: !1,
                        focused: !1,
                        suppressEdits: !1,
                        pasteIncoming: !1,
                        cutIncoming: !1,
                        selectingText: !1,
                        draggingText: !1,
                        highlight: new Ei,
                        keySeq: null,
                        specialChars: null
                    };
                    var s = this;
                    xo && 11 > bo && setTimeout(function () {
                        s.display.input.reset(!0)
                    }, 20), jt(this), Ki(), bt(this), this.curOp.forceUpdate = !0, Xr(this, i), r.autofocus && !Ao || s.hasFocus() ? setTimeout(Bi(vn, this), 20) : yn(this);
                    for (var u in ta)ta.hasOwnProperty(u) && ta[u](this, r[u], na);
                    k(this), r.finishInit && r.finishInit(this);
                    for (var f = 0; f < aa.length; ++f)aa[f](this);
                    kt(this), wo && r.lineWrapping && "optimizelegibility" == getComputedStyle(a.lineDiv).textRendering && (a.lineDiv.style.textRendering = "auto")
                }

                function t(e, t, n) {
                    var r = this;
                    this.input = n, r.scrollbarFiller = ji("div", null, "CodeMirror-scrollbar-filler"), r.scrollbarFiller.setAttribute("cm-not-content", "true"), r.gutterFiller = ji("div", null, "CodeMirror-gutter-filler"), r.gutterFiller.setAttribute("cm-not-content", "true"), r.lineDiv = ji("div", null, "CodeMirror-code"), r.selectionDiv = ji("div", null, null, "position: relative; z-index: 1"), r.cursorDiv = ji("div", null, "CodeMirror-cursors"), r.measure = ji("div", null, "CodeMirror-measure"), r.lineMeasure = ji("div", null, "CodeMirror-measure"), r.lineSpace = ji("div", [r.measure, r.lineMeasure, r.selectionDiv, r.cursorDiv, r.lineDiv], null, "position: relative; outline: none"), r.mover = ji("div", [ji("div", [r.lineSpace], "CodeMirror-lines")], null, "position: relative"), r.sizer = ji("div", [r.mover], "CodeMirror-sizer"), r.sizerWidth = null, r.heightForcer = ji("div", null, null, "position: absolute; height: " + Da + "px; width: 1px;"), r.gutters = ji("div", null, "CodeMirror-gutters"), r.lineGutter = null, r.scroller = ji("div", [r.sizer, r.heightForcer, r.gutters], "CodeMirror-scroll"), r.scroller.setAttribute("tabIndex", "-1"), r.wrapper = ji("div", [r.scrollbarFiller, r.gutterFiller, r.scroller], "CodeMirror"), xo && 8 > bo && (r.gutters.style.zIndex = -1, r.scroller.style.paddingRight = 0), wo || go && Ao || (r.scroller.draggable = !0), e && (e.appendChild ? e.appendChild(r.wrapper) : e(r.wrapper)), r.viewFrom = r.viewTo = t.first, r.reportedViewFrom = r.reportedViewTo = t.first, r.view = [], r.renderedView = null, r.externalMeasured = null, r.viewOffset = 0, r.lastWrapHeight = r.lastWrapWidth = 0, r.updateLineNumbers = null, r.nativeBarWidth = r.barHeight = r.barWidth = 0, r.scrollbarsClipped = !1, r.lineNumWidth = r.lineNumInnerWidth = r.lineNumChars = null, r.alignWidgets = !1, r.cachedCharWidth = r.cachedTextHeight = r.cachedPaddingH = null,
                        r.maxLine = null, r.maxLineLength = 0, r.maxLineChanged = !1, r.wheelDX = r.wheelDY = r.wheelStartX = r.wheelStartY = null, r.shift = !1, r.selForContextMenu = null, r.activeTouch = null, n.init(r)
                }

                function n(t) {
                    t.doc.mode = e.getMode(t.options, t.doc.modeOption), r(t)
                }

                function r(e) {
                    e.doc.iter(function (e) {
                        e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null)
                    }), e.doc.frontier = e.doc.first, _e(e, 100), e.state.modeGen++, e.curOp && Dt(e)
                }

                function i(e) {
                    e.options.lineWrapping ? (Ja(e.display.wrapper, "CodeMirror-wrap"), e.display.sizer.style.minWidth = "", e.display.sizerWidth = null) : (Za(e.display.wrapper, "CodeMirror-wrap"), h(e)), a(e), Dt(e), lt(e), setTimeout(function () {
                        y(e)
                    }, 100)
                }

                function o(e) {
                    var t = yt(e.display), n = e.options.lineWrapping,
                        r = n && Math.max(5, e.display.scroller.clientWidth / xt(e.display) - 3);
                    return function (i) {
                        if (kr(e.doc, i))return 0;
                        var o = 0;
                        if (i.widgets)for (var a = 0; a < i.widgets.length; a++)i.widgets[a].height && (o += i.widgets[a].height);
                        return n ? o + (Math.ceil(i.text.length / r) || 1) * t : o + t
                    }
                }

                function a(e) {
                    var t = e.doc, n = o(e);
                    t.iter(function (e) {
                        var t = n(e);
                        t != e.height && ei(e, t)
                    })
                }

                function l(e) {
                    e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + e.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), lt(e)
                }

                function s(e) {
                    c(e), Dt(e), setTimeout(function () {
                        w(e)
                    }, 20)
                }

                function c(e) {
                    var t = e.display.gutters, n = e.options.gutters;
                    Ui(t);
                    for (var r = 0; r < n.length; ++r) {
                        var i = n[r], o = t.appendChild(ji("div", null, "CodeMirror-gutter " + i));
                        "CodeMirror-linenumbers" == i && (e.display.lineGutter = o, o.style.width = (e.display.lineNumWidth || 1) + "px")
                    }
                    t.style.display = r ? "" : "none", u(e)
                }

                function u(e) {
                    var t = e.display.gutters.offsetWidth;
                    e.display.sizer.style.marginLeft = t + "px"
                }

                function f(e) {
                    if (0 == e.height)return 0;
                    for (var t, n = e.text.length, r = e; t = mr(r);) {
                        var i = t.find(0, !0);
                        r = i.from.line, n += i.from.ch - i.to.ch
                    }
                    for (r = e; t = gr(r);) {
                        var i = t.find(0, !0);
                        n -= r.text.length - i.from.ch, r = i.to.line, n += r.text.length - i.to.ch
                    }
                    return n
                }

                function h(e) {
                    var t = e.display, n = e.doc;
                    t.maxLine = Zr(n, n.first), t.maxLineLength = f(t.maxLine), t.maxLineChanged = !0, n.iter(function (e) {
                        var n = f(e);
                        n > t.maxLineLength && (t.maxLineLength = n, t.maxLine = e)
                    })
                }

                function d(e) {
                    var t = Pi(e.gutters, "CodeMirror-linenumbers");
                    -1 == t && e.lineNumbers ? e.gutters = e.gutters.concat(["CodeMirror-linenumbers"]) : t > -1 && !e.lineNumbers && (e.gutters = e.gutters.slice(0), e.gutters.splice(t, 1))
                }

                function p(e) {
                    var t = e.display, n = t.gutters.offsetWidth, r = Math.round(e.doc.height + qe(e.display));
                    return {
                        clientHeight: t.scroller.clientHeight,
                        viewHeight: t.wrapper.clientHeight,
                        scrollWidth: t.scroller.scrollWidth,
                        clientWidth: t.scroller.clientWidth,
                        viewWidth: t.wrapper.clientWidth,
                        barLeft: e.options.fixedGutter ? n : 0,
                        docHeight: r,
                        scrollHeight: r + Ye(e) + t.barHeight,
                        nativeBarWidth: t.nativeBarWidth,
                        gutterWidth: n
                    }
                }

                function m(e, t, n) {
                    this.cm = n;
                    var r = this.vert = ji("div", [ji("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"),
                        i = this.horiz = ji("div", [ji("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
                    e(r), e(i), Ea(r, "scroll", function () {
                        r.clientHeight && t(r.scrollTop, "vertical")
                    }), Ea(i, "scroll", function () {
                        i.clientWidth && t(i.scrollLeft, "horizontal")
                    }), this.checkedZeroWidth = !1, xo && 8 > bo && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px")
                }

                function g() {
                }

                function v(t) {
                    t.display.scrollbars && (t.display.scrollbars.clear(), t.display.scrollbars.addClass && Za(t.display.wrapper, t.display.scrollbars.addClass)), t.display.scrollbars = new e.scrollbarModel[t.options.scrollbarStyle](function (e) {
                        t.display.wrapper.insertBefore(e, t.display.scrollbarFiller), Ea(e, "mousedown", function () {
                            t.state.focused && setTimeout(function () {
                                t.display.input.focus()
                            }, 0)
                        }), e.setAttribute("cm-not-content", "true")
                    }, function (e, n) {
                        "horizontal" == n ? on(t, e) : rn(t, e)
                    }, t), t.display.scrollbars.addClass && Ja(t.display.wrapper, t.display.scrollbars.addClass)
                }

                function y(e, t) {
                    t || (t = p(e));
                    var n = e.display.barWidth, r = e.display.barHeight;
                    x(e, t);
                    for (var i = 0; 4 > i && n != e.display.barWidth || r != e.display.barHeight; i++)n != e.display.barWidth && e.options.lineWrapping && O(e), x(e, p(e)), n = e.display.barWidth, r = e.display.barHeight
                }

                function x(e, t) {
                    var n = e.display, r = n.scrollbars.update(t);
                    n.sizer.style.paddingRight = (n.barWidth = r.right) + "px", n.sizer.style.paddingBottom = (n.barHeight = r.bottom) + "px", n.heightForcer.style.borderBottom = r.bottom + "px solid transparent", r.right && r.bottom ? (n.scrollbarFiller.style.display = "block", n.scrollbarFiller.style.height = r.bottom + "px", n.scrollbarFiller.style.width = r.right + "px") : n.scrollbarFiller.style.display = "", r.bottom && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (n.gutterFiller.style.display = "block", n.gutterFiller.style.height = r.bottom + "px", n.gutterFiller.style.width = t.gutterWidth + "px") : n.gutterFiller.style.display = ""
                }

                function b(e, t, n) {
                    var r = n && null != n.top ? Math.max(0, n.top) : e.scroller.scrollTop;
                    r = Math.floor(r - Ue(e));
                    var i = n && null != n.bottom ? n.bottom : r + e.wrapper.clientHeight, o = ni(t, r), a = ni(t, i);
                    if (n && n.ensure) {
                        var l = n.ensure.from.line, s = n.ensure.to.line;
                        o > l ? (o = l, a = ni(t, ri(Zr(t, l)) + e.wrapper.clientHeight)) : Math.min(s, t.lastLine()) >= a && (o = ni(t, ri(Zr(t, s)) - e.wrapper.clientHeight), a = s)
                    }
                    return {from: o, to: Math.max(a, o + 1)}
                }

                function w(e) {
                    var t = e.display, n = t.view;
                    if (t.alignWidgets || t.gutters.firstChild && e.options.fixedGutter) {
                        for (var r = C(t) - t.scroller.scrollLeft + e.doc.scrollLeft, i = t.gutters.offsetWidth,
                                 o = r + "px", a = 0; a < n.length; a++)if (!n[a].hidden) {
                            e.options.fixedGutter && n[a].gutter && (n[a].gutter.style.left = o);
                            var l = n[a].alignable;
                            if (l)for (var s = 0; s < l.length; s++)l[s].style.left = o
                        }
                        e.options.fixedGutter && (t.gutters.style.left = r + i + "px")
                    }
                }

                function k(e) {
                    if (!e.options.lineNumbers)return !1;
                    var t = e.doc, n = S(e.options, t.first + t.size - 1), r = e.display;
                    if (n.length != r.lineNumChars) {
                        var i = r.measure.appendChild(ji("div", [ji("div", n)], "CodeMirror-linenumber CodeMirror-gutter-elt")),
                            o = i.firstChild.offsetWidth, a = i.offsetWidth - o;
                        return r.lineGutter.style.width = "", r.lineNumInnerWidth = Math.max(o, r.lineGutter.offsetWidth - a) + 1, r.lineNumWidth = r.lineNumInnerWidth + a, r.lineNumChars = r.lineNumInnerWidth ? n.length : -1, r.lineGutter.style.width = r.lineNumWidth + "px", u(e), !0
                    }
                    return !1
                }

                function S(e, t) {
                    return String(e.lineNumberFormatter(t + e.firstLineNumber))
                }

                function C(e) {
                    return e.scroller.getBoundingClientRect().left - e.sizer.getBoundingClientRect().left
                }

                function L(e, t, n) {
                    var r = e.display;
                    this.viewport = t, this.visible = b(r, e.doc, t), this.editorIsHidden = !r.wrapper.offsetWidth, this.wrapperHeight = r.wrapper.clientHeight, this.wrapperWidth = r.wrapper.clientWidth, this.oldDisplayWidth = $e(e), this.force = n, this.dims = P(e), this.events = []
                }

                function T(e) {
                    var t = e.display;
                    !t.scrollbarsClipped && t.scroller.offsetWidth && (t.nativeBarWidth = t.scroller.offsetWidth - t.scroller.clientWidth, t.heightForcer.style.height = Ye(e) + "px", t.sizer.style.marginBottom = -t.nativeBarWidth + "px", t.sizer.style.borderRightWidth = Ye(e) + "px", t.scrollbarsClipped = !0)
                }

                function M(e, t) {
                    var n = e.display, r = e.doc;
                    if (t.editorIsHidden)return Wt(e), !1;
                    if (!t.force && t.visible.from >= n.viewFrom && t.visible.to <= n.viewTo && (null == n.updateLineNumbers || n.updateLineNumbers >= n.viewTo) && n.renderedView == n.view && 0 == zt(e))return !1;
                    k(e) && (Wt(e), t.dims = P(e));
                    var i = r.first + r.size, o = Math.max(t.visible.from - e.options.viewportMargin, r.first),
                        a = Math.min(i, t.visible.to + e.options.viewportMargin);
                    n.viewFrom < o && o - n.viewFrom < 20 && (o = Math.max(r.first, n.viewFrom)), n.viewTo > a && n.viewTo - a < 20 && (a = Math.min(i, n.viewTo)), Wo && (o = br(e.doc, o), a = wr(e.doc, a));
                    var l = o != n.viewFrom || a != n.viewTo || n.lastWrapHeight != t.wrapperHeight || n.lastWrapWidth != t.wrapperWidth;
                    Ft(e, o, a), n.viewOffset = ri(Zr(e.doc, n.viewFrom)), e.display.mover.style.top = n.viewOffset + "px";
                    var s = zt(e);
                    if (!l && 0 == s && !t.force && n.renderedView == n.view && (null == n.updateLineNumbers || n.updateLineNumbers >= n.viewTo))return !1;
                    var c = Gi();
                    return s > 4 && (n.lineDiv.style.display = "none"), R(e, n.updateLineNumbers, t.dims), s > 4 && (n.lineDiv.style.display = ""), n.renderedView = n.view, c && Gi() != c && c.offsetHeight && c.focus(), Ui(n.cursorDiv), Ui(n.selectionDiv), n.gutters.style.height = n.sizer.style.minHeight = 0, l && (n.lastWrapHeight = t.wrapperHeight, n.lastWrapWidth = t.wrapperWidth, _e(e, 400)), n.updateLineNumbers = null, !0
                }

                function N(e, t) {
                    for (var n = t.viewport,
                             r = !0; (r && e.options.lineWrapping && t.oldDisplayWidth != $e(e) || (n && null != n.top && (n = {top: Math.min(e.doc.height + qe(e.display) - Ve(e), n.top)}), t.visible = b(e.display, e.doc, n), !(t.visible.from >= e.display.viewFrom && t.visible.to <= e.display.viewTo))) && M(e, t); r = !1) {
                        O(e);
                        var i = p(e);
                        Re(e), y(e, i), E(e, i)
                    }
                    t.signal(e, "update", e), e.display.viewFrom == e.display.reportedViewFrom && e.display.viewTo == e.display.reportedViewTo || (t.signal(e, "viewportChange", e, e.display.viewFrom, e.display.viewTo), e.display.reportedViewFrom = e.display.viewFrom, e.display.reportedViewTo = e.display.viewTo)
                }

                function A(e, t) {
                    var n = new L(e, t);
                    if (M(e, n)) {
                        O(e), N(e, n);
                        var r = p(e);
                        Re(e), y(e, r), E(e, r), n.finish()
                    }
                }

                function E(e, t) {
                    e.display.sizer.style.minHeight = t.docHeight + "px", e.display.heightForcer.style.top = t.docHeight + "px", e.display.gutters.style.height = t.docHeight + e.display.barHeight + Ye(e) + "px"
                }

                function O(e) {
                    for (var t = e.display, n = t.lineDiv.offsetTop, r = 0; r < t.view.length; r++) {
                        var i, o = t.view[r];
                        if (!o.hidden) {
                            if (xo && 8 > bo) {
                                var a = o.node.offsetTop + o.node.offsetHeight;
                                i = a - n, n = a
                            } else {
                                var l = o.node.getBoundingClientRect();
                                i = l.bottom - l.top
                            }
                            var s = o.line.height - i;
                            if (2 > i && (i = yt(t)), (s > .001 || -.001 > s) && (ei(o.line, i), I(o.line), o.rest))for (var c = 0; c < o.rest.length; c++)I(o.rest[c])
                        }
                    }
                }

                function I(e) {
                    if (e.widgets)for (var t = 0; t < e.widgets.length; ++t)e.widgets[t].height = e.widgets[t].node.parentNode.offsetHeight
                }

                function P(e) {
                    for (var t = e.display, n = {}, r = {}, i = t.gutters.clientLeft, o = t.gutters.firstChild,
                             a = 0; o; o = o.nextSibling, ++a)n[e.options.gutters[a]] = o.offsetLeft + o.clientLeft + i, r[e.options.gutters[a]] = o.clientWidth;
                    return {
                        fixedPos: C(t),
                        gutterTotalWidth: t.gutters.offsetWidth,
                        gutterLeft: n,
                        gutterWidth: r,
                        wrapperWidth: t.wrapper.clientWidth
                    }
                }

                function R(e, t, n) {
                    function r(t) {
                        var n = t.nextSibling;
                        return wo && Eo && e.display.currentWheelTarget == t ? t.style.display = "none" : t.parentNode.removeChild(t), n
                    }

                    for (var i = e.display, o = e.options.lineNumbers, a = i.lineDiv, l = a.firstChild, s = i.view,
                             c = i.viewFrom, u = 0; u < s.length; u++) {
                        var f = s[u];
                        if (f.hidden); else if (f.node && f.node.parentNode == a) {
                            for (; l != f.node;)l = r(l);
                            var h = o && null != t && c >= t && f.lineNumber;
                            f.changes && (Pi(f.changes, "gutter") > -1 && (h = !1), D(e, f, c, n)), h && (Ui(f.lineNumber), f.lineNumber.appendChild(document.createTextNode(S(e.options, c)))), l = f.node.nextSibling
                        } else {
                            var d = U(e, f, c, n);
                            a.insertBefore(d, l)
                        }
                        c += f.size
                    }
                    for (; l;)l = r(l)
                }

                function D(e, t, n, r) {
                    for (var i = 0; i < t.changes.length; i++) {
                        var o = t.changes[i];
                        "text" == o ? _(e, t) : "gutter" == o ? z(e, t, n, r) : "class" == o ? F(t) : "widget" == o && j(e, t, r)
                    }
                    t.changes = null
                }

                function H(e) {
                    return e.node == e.text && (e.node = ji("div", null, null, "position: relative"), e.text.parentNode && e.text.parentNode.replaceChild(e.node, e.text), e.node.appendChild(e.text), xo && 8 > bo && (e.node.style.zIndex = 2)), e.node
                }

                function W(e) {
                    var t = e.bgClass ? e.bgClass + " " + (e.line.bgClass || "") : e.line.bgClass;
                    if (t && (t += " CodeMirror-linebackground"), e.background) t ? e.background.className = t : (e.background.parentNode.removeChild(e.background), e.background = null); else if (t) {
                        var n = H(e);
                        e.background = n.insertBefore(ji("div", null, t), n.firstChild)
                    }
                }

                function B(e, t) {
                    var n = e.display.externalMeasured;
                    return n && n.line == t.line ? (e.display.externalMeasured = null, t.measure = n.measure, n.built) : Br(e, t)
                }

                function _(e, t) {
                    var n = t.text.className, r = B(e, t);
                    t.text == t.node && (t.node = r.pre), t.text.parentNode.replaceChild(r.pre, t.text), t.text = r.pre, r.bgClass != t.bgClass || r.textClass != t.textClass ? (t.bgClass = r.bgClass, t.textClass = r.textClass, F(t)) : n && (t.text.className = n)
                }

                function F(e) {
                    W(e), e.line.wrapClass ? H(e).className = e.line.wrapClass : e.node != e.text && (e.node.className = "");
                    var t = e.textClass ? e.textClass + " " + (e.line.textClass || "") : e.line.textClass;
                    e.text.className = t || ""
                }

                function z(e, t, n, r) {
                    if (t.gutter && (t.node.removeChild(t.gutter), t.gutter = null), t.gutterBackground && (t.node.removeChild(t.gutterBackground), t.gutterBackground = null), t.line.gutterClass) {
                        var i = H(t);
                        t.gutterBackground = ji("div", null, "CodeMirror-gutter-background " + t.line.gutterClass, "left: " + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px; width: " + r.gutterTotalWidth + "px"), i.insertBefore(t.gutterBackground, t.text)
                    }
                    var o = t.line.gutterMarkers;
                    if (e.options.lineNumbers || o) {
                        var i = H(t),
                            a = t.gutter = ji("div", null, "CodeMirror-gutter-wrapper", "left: " + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px");
                        if (e.display.input.setUneditable(a), i.insertBefore(a, t.text), t.line.gutterClass && (a.className += " " + t.line.gutterClass), !e.options.lineNumbers || o && o["CodeMirror-linenumbers"] || (t.lineNumber = a.appendChild(ji("div", S(e.options, n), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + r.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + e.display.lineNumInnerWidth + "px"))), o)for (var l = 0; l < e.options.gutters.length; ++l) {
                            var s = e.options.gutters[l], c = o.hasOwnProperty(s) && o[s];
                            c && a.appendChild(ji("div", [c], "CodeMirror-gutter-elt", "left: " + r.gutterLeft[s] + "px; width: " + r.gutterWidth[s] + "px"))
                        }
                    }
                }

                function j(e, t, n) {
                    t.alignable && (t.alignable = null);
                    for (var r, i = t.node.firstChild; i; i = r) {
                        var r = i.nextSibling;
                        "CodeMirror-linewidget" == i.className && t.node.removeChild(i)
                    }
                    q(e, t, n)
                }

                function U(e, t, n, r) {
                    var i = B(e, t);
                    return t.text = t.node = i.pre, i.bgClass && (t.bgClass = i.bgClass), i.textClass && (t.textClass = i.textClass), F(t), z(e, t, n, r), q(e, t, r), t.node
                }

                function q(e, t, n) {
                    if (G(e, t.line, t, n, !0), t.rest)for (var r = 0; r < t.rest.length; r++)G(e, t.rest[r], t, n, !1)
                }

                function G(e, t, n, r, i) {
                    if (t.widgets)for (var o = H(n), a = 0, l = t.widgets; a < l.length; ++a) {
                        var s = l[a], c = ji("div", [s.node], "CodeMirror-linewidget");
                        s.handleMouseEvents || c.setAttribute("cm-ignore-events", "true"), Y(s, c, n, r), e.display.input.setUneditable(c), i && s.above ? o.insertBefore(c, n.gutter || n.text) : o.appendChild(c), Ci(s, "redraw")
                    }
                }

                function Y(e, t, n, r) {
                    if (e.noHScroll) {
                        (n.alignable || (n.alignable = [])).push(t);
                        var i = r.wrapperWidth;
                        t.style.left = r.fixedPos + "px", e.coverGutter || (i -= r.gutterTotalWidth, t.style.paddingLeft = r.gutterTotalWidth + "px"), t.style.width = i + "px"
                    }
                    e.coverGutter && (t.style.zIndex = 5, t.style.position = "relative", e.noHScroll || (t.style.marginLeft = -r.gutterTotalWidth + "px"))
                }

                function $(e) {
                    return Bo(e.line, e.ch)
                }

                function V(e, t) {
                    return _o(e, t) < 0 ? t : e
                }

                function K(e, t) {
                    return _o(e, t) < 0 ? e : t
                }

                function X(e) {
                    e.state.focused || (e.display.input.focus(), vn(e))
                }

                function Z(e, t, n, r, i) {
                    var o = e.doc;
                    e.display.shift = !1, r || (r = o.sel);
                    var a = e.state.pasteIncoming || "paste" == i, l = o.splitLines(t), s = null;
                    if (a && r.ranges.length > 1)if (Fo && Fo.text.join("\n") == t) {
                        if (r.ranges.length % Fo.text.length == 0) {
                            s = [];
                            for (var c = 0; c < Fo.text.length; c++)s.push(o.splitLines(Fo.text[c]))
                        }
                    } else l.length == r.ranges.length && (s = Ri(l, function (e) {
                        return [e]
                    }));
                    for (var c = r.ranges.length - 1; c >= 0; c--) {
                        var u = r.ranges[c], f = u.from(), h = u.to();
                        u.empty() && (n && n > 0 ? f = Bo(f.line, f.ch - n) : e.state.overwrite && !a ? h = Bo(h.line, Math.min(Zr(o, h.line).text.length, h.ch + Ii(l).length)) : Fo && Fo.lineWise && Fo.text.join("\n") == t && (f = h = Bo(f.line, 0)));
                        var d = e.curOp.updateInput, p = {
                            from: f,
                            to: h,
                            text: s ? s[c % s.length] : l,
                            origin: i || (a ? "paste" : e.state.cutIncoming ? "cut" : "+input")
                        };
                        Tn(e.doc, p), Ci(e, "inputRead", e, p)
                    }
                    t && !a && Q(e, t), Bn(e), e.curOp.updateInput = d, e.curOp.typing = !0, e.state.pasteIncoming = e.state.cutIncoming = !1
                }

                function J(e, t) {
                    var n = e.clipboardData && e.clipboardData.getData("text/plain");
                    return n ? (e.preventDefault(), t.isReadOnly() || t.options.disableInput || At(t, function () {
                        Z(t, n, 0, null, "paste")
                    }), !0) : void 0
                }

                function Q(e, t) {
                    if (e.options.electricChars && e.options.smartIndent)for (var n = e.doc.sel,
                                                                                  r = n.ranges.length - 1; r >= 0; r--) {
                        var i = n.ranges[r];
                        if (!(i.head.ch > 100 || r && n.ranges[r - 1].head.line == i.head.line)) {
                            var o = e.getModeAt(i.head), a = !1;
                            if (o.electricChars) {
                                for (var l = 0; l < o.electricChars.length; l++)if (t.indexOf(o.electricChars.charAt(l)) > -1) {
                                    a = Fn(e, i.head.line, "smart");
                                    break
                                }
                            } else o.electricInput && o.electricInput.test(Zr(e.doc, i.head.line).text.slice(0, i.head.ch)) && (a = Fn(e, i.head.line, "smart"));
                            a && Ci(e, "electricInput", e, i.head.line)
                        }
                    }
                }

                function ee(e) {
                    for (var t = [], n = [], r = 0; r < e.doc.sel.ranges.length; r++) {
                        var i = e.doc.sel.ranges[r].head.line, o = {anchor: Bo(i, 0), head: Bo(i + 1, 0)};
                        n.push(o), t.push(e.getRange(o.anchor, o.head))
                    }
                    return {text: t, ranges: n}
                }

                function te(e) {
                    e.setAttribute("autocorrect", "off"), e.setAttribute("autocapitalize", "off"), e.setAttribute("spellcheck", "false")
                }

                function ne(e) {
                    this.cm = e, this.prevInput = "", this.pollingFast = !1, this.polling = new Ei, this.inaccurateSelection = !1, this.hasSelection = !1, this.composing = null
                }

                function re() {
                    var e = ji("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none"),
                        t = ji("div", [e], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
                    return wo ? e.style.width = "1000px" : e.setAttribute("wrap", "off"), No && (e.style.border = "1px solid black"), te(e), t
                }

                function ie(e) {
                    this.cm = e, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new Ei, this.gracePeriod = !1
                }

                function oe(e, t) {
                    var n = Qe(e, t.line);
                    if (!n || n.hidden)return null;
                    var r = Zr(e.doc, t.line), i = Xe(n, r, t.line), o = ii(r), a = "left";
                    if (o) {
                        var l = co(o, t.ch);
                        a = l % 2 ? "right" : "left"
                    }
                    var s = nt(i.map, t.ch, a);
                    return s.offset = "right" == s.collapse ? s.end : s.start, s
                }

                function ae(e, t) {
                    return t && (e.bad = !0), e
                }

                function le(e, t, n) {
                    var r;
                    if (t == e.display.lineDiv) {
                        if (r = e.display.lineDiv.childNodes[n], !r)return ae(e.clipPos(Bo(e.display.viewTo - 1)), !0);
                        t = null, n = 0
                    } else for (r = t; ; r = r.parentNode) {
                        if (!r || r == e.display.lineDiv)return null;
                        if (r.parentNode && r.parentNode == e.display.lineDiv)break
                    }
                    for (var i = 0; i < e.display.view.length; i++) {
                        var o = e.display.view[i];
                        if (o.node == r)return se(o, t, n)
                    }
                }

                function se(e, t, n) {
                    function r(t, n, r) {
                        for (var i = -1; i < (u ? u.length : 0); i++)for (var o = 0 > i ? c.map : u[i],
                                                                              a = 0; a < o.length; a += 3) {
                            var l = o[a + 2];
                            if (l == t || l == n) {
                                var s = ti(0 > i ? e.line : e.rest[i]), f = o[a] + r;
                                return (0 > r || l != t) && (f = o[a + (r ? 1 : 0)]), Bo(s, f)
                            }
                        }
                    }

                    var i = e.text.firstChild, o = !1;
                    if (!t || !Va(i, t))return ae(Bo(ti(e.line), 0), !0);
                    if (t == i && (o = !0, t = i.childNodes[n], n = 0, !t)) {
                        var a = e.rest ? Ii(e.rest) : e.line;
                        return ae(Bo(ti(a), a.text.length), o)
                    }
                    var l = 3 == t.nodeType ? t : null, s = t;
                    for (l || 1 != t.childNodes.length || 3 != t.firstChild.nodeType || (l = t.firstChild, n && (n = l.nodeValue.length)); s.parentNode != i;)s = s.parentNode;
                    var c = e.measure, u = c.maps, f = r(l, s, n);
                    if (f)return ae(f, o);
                    for (var h = s.nextSibling, d = l ? l.nodeValue.length - n : 0; h; h = h.nextSibling) {
                        if (f = r(h, h.firstChild, 0))return ae(Bo(f.line, f.ch - d), o);
                        d += h.textContent.length
                    }
                    for (var p = s.previousSibling, d = n; p; p = p.previousSibling) {
                        if (f = r(p, p.firstChild, -1))return ae(Bo(f.line, f.ch + d), o);
                        d += h.textContent.length
                    }
                }

                function ce(e, t, n, r, i) {
                    function o(e) {
                        return function (t) {
                            return t.id == e
                        }
                    }

                    function a(t) {
                        if (1 == t.nodeType) {
                            var n = t.getAttribute("cm-text");
                            if (null != n)return "" == n && (n = t.textContent.replace(/\u200b/g, "")), void(l += n);
                            var u, f = t.getAttribute("cm-marker");
                            if (f) {
                                var h = e.findMarks(Bo(r, 0), Bo(i + 1, 0), o(+f));
                                return void(h.length && (u = h[0].find()) && (l += Jr(e.doc, u.from, u.to).join(c)))
                            }
                            if ("false" == t.getAttribute("contenteditable"))return;
                            for (var d = 0; d < t.childNodes.length; d++)a(t.childNodes[d]);
                            /^(pre|div|p)$/i.test(t.nodeName) && (s = !0)
                        } else if (3 == t.nodeType) {
                            var p = t.nodeValue;
                            if (!p)return;
                            s && (l += c, s = !1), l += p
                        }
                    }

                    for (var l = "", s = !1, c = e.doc.lineSeparator(); a(t), t != n;)t = t.nextSibling;
                    return l
                }

                function ue(e, t) {
                    this.ranges = e, this.primIndex = t
                }

                function fe(e, t) {
                    this.anchor = e, this.head = t
                }

                function he(e, t) {
                    var n = e[t];
                    e.sort(function (e, t) {
                        return _o(e.from(), t.from())
                    }), t = Pi(e, n);
                    for (var r = 1; r < e.length; r++) {
                        var i = e[r], o = e[r - 1];
                        if (_o(o.to(), i.from()) >= 0) {
                            var a = K(o.from(), i.from()), l = V(o.to(), i.to()),
                                s = o.empty() ? i.from() == i.head : o.from() == o.head;
                            t >= r && --t, e.splice(--r, 2, new fe(s ? l : a, s ? a : l))
                        }
                    }
                    return new ue(e, t)
                }

                function de(e, t) {
                    return new ue([new fe(e, t || e)], 0)
                }

                function pe(e, t) {
                    return Math.max(e.first, Math.min(t, e.first + e.size - 1))
                }

                function me(e, t) {
                    if (t.line < e.first)return Bo(e.first, 0);
                    var n = e.first + e.size - 1;
                    return t.line > n ? Bo(n, Zr(e, n).text.length) : ge(t, Zr(e, t.line).text.length)
                }

                function ge(e, t) {
                    var n = e.ch;
                    return null == n || n > t ? Bo(e.line, t) : 0 > n ? Bo(e.line, 0) : e
                }

                function ve(e, t) {
                    return t >= e.first && t < e.first + e.size
                }

                function ye(e, t) {
                    for (var n = [], r = 0; r < t.length; r++)n[r] = me(e, t[r]);
                    return n
                }

                function xe(e, t, n, r) {
                    if (e.cm && e.cm.display.shift || e.extend) {
                        var i = t.anchor;
                        if (r) {
                            var o = _o(n, i) < 0;
                            o != _o(r, i) < 0 ? (i = n, n = r) : o != _o(n, r) < 0 && (n = r)
                        }
                        return new fe(i, n)
                    }
                    return new fe(r || n, n)
                }

                function be(e, t, n, r) {
                    Te(e, new ue([xe(e, e.sel.primary(), t, n)], 0), r)
                }

                function we(e, t, n) {
                    for (var r = [], i = 0; i < e.sel.ranges.length; i++)r[i] = xe(e, e.sel.ranges[i], t[i], null);
                    var o = he(r, e.sel.primIndex);
                    Te(e, o, n)
                }

                function ke(e, t, n, r) {
                    var i = e.sel.ranges.slice(0);
                    i[t] = n, Te(e, he(i, e.sel.primIndex), r)
                }

                function Se(e, t, n, r) {
                    Te(e, de(t, n), r)
                }

                function Ce(e, t, n) {
                    var r = {
                        ranges: t.ranges, update: function (t) {
                            this.ranges = [];
                            for (var n = 0; n < t.length; n++)this.ranges[n] = new fe(me(e, t[n].anchor), me(e, t[n].head))
                        }, origin: n && n.origin
                    };
                    return Pa(e, "beforeSelectionChange", e, r), e.cm && Pa(e.cm, "beforeSelectionChange", e.cm, r), r.ranges != t.ranges ? he(r.ranges, r.ranges.length - 1) : t
                }

                function Le(e, t, n) {
                    var r = e.history.done, i = Ii(r);
                    i && i.ranges ? (r[r.length - 1] = t, Me(e, t, n)) : Te(e, t, n)
                }

                function Te(e, t, n) {
                    Me(e, t, n), fi(e, e.sel, e.cm ? e.cm.curOp.id : NaN, n)
                }

                function Me(e, t, n) {
                    (Ni(e, "beforeSelectionChange") || e.cm && Ni(e.cm, "beforeSelectionChange")) && (t = Ce(e, t, n));
                    var r = n && n.bias || (_o(t.primary().head, e.sel.primary().head) < 0 ? -1 : 1);
                    Ne(e, Ee(e, t, r, !0)), n && n.scroll === !1 || !e.cm || Bn(e.cm)
                }

                function Ne(e, t) {
                    t.equals(e.sel) || (e.sel = t, e.cm && (e.cm.curOp.updateInput = e.cm.curOp.selectionChanged = !0, Mi(e.cm)), Ci(e, "cursorActivity", e))
                }

                function Ae(e) {
                    Ne(e, Ee(e, e.sel, null, !1), Wa)
                }

                function Ee(e, t, n, r) {
                    for (var i, o = 0; o < t.ranges.length; o++) {
                        var a = t.ranges[o], l = t.ranges.length == e.sel.ranges.length && e.sel.ranges[o],
                            s = Ie(e, a.anchor, l && l.anchor, n, r), c = Ie(e, a.head, l && l.head, n, r);
                        (i || s != a.anchor || c != a.head) && (i || (i = t.ranges.slice(0, o)), i[o] = new fe(s, c))
                    }
                    return i ? he(i, t.primIndex) : t
                }

                function Oe(e, t, n, r, i) {
                    var o = Zr(e, t.line);
                    if (o.markedSpans)for (var a = 0; a < o.markedSpans.length; ++a) {
                        var l = o.markedSpans[a], s = l.marker;
                        if ((null == l.from || (s.inclusiveLeft ? l.from <= t.ch : l.from < t.ch)) && (null == l.to || (s.inclusiveRight ? l.to >= t.ch : l.to > t.ch))) {
                            if (i && (Pa(s, "beforeCursorEnter"), s.explicitlyCleared)) {
                                if (o.markedSpans) {
                                    --a;
                                    continue
                                }
                                break
                            }
                            if (!s.atomic)continue;
                            if (n) {
                                var c, u = s.find(0 > r ? 1 : -1);
                                if ((0 > r ? s.inclusiveRight : s.inclusiveLeft) && (u = Pe(e, u, -r, u && u.line == t.line ? o : null)), u && u.line == t.line && (c = _o(u, n)) && (0 > r ? 0 > c : c > 0))return Oe(e, u, t, r, i)
                            }
                            var f = s.find(0 > r ? -1 : 1);
                            return (0 > r ? s.inclusiveLeft : s.inclusiveRight) && (f = Pe(e, f, r, f.line == t.line ? o : null)), f ? Oe(e, f, t, r, i) : null
                        }
                    }
                    return t
                }

                function Ie(e, t, n, r, i) {
                    var o = r || 1,
                        a = Oe(e, t, n, o, i) || !i && Oe(e, t, n, o, !0) || Oe(e, t, n, -o, i) || !i && Oe(e, t, n, -o, !0);
                    return a ? a : (e.cantEdit = !0, Bo(e.first, 0))
                }

                function Pe(e, t, n, r) {
                    return 0 > n && 0 == t.ch ? t.line > e.first ? me(e, Bo(t.line - 1)) : null : n > 0 && t.ch == (r || Zr(e, t.line)).text.length ? t.line < e.first + e.size - 1 ? Bo(t.line + 1, 0) : null : new Bo(t.line, t.ch + n)
                }

                function Re(e) {
                    e.display.input.showSelection(e.display.input.prepareSelection())
                }

                function De(e, t) {
                    for (var n = e.doc, r = {}, i = r.cursors = document.createDocumentFragment(),
                             o = r.selection = document.createDocumentFragment(),
                             a = 0; a < n.sel.ranges.length; a++)if (t !== !1 || a != n.sel.primIndex) {
                        var l = n.sel.ranges[a];
                        if (!(l.from().line >= e.display.viewTo || l.to().line < e.display.viewFrom)) {
                            var s = l.empty();
                            (s || e.options.showCursorWhenSelecting) && He(e, l.head, i), s || We(e, l, o)
                        }
                    }
                    return r
                }

                function He(e, t, n) {
                    var r = dt(e, t, "div", null, null, !e.options.singleCursorHeightPerLine),
                        i = n.appendChild(ji("div", "", "CodeMirror-cursor"));
                    if (i.style.left = r.left + "px", i.style.top = r.top + "px", i.style.height = Math.max(0, r.bottom - r.top) * e.options.cursorHeight + "px", r.other) {
                        var o = n.appendChild(ji("div", "", "CodeMirror-cursor CodeMirror-secondarycursor"));
                        o.style.display = "", o.style.left = r.other.left + "px", o.style.top = r.other.top + "px", o.style.height = .85 * (r.other.bottom - r.other.top) + "px"
                    }
                }

                function We(e, t, n) {
                    function r(e, t, n, r) {
                        0 > t && (t = 0), t = Math.round(t), r = Math.round(r), l.appendChild(ji("div", null, "CodeMirror-selected", "position: absolute; left: " + e + "px; top: " + t + "px; width: " + (null == n ? u - e : n) + "px; height: " + (r - t) + "px"))
                    }

                    function i(t, n, i) {
                        function o(n, r) {
                            return ht(e, Bo(t, n), "div", f, r)
                        }

                        var l, s, f = Zr(a, t), h = f.text.length;
                        return eo(ii(f), n || 0, null == i ? h : i, function (e, t, a) {
                            var f, d, p, m = o(e, "left");
                            if (e == t) f = m, d = p = m.left; else {
                                if (f = o(t - 1, "right"), "rtl" == a) {
                                    var g = m;
                                    m = f, f = g
                                }
                                d = m.left, p = f.right
                            }
                            null == n && 0 == e && (d = c), f.top - m.top > 3 && (r(d, m.top, null, m.bottom), d = c, m.bottom < f.top && r(d, m.bottom, null, f.top)), null == i && t == h && (p = u), (!l || m.top < l.top || m.top == l.top && m.left < l.left) && (l = m), (!s || f.bottom > s.bottom || f.bottom == s.bottom && f.right > s.right) && (s = f), c + 1 > d && (d = c), r(d, f.top, p - d, f.bottom)
                        }), {start: l, end: s}
                    }

                    var o = e.display, a = e.doc, l = document.createDocumentFragment(), s = Ge(e.display), c = s.left,
                        u = Math.max(o.sizerWidth, $e(e) - o.sizer.offsetLeft) - s.right, f = t.from(), h = t.to();
                    if (f.line == h.line) i(f.line, f.ch, h.ch); else {
                        var d = Zr(a, f.line), p = Zr(a, h.line), m = yr(d) == yr(p),
                            g = i(f.line, f.ch, m ? d.text.length + 1 : null).end,
                            v = i(h.line, m ? 0 : null, h.ch).start;
                        m && (g.top < v.top - 2 ? (r(g.right, g.top, null, g.bottom), r(c, v.top, v.left, v.bottom)) : r(g.right, g.top, v.left - g.right, g.bottom)), g.bottom < v.top && r(c, g.bottom, null, v.top)
                    }
                    n.appendChild(l)
                }

                function Be(e) {
                    if (e.state.focused) {
                        var t = e.display;
                        clearInterval(t.blinker);
                        var n = !0;
                        t.cursorDiv.style.visibility = "", e.options.cursorBlinkRate > 0 ? t.blinker = setInterval(function () {
                            t.cursorDiv.style.visibility = (n = !n) ? "" : "hidden"
                        }, e.options.cursorBlinkRate) : e.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = "hidden")
                    }
                }

                function _e(e, t) {
                    e.doc.mode.startState && e.doc.frontier < e.display.viewTo && e.state.highlight.set(t, Bi(Fe, e))
                }

                function Fe(e) {
                    var t = e.doc;
                    if (t.frontier < t.first && (t.frontier = t.first), !(t.frontier >= e.display.viewTo)) {
                        var n = +new Date + e.options.workTime, r = sa(t.mode, je(e, t.frontier)), i = [];
                        t.iter(t.frontier, Math.min(t.first + t.size, e.display.viewTo + 500), function (o) {
                            if (t.frontier >= e.display.viewFrom) {
                                var a = o.styles, l = o.text.length > e.options.maxHighlightLength,
                                    s = Rr(e, o, l ? sa(t.mode, r) : r, !0);
                                o.styles = s.styles;
                                var c = o.styleClasses, u = s.classes;
                                u ? o.styleClasses = u : c && (o.styleClasses = null);
                                for (var f = !a || a.length != o.styles.length || c != u && (!c || !u || c.bgClass != u.bgClass || c.textClass != u.textClass),
                                         h = 0; !f && h < a.length; ++h)f = a[h] != o.styles[h];
                                f && i.push(t.frontier), o.stateAfter = l ? r : sa(t.mode, r)
                            } else o.text.length <= e.options.maxHighlightLength && Hr(e, o.text, r), o.stateAfter = t.frontier % 5 == 0 ? sa(t.mode, r) : null;
                            return ++t.frontier, +new Date > n ? (_e(e, e.options.workDelay), !0) : void 0
                        }), i.length && At(e, function () {
                            for (var t = 0; t < i.length; t++)Ht(e, i[t], "text")
                        })
                    }
                }

                function ze(e, t, n) {
                    for (var r, i, o = e.doc, a = n ? -1 : t - (e.doc.mode.innerMode ? 1e3 : 100), l = t; l > a; --l) {
                        if (l <= o.first)return o.first;
                        var s = Zr(o, l - 1);
                        if (s.stateAfter && (!n || l <= o.frontier))return l;
                        var c = Fa(s.text, null, e.options.tabSize);
                        (null == i || r > c) && (i = l - 1, r = c)
                    }
                    return i
                }

                function je(e, t, n) {
                    var r = e.doc, i = e.display;
                    if (!r.mode.startState)return !0;
                    var o = ze(e, t, n), a = o > r.first && Zr(r, o - 1).stateAfter;
                    return a = a ? sa(r.mode, a) : ca(r.mode), r.iter(o, t, function (n) {
                        Hr(e, n.text, a);
                        var l = o == t - 1 || o % 5 == 0 || o >= i.viewFrom && o < i.viewTo;
                        n.stateAfter = l ? sa(r.mode, a) : null, ++o
                    }), n && (r.frontier = o), a
                }

                function Ue(e) {
                    return e.lineSpace.offsetTop
                }

                function qe(e) {
                    return e.mover.offsetHeight - e.lineSpace.offsetHeight
                }

                function Ge(e) {
                    if (e.cachedPaddingH)return e.cachedPaddingH;
                    var t = qi(e.measure, ji("pre", "x")),
                        n = window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle,
                        r = {left: parseInt(n.paddingLeft), right: parseInt(n.paddingRight)};
                    return isNaN(r.left) || isNaN(r.right) || (e.cachedPaddingH = r), r
                }

                function Ye(e) {
                    return Da - e.display.nativeBarWidth
                }

                function $e(e) {
                    return e.display.scroller.clientWidth - Ye(e) - e.display.barWidth
                }

                function Ve(e) {
                    return e.display.scroller.clientHeight - Ye(e) - e.display.barHeight
                }

                function Ke(e, t, n) {
                    var r = e.options.lineWrapping, i = r && $e(e);
                    if (!t.measure.heights || r && t.measure.width != i) {
                        var o = t.measure.heights = [];
                        if (r) {
                            t.measure.width = i;
                            for (var a = t.text.firstChild.getClientRects(), l = 0; l < a.length - 1; l++) {
                                var s = a[l], c = a[l + 1];
                                Math.abs(s.bottom - c.bottom) > 2 && o.push((s.bottom + c.top) / 2 - n.top)
                            }
                        }
                        o.push(n.bottom - n.top)
                    }
                }

                function Xe(e, t, n) {
                    if (e.line == t)return {map: e.measure.map, cache: e.measure.cache};
                    for (var r = 0; r < e.rest.length; r++)if (e.rest[r] == t)return {
                        map: e.measure.maps[r],
                        cache: e.measure.caches[r]
                    };
                    for (var r = 0; r < e.rest.length; r++)if (ti(e.rest[r]) > n)return {
                        map: e.measure.maps[r],
                        cache: e.measure.caches[r],
                        before: !0
                    }
                }

                function Ze(e, t) {
                    t = yr(t);
                    var n = ti(t), r = e.display.externalMeasured = new Pt(e.doc, t, n);
                    r.lineN = n;
                    var i = r.built = Br(e, r);
                    return r.text = i.pre, qi(e.display.lineMeasure, i.pre), r
                }

                function Je(e, t, n, r) {
                    return tt(e, et(e, t), n, r)
                }

                function Qe(e, t) {
                    if (t >= e.display.viewFrom && t < e.display.viewTo)return e.display.view[Bt(e, t)];
                    var n = e.display.externalMeasured;
                    return n && t >= n.lineN && t < n.lineN + n.size ? n : void 0
                }

                function et(e, t) {
                    var n = ti(t), r = Qe(e, n);
                    r && !r.text ? r = null : r && r.changes && (D(e, r, n, P(e)), e.curOp.forceUpdate = !0), r || (r = Ze(e, t));
                    var i = Xe(r, t, n);
                    return {line: t, view: r, rect: null, map: i.map, cache: i.cache, before: i.before, hasHeights: !1}
                }

                function tt(e, t, n, r, i) {
                    t.before && (n = -1);
                    var o, a = n + (r || "");
                    return t.cache.hasOwnProperty(a) ? o = t.cache[a] : (t.rect || (t.rect = t.view.text.getBoundingClientRect()), t.hasHeights || (Ke(e, t.view, t.rect), t.hasHeights = !0), o = rt(e, t, n, r), o.bogus || (t.cache[a] = o)), {
                        left: o.left,
                        right: o.right,
                        top: i ? o.rtop : o.top,
                        bottom: i ? o.rbottom : o.bottom
                    }
                }

                function nt(e, t, n) {
                    for (var r, i, o, a, l = 0; l < e.length; l += 3) {
                        var s = e[l], c = e[l + 1];
                        if (s > t ? (i = 0, o = 1, a = "left") : c > t ? (i = t - s, o = i + 1) : (l == e.length - 3 || t == c && e[l + 3] > t) && (o = c - s, i = o - 1, t >= c && (a = "right")), null != i) {
                            if (r = e[l + 2], s == c && n == (r.insertLeft ? "left" : "right") && (a = n), "left" == n && 0 == i)for (; l && e[l - 2] == e[l - 3] && e[l - 1].insertLeft;)r = e[(l -= 3) + 2], a = "left";
                            if ("right" == n && i == c - s)for (; l < e.length - 3 && e[l + 3] == e[l + 4] && !e[l + 5].insertLeft;)r = e[(l += 3) + 2], a = "right";
                            break
                        }
                    }
                    return {node: r, start: i, end: o, collapse: a, coverStart: s, coverEnd: c}
                }

                function rt(e, t, n, r) {
                    var i, o = nt(t.map, n, r), a = o.node, l = o.start, s = o.end, c = o.collapse;
                    if (3 == a.nodeType) {
                        for (var u = 0; 4 > u; u++) {
                            for (; l && zi(t.line.text.charAt(o.coverStart + l));)--l;
                            for (; o.coverStart + s < o.coverEnd && zi(t.line.text.charAt(o.coverStart + s));)++s;
                            if (xo && 9 > bo && 0 == l && s == o.coverEnd - o.coverStart) i = a.parentNode.getBoundingClientRect(); else if (xo && e.options.lineWrapping) {
                                var f = qa(a, l, s).getClientRects();
                                i = f.length ? f["right" == r ? f.length - 1 : 0] : qo
                            } else i = qa(a, l, s).getBoundingClientRect() || qo;
                            if (i.left || i.right || 0 == l)break;
                            s = l, l -= 1, c = "right"
                        }
                        xo && 11 > bo && (i = it(e.display.measure, i))
                    } else {
                        l > 0 && (c = r = "right");
                        var f;
                        i = e.options.lineWrapping && (f = a.getClientRects()).length > 1 ? f["right" == r ? f.length - 1 : 0] : a.getBoundingClientRect()
                    }
                    if (xo && 9 > bo && !l && (!i || !i.left && !i.right)) {
                        var h = a.parentNode.getClientRects()[0];
                        i = h ? {left: h.left, right: h.left + xt(e.display), top: h.top, bottom: h.bottom} : qo
                    }
                    for (var d = i.top - t.rect.top, p = i.bottom - t.rect.top, m = (d + p) / 2,
                             g = t.view.measure.heights, u = 0; u < g.length - 1 && !(m < g[u]); u++);
                    var v = u ? g[u - 1] : 0, y = g[u], x = {
                        left: ("right" == c ? i.right : i.left) - t.rect.left,
                        right: ("left" == c ? i.left : i.right) - t.rect.left,
                        top: v,
                        bottom: y
                    };
                    return i.left || i.right || (x.bogus = !0), e.options.singleCursorHeightPerLine || (x.rtop = d, x.rbottom = p), x
                }

                function it(e, t) {
                    if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !Qi(e))return t;
                    var n = screen.logicalXDPI / screen.deviceXDPI, r = screen.logicalYDPI / screen.deviceYDPI;
                    return {left: t.left * n, right: t.right * n, top: t.top * r, bottom: t.bottom * r}
                }

                function ot(e) {
                    if (e.measure && (e.measure.cache = {}, e.measure.heights = null, e.rest))for (var t = 0; t < e.rest.length; t++)e.measure.caches[t] = {}
                }

                function at(e) {
                    e.display.externalMeasure = null, Ui(e.display.lineMeasure);
                    for (var t = 0; t < e.display.view.length; t++)ot(e.display.view[t])
                }

                function lt(e) {
                    at(e), e.display.cachedCharWidth = e.display.cachedTextHeight = e.display.cachedPaddingH = null, e.options.lineWrapping || (e.display.maxLineChanged = !0), e.display.lineNumChars = null
                }

                function st() {
                    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
                }

                function ct() {
                    return window.pageYOffset || (document.documentElement || document.body).scrollTop
                }

                function ut(e, t, n, r) {
                    if (t.widgets)for (var i = 0; i < t.widgets.length; ++i)if (t.widgets[i].above) {
                        var o = Lr(t.widgets[i]);
                        n.top += o, n.bottom += o
                    }
                    if ("line" == r)return n;
                    r || (r = "local");
                    var a = ri(t);
                    if ("local" == r ? a += Ue(e.display) : a -= e.display.viewOffset, "page" == r || "window" == r) {
                        var l = e.display.lineSpace.getBoundingClientRect();
                        a += l.top + ("window" == r ? 0 : ct());
                        var s = l.left + ("window" == r ? 0 : st());
                        n.left += s, n.right += s
                    }
                    return n.top += a, n.bottom += a, n
                }

                function ft(e, t, n) {
                    if ("div" == n)return t;
                    var r = t.left, i = t.top;
                    if ("page" == n) r -= st(),
                        i -= ct(); else if ("local" == n || !n) {
                        var o = e.display.sizer.getBoundingClientRect();
                        r += o.left, i += o.top
                    }
                    var a = e.display.lineSpace.getBoundingClientRect();
                    return {left: r - a.left, top: i - a.top}
                }

                function ht(e, t, n, r, i) {
                    return r || (r = Zr(e.doc, t.line)), ut(e, r, Je(e, r, t.ch, i), n)
                }

                function dt(e, t, n, r, i, o) {
                    function a(t, a) {
                        var l = tt(e, i, t, a ? "right" : "left", o);
                        return a ? l.left = l.right : l.right = l.left, ut(e, r, l, n)
                    }

                    function l(e, t) {
                        var n = s[t], r = n.level % 2;
                        return e == to(n) && t && n.level < s[t - 1].level ? (n = s[--t], e = no(n) - (n.level % 2 ? 0 : 1), r = !0) : e == no(n) && t < s.length - 1 && n.level < s[t + 1].level && (n = s[++t], e = to(n) - n.level % 2, r = !1), r && e == n.to && e > n.from ? a(e - 1) : a(e, r)
                    }

                    r = r || Zr(e.doc, t.line), i || (i = et(e, r));
                    var s = ii(r), c = t.ch;
                    if (!s)return a(c);
                    var u = co(s, c), f = l(c, u);
                    return null != al && (f.other = l(c, al)), f
                }

                function pt(e, t) {
                    var n = 0, t = me(e.doc, t);
                    e.options.lineWrapping || (n = xt(e.display) * t.ch);
                    var r = Zr(e.doc, t.line), i = ri(r) + Ue(e.display);
                    return {left: n, right: n, top: i, bottom: i + r.height}
                }

                function mt(e, t, n, r) {
                    var i = Bo(e, t);
                    return i.xRel = r, n && (i.outside = !0), i
                }

                function gt(e, t, n) {
                    var r = e.doc;
                    if (n += e.display.viewOffset, 0 > n)return mt(r.first, 0, !0, -1);
                    var i = ni(r, n), o = r.first + r.size - 1;
                    if (i > o)return mt(r.first + r.size - 1, Zr(r, o).text.length, !0, 1);
                    0 > t && (t = 0);
                    for (var a = Zr(r, i); ;) {
                        var l = vt(e, a, i, t, n), s = gr(a), c = s && s.find(0, !0);
                        if (!s || !(l.ch > c.from.ch || l.ch == c.from.ch && l.xRel > 0))return l;
                        i = ti(a = c.to.line)
                    }
                }

                function vt(e, t, n, r, i) {
                    function o(r) {
                        var i = dt(e, Bo(n, r), "line", t, c);
                        return l = !0, a > i.bottom ? i.left - s : a < i.top ? i.left + s : (l = !1, i.left)
                    }

                    var a = i - ri(t), l = !1, s = 2 * e.display.wrapper.clientWidth, c = et(e, t), u = ii(t),
                        f = t.text.length, h = ro(t), d = io(t), p = o(h), m = l, g = o(d), v = l;
                    if (r > g)return mt(n, d, v, 1);
                    for (; ;) {
                        if (u ? d == h || d == fo(t, h, 1) : 1 >= d - h) {
                            for (var y = p > r || g - r >= r - p ? h : d,
                                     x = r - (y == h ? p : g); zi(t.text.charAt(y));)++y;
                            var b = mt(n, y, y == h ? m : v, -1 > x ? -1 : x > 1 ? 1 : 0);
                            return b
                        }
                        var w = Math.ceil(f / 2), k = h + w;
                        if (u) {
                            k = h;
                            for (var S = 0; w > S; ++S)k = fo(t, k, 1)
                        }
                        var C = o(k);
                        C > r ? (d = k, g = C, (v = l) && (g += 1e3), f = w) : (h = k, p = C, m = l, f -= w)
                    }
                }

                function yt(e) {
                    if (null != e.cachedTextHeight)return e.cachedTextHeight;
                    if (null == zo) {
                        zo = ji("pre");
                        for (var t = 0; 49 > t; ++t)zo.appendChild(document.createTextNode("x")), zo.appendChild(ji("br"));
                        zo.appendChild(document.createTextNode("x"))
                    }
                    qi(e.measure, zo);
                    var n = zo.offsetHeight / 50;
                    return n > 3 && (e.cachedTextHeight = n), Ui(e.measure), n || 1
                }

                function xt(e) {
                    if (null != e.cachedCharWidth)return e.cachedCharWidth;
                    var t = ji("span", "xxxxxxxxxx"), n = ji("pre", [t]);
                    qi(e.measure, n);
                    var r = t.getBoundingClientRect(), i = (r.right - r.left) / 10;
                    return i > 2 && (e.cachedCharWidth = i), i || 10
                }

                function bt(e) {
                    e.curOp = {
                        cm: e,
                        viewChanged: !1,
                        startHeight: e.doc.height,
                        forceUpdate: !1,
                        updateInput: null,
                        typing: !1,
                        changeObjs: null,
                        cursorActivityHandlers: null,
                        cursorActivityCalled: 0,
                        selectionChanged: !1,
                        updateMaxLine: !1,
                        scrollLeft: null,
                        scrollTop: null,
                        scrollToPos: null,
                        focus: !1,
                        id: ++Yo
                    }, Go ? Go.ops.push(e.curOp) : e.curOp.ownsGroup = Go = {ops: [e.curOp], delayedCallbacks: []}
                }

                function wt(e) {
                    var t = e.delayedCallbacks, n = 0;
                    do {
                        for (; n < t.length; n++)t[n].call(null);
                        for (var r = 0; r < e.ops.length; r++) {
                            var i = e.ops[r];
                            if (i.cursorActivityHandlers)for (; i.cursorActivityCalled < i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null, i.cm)
                        }
                    } while (n < t.length)
                }

                function kt(e) {
                    var t = e.curOp, n = t.ownsGroup;
                    if (n)try {
                        wt(n)
                    } finally {
                        Go = null;
                        for (var r = 0; r < n.ops.length; r++)n.ops[r].cm.curOp = null;
                        St(n)
                    }
                }

                function St(e) {
                    for (var t = e.ops, n = 0; n < t.length; n++)Ct(t[n]);
                    for (var n = 0; n < t.length; n++)Lt(t[n]);
                    for (var n = 0; n < t.length; n++)Tt(t[n]);
                    for (var n = 0; n < t.length; n++)Mt(t[n]);
                    for (var n = 0; n < t.length; n++)Nt(t[n])
                }

                function Ct(e) {
                    var t = e.cm, n = t.display;
                    T(t), e.updateMaxLine && h(t), e.mustUpdate = e.viewChanged || e.forceUpdate || null != e.scrollTop || e.scrollToPos && (e.scrollToPos.from.line < n.viewFrom || e.scrollToPos.to.line >= n.viewTo) || n.maxLineChanged && t.options.lineWrapping, e.update = e.mustUpdate && new L(t, e.mustUpdate && {
                                top: e.scrollTop,
                                ensure: e.scrollToPos
                            }, e.forceUpdate)
                }

                function Lt(e) {
                    e.updatedDisplay = e.mustUpdate && M(e.cm, e.update)
                }

                function Tt(e) {
                    var t = e.cm, n = t.display;
                    e.updatedDisplay && O(t), e.barMeasure = p(t), n.maxLineChanged && !t.options.lineWrapping && (e.adjustWidthTo = Je(t, n.maxLine, n.maxLine.text.length).left + 3, t.display.sizerWidth = e.adjustWidthTo, e.barMeasure.scrollWidth = Math.max(n.scroller.clientWidth, n.sizer.offsetLeft + e.adjustWidthTo + Ye(t) + t.display.barWidth), e.maxScrollLeft = Math.max(0, n.sizer.offsetLeft + e.adjustWidthTo - $e(t))), (e.updatedDisplay || e.selectionChanged) && (e.preparedSelection = n.input.prepareSelection(e.focus))
                }

                function Mt(e) {
                    var t = e.cm;
                    null != e.adjustWidthTo && (t.display.sizer.style.minWidth = e.adjustWidthTo + "px", e.maxScrollLeft < t.doc.scrollLeft && on(t, Math.min(t.display.scroller.scrollLeft, e.maxScrollLeft), !0), t.display.maxLineChanged = !1);
                    var n = e.focus && e.focus == Gi() && (!document.hasFocus || document.hasFocus());
                    e.preparedSelection && t.display.input.showSelection(e.preparedSelection, n), (e.updatedDisplay || e.startHeight != t.doc.height) && y(t, e.barMeasure), e.updatedDisplay && E(t, e.barMeasure), e.selectionChanged && Be(t), t.state.focused && e.updateInput && t.display.input.reset(e.typing), n && X(e.cm)
                }

                function Nt(e) {
                    var t = e.cm, n = t.display, r = t.doc;
                    if (e.updatedDisplay && N(t, e.update), null == n.wheelStartX || null == e.scrollTop && null == e.scrollLeft && !e.scrollToPos || (n.wheelStartX = n.wheelStartY = null), null == e.scrollTop || n.scroller.scrollTop == e.scrollTop && !e.forceScroll || (r.scrollTop = Math.max(0, Math.min(n.scroller.scrollHeight - n.scroller.clientHeight, e.scrollTop)), n.scrollbars.setScrollTop(r.scrollTop), n.scroller.scrollTop = r.scrollTop), null == e.scrollLeft || n.scroller.scrollLeft == e.scrollLeft && !e.forceScroll || (r.scrollLeft = Math.max(0, Math.min(n.scroller.scrollWidth - n.scroller.clientWidth, e.scrollLeft)), n.scrollbars.setScrollLeft(r.scrollLeft), n.scroller.scrollLeft = r.scrollLeft, w(t)), e.scrollToPos) {
                        var i = Rn(t, me(r, e.scrollToPos.from), me(r, e.scrollToPos.to), e.scrollToPos.margin);
                        e.scrollToPos.isCursor && t.state.focused && Pn(t, i)
                    }
                    var o = e.maybeHiddenMarkers, a = e.maybeUnhiddenMarkers;
                    if (o)for (var l = 0; l < o.length; ++l)o[l].lines.length || Pa(o[l], "hide");
                    if (a)for (var l = 0; l < a.length; ++l)a[l].lines.length && Pa(a[l], "unhide");
                    n.wrapper.offsetHeight && (r.scrollTop = t.display.scroller.scrollTop), e.changeObjs && Pa(t, "changes", t, e.changeObjs), e.update && e.update.finish()
                }

                function At(e, t) {
                    if (e.curOp)return t();
                    bt(e);
                    try {
                        return t()
                    } finally {
                        kt(e)
                    }
                }

                function Et(e, t) {
                    return function () {
                        if (e.curOp)return t.apply(e, arguments);
                        bt(e);
                        try {
                            return t.apply(e, arguments)
                        } finally {
                            kt(e)
                        }
                    }
                }

                function Ot(e) {
                    return function () {
                        if (this.curOp)return e.apply(this, arguments);
                        bt(this);
                        try {
                            return e.apply(this, arguments)
                        } finally {
                            kt(this)
                        }
                    }
                }

                function It(e) {
                    return function () {
                        var t = this.cm;
                        if (!t || t.curOp)return e.apply(this, arguments);
                        bt(t);
                        try {
                            return e.apply(this, arguments)
                        } finally {
                            kt(t)
                        }
                    }
                }

                function Pt(e, t, n) {
                    this.line = t, this.rest = xr(t), this.size = this.rest ? ti(Ii(this.rest)) - n + 1 : 1, this.node = this.text = null, this.hidden = kr(e, t)
                }

                function Rt(e, t, n) {
                    for (var r, i = [], o = t; n > o; o = r) {
                        var a = new Pt(e.doc, Zr(e.doc, o), o);
                        r = o + a.size, i.push(a)
                    }
                    return i
                }

                function Dt(e, t, n, r) {
                    null == t && (t = e.doc.first), null == n && (n = e.doc.first + e.doc.size), r || (r = 0);
                    var i = e.display;
                    if (r && n < i.viewTo && (null == i.updateLineNumbers || i.updateLineNumbers > t) && (i.updateLineNumbers = t), e.curOp.viewChanged = !0, t >= i.viewTo) Wo && br(e.doc, t) < i.viewTo && Wt(e); else if (n <= i.viewFrom) Wo && wr(e.doc, n + r) > i.viewFrom ? Wt(e) : (i.viewFrom += r, i.viewTo += r); else if (t <= i.viewFrom && n >= i.viewTo) Wt(e); else if (t <= i.viewFrom) {
                        var o = _t(e, n, n + r, 1);
                        o ? (i.view = i.view.slice(o.index), i.viewFrom = o.lineN, i.viewTo += r) : Wt(e)
                    } else if (n >= i.viewTo) {
                        var o = _t(e, t, t, -1);
                        o ? (i.view = i.view.slice(0, o.index), i.viewTo = o.lineN) : Wt(e)
                    } else {
                        var a = _t(e, t, t, -1), l = _t(e, n, n + r, 1);
                        a && l ? (i.view = i.view.slice(0, a.index).concat(Rt(e, a.lineN, l.lineN)).concat(i.view.slice(l.index)), i.viewTo += r) : Wt(e)
                    }
                    var s = i.externalMeasured;
                    s && (n < s.lineN ? s.lineN += r : t < s.lineN + s.size && (i.externalMeasured = null))
                }

                function Ht(e, t, n) {
                    e.curOp.viewChanged = !0;
                    var r = e.display, i = e.display.externalMeasured;
                    if (i && t >= i.lineN && t < i.lineN + i.size && (r.externalMeasured = null), !(t < r.viewFrom || t >= r.viewTo)) {
                        var o = r.view[Bt(e, t)];
                        if (null != o.node) {
                            var a = o.changes || (o.changes = []);
                            -1 == Pi(a, n) && a.push(n)
                        }
                    }
                }

                function Wt(e) {
                    e.display.viewFrom = e.display.viewTo = e.doc.first, e.display.view = [], e.display.viewOffset = 0
                }

                function Bt(e, t) {
                    if (t >= e.display.viewTo)return null;
                    if (t -= e.display.viewFrom, 0 > t)return null;
                    for (var n = e.display.view, r = 0; r < n.length; r++)if (t -= n[r].size, 0 > t)return r
                }

                function _t(e, t, n, r) {
                    var i, o = Bt(e, t), a = e.display.view;
                    if (!Wo || n == e.doc.first + e.doc.size)return {index: o, lineN: n};
                    for (var l = 0, s = e.display.viewFrom; o > l; l++)s += a[l].size;
                    if (s != t) {
                        if (r > 0) {
                            if (o == a.length - 1)return null;
                            i = s + a[o].size - t, o++
                        } else i = s - t;
                        t += i, n += i
                    }
                    for (; br(e.doc, n) != n;) {
                        if (o == (0 > r ? 0 : a.length - 1))return null;
                        n += r * a[o - (0 > r ? 1 : 0)].size, o += r
                    }
                    return {index: o, lineN: n}
                }

                function Ft(e, t, n) {
                    var r = e.display, i = r.view;
                    0 == i.length || t >= r.viewTo || n <= r.viewFrom ? (r.view = Rt(e, t, n), r.viewFrom = t) : (r.viewFrom > t ? r.view = Rt(e, t, r.viewFrom).concat(r.view) : r.viewFrom < t && (r.view = r.view.slice(Bt(e, t))), r.viewFrom = t, r.viewTo < n ? r.view = r.view.concat(Rt(e, r.viewTo, n)) : r.viewTo > n && (r.view = r.view.slice(0, Bt(e, n)))), r.viewTo = n
                }

                function zt(e) {
                    for (var t = e.display.view, n = 0, r = 0; r < t.length; r++) {
                        var i = t[r];
                        i.hidden || i.node && !i.changes || ++n
                    }
                    return n
                }

                function jt(e) {
                    function t() {
                        i.activeTouch && (o = setTimeout(function () {
                            i.activeTouch = null
                        }, 1e3), a = i.activeTouch, a.end = +new Date)
                    }

                    function n(e) {
                        if (1 != e.touches.length)return !1;
                        var t = e.touches[0];
                        return t.radiusX <= 1 && t.radiusY <= 1
                    }

                    function r(e, t) {
                        if (null == t.left)return !0;
                        var n = t.left - e.left, r = t.top - e.top;
                        return n * n + r * r > 400
                    }

                    var i = e.display;
                    Ea(i.scroller, "mousedown", Et(e, $t)), xo && 11 > bo ? Ea(i.scroller, "dblclick", Et(e, function (t) {
                        if (!Ti(e, t)) {
                            var n = Yt(e, t);
                            if (n && !Jt(e, t) && !Gt(e.display, t)) {
                                Ma(t);
                                var r = e.findWordAt(n);
                                be(e.doc, r.anchor, r.head)
                            }
                        }
                    })) : Ea(i.scroller, "dblclick", function (t) {
                        Ti(e, t) || Ma(t)
                    }), Do || Ea(i.scroller, "contextmenu", function (t) {
                        xn(e, t)
                    });
                    var o, a = {end: 0};
                    Ea(i.scroller, "touchstart", function (t) {
                        if (!Ti(e, t) && !n(t)) {
                            clearTimeout(o);
                            var r = +new Date;
                            i.activeTouch = {
                                start: r,
                                moved: !1,
                                prev: r - a.end <= 300 ? a : null
                            }, 1 == t.touches.length && (i.activeTouch.left = t.touches[0].pageX, i.activeTouch.top = t.touches[0].pageY)
                        }
                    }), Ea(i.scroller, "touchmove", function () {
                        i.activeTouch && (i.activeTouch.moved = !0)
                    }), Ea(i.scroller, "touchend", function (n) {
                        var o = i.activeTouch;
                        if (o && !Gt(i, n) && null != o.left && !o.moved && new Date - o.start < 300) {
                            var a, l = e.coordsChar(i.activeTouch, "page");
                            a = !o.prev || r(o, o.prev) ? new fe(l, l) : !o.prev.prev || r(o, o.prev.prev) ? e.findWordAt(l) : new fe(Bo(l.line, 0), me(e.doc, Bo(l.line + 1, 0))), e.setSelection(a.anchor, a.head), e.focus(), Ma(n)
                        }
                        t()
                    }), Ea(i.scroller, "touchcancel", t), Ea(i.scroller, "scroll", function () {
                        i.scroller.clientHeight && (rn(e, i.scroller.scrollTop), on(e, i.scroller.scrollLeft, !0), Pa(e, "scroll", e))
                    }), Ea(i.scroller, "mousewheel", function (t) {
                        an(e, t)
                    }), Ea(i.scroller, "DOMMouseScroll", function (t) {
                        an(e, t)
                    }), Ea(i.wrapper, "scroll", function () {
                        i.wrapper.scrollTop = i.wrapper.scrollLeft = 0
                    }), i.dragFunctions = {
                        enter: function (t) {
                            Ti(e, t) || Aa(t)
                        }, over: function (t) {
                            Ti(e, t) || (tn(e, t), Aa(t))
                        }, start: function (t) {
                            en(e, t)
                        }, drop: Et(e, Qt), leave: function (t) {
                            Ti(e, t) || nn(e)
                        }
                    };
                    var l = i.input.getField();
                    Ea(l, "keyup", function (t) {
                        pn.call(e, t)
                    }), Ea(l, "keydown", Et(e, hn)), Ea(l, "keypress", Et(e, mn)), Ea(l, "focus", Bi(vn, e)), Ea(l, "blur", Bi(yn, e))
                }

                function Ut(t, n, r) {
                    var i = r && r != e.Init;
                    if (!n != !i) {
                        var o = t.display.dragFunctions, a = n ? Ea : Ia;
                        a(t.display.scroller, "dragstart", o.start), a(t.display.scroller, "dragenter", o.enter), a(t.display.scroller, "dragover", o.over), a(t.display.scroller, "dragleave", o.leave), a(t.display.scroller, "drop", o.drop)
                    }
                }

                function qt(e) {
                    var t = e.display;
                    t.lastWrapHeight == t.wrapper.clientHeight && t.lastWrapWidth == t.wrapper.clientWidth || (t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null, t.scrollbarsClipped = !1, e.setSize())
                }

                function Gt(e, t) {
                    for (var n = wi(t); n != e.wrapper; n = n.parentNode)if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == e.sizer && n != e.mover)return !0
                }

                function Yt(e, t, n, r) {
                    var i = e.display;
                    if (!n && "true" == wi(t).getAttribute("cm-not-content"))return null;
                    var o, a, l = i.lineSpace.getBoundingClientRect();
                    try {
                        o = t.clientX - l.left, a = t.clientY - l.top
                    } catch (t) {
                        return null
                    }
                    var s, c = gt(e, o, a);
                    if (r && 1 == c.xRel && (s = Zr(e.doc, c.line).text).length == c.ch) {
                        var u = Fa(s, s.length, e.options.tabSize) - s.length;
                        c = Bo(c.line, Math.max(0, Math.round((o - Ge(e.display).left) / xt(e.display)) - u))
                    }
                    return c
                }

                function $t(e) {
                    var t = this, n = t.display;
                    if (!(Ti(t, e) || n.activeTouch && n.input.supportsTouch())) {
                        if (n.shift = e.shiftKey, Gt(n, e))return void(wo || (n.scroller.draggable = !1, setTimeout(function () {
                            n.scroller.draggable = !0
                        }, 100)));
                        if (!Jt(t, e)) {
                            var r = Yt(t, e);
                            switch (window.focus(), ki(e)) {
                                case 1:
                                    t.state.selectingText ? t.state.selectingText(e) : r ? Vt(t, e, r) : wi(e) == n.scroller && Ma(e);
                                    break;
                                case 2:
                                    wo && (t.state.lastMiddleDown = +new Date), r && be(t.doc, r), setTimeout(function () {
                                        n.input.focus()
                                    }, 20), Ma(e);
                                    break;
                                case 3:
                                    Do ? xn(t, e) : gn(t)
                            }
                        }
                    }
                }

                function Vt(e, t, n) {
                    xo ? setTimeout(Bi(X, e), 0) : e.curOp.focus = Gi();
                    var r, i = +new Date;
                    Uo && Uo.time > i - 400 && 0 == _o(Uo.pos, n) ? r = "triple" : jo && jo.time > i - 400 && 0 == _o(jo.pos, n) ? (r = "double", Uo = {
                        time: i,
                        pos: n
                    }) : (r = "single", jo = {time: i, pos: n});
                    var o, a = e.doc.sel, l = Eo ? t.metaKey : t.ctrlKey;
                    e.options.dragDrop && el && !e.isReadOnly() && "single" == r && (o = a.contains(n)) > -1 && (_o((o = a.ranges[o]).from(), n) < 0 || n.xRel > 0) && (_o(o.to(), n) > 0 || n.xRel < 0) ? Kt(e, t, n, l) : Xt(e, t, n, r, l)
                }

                function Kt(e, t, n, r) {
                    var i = e.display, o = +new Date, a = Et(e, function (l) {
                        wo && (i.scroller.draggable = !1), e.state.draggingText = !1, Ia(document, "mouseup", a), Ia(i.scroller, "drop", a), Math.abs(t.clientX - l.clientX) + Math.abs(t.clientY - l.clientY) < 10 && (Ma(l), !r && +new Date - 200 < o && be(e.doc, n), wo || xo && 9 == bo ? setTimeout(function () {
                            document.body.focus(), i.input.focus()
                        }, 20) : i.input.focus())
                    });
                    wo && (i.scroller.draggable = !0), e.state.draggingText = a, i.scroller.dragDrop && i.scroller.dragDrop(), Ea(document, "mouseup", a), Ea(i.scroller, "drop", a)
                }

                function Xt(e, t, n, r, i) {
                    function o(t) {
                        if (0 != _o(g, t))if (g = t, "rect" == r) {
                            for (var i = [], o = e.options.tabSize, a = Fa(Zr(c, n.line).text, n.ch, o),
                                     l = Fa(Zr(c, t.line).text, t.ch, o), s = Math.min(a, l), d = Math.max(a, l),
                                     p = Math.min(n.line, t.line),
                                     m = Math.min(e.lastLine(), Math.max(n.line, t.line)); m >= p; p++) {
                                var v = Zr(c, p).text, y = za(v, s, o);
                                s == d ? i.push(new fe(Bo(p, y), Bo(p, y))) : v.length > y && i.push(new fe(Bo(p, y), Bo(p, za(v, d, o))))
                            }
                            i.length || i.push(new fe(n, n)), Te(c, he(h.ranges.slice(0, f).concat(i), f), {
                                origin: "*mouse",
                                scroll: !1
                            }), e.scrollIntoView(t)
                        } else {
                            var x = u, b = x.anchor, w = t;
                            if ("single" != r) {
                                if ("double" == r)var k = e.findWordAt(t); else var k = new fe(Bo(t.line, 0), me(c, Bo(t.line + 1, 0)));
                                _o(k.anchor, b) > 0 ? (w = k.head, b = K(x.from(), k.anchor)) : (w = k.anchor, b = V(x.to(), k.head))
                            }
                            var i = h.ranges.slice(0);
                            i[f] = new fe(me(c, b), w), Te(c, he(i, f), Ba)
                        }
                    }

                    function a(t) {
                        var n = ++y, i = Yt(e, t, !0, "rect" == r);
                        if (i)if (0 != _o(i, g)) {
                            e.curOp.focus = Gi(), o(i);
                            var l = b(s, c);
                            (i.line >= l.to || i.line < l.from) && setTimeout(Et(e, function () {
                                y == n && a(t)
                            }), 150)
                        } else {
                            var u = t.clientY < v.top ? -20 : t.clientY > v.bottom ? 20 : 0;
                            u && setTimeout(Et(e, function () {
                                y == n && (s.scroller.scrollTop += u, a(t))
                            }), 50)
                        }
                    }

                    function l(t) {
                        e.state.selectingText = !1, y = 1 / 0, Ma(t), s.input.focus(), Ia(document, "mousemove", x), Ia(document, "mouseup", w), c.history.lastSelOrigin = null
                    }

                    var s = e.display, c = e.doc;
                    Ma(t);
                    var u, f, h = c.sel, d = h.ranges;
                    if (i && !t.shiftKey ? (f = c.sel.contains(n), u = f > -1 ? d[f] : new fe(n, n)) : (u = c.sel.primary(), f = c.sel.primIndex), Oo ? t.shiftKey && t.metaKey : t.altKey) r = "rect", i || (u = new fe(n, n)), n = Yt(e, t, !0, !0), f = -1; else if ("double" == r) {
                        var p = e.findWordAt(n);
                        u = e.display.shift || c.extend ? xe(c, u, p.anchor, p.head) : p
                    } else if ("triple" == r) {
                        var m = new fe(Bo(n.line, 0), me(c, Bo(n.line + 1, 0)));
                        u = e.display.shift || c.extend ? xe(c, u, m.anchor, m.head) : m
                    } else u = xe(c, u, n);
                    i ? -1 == f ? (f = d.length, Te(c, he(d.concat([u]), f), {
                        scroll: !1,
                        origin: "*mouse"
                    })) : d.length > 1 && d[f].empty() && "single" == r && !t.shiftKey ? (Te(c, he(d.slice(0, f).concat(d.slice(f + 1)), 0), {
                        scroll: !1,
                        origin: "*mouse"
                    }), h = c.sel) : ke(c, f, u, Ba) : (f = 0, Te(c, new ue([u], 0), Ba), h = c.sel);
                    var g = n, v = s.wrapper.getBoundingClientRect(), y = 0, x = Et(e, function (e) {
                        ki(e) ? a(e) : l(e)
                    }), w = Et(e, l);
                    e.state.selectingText = w, Ea(document, "mousemove", x), Ea(document, "mouseup", w)
                }

                function Zt(e, t, n, r) {
                    try {
                        var i = t.clientX, o = t.clientY
                    } catch (t) {
                        return !1
                    }
                    if (i >= Math.floor(e.display.gutters.getBoundingClientRect().right))return !1;
                    r && Ma(t);
                    var a = e.display, l = a.lineDiv.getBoundingClientRect();
                    if (o > l.bottom || !Ni(e, n))return bi(t);
                    o -= l.top - a.viewOffset;
                    for (var s = 0; s < e.options.gutters.length; ++s) {
                        var c = a.gutters.childNodes[s];
                        if (c && c.getBoundingClientRect().right >= i) {
                            var u = ni(e.doc, o), f = e.options.gutters[s];
                            return Pa(e, n, e, u, f, t), bi(t)
                        }
                    }
                }

                function Jt(e, t) {
                    return Zt(e, t, "gutterClick", !0)
                }

                function Qt(e) {
                    var t = this;
                    if (nn(t), !Ti(t, e) && !Gt(t.display, e)) {
                        Ma(e), xo && ($o = +new Date);
                        var n = Yt(t, e, !0), r = e.dataTransfer.files;
                        if (n && !t.isReadOnly())if (r && r.length && window.FileReader && window.File)for (var i = r.length,
                                                                                                                o = Array(i),
                                                                                                                a = 0,
                                                                                                                l = function (e, r) {
                                                                                                                    if (!t.options.allowDropFileTypes || -1 != Pi(t.options.allowDropFileTypes, e.type)) {
                                                                                                                        var l = new FileReader;
                                                                                                                        l.onload = Et(t, function () {
                                                                                                                            var e = l.result;
                                                                                                                            if (/[\x00-\x08\x0e-\x1f]{2}/.test(e) && (e = ""), o[r] = e, ++a == i) {
                                                                                                                                n = me(t.doc, n);
                                                                                                                                var s = {
                                                                                                                                    from: n,
                                                                                                                                    to: n,
                                                                                                                                    text: t.doc.splitLines(o.join(t.doc.lineSeparator())),
                                                                                                                                    origin: "paste"
                                                                                                                                };
                                                                                                                                Tn(t.doc, s), Le(t.doc, de(n, Qo(s)))
                                                                                                                            }
                                                                                                                        }), l.readAsText(e)
                                                                                                                    }
                                                                                                                },
                                                                                                                s = 0; i > s; ++s)l(r[s], s); else {
                            if (t.state.draggingText && t.doc.sel.contains(n) > -1)return t.state.draggingText(e), void setTimeout(function () {
                                t.display.input.focus()
                            }, 20);
                            try {
                                var o = e.dataTransfer.getData("Text");
                                if (o) {
                                    if (t.state.draggingText && !(Eo ? e.altKey : e.ctrlKey))var c = t.listSelections();
                                    if (Me(t.doc, de(n, n)), c)for (var s = 0; s < c.length; ++s)In(t.doc, "", c[s].anchor, c[s].head, "drag");
                                    t.replaceSelection(o, "around", "paste"), t.display.input.focus()
                                }
                            } catch (e) {
                            }
                        }
                    }
                }

                function en(e, t) {
                    if (xo && (!e.state.draggingText || +new Date - $o < 100))return void Aa(t);
                    if (!Ti(e, t) && !Gt(e.display, t) && (t.dataTransfer.setData("Text", e.getSelection()), t.dataTransfer.effectAllowed = "copyMove", t.dataTransfer.setDragImage && !Lo)) {
                        var n = ji("img", null, null, "position: fixed; left: 0; top: 0;");
                        n.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", Co && (n.width = n.height = 1, e.display.wrapper.appendChild(n), n._top = n.offsetTop), t.dataTransfer.setDragImage(n, 0, 0), Co && n.parentNode.removeChild(n)
                    }
                }

                function tn(e, t) {
                    var n = Yt(e, t);
                    if (n) {
                        var r = document.createDocumentFragment();
                        He(e, n, r), e.display.dragCursor || (e.display.dragCursor = ji("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), e.display.lineSpace.insertBefore(e.display.dragCursor, e.display.cursorDiv)), qi(e.display.dragCursor, r)
                    }
                }

                function nn(e) {
                    e.display.dragCursor && (e.display.lineSpace.removeChild(e.display.dragCursor), e.display.dragCursor = null)
                }

                function rn(e, t) {
                    Math.abs(e.doc.scrollTop - t) < 2 || (e.doc.scrollTop = t, go || A(e, {top: t}), e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t), e.display.scrollbars.setScrollTop(t), go && A(e), _e(e, 100))
                }

                function on(e, t, n) {
                    (n ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) || (t = Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth), e.doc.scrollLeft = t, w(e), e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t), e.display.scrollbars.setScrollLeft(t))
                }

                function an(e, t) {
                    var n = Xo(t), r = n.x, i = n.y, o = e.display, a = o.scroller, l = a.scrollWidth > a.clientWidth,
                        s = a.scrollHeight > a.clientHeight;
                    if (r && l || i && s) {
                        if (i && Eo && wo)e:for (var c = t.target,
                                                     u = o.view; c != a; c = c.parentNode)for (var f = 0; f < u.length; f++)if (u[f].node == c) {
                            e.display.currentWheelTarget = c;
                            break e
                        }
                        if (r && !go && !Co && null != Ko)return i && s && rn(e, Math.max(0, Math.min(a.scrollTop + i * Ko, a.scrollHeight - a.clientHeight))), on(e, Math.max(0, Math.min(a.scrollLeft + r * Ko, a.scrollWidth - a.clientWidth))), (!i || i && s) && Ma(t), void(o.wheelStartX = null);
                        if (i && null != Ko) {
                            var h = i * Ko, d = e.doc.scrollTop, p = d + o.wrapper.clientHeight;
                            0 > h ? d = Math.max(0, d + h - 50) : p = Math.min(e.doc.height, p + h + 50), A(e, {
                                top: d,
                                bottom: p
                            })
                        }
                        20 > Vo && (null == o.wheelStartX ? (o.wheelStartX = a.scrollLeft, o.wheelStartY = a.scrollTop, o.wheelDX = r, o.wheelDY = i, setTimeout(function () {
                            if (null != o.wheelStartX) {
                                var e = a.scrollLeft - o.wheelStartX, t = a.scrollTop - o.wheelStartY,
                                    n = t && o.wheelDY && t / o.wheelDY || e && o.wheelDX && e / o.wheelDX;
                                o.wheelStartX = o.wheelStartY = null, n && (Ko = (Ko * Vo + n) / (Vo + 1), ++Vo)
                            }
                        }, 200)) : (o.wheelDX += r, o.wheelDY += i))
                    }
                }

                function ln(e, t, n) {
                    if ("string" == typeof t && (t = ua[t], !t))return !1;
                    e.display.input.ensurePolled();
                    var r = e.display.shift, i = !1;
                    try {
                        e.isReadOnly() && (e.state.suppressEdits = !0), n && (e.display.shift = !1), i = t(e) != Ha
                    } finally {
                        e.display.shift = r, e.state.suppressEdits = !1
                    }
                    return i
                }

                function sn(e, t, n) {
                    for (var r = 0; r < e.state.keyMaps.length; r++) {
                        var i = ha(t, e.state.keyMaps[r], n, e);
                        if (i)return i
                    }
                    return e.options.extraKeys && ha(t, e.options.extraKeys, n, e) || ha(t, e.options.keyMap, n, e)
                }

                function cn(e, t, n, r) {
                    var i = e.state.keySeq;
                    if (i) {
                        if (da(t))return "handled";
                        Zo.set(50, function () {
                            e.state.keySeq == i && (e.state.keySeq = null, e.display.input.reset())
                        }), t = i + " " + t
                    }
                    var o = sn(e, t, r);
                    return "multi" == o && (e.state.keySeq = t), "handled" == o && Ci(e, "keyHandled", e, t, n), "handled" != o && "multi" != o || (Ma(n), Be(e)), i && !o && /\'$/.test(t) ? (Ma(n), !0) : !!o
                }

                function un(e, t) {
                    var n = pa(t, !0);
                    return n ? t.shiftKey && !e.state.keySeq ? cn(e, "Shift-" + n, t, function (t) {
                            return ln(e, t, !0)
                        }) || cn(e, n, t, function (t) {
                            return ("string" == typeof t ? /^go[A-Z]/.test(t) : t.motion) ? ln(e, t) : void 0
                        }) : cn(e, n, t, function (t) {
                        return ln(e, t)
                    }) : !1
                }

                function fn(e, t, n) {
                    return cn(e, "'" + n + "'", t, function (t) {
                        return ln(e, t, !0)
                    })
                }

                function hn(e) {
                    var t = this;
                    if (t.curOp.focus = Gi(), !Ti(t, e)) {
                        xo && 11 > bo && 27 == e.keyCode && (e.returnValue = !1);
                        var n = e.keyCode;
                        t.display.shift = 16 == n || e.shiftKey;
                        var r = un(t, e);
                        Co && (Jo = r ? n : null, !r && 88 == n && !rl && (Eo ? e.metaKey : e.ctrlKey) && t.replaceSelection("", null, "cut")), 18 != n || /\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className) || dn(t)
                    }
                }

                function dn(e) {
                    function t(e) {
                        18 != e.keyCode && e.altKey || (Za(n, "CodeMirror-crosshair"), Ia(document, "keyup", t), Ia(document, "mouseover", t))
                    }

                    var n = e.display.lineDiv;
                    Ja(n, "CodeMirror-crosshair"), Ea(document, "keyup", t), Ea(document, "mouseover", t)
                }

                function pn(e) {
                    16 == e.keyCode && (this.doc.sel.shift = !1), Ti(this, e)
                }

                function mn(e) {
                    var t = this;
                    if (!(Gt(t.display, e) || Ti(t, e) || e.ctrlKey && !e.altKey || Eo && e.metaKey)) {
                        var n = e.keyCode, r = e.charCode;
                        if (Co && n == Jo)return Jo = null, void Ma(e);
                        if (!Co || e.which && !(e.which < 10) || !un(t, e)) {
                            var i = String.fromCharCode(null == r ? n : r);
                            fn(t, e, i) || t.display.input.onKeyPress(e)
                        }
                    }
                }

                function gn(e) {
                    e.state.delayingBlurEvent = !0, setTimeout(function () {
                        e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1, yn(e))
                    }, 100)
                }

                function vn(e) {
                    e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1), "nocursor" != e.options.readOnly && (e.state.focused || (Pa(e, "focus", e), e.state.focused = !0, Ja(e.display.wrapper, "CodeMirror-focused"), e.curOp || e.display.selForContextMenu == e.doc.sel || (e.display.input.reset(), wo && setTimeout(function () {
                        e.display.input.reset(!0)
                    }, 20)), e.display.input.receivedFocus()), Be(e))
                }

                function yn(e) {
                    e.state.delayingBlurEvent || (e.state.focused && (Pa(e, "blur", e), e.state.focused = !1, Za(e.display.wrapper, "CodeMirror-focused")), clearInterval(e.display.blinker), setTimeout(function () {
                        e.state.focused || (e.display.shift = !1)
                    }, 150))
                }

                function xn(e, t) {
                    Gt(e.display, t) || bn(e, t) || Ti(e, t, "contextmenu") || e.display.input.onContextMenu(t)
                }

                function bn(e, t) {
                    return Ni(e, "gutterContextMenu") ? Zt(e, t, "gutterContextMenu", !1) : !1
                }

                function wn(e, t) {
                    if (_o(e, t.from) < 0)return e;
                    if (_o(e, t.to) <= 0)return Qo(t);
                    var n = e.line + t.text.length - (t.to.line - t.from.line) - 1, r = e.ch;
                    return e.line == t.to.line && (r += Qo(t).ch - t.to.ch), Bo(n, r)
                }

                function kn(e, t) {
                    for (var n = [], r = 0; r < e.sel.ranges.length; r++) {
                        var i = e.sel.ranges[r];
                        n.push(new fe(wn(i.anchor, t), wn(i.head, t)))
                    }
                    return he(n, e.sel.primIndex)
                }

                function Sn(e, t, n) {
                    return e.line == t.line ? Bo(n.line, e.ch - t.ch + n.ch) : Bo(n.line + (e.line - t.line), e.ch)
                }

                function Cn(e, t, n) {
                    for (var r = [], i = Bo(e.first, 0), o = i, a = 0; a < t.length; a++) {
                        var l = t[a], s = Sn(l.from, i, o), c = Sn(Qo(l), i, o);
                        if (i = l.to, o = c, "around" == n) {
                            var u = e.sel.ranges[a], f = _o(u.head, u.anchor) < 0;
                            r[a] = new fe(f ? c : s, f ? s : c)
                        } else r[a] = new fe(s, s)
                    }
                    return new ue(r, e.sel.primIndex)
                }

                function Ln(e, t, n) {
                    var r = {
                        canceled: !1, from: t.from, to: t.to, text: t.text, origin: t.origin, cancel: function () {
                            this.canceled = !0
                        }
                    };
                    return n && (r.update = function (t, n, r, i) {
                        t && (this.from = me(e, t)), n && (this.to = me(e, n)), r && (this.text = r), void 0 !== i && (this.origin = i)
                    }), Pa(e, "beforeChange", e, r), e.cm && Pa(e.cm, "beforeChange", e.cm, r), r.canceled ? null : {
                        from: r.from,
                        to: r.to,
                        text: r.text,
                        origin: r.origin
                    }
                }

                function Tn(e, t, n) {
                    if (e.cm) {
                        if (!e.cm.curOp)return Et(e.cm, Tn)(e, t, n);
                        if (e.cm.state.suppressEdits)return
                    }
                    if (!(Ni(e, "beforeChange") || e.cm && Ni(e.cm, "beforeChange")) || (t = Ln(e, t, !0))) {
                        var r = Ho && !n && sr(e, t.from, t.to);
                        if (r)for (var i = r.length - 1; i >= 0; --i)Mn(e, {
                            from: r[i].from,
                            to: r[i].to,
                            text: i ? [""] : t.text
                        }); else Mn(e, t)
                    }
                }

                function Mn(e, t) {
                    if (1 != t.text.length || "" != t.text[0] || 0 != _o(t.from, t.to)) {
                        var n = kn(e, t);
                        ci(e, t, n, e.cm ? e.cm.curOp.id : NaN), En(e, t, n, or(e, t));
                        var r = [];
                        Kr(e, function (e, n) {
                            n || -1 != Pi(r, e.history) || (xi(e.history, t), r.push(e.history)), En(e, t, null, or(e, t))
                        })
                    }
                }

                function Nn(e, t, n) {
                    if (!e.cm || !e.cm.state.suppressEdits) {
                        for (var r, i = e.history, o = e.sel, a = "undo" == t ? i.done : i.undone,
                                 l = "undo" == t ? i.undone : i.done,
                                 s = 0; s < a.length && (r = a[s], n ? !r.ranges || r.equals(e.sel) : r.ranges); s++);
                        if (s != a.length) {
                            for (i.lastOrigin = i.lastSelOrigin = null; r = a.pop(), r.ranges;) {
                                if (hi(r, l), n && !r.equals(e.sel))return void Te(e, r, {clearRedo: !1});
                                o = r
                            }
                            var c = [];
                            hi(o, l), l.push({
                                changes: c,
                                generation: i.generation
                            }), i.generation = r.generation || ++i.maxGeneration;
                            for (var u = Ni(e, "beforeChange") || e.cm && Ni(e.cm, "beforeChange"),
                                     s = r.changes.length - 1; s >= 0; --s) {
                                var f = r.changes[s];
                                if (f.origin = t, u && !Ln(e, f, !1))return void(a.length = 0);
                                c.push(ai(e, f));
                                var h = s ? kn(e, f) : Ii(a);
                                En(e, f, h, lr(e, f)), !s && e.cm && e.cm.scrollIntoView({from: f.from, to: Qo(f)});
                                var d = [];
                                Kr(e, function (e, t) {
                                    t || -1 != Pi(d, e.history) || (xi(e.history, f), d.push(e.history)), En(e, f, null, lr(e, f))
                                })
                            }
                        }
                    }
                }

                function An(e, t) {
                    if (0 != t && (e.first += t, e.sel = new ue(Ri(e.sel.ranges, function (e) {
                            return new fe(Bo(e.anchor.line + t, e.anchor.ch), Bo(e.head.line + t, e.head.ch))
                        }), e.sel.primIndex), e.cm)) {
                        Dt(e.cm, e.first, e.first - t, t);
                        for (var n = e.cm.display, r = n.viewFrom; r < n.viewTo; r++)Ht(e.cm, r, "gutter")
                    }
                }

                function En(e, t, n, r) {
                    if (e.cm && !e.cm.curOp)return Et(e.cm, En)(e, t, n, r);
                    if (t.to.line < e.first)return void An(e, t.text.length - 1 - (t.to.line - t.from.line));
                    if (!(t.from.line > e.lastLine())) {
                        if (t.from.line < e.first) {
                            var i = t.text.length - 1 - (e.first - t.from.line);
                            An(e, i), t = {
                                from: Bo(e.first, 0),
                                to: Bo(t.to.line + i, t.to.ch),
                                text: [Ii(t.text)],
                                origin: t.origin
                            }
                        }
                        var o = e.lastLine();
                        t.to.line > o && (t = {
                            from: t.from,
                            to: Bo(o, Zr(e, o).text.length),
                            text: [t.text[0]],
                            origin: t.origin
                        }), t.removed = Jr(e, t.from, t.to), n || (n = kn(e, t)), e.cm ? On(e.cm, t, r) : Yr(e, t, r), Me(e, n, Wa)
                    }
                }

                function On(e, t, n) {
                    var r = e.doc, i = e.display, a = t.from, l = t.to, s = !1, c = a.line;
                    e.options.lineWrapping || (c = ti(yr(Zr(r, a.line))), r.iter(c, l.line + 1, function (e) {
                        return e == i.maxLine ? (s = !0, !0) : void 0
                    })), r.sel.contains(t.from, t.to) > -1 && Mi(e), Yr(r, t, n, o(e)), e.options.lineWrapping || (r.iter(c, a.line + t.text.length, function (e) {
                        var t = f(e);
                        t > i.maxLineLength && (i.maxLine = e, i.maxLineLength = t, i.maxLineChanged = !0, s = !1)
                    }), s && (e.curOp.updateMaxLine = !0)), r.frontier = Math.min(r.frontier, a.line), _e(e, 400);
                    var u = t.text.length - (l.line - a.line) - 1;
                    t.full ? Dt(e) : a.line != l.line || 1 != t.text.length || Gr(e.doc, t) ? Dt(e, a.line, l.line + 1, u) : Ht(e, a.line, "text");
                    var h = Ni(e, "changes"), d = Ni(e, "change");
                    if (d || h) {
                        var p = {from: a, to: l, text: t.text, removed: t.removed, origin: t.origin};
                        d && Ci(e, "change", e, p), h && (e.curOp.changeObjs || (e.curOp.changeObjs = [])).push(p)
                    }
                    e.display.selForContextMenu = null
                }

                function In(e, t, n, r, i) {
                    if (r || (r = n), _o(r, n) < 0) {
                        var o = r;
                        r = n, n = o
                    }
                    "string" == typeof t && (t = e.splitLines(t)), Tn(e, {from: n, to: r, text: t, origin: i})
                }

                function Pn(e, t) {
                    if (!Ti(e, "scrollCursorIntoView")) {
                        var n = e.display, r = n.sizer.getBoundingClientRect(), i = null;
                        if (t.top + r.top < 0 ? i = !0 : t.bottom + r.top > (window.innerHeight || document.documentElement.clientHeight) && (i = !1), null != i && !Mo) {
                            var o = ji("div", "", null, "position: absolute; top: " + (t.top - n.viewOffset - Ue(e.display)) + "px; height: " + (t.bottom - t.top + Ye(e) + n.barHeight) + "px; left: " + t.left + "px; width: 2px;");
                            e.display.lineSpace.appendChild(o), o.scrollIntoView(i), e.display.lineSpace.removeChild(o)
                        }
                    }
                }

                function Rn(e, t, n, r) {
                    null == r && (r = 0);
                    for (var i = 0; 5 > i; i++) {
                        var o = !1, a = dt(e, t), l = n && n != t ? dt(e, n) : a,
                            s = Hn(e, Math.min(a.left, l.left), Math.min(a.top, l.top) - r, Math.max(a.left, l.left), Math.max(a.bottom, l.bottom) + r),
                            c = e.doc.scrollTop, u = e.doc.scrollLeft;
                        if (null != s.scrollTop && (rn(e, s.scrollTop), Math.abs(e.doc.scrollTop - c) > 1 && (o = !0)), null != s.scrollLeft && (on(e, s.scrollLeft), Math.abs(e.doc.scrollLeft - u) > 1 && (o = !0)), !o)break
                    }
                    return a
                }

                function Dn(e, t, n, r, i) {
                    var o = Hn(e, t, n, r, i);
                    null != o.scrollTop && rn(e, o.scrollTop), null != o.scrollLeft && on(e, o.scrollLeft)
                }

                function Hn(e, t, n, r, i) {
                    var o = e.display, a = yt(e.display);
                    0 > n && (n = 0);
                    var l = e.curOp && null != e.curOp.scrollTop ? e.curOp.scrollTop : o.scroller.scrollTop, s = Ve(e),
                        c = {};
                    i - n > s && (i = n + s);
                    var u = e.doc.height + qe(o), f = a > n, h = i > u - a;
                    if (l > n) c.scrollTop = f ? 0 : n; else if (i > l + s) {
                        var d = Math.min(n, (h ? u : i) - s);
                        d != l && (c.scrollTop = d)
                    }
                    var p = e.curOp && null != e.curOp.scrollLeft ? e.curOp.scrollLeft : o.scroller.scrollLeft,
                        m = $e(e) - (e.options.fixedGutter ? o.gutters.offsetWidth : 0), g = r - t > m;
                    return g && (r = t + m), 10 > t ? c.scrollLeft = 0 : p > t ? c.scrollLeft = Math.max(0, t - (g ? 0 : 10)) : r > m + p - 3 && (c.scrollLeft = r + (g ? 0 : 10) - m), c
                }

                function Wn(e, t, n) {
                    null == t && null == n || _n(e), null != t && (e.curOp.scrollLeft = (null == e.curOp.scrollLeft ? e.doc.scrollLeft : e.curOp.scrollLeft) + t), null != n && (e.curOp.scrollTop = (null == e.curOp.scrollTop ? e.doc.scrollTop : e.curOp.scrollTop) + n)
                }

                function Bn(e) {
                    _n(e);
                    var t = e.getCursor(), n = t, r = t;
                    e.options.lineWrapping || (n = t.ch ? Bo(t.line, t.ch - 1) : t, r = Bo(t.line, t.ch + 1)), e.curOp.scrollToPos = {
                        from: n,
                        to: r,
                        margin: e.options.cursorScrollMargin,
                        isCursor: !0
                    }
                }

                function _n(e) {
                    var t = e.curOp.scrollToPos;
                    if (t) {
                        e.curOp.scrollToPos = null;
                        var n = pt(e, t.from), r = pt(e, t.to),
                            i = Hn(e, Math.min(n.left, r.left), Math.min(n.top, r.top) - t.margin, Math.max(n.right, r.right), Math.max(n.bottom, r.bottom) + t.margin);
                        e.scrollTo(i.scrollLeft, i.scrollTop)
                    }
                }

                function Fn(e, t, n, r) {
                    var i, o = e.doc;
                    null == n && (n = "add"), "smart" == n && (o.mode.indent ? i = je(e, t) : n = "prev");
                    var a = e.options.tabSize, l = Zr(o, t), s = Fa(l.text, null, a);
                    l.stateAfter && (l.stateAfter = null);
                    var c, u = l.text.match(/^\s*/)[0];
                    if (r || /\S/.test(l.text)) {
                        if ("smart" == n && (c = o.mode.indent(i, l.text.slice(u.length), l.text), c == Ha || c > 150)) {
                            if (!r)return;
                            n = "prev"
                        }
                    } else c = 0, n = "not";
                    "prev" == n ? c = t > o.first ? Fa(Zr(o, t - 1).text, null, a) : 0 : "add" == n ? c = s + e.options.indentUnit : "subtract" == n ? c = s - e.options.indentUnit : "number" == typeof n && (c = s + n), c = Math.max(0, c);
                    var f = "", h = 0;
                    if (e.options.indentWithTabs)for (var d = Math.floor(c / a); d; --d)h += a, f += "	";
                    if (c > h && (f += Oi(c - h)), f != u)return In(o, f, Bo(t, 0), Bo(t, u.length), "+input"), l.stateAfter = null, !0;
                    for (var d = 0; d < o.sel.ranges.length; d++) {
                        var p = o.sel.ranges[d];
                        if (p.head.line == t && p.head.ch < u.length) {
                            var h = Bo(t, u.length);
                            ke(o, d, new fe(h, h));
                            break
                        }
                    }
                }

                function zn(e, t, n, r) {
                    var i = t, o = t;
                    return "number" == typeof t ? o = Zr(e, pe(e, t)) : i = ti(t), null == i ? null : (r(o, i) && e.cm && Ht(e.cm, i, n), o)
                }

                function jn(e, t) {
                    for (var n = e.doc.sel.ranges, r = [], i = 0; i < n.length; i++) {
                        for (var o = t(n[i]); r.length && _o(o.from, Ii(r).to) <= 0;) {
                            var a = r.pop();
                            if (_o(a.from, o.from) < 0) {
                                o.from = a.from;
                                break
                            }
                        }
                        r.push(o)
                    }
                    At(e, function () {
                        for (var t = r.length - 1; t >= 0; t--)In(e.doc, "", r[t].from, r[t].to, "+delete");
                        Bn(e)
                    })
                }

                function Un(e, t, n, r, i) {
                    function o() {
                        var t = l + n;
                        return t < e.first || t >= e.first + e.size ? !1 : (l = t, u = Zr(e, t))
                    }

                    function a(e) {
                        var t = (i ? fo : ho)(u, s, n, !0);
                        if (null == t) {
                            if (e || !o())return !1;
                            s = i ? (0 > n ? io : ro)(u) : 0 > n ? u.text.length : 0
                        } else s = t;
                        return !0
                    }

                    var l = t.line, s = t.ch, c = n, u = Zr(e, l);
                    if ("char" == r) a(); else if ("column" == r) a(!0); else if ("word" == r || "group" == r)for (var f = null,
                                                                                                                       h = "group" == r,
                                                                                                                       d = e.cm && e.cm.getHelper(t, "wordChars"),
                                                                                                                       p = !0; !(0 > n) || a(!p); p = !1) {
                        var m = u.text.charAt(s) || "\n",
                            g = _i(m, d) ? "w" : h && "\n" == m ? "n" : !h || /\s/.test(m) ? null : "p";
                        if (!h || p || g || (g = "s"), f && f != g) {
                            0 > n && (n = 1, a());
                            break
                        }
                        if (g && (f = g), n > 0 && !a(!p))break
                    }
                    var v = Ie(e, Bo(l, s), t, c, !0);
                    return _o(t, v) || (v.hitSide = !0), v
                }

                function qn(e, t, n, r) {
                    var i, o = e.doc, a = t.left;
                    if ("page" == r) {
                        var l = Math.min(e.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
                        i = t.top + n * (l - (0 > n ? 1.5 : .5) * yt(e.display))
                    } else"line" == r && (i = n > 0 ? t.bottom + 3 : t.top - 3);
                    for (; ;) {
                        var s = gt(e, a, i);
                        if (!s.outside)break;
                        if (0 > n ? 0 >= i : i >= o.height) {
                            s.hitSide = !0;
                            break
                        }
                        i += 5 * n
                    }
                    return s
                }

                function Gn(t, n, r, i) {
                    e.defaults[t] = n, r && (ta[t] = i ? function (e, t, n) {
                        n != na && r(e, t, n)
                    } : r)
                }

                function Yn(e) {
                    for (var t, n, r, i, o = e.split(/-(?!$)/), e = o[o.length - 1], a = 0; a < o.length - 1; a++) {
                        var l = o[a];
                        if (/^(cmd|meta|m)$/i.test(l)) i = !0; else if (/^a(lt)?$/i.test(l)) t = !0; else if (/^(c|ctrl|control)$/i.test(l)) n = !0; else {
                            if (!/^s(hift)$/i.test(l))throw new Error("Unrecognized modifier name: " + l);
                            r = !0
                        }
                    }
                    return t && (e = "Alt-" + e), n && (e = "Ctrl-" + e), i && (e = "Cmd-" + e), r && (e = "Shift-" + e), e
                }

                function $n(e) {
                    return "string" == typeof e ? fa[e] : e
                }

                function Vn(e, t, n, r, i) {
                    if (r && r.shared)return Kn(e, t, n, r, i);
                    if (e.cm && !e.cm.curOp)return Et(e.cm, Vn)(e, t, n, r, i);
                    var o = new va(e, i), a = _o(t, n);
                    if (r && Wi(r, o, !1), a > 0 || 0 == a && o.clearWhenEmpty !== !1)return o;
                    if (o.replacedWith && (o.collapsed = !0, o.widgetNode = ji("span", [o.replacedWith], "CodeMirror-widget"), r.handleMouseEvents || o.widgetNode.setAttribute("cm-ignore-events", "true"), r.insertLeft && (o.widgetNode.insertLeft = !0)), o.collapsed) {
                        if (vr(e, t.line, t, n, o) || t.line != n.line && vr(e, n.line, t, n, o))throw new Error("Inserting collapsed marker partially overlapping an existing one");
                        Wo = !0
                    }
                    o.addToHistory && ci(e, {from: t, to: n, origin: "markText"}, e.sel, NaN);
                    var l, s = t.line, c = e.cm;
                    if (e.iter(s, n.line + 1, function (e) {
                            c && o.collapsed && !c.options.lineWrapping && yr(e) == c.display.maxLine && (l = !0), o.collapsed && s != t.line && ei(e, 0), nr(e, new Qn(o, s == t.line ? t.ch : null, s == n.line ? n.ch : null)), ++s
                        }), o.collapsed && e.iter(t.line, n.line + 1, function (t) {
                            kr(e, t) && ei(t, 0)
                        }), o.clearOnEnter && Ea(o, "beforeCursorEnter", function () {
                            o.clear()
                        }), o.readOnly && (Ho = !0, (e.history.done.length || e.history.undone.length) && e.clearHistory()), o.collapsed && (o.id = ++ga, o.atomic = !0), c) {
                        if (l && (c.curOp.updateMaxLine = !0), o.collapsed) Dt(c, t.line, n.line + 1); else if (o.className || o.title || o.startStyle || o.endStyle || o.css)for (var u = t.line; u <= n.line; u++)Ht(c, u, "text");
                        o.atomic && Ae(c.doc), Ci(c, "markerAdded", c, o)
                    }
                    return o
                }

                function Kn(e, t, n, r, i) {
                    r = Wi(r), r.shared = !1;
                    var o = [Vn(e, t, n, r, i)], a = o[0], l = r.widgetNode;
                    return Kr(e, function (e) {
                        l && (r.widgetNode = l.cloneNode(!0)), o.push(Vn(e, me(e, t), me(e, n), r, i));
                        for (var s = 0; s < e.linked.length; ++s)if (e.linked[s].isParent)return;
                        a = Ii(o)
                    }), new ya(o, a)
                }

                function Xn(e) {
                    return e.findMarks(Bo(e.first, 0), e.clipPos(Bo(e.lastLine())), function (e) {
                        return e.parent
                    })
                }

                function Zn(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n], i = r.find(), o = e.clipPos(i.from), a = e.clipPos(i.to);
                        if (_o(o, a)) {
                            var l = Vn(e, o, a, r.primary, r.primary.type);
                            r.markers.push(l), l.parent = r
                        }
                    }
                }

                function Jn(e) {
                    for (var t = 0; t < e.length; t++) {
                        var n = e[t], r = [n.primary.doc];
                        Kr(n.primary.doc, function (e) {
                            r.push(e)
                        });
                        for (var i = 0; i < n.markers.length; i++) {
                            var o = n.markers[i];
                            -1 == Pi(r, o.doc) && (o.parent = null, n.markers.splice(i--, 1))
                        }
                    }
                }

                function Qn(e, t, n) {
                    this.marker = e, this.from = t, this.to = n
                }

                function er(e, t) {
                    if (e)for (var n = 0; n < e.length; ++n) {
                        var r = e[n];
                        if (r.marker == t)return r
                    }
                }

                function tr(e, t) {
                    for (var n, r = 0; r < e.length; ++r)e[r] != t && (n || (n = [])).push(e[r]);
                    return n
                }

                function nr(e, t) {
                    e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t], t.marker.attachLine(e)
                }

                function rr(e, t, n) {
                    if (e)for (var r, i = 0; i < e.length; ++i) {
                        var o = e[i], a = o.marker, l = null == o.from || (a.inclusiveLeft ? o.from <= t : o.from < t);
                        if (l || o.from == t && "bookmark" == a.type && (!n || !o.marker.insertLeft)) {
                            var s = null == o.to || (a.inclusiveRight ? o.to >= t : o.to > t);
                            (r || (r = [])).push(new Qn(a, o.from, s ? null : o.to))
                        }
                    }
                    return r
                }

                function ir(e, t, n) {
                    if (e)for (var r, i = 0; i < e.length; ++i) {
                        var o = e[i], a = o.marker, l = null == o.to || (a.inclusiveRight ? o.to >= t : o.to > t);
                        if (l || o.from == t && "bookmark" == a.type && (!n || o.marker.insertLeft)) {
                            var s = null == o.from || (a.inclusiveLeft ? o.from <= t : o.from < t);
                            (r || (r = [])).push(new Qn(a, s ? null : o.from - t, null == o.to ? null : o.to - t))
                        }
                    }
                    return r
                }

                function or(e, t) {
                    if (t.full)return null;
                    var n = ve(e, t.from.line) && Zr(e, t.from.line).markedSpans,
                        r = ve(e, t.to.line) && Zr(e, t.to.line).markedSpans;
                    if (!n && !r)return null;
                    var i = t.from.ch, o = t.to.ch, a = 0 == _o(t.from, t.to), l = rr(n, i, a), s = ir(r, o, a),
                        c = 1 == t.text.length, u = Ii(t.text).length + (c ? i : 0);
                    if (l)for (var f = 0; f < l.length; ++f) {
                        var h = l[f];
                        if (null == h.to) {
                            var d = er(s, h.marker);
                            d ? c && (h.to = null == d.to ? null : d.to + u) : h.to = i
                        }
                    }
                    if (s)for (var f = 0; f < s.length; ++f) {
                        var h = s[f];
                        if (null != h.to && (h.to += u), null == h.from) {
                            var d = er(l, h.marker);
                            d || (h.from = u, c && (l || (l = [])).push(h))
                        } else h.from += u, c && (l || (l = [])).push(h)
                    }
                    l && (l = ar(l)), s && s != l && (s = ar(s));
                    var p = [l];
                    if (!c) {
                        var m, g = t.text.length - 2;
                        if (g > 0 && l)for (var f = 0; f < l.length; ++f)null == l[f].to && (m || (m = [])).push(new Qn(l[f].marker, null, null));
                        for (var f = 0; g > f; ++f)p.push(m);
                        p.push(s)
                    }
                    return p
                }

                function ar(e) {
                    for (var t = 0; t < e.length; ++t) {
                        var n = e[t];
                        null != n.from && n.from == n.to && n.marker.clearWhenEmpty !== !1 && e.splice(t--, 1)
                    }
                    return e.length ? e : null
                }

                function lr(e, t) {
                    var n = mi(e, t), r = or(e, t);
                    if (!n)return r;
                    if (!r)return n;
                    for (var i = 0; i < n.length; ++i) {
                        var o = n[i], a = r[i];
                        if (o && a)e:for (var l = 0; l < a.length; ++l) {
                            for (var s = a[l], c = 0; c < o.length; ++c)if (o[c].marker == s.marker)continue e;
                            o.push(s)
                        } else a && (n[i] = a)
                    }
                    return n
                }

                function sr(e, t, n) {
                    var r = null;
                    if (e.iter(t.line, n.line + 1, function (e) {
                            if (e.markedSpans)for (var t = 0; t < e.markedSpans.length; ++t) {
                                var n = e.markedSpans[t].marker;
                                !n.readOnly || r && -1 != Pi(r, n) || (r || (r = [])).push(n)
                            }
                        }), !r)return null;
                    for (var i = [{from: t, to: n}], o = 0; o < r.length; ++o)for (var a = r[o], l = a.find(0),
                                                                                       s = 0; s < i.length; ++s) {
                        var c = i[s];
                        if (!(_o(c.to, l.from) < 0 || _o(c.from, l.to) > 0)) {
                            var u = [s, 1], f = _o(c.from, l.from), h = _o(c.to, l.to);
                            (0 > f || !a.inclusiveLeft && !f) && u.push({
                                from: c.from,
                                to: l.from
                            }), (h > 0 || !a.inclusiveRight && !h) && u.push({
                                from: l.to,
                                to: c.to
                            }), i.splice.apply(i, u), s += u.length - 1
                        }
                    }
                    return i
                }

                function cr(e) {
                    var t = e.markedSpans;
                    if (t) {
                        for (var n = 0; n < t.length; ++n)t[n].marker.detachLine(e);
                        e.markedSpans = null
                    }
                }

                function ur(e, t) {
                    if (t) {
                        for (var n = 0; n < t.length; ++n)t[n].marker.attachLine(e);
                        e.markedSpans = t
                    }
                }

                function fr(e) {
                    return e.inclusiveLeft ? -1 : 0
                }

                function hr(e) {
                    return e.inclusiveRight ? 1 : 0
                }

                function dr(e, t) {
                    var n = e.lines.length - t.lines.length;
                    if (0 != n)return n;
                    var r = e.find(), i = t.find(), o = _o(r.from, i.from) || fr(e) - fr(t);
                    if (o)return -o;
                    var a = _o(r.to, i.to) || hr(e) - hr(t);
                    return a ? a : t.id - e.id
                }

                function pr(e, t) {
                    var n, r = Wo && e.markedSpans;
                    if (r)for (var i,
                                   o = 0; o < r.length; ++o)i = r[o], i.marker.collapsed && null == (t ? i.from : i.to) && (!n || dr(n, i.marker) < 0) && (n = i.marker);
                    return n
                }

                function mr(e) {
                    return pr(e, !0)
                }

                function gr(e) {
                    return pr(e, !1)
                }

                function vr(e, t, n, r, i) {
                    var o = Zr(e, t), a = Wo && o.markedSpans;
                    if (a)for (var l = 0; l < a.length; ++l) {
                        var s = a[l];
                        if (s.marker.collapsed) {
                            var c = s.marker.find(0), u = _o(c.from, n) || fr(s.marker) - fr(i),
                                f = _o(c.to, r) || hr(s.marker) - hr(i);
                            if (!(u >= 0 && 0 >= f || 0 >= u && f >= 0) && (0 >= u && (s.marker.inclusiveRight && i.inclusiveLeft ? _o(c.to, n) >= 0 : _o(c.to, n) > 0) || u >= 0 && (s.marker.inclusiveRight && i.inclusiveLeft ? _o(c.from, r) <= 0 : _o(c.from, r) < 0)))return !0
                        }
                    }
                }

                function yr(e) {
                    for (var t; t = mr(e);)e = t.find(-1, !0).line;
                    return e
                }

                function xr(e) {
                    for (var t, n; t = gr(e);)e = t.find(1, !0).line, (n || (n = [])).push(e);
                    return n
                }

                function br(e, t) {
                    var n = Zr(e, t), r = yr(n);
                    return n == r ? t : ti(r)
                }

                function wr(e, t) {
                    if (t > e.lastLine())return t;
                    var n, r = Zr(e, t);
                    if (!kr(e, r))return t;
                    for (; n = gr(r);)r = n.find(1, !0).line;
                    return ti(r) + 1
                }

                function kr(e, t) {
                    var n = Wo && t.markedSpans;
                    if (n)for (var r, i = 0; i < n.length; ++i)if (r = n[i], r.marker.collapsed) {
                        if (null == r.from)return !0;
                        if (!r.marker.widgetNode && 0 == r.from && r.marker.inclusiveLeft && Sr(e, t, r))return !0
                    }
                }

                function Sr(e, t, n) {
                    if (null == n.to) {
                        var r = n.marker.find(1, !0);
                        return Sr(e, r.line, er(r.line.markedSpans, n.marker))
                    }
                    if (n.marker.inclusiveRight && n.to == t.text.length)return !0;
                    for (var i,
                             o = 0; o < t.markedSpans.length; ++o)if (i = t.markedSpans[o], i.marker.collapsed && !i.marker.widgetNode && i.from == n.to && (null == i.to || i.to != n.from) && (i.marker.inclusiveLeft || n.marker.inclusiveRight) && Sr(e, t, i))return !0
                }

                function Cr(e, t, n) {
                    ri(t) < (e.curOp && e.curOp.scrollTop || e.doc.scrollTop) && Wn(e, null, n)
                }

                function Lr(e) {
                    if (null != e.height)return e.height;
                    var t = e.doc.cm;
                    if (!t)return 0;
                    if (!Va(document.body, e.node)) {
                        var n = "position: relative;";
                        e.coverGutter && (n += "margin-left: -" + t.display.gutters.offsetWidth + "px;"), e.noHScroll && (n += "width: " + t.display.wrapper.clientWidth + "px;"), qi(t.display.measure, ji("div", [e.node], null, n))
                    }
                    return e.height = e.node.parentNode.offsetHeight
                }

                function Tr(e, t, n, r) {
                    var i = new xa(e, n, r), o = e.cm;
                    return o && i.noHScroll && (o.display.alignWidgets = !0), zn(e, t, "widget", function (t) {
                        var n = t.widgets || (t.widgets = []);
                        if (null == i.insertAt ? n.push(i) : n.splice(Math.min(n.length - 1, Math.max(0, i.insertAt)), 0, i), i.line = t, o && !kr(e, t)) {
                            var r = ri(t) < e.scrollTop;
                            ei(t, t.height + Lr(i)), r && Wn(o, null, i.height), o.curOp.forceUpdate = !0
                        }
                        return !0
                    }), i
                }

                function Mr(e, t, n, r) {
                    e.text = t, e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null), null != e.order && (e.order = null), cr(e), ur(e, n);
                    var i = r ? r(e) : 1;
                    i != e.height && ei(e, i)
                }

                function Nr(e) {
                    e.parent = null, cr(e)
                }

                function Ar(e, t) {
                    if (e)for (; ;) {
                        var n = e.match(/(?:^|\s+)line-(background-)?(\S+)/);
                        if (!n)break;
                        e = e.slice(0, n.index) + e.slice(n.index + n[0].length);
                        var r = n[1] ? "bgClass" : "textClass";
                        null == t[r] ? t[r] = n[2] : new RegExp("(?:^|s)" + n[2] + "(?:$|s)").test(t[r]) || (t[r] += " " + n[2])
                    }
                    return e
                }

                function Er(t, n) {
                    if (t.blankLine)return t.blankLine(n);
                    if (t.innerMode) {
                        var r = e.innerMode(t, n);
                        return r.mode.blankLine ? r.mode.blankLine(r.state) : void 0
                    }
                }

                function Or(t, n, r, i) {
                    for (var o = 0; 10 > o; o++) {
                        i && (i[0] = e.innerMode(t, r).mode);
                        var a = t.token(n, r);
                        if (n.pos > n.start)return a
                    }
                    throw new Error("Mode " + t.name + " failed to advance stream.")
                }

                function Ir(e, t, n, r) {
                    function i(e) {
                        return {
                            start: f.start,
                            end: f.pos,
                            string: f.current(),
                            type: o || null,
                            state: e ? sa(a.mode, u) : u
                        }
                    }

                    var o, a = e.doc, l = a.mode;
                    t = me(a, t);
                    var s, c = Zr(a, t.line), u = je(e, t.line, n), f = new ma(c.text, e.options.tabSize);
                    for (r && (s = []); (r || f.pos < t.ch) && !f.eol();)f.start = f.pos, o = Or(l, f, u), r && s.push(i(!0));
                    return r ? s : i()
                }

                function Pr(e, t, n, r, i, o, a) {
                    var l = n.flattenSpans;
                    null == l && (l = e.options.flattenSpans);
                    var s, c = 0, u = null, f = new ma(t, e.options.tabSize), h = e.options.addModeClass && [null];
                    for ("" == t && Ar(Er(n, r), o); !f.eol();) {
                        if (f.pos > e.options.maxHighlightLength ? (l = !1, a && Hr(e, t, r, f.pos), f.pos = t.length, s = null) : s = Ar(Or(n, f, r, h), o), h) {
                            var d = h[0].name;
                            d && (s = "m-" + (s ? d + " " + s : d))
                        }
                        if (!l || u != s) {
                            for (; c < f.start;)c = Math.min(f.start, c + 5e4), i(c, u);
                            u = s
                        }
                        f.start = f.pos
                    }
                    for (; c < f.pos;) {
                        var p = Math.min(f.pos, c + 5e4);
                        i(p, u), c = p
                    }
                }

                function Rr(e, t, n, r) {
                    var i = [e.state.modeGen], o = {};
                    Pr(e, t.text, e.doc.mode, n, function (e, t) {
                        i.push(e, t)
                    }, o, r);
                    for (var a = 0; a < e.state.overlays.length; ++a) {
                        var l = e.state.overlays[a], s = 1, c = 0;
                        Pr(e, t.text, l.mode, !0, function (e, t) {
                            for (var n = s; e > c;) {
                                var r = i[s];
                                r > e && i.splice(s, 1, e, i[s + 1], r), s += 2, c = Math.min(e, r)
                            }
                            if (t)if (l.opaque) i.splice(n, s - n, e, "cm-overlay " + t), s = n + 2; else for (; s > n; n += 2) {
                                var o = i[n + 1];
                                i[n + 1] = (o ? o + " " : "") + "cm-overlay " + t
                            }
                        }, o)
                    }
                    return {styles: i, classes: o.bgClass || o.textClass ? o : null}
                }

                function Dr(e, t, n) {
                    if (!t.styles || t.styles[0] != e.state.modeGen) {
                        var r = je(e, ti(t)),
                            i = Rr(e, t, t.text.length > e.options.maxHighlightLength ? sa(e.doc.mode, r) : r);
                        t.stateAfter = r, t.styles = i.styles, i.classes ? t.styleClasses = i.classes : t.styleClasses && (t.styleClasses = null), n === e.doc.frontier && e.doc.frontier++
                    }
                    return t.styles
                }

                function Hr(e, t, n, r) {
                    var i = e.doc.mode, o = new ma(t, e.options.tabSize);
                    for (o.start = o.pos = r || 0, "" == t && Er(i, n); !o.eol();)Or(i, o, n), o.start = o.pos
                }

                function Wr(e, t) {
                    if (!e || /^\s*$/.test(e))return null;
                    var n = t.addModeClass ? ka : wa;
                    return n[e] || (n[e] = e.replace(/\S+/g, "cm-$&"))
                }

                function Br(e, t) {
                    var n = ji("span", null, null, wo ? "padding-right: .1px" : null), r = {
                        pre: ji("pre", [n], "CodeMirror-line"),
                        content: n,
                        col: 0,
                        pos: 0,
                        cm: e,
                        splitSpaces: (xo || wo) && e.getOption("lineWrapping")
                    };
                    t.measure = {};
                    for (var i = 0; i <= (t.rest ? t.rest.length : 0); i++) {
                        var o, a = i ? t.rest[i - 1] : t.line;
                        r.pos = 0, r.addToken = Fr, Ji(e.display.measure) && (o = ii(a)) && (r.addToken = jr(r.addToken, o)), r.map = [];
                        var l = t != e.display.externalMeasured && ti(a);
                        qr(a, r, Dr(e, a, l)), a.styleClasses && (a.styleClasses.bgClass && (r.bgClass = $i(a.styleClasses.bgClass, r.bgClass || "")), a.styleClasses.textClass && (r.textClass = $i(a.styleClasses.textClass, r.textClass || ""))), 0 == r.map.length && r.map.push(0, 0, r.content.appendChild(Zi(e.display.measure))), 0 == i ? (t.measure.map = r.map, t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(r.map), (t.measure.caches || (t.measure.caches = [])).push({}))
                    }
                    if (wo) {
                        var s = r.content.lastChild;
                        (/\bcm-tab\b/.test(s.className) || s.querySelector && s.querySelector(".cm-tab")) && (r.content.className = "cm-tab-wrap-hack")
                    }
                    return Pa(e, "renderLine", e, t.line, r.pre), r.pre.className && (r.textClass = $i(r.pre.className, r.textClass || "")), r
                }

                function _r(e) {
                    var t = ji("span", "", "cm-invalidchar");
                    return t.title = "\\u" + e.charCodeAt(0).toString(16), t.setAttribute("aria-label", t.title), t
                }

                function Fr(e, t, n, r, i, o, a) {
                    if (t) {
                        var l = e.splitSpaces ? t.replace(/ {3,}/g, zr) : t, s = e.cm.state.specialChars, c = !1;
                        if (s.test(t))for (var u = document.createDocumentFragment(), f = 0; ;) {
                            s.lastIndex = f;
                            var h = s.exec(t), d = h ? h.index - f : t.length - f;
                            if (d) {
                                var p = document.createTextNode(l.slice(f, f + d));
                                xo && 9 > bo ? u.appendChild(ji("span", [p])) : u.appendChild(p), e.map.push(e.pos, e.pos + d, p), e.col += d, e.pos += d
                            }
                            if (!h)break;
                            if (f += d + 1, "	" == h[0]) {
                                var m = e.cm.options.tabSize, g = m - e.col % m,
                                    p = u.appendChild(ji("span", Oi(g), "cm-tab"));
                                p.setAttribute("role", "presentation"), p.setAttribute("cm-text", "	"), e.col += g
                            } else if ("\r" == h[0] || "\n" == h[0]) {
                                var p = u.appendChild(ji("span", "\r" == h[0] ? "" : "", "cm-invalidchar"));
                                p.setAttribute("cm-text", h[0]), e.col += 1
                            } else {
                                var p = e.cm.options.specialCharPlaceholder(h[0]);
                                p.setAttribute("cm-text", h[0]), xo && 9 > bo ? u.appendChild(ji("span", [p])) : u.appendChild(p), e.col += 1
                            }
                            e.map.push(e.pos, e.pos + 1, p), e.pos++
                        } else {
                            e.col += t.length;
                            var u = document.createTextNode(l);
                            e.map.push(e.pos, e.pos + t.length, u), xo && 9 > bo && (c = !0), e.pos += t.length
                        }
                        if (n || r || i || c || a) {
                            var v = n || "";
                            r && (v += r), i && (v += i);
                            var y = ji("span", [u], v, a);
                            return o && (y.title = o), e.content.appendChild(y)
                        }
                        e.content.appendChild(u)
                    }
                }

                function zr(e) {
                    for (var t = " ", n = 0; n < e.length - 2; ++n)t += n % 2 ? " " : "";
                    return t += " "
                }

                function jr(e, t) {
                    return function (n, r, i, o, a, l, s) {
                        i = i ? i + " cm-force-border" : "cm-force-border";
                        for (var c = n.pos, u = c + r.length; ;) {
                            for (var f = 0; f < t.length; f++) {
                                var h = t[f];
                                if (h.to > c && h.from <= c)break
                            }
                            if (h.to >= u)return e(n, r, i, o, a, l, s);
                            e(n, r.slice(0, h.to - c), i, o, null, l, s), o = null, r = r.slice(h.to - c), c = h.to
                        }
                    }
                }

                function Ur(e, t, n, r) {
                    var i = !r && n.widgetNode;
                    i && e.map.push(e.pos, e.pos + t, i), !r && e.cm.display.input.needsContentAttribute && (i || (i = e.content.appendChild(document.createElement("span"))), i.setAttribute("cm-marker", n.id)), i && (e.cm.display.input.setUneditable(i), e.content.appendChild(i)), e.pos += t
                }

                function qr(e, t, n) {
                    var r = e.markedSpans, i = e.text, o = 0;
                    if (r)for (var a, l, s, c, u, f, h, d = i.length, p = 0, m = 1, g = "", v = 0; ;) {
                        if (v == p) {
                            s = c = u = f = l = "", h = null, v = 1 / 0;
                            for (var y, x = [], b = 0; b < r.length; ++b) {
                                var w = r[b], k = w.marker;
                                "bookmark" == k.type && w.from == p && k.widgetNode ? x.push(k) : w.from <= p && (null == w.to || w.to > p || k.collapsed && w.to == p && w.from == p) ? (null != w.to && w.to != p && v > w.to && (v = w.to, c = ""), k.className && (s += " " + k.className), k.css && (l = (l ? l + ";" : "") + k.css), k.startStyle && w.from == p && (u += " " + k.startStyle), k.endStyle && w.to == v && (y || (y = [])).push(k.endStyle, w.to), k.title && !f && (f = k.title), k.collapsed && (!h || dr(h.marker, k) < 0) && (h = w)) : w.from > p && v > w.from && (v = w.from)
                            }
                            if (y)for (var b = 0; b < y.length; b += 2)y[b + 1] == v && (c += " " + y[b]);
                            if (!h || h.from == p)for (var b = 0; b < x.length; ++b)Ur(t, 0, x[b]);
                            if (h && (h.from || 0) == p) {
                                if (Ur(t, (null == h.to ? d + 1 : h.to) - p, h.marker, null == h.from), null == h.to)return;
                                h.to == p && (h = !1)
                            }
                        }
                        if (p >= d)break;
                        for (var S = Math.min(d, v); ;) {
                            if (g) {
                                var C = p + g.length;
                                if (!h) {
                                    var L = C > S ? g.slice(0, S - p) : g;
                                    t.addToken(t, L, a ? a + s : s, u, p + L.length == v ? c : "", f, l)
                                }
                                if (C >= S) {
                                    g = g.slice(S - p), p = S;
                                    break
                                }
                                p = C, u = ""
                            }
                            g = i.slice(o, o = n[m++]), a = Wr(n[m++], t.cm.options)
                        }
                    } else for (var m = 1; m < n.length; m += 2)t.addToken(t, i.slice(o, o = n[m]), Wr(n[m + 1], t.cm.options))
                }

                function Gr(e, t) {
                    return 0 == t.from.ch && 0 == t.to.ch && "" == Ii(t.text) && (!e.cm || e.cm.options.wholeLineUpdateBefore)
                }

                function Yr(e, t, n, r) {
                    function i(e) {
                        return n ? n[e] : null
                    }

                    function o(e, n, i) {
                        Mr(e, n, i, r), Ci(e, "change", e, t)
                    }

                    function a(e, t) {
                        for (var n = e, o = []; t > n; ++n)o.push(new ba(c[n], i(n), r));
                        return o
                    }

                    var l = t.from, s = t.to, c = t.text, u = Zr(e, l.line), f = Zr(e, s.line), h = Ii(c),
                        d = i(c.length - 1), p = s.line - l.line;
                    if (t.full) e.insert(0, a(0, c.length)), e.remove(c.length, e.size - c.length); else if (Gr(e, t)) {
                        var m = a(0, c.length - 1);
                        o(f, f.text, d), p && e.remove(l.line, p), m.length && e.insert(l.line, m)
                    } else if (u == f)if (1 == c.length) o(u, u.text.slice(0, l.ch) + h + u.text.slice(s.ch), d); else {
                        var m = a(1, c.length - 1);
                        m.push(new ba(h + u.text.slice(s.ch), d, r)), o(u, u.text.slice(0, l.ch) + c[0], i(0)), e.insert(l.line + 1, m)
                    } else if (1 == c.length) o(u, u.text.slice(0, l.ch) + c[0] + f.text.slice(s.ch), i(0)), e.remove(l.line + 1, p); else {
                        o(u, u.text.slice(0, l.ch) + c[0], i(0)), o(f, h + f.text.slice(s.ch), d);
                        var m = a(1, c.length - 1);
                        p > 1 && e.remove(l.line + 1, p - 1), e.insert(l.line + 1, m)
                    }
                    Ci(e, "change", e, t)
                }

                function $r(e) {
                    this.lines = e, this.parent = null;
                    for (var t = 0, n = 0; t < e.length; ++t)e[t].parent = this, n += e[t].height;
                    this.height = n
                }

                function Vr(e) {
                    this.children = e;
                    for (var t = 0, n = 0, r = 0; r < e.length; ++r) {
                        var i = e[r];
                        t += i.chunkSize(), n += i.height, i.parent = this
                    }
                    this.size = t, this.height = n, this.parent = null
                }

                function Kr(e, t, n) {
                    function r(e, i, o) {
                        if (e.linked)for (var a = 0; a < e.linked.length; ++a) {
                            var l = e.linked[a];
                            if (l.doc != i) {
                                var s = o && l.sharedHist;
                                n && !s || (t(l.doc, s), r(l.doc, e, s))
                            }
                        }
                    }

                    r(e, null, !0)
                }

                function Xr(e, t) {
                    if (t.cm)throw new Error("This document is already in use.");
                    e.doc = t, t.cm = e, a(e), n(e), e.options.lineWrapping || h(e), e.options.mode = t.modeOption, Dt(e)
                }

                function Zr(e, t) {
                    if (t -= e.first, 0 > t || t >= e.size)throw new Error("There is no line " + (t + e.first) + " in the document.");
                    for (var n = e; !n.lines;)for (var r = 0; ; ++r) {
                        var i = n.children[r], o = i.chunkSize();
                        if (o > t) {
                            n = i;
                            break
                        }
                        t -= o
                    }
                    return n.lines[t]
                }

                function Jr(e, t, n) {
                    var r = [], i = t.line;
                    return e.iter(t.line, n.line + 1, function (e) {
                        var o = e.text;
                        i == n.line && (o = o.slice(0, n.ch)), i == t.line && (o = o.slice(t.ch)), r.push(o), ++i
                    }), r
                }

                function Qr(e, t, n) {
                    var r = [];
                    return e.iter(t, n, function (e) {
                        r.push(e.text)
                    }), r
                }

                function ei(e, t) {
                    var n = t - e.height;
                    if (n)for (var r = e; r; r = r.parent)r.height += n
                }

                function ti(e) {
                    if (null == e.parent)return null;
                    for (var t = e.parent, n = Pi(t.lines, e),
                             r = t.parent; r; t = r, r = r.parent)for (var i = 0; r.children[i] != t; ++i)n += r.children[i].chunkSize();
                    return n + t.first
                }

                function ni(e, t) {
                    var n = e.first;
                    e:do {
                        for (var r = 0; r < e.children.length; ++r) {
                            var i = e.children[r], o = i.height;
                            if (o > t) {
                                e = i;
                                continue e
                            }
                            t -= o, n += i.chunkSize()
                        }
                        return n
                    } while (!e.lines);
                    for (var r = 0; r < e.lines.length; ++r) {
                        var a = e.lines[r], l = a.height;
                        if (l > t)break;
                        t -= l
                    }
                    return n + r
                }

                function ri(e) {
                    e = yr(e);
                    for (var t = 0, n = e.parent, r = 0; r < n.lines.length; ++r) {
                        var i = n.lines[r];
                        if (i == e)break;
                        t += i.height
                    }
                    for (var o = n.parent; o; n = o, o = n.parent)for (var r = 0; r < o.children.length; ++r) {
                        var a = o.children[r];
                        if (a == n)break;
                        t += a.height
                    }
                    return t
                }

                function ii(e) {
                    var t = e.order;
                    return null == t && (t = e.order = ll(e.text)), t
                }

                function oi(e) {
                    this.done = [], this.undone = [], this.undoDepth = 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = e || 1
                }

                function ai(e, t) {
                    var n = {from: $(t.from), to: Qo(t), text: Jr(e, t.from, t.to)};
                    return di(e, n, t.from.line, t.to.line + 1), Kr(e, function (e) {
                        di(e, n, t.from.line, t.to.line + 1)
                    }, !0), n
                }

                function li(e) {
                    for (; e.length;) {
                        var t = Ii(e);
                        if (!t.ranges)break;
                        e.pop()
                    }
                }

                function si(e, t) {
                    return t ? (li(e.done), Ii(e.done)) : e.done.length && !Ii(e.done).ranges ? Ii(e.done) : e.done.length > 1 && !e.done[e.done.length - 2].ranges ? (e.done.pop(), Ii(e.done)) : void 0
                }

                function ci(e, t, n, r) {
                    var i = e.history;
                    i.undone.length = 0;
                    var o, a = +new Date;
                    if ((i.lastOp == r || i.lastOrigin == t.origin && t.origin && ("+" == t.origin.charAt(0) && e.cm && i.lastModTime > a - e.cm.options.historyEventDelay || "*" == t.origin.charAt(0))) && (o = si(i, i.lastOp == r))) {
                        var l = Ii(o.changes);
                        0 == _o(t.from, t.to) && 0 == _o(t.from, l.to) ? l.to = Qo(t) : o.changes.push(ai(e, t))
                    } else {
                        var s = Ii(i.done);
                        for (s && s.ranges || hi(e.sel, i.done), o = {
                            changes: [ai(e, t)],
                            generation: i.generation
                        }, i.done.push(o); i.done.length > i.undoDepth;)i.done.shift(), i.done[0].ranges || i.done.shift()
                    }
                    i.done.push(n), i.generation = ++i.maxGeneration, i.lastModTime = i.lastSelTime = a, i.lastOp = i.lastSelOp = r, i.lastOrigin = i.lastSelOrigin = t.origin, l || Pa(e, "historyAdded")
                }

                function ui(e, t, n, r) {
                    var i = t.charAt(0);
                    return "*" == i || "+" == i && n.ranges.length == r.ranges.length && n.somethingSelected() == r.somethingSelected() && new Date - e.history.lastSelTime <= (e.cm ? e.cm.options.historyEventDelay : 500)
                }

                function fi(e, t, n, r) {
                    var i = e.history, o = r && r.origin;
                    n == i.lastSelOp || o && i.lastSelOrigin == o && (i.lastModTime == i.lastSelTime && i.lastOrigin == o || ui(e, o, Ii(i.done), t)) ? i.done[i.done.length - 1] = t : hi(t, i.done), i.lastSelTime = +new Date, i.lastSelOrigin = o, i.lastSelOp = n, r && r.clearRedo !== !1 && li(i.undone)
                }

                function hi(e, t) {
                    var n = Ii(t);
                    n && n.ranges && n.equals(e) || t.push(e)
                }

                function di(e, t, n, r) {
                    var i = t["spans_" + e.id], o = 0;
                    e.iter(Math.max(e.first, n), Math.min(e.first + e.size, r), function (n) {
                        n.markedSpans && ((i || (i = t["spans_" + e.id] = {}))[o] = n.markedSpans), ++o
                    })
                }

                function pi(e) {
                    if (!e)return null;
                    for (var t,
                             n = 0; n < e.length; ++n)e[n].marker.explicitlyCleared ? t || (t = e.slice(0, n)) : t && t.push(e[n]);
                    return t ? t.length ? t : null : e
                }

                function mi(e, t) {
                    var n = t["spans_" + e.id];
                    if (!n)return null;
                    for (var r = 0, i = []; r < t.text.length; ++r)i.push(pi(n[r]));
                    return i
                }

                function gi(e, t, n) {
                    for (var r = 0, i = []; r < e.length; ++r) {
                        var o = e[r];
                        if (o.ranges) i.push(n ? ue.prototype.deepCopy.call(o) : o); else {
                            var a = o.changes, l = [];
                            i.push({changes: l});
                            for (var s = 0; s < a.length; ++s) {
                                var c, u = a[s];
                                if (l.push({
                                        from: u.from,
                                        to: u.to,
                                        text: u.text
                                    }), t)for (var f in u)(c = f.match(/^spans_(\d+)$/)) && Pi(t, Number(c[1])) > -1 && (Ii(l)[f] = u[f], delete u[f])
                            }
                        }
                    }
                    return i
                }

                function vi(e, t, n, r) {
                    n < e.line ? e.line += r : t < e.line && (e.line = t, e.ch = 0)
                }

                function yi(e, t, n, r) {
                    for (var i = 0; i < e.length; ++i) {
                        var o = e[i], a = !0;
                        if (o.ranges) {
                            o.copied || (o = e[i] = o.deepCopy(), o.copied = !0);
                            for (var l = 0; l < o.ranges.length; l++)vi(o.ranges[l].anchor, t, n, r), vi(o.ranges[l].head, t, n, r)
                        } else {
                            for (var l = 0; l < o.changes.length; ++l) {
                                var s = o.changes[l];
                                if (n < s.from.line) s.from = Bo(s.from.line + r, s.from.ch), s.to = Bo(s.to.line + r, s.to.ch); else if (t <= s.to.line) {
                                    a = !1;
                                    break
                                }
                            }
                            a || (e.splice(0, i + 1), i = 0)
                        }
                    }
                }

                function xi(e, t) {
                    var n = t.from.line, r = t.to.line, i = t.text.length - (r - n) - 1;
                    yi(e.done, n, r, i), yi(e.undone, n, r, i)
                }

                function bi(e) {
                    return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue
                }

                function wi(e) {
                    return e.target || e.srcElement
                }

                function ki(e) {
                    var t = e.which;
                    return null == t && (1 & e.button ? t = 1 : 2 & e.button ? t = 3 : 4 & e.button && (t = 2)), Eo && e.ctrlKey && 1 == t && (t = 3), t
                }

                function Si(e, t, n) {
                    var r = e._handlers && e._handlers[t];
                    return n ? r && r.length > 0 ? r.slice() : Oa : r || Oa
                }

                function Ci(e, t) {
                    function n(e) {
                        return function () {
                            e.apply(null, o)
                        }
                    }

                    var r = Si(e, t, !1);
                    if (r.length) {
                        var i, o = Array.prototype.slice.call(arguments, 2);
                        Go ? i = Go.delayedCallbacks : Ra ? i = Ra : (i = Ra = [], setTimeout(Li, 0));
                        for (var a = 0; a < r.length; ++a)i.push(n(r[a]))
                    }
                }

                function Li() {
                    var e = Ra;
                    Ra = null;
                    for (var t = 0; t < e.length; ++t)e[t]()
                }

                function Ti(e, t, n) {
                    return "string" == typeof t && (t = {
                        type: t, preventDefault: function () {
                            this.defaultPrevented = !0
                        }
                    }), Pa(e, n || t.type, e, t), bi(t) || t.codemirrorIgnore
                }

                function Mi(e) {
                    var t = e._handlers && e._handlers.cursorActivity;
                    if (t)for (var n = e.curOp.cursorActivityHandlers || (e.curOp.cursorActivityHandlers = []),
                                   r = 0; r < t.length; ++r)-1 == Pi(n, t[r]) && n.push(t[r])
                }

                function Ni(e, t) {
                    return Si(e, t).length > 0
                }

                function Ai(e) {
                    e.prototype.on = function (e, t) {
                        Ea(this, e, t)
                    }, e.prototype.off = function (e, t) {
                        Ia(this, e, t)
                    }
                }

                function Ei() {
                    this.id = null
                }

                function Oi(e) {
                    for (; ja.length <= e;)ja.push(Ii(ja) + " ");
                    return ja[e]
                }

                function Ii(e) {
                    return e[e.length - 1]
                }

                function Pi(e, t) {
                    for (var n = 0; n < e.length; ++n)if (e[n] == t)return n;
                    return -1
                }

                function Ri(e, t) {
                    for (var n = [], r = 0; r < e.length; r++)n[r] = t(e[r], r);
                    return n
                }

                function Di() {
                }

                function Hi(e, t) {
                    var n;
                    return Object.create ? n = Object.create(e) : (Di.prototype = e, n = new Di), t && Wi(t, n), n
                }

                function Wi(e, t, n) {
                    t || (t = {});
                    for (var r in e)!e.hasOwnProperty(r) || n === !1 && t.hasOwnProperty(r) || (t[r] = e[r]);
                    return t
                }

                function Bi(e) {
                    var t = Array.prototype.slice.call(arguments, 1);
                    return function () {
                        return e.apply(null, t)
                    }
                }

                function _i(e, t) {
                    return t ? t.source.indexOf("\\w") > -1 && Ya(e) ? !0 : t.test(e) : Ya(e)
                }

                function Fi(e) {
                    for (var t in e)if (e.hasOwnProperty(t) && e[t])return !1;
                    return !0
                }

                function zi(e) {
                    return e.charCodeAt(0) >= 768 && $a.test(e)
                }

                function ji(e, t, n, r) {
                    var i = document.createElement(e);
                    if (n && (i.className = n), r && (i.style.cssText = r), "string" == typeof t) i.appendChild(document.createTextNode(t)); else if (t)for (var o = 0; o < t.length; ++o)i.appendChild(t[o]);
                    return i
                }

                function Ui(e) {
                    for (var t = e.childNodes.length; t > 0; --t)e.removeChild(e.firstChild);
                    return e
                }

                function qi(e, t) {
                    return Ui(e).appendChild(t)
                }

                function Gi() {
                    for (var e = document.activeElement; e && e.root && e.root.activeElement;)e = e.root.activeElement;
                    return e
                }

                function Yi(e) {
                    return new RegExp("(^|\\s)" + e + "(?:$|\\s)\\s*")
                }

                function $i(e, t) {
                    for (var n = e.split(" "), r = 0; r < n.length; r++)n[r] && !Yi(n[r]).test(t) && (t += " " + n[r]);
                    return t
                }

                function Vi(e) {
                    if (document.body.getElementsByClassName)for (var t = document.body.getElementsByClassName("CodeMirror"),
                                                                      n = 0; n < t.length; n++) {
                        var r = t[n].CodeMirror;
                        r && e(r)
                    }
                }

                function Ki() {
                    Qa || (Xi(), Qa = !0)
                }

                function Xi() {
                    var e;
                    Ea(window, "resize", function () {
                        null == e && (e = setTimeout(function () {
                            e = null, Vi(qt)
                        }, 100))
                    }), Ea(window, "blur", function () {
                        Vi(yn)
                    })
                }

                function Zi(e) {
                    if (null == Ka) {
                        var t = ji("span", "");
                        qi(e, ji("span", [t, document.createTextNode("x")])), 0 != e.firstChild.offsetHeight && (Ka = t.offsetWidth <= 1 && t.offsetHeight > 2 && !(xo && 8 > bo))
                    }
                    var n = Ka ? ji("span", "") : ji("span", "", null, "display: inline-block; width: 1px; margin-right: -1px");
                    return n.setAttribute("cm-text", ""), n
                }

                function Ji(e) {
                    if (null != Xa)return Xa;
                    var t = qi(e, document.createTextNode("AA")), n = qa(t, 0, 1).getBoundingClientRect();
                    if (!n || n.left == n.right)return !1;
                    var r = qa(t, 1, 2).getBoundingClientRect();
                    return Xa = r.right - n.right < 3
                }

                function Qi(e) {
                    if (null != il)return il;
                    var t = qi(e, ji("span", "x")), n = t.getBoundingClientRect(),
                        r = qa(t, 0, 1).getBoundingClientRect();
                    return il = Math.abs(n.left - r.left) > 1
                }

                function eo(e, t, n, r) {
                    if (!e)return r(t, n, "ltr");
                    for (var i = !1, o = 0; o < e.length; ++o) {
                        var a = e[o];
                        (a.from < n && a.to > t || t == n && a.to == t) && (r(Math.max(a.from, t), Math.min(a.to, n), 1 == a.level ? "rtl" : "ltr"), i = !0)
                    }
                    i || r(t, n, "ltr")
                }

                function to(e) {
                    return e.level % 2 ? e.to : e.from
                }

                function no(e) {
                    return e.level % 2 ? e.from : e.to
                }

                function ro(e) {
                    var t = ii(e);
                    return t ? to(t[0]) : 0
                }

                function io(e) {
                    var t = ii(e);
                    return t ? no(Ii(t)) : e.text.length
                }

                function oo(e, t) {
                    var n = Zr(e.doc, t), r = yr(n);
                    r != n && (t = ti(r));
                    var i = ii(r), o = i ? i[0].level % 2 ? io(r) : ro(r) : 0;
                    return Bo(t, o)
                }

                function ao(e, t) {
                    for (var n, r = Zr(e.doc, t); n = gr(r);)r = n.find(1, !0).line, t = null;
                    var i = ii(r), o = i ? i[0].level % 2 ? ro(r) : io(r) : r.text.length;
                    return Bo(null == t ? ti(r) : t, o)
                }

                function lo(e, t) {
                    var n = oo(e, t.line), r = Zr(e.doc, n.line), i = ii(r);
                    if (!i || 0 == i[0].level) {
                        var o = Math.max(0, r.text.search(/\S/)), a = t.line == n.line && t.ch <= o && t.ch;
                        return Bo(n.line, a ? 0 : o)
                    }
                    return n
                }

                function so(e, t, n) {
                    var r = e[0].level;
                    return t == r ? !0 : n == r ? !1 : n > t
                }

                function co(e, t) {
                    al = null;
                    for (var n, r = 0; r < e.length; ++r) {
                        var i = e[r];
                        if (i.from < t && i.to > t)return r;
                        if (i.from == t || i.to == t) {
                            if (null != n)return so(e, i.level, e[n].level) ? (i.from != i.to && (al = n), r) : (i.from != i.to && (al = r), n);
                            n = r
                        }
                    }
                    return n
                }

                function uo(e, t, n, r) {
                    if (!r)return t + n;
                    do t += n; while (t > 0 && zi(e.text.charAt(t)));
                    return t
                }

                function fo(e, t, n, r) {
                    var i = ii(e);
                    if (!i)return ho(e, t, n, r);
                    for (var o = co(i, t), a = i[o], l = uo(e, t, a.level % 2 ? -n : n, r); ;) {
                        if (l > a.from && l < a.to)return l;
                        if (l == a.from || l == a.to)return co(i, l) == o ? l : (a = i[o += n], n > 0 == a.level % 2 ? a.to : a.from);
                        if (a = i[o += n], !a)return null;
                        l = n > 0 == a.level % 2 ? uo(e, a.to, -1, r) : uo(e, a.from, 1, r)
                    }
                }

                function ho(e, t, n, r) {
                    var i = t + n;
                    if (r)for (; i > 0 && zi(e.text.charAt(i));)i += n;
                    return 0 > i || i > e.text.length ? null : i
                }

                var po = navigator.userAgent, mo = navigator.platform, go = /gecko\/\d/i.test(po),
                    vo = /MSIE \d/.test(po), yo = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(po), xo = vo || yo,
                    bo = xo && (vo ? document.documentMode || 6 : yo[1]), wo = /WebKit\//.test(po),
                    ko = wo && /Qt\/\d+\.\d+/.test(po), So = /Chrome\//.test(po), Co = /Opera\//.test(po),
                    Lo = /Apple Computer/.test(navigator.vendor), To = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(po),
                    Mo = /PhantomJS/.test(po), No = /AppleWebKit/.test(po) && /Mobile\/\w+/.test(po),
                    Ao = No || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(po),
                    Eo = No || /Mac/.test(mo), Oo = /\bCrOS\b/.test(po), Io = /win/i.test(mo),
                    Po = Co && po.match(/Version\/(\d*\.\d*)/);
                Po && (Po = Number(Po[1])), Po && Po >= 15 && (Co = !1, wo = !0);
                var Ro = Eo && (ko || Co && (null == Po || 12.11 > Po)), Do = go || xo && bo >= 9, Ho = !1, Wo = !1;
                m.prototype = Wi({
                    update: function (e) {
                        var t = e.scrollWidth > e.clientWidth + 1, n = e.scrollHeight > e.clientHeight + 1,
                            r = e.nativeBarWidth;
                        if (n) {
                            this.vert.style.display = "block", this.vert.style.bottom = t ? r + "px" : "0";
                            var i = e.viewHeight - (t ? r : 0);
                            this.vert.firstChild.style.height = Math.max(0, e.scrollHeight - e.clientHeight + i) + "px"
                        } else this.vert.style.display = "", this.vert.firstChild.style.height = "0";
                        if (t) {
                            this.horiz.style.display = "block", this.horiz.style.right = n ? r + "px" : "0", this.horiz.style.left = e.barLeft + "px";
                            var o = e.viewWidth - e.barLeft - (n ? r : 0);
                            this.horiz.firstChild.style.width = e.scrollWidth - e.clientWidth + o + "px"
                        } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
                        return !this.checkedZeroWidth && e.clientHeight > 0 && (0 == r && this.zeroWidthHack(), this.checkedZeroWidth = !0), {
                            right: n ? r : 0,
                            bottom: t ? r : 0
                        }
                    }, setScrollLeft: function (e) {
                        this.horiz.scrollLeft != e && (this.horiz.scrollLeft = e), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz)
                    }, setScrollTop: function (e) {
                        this.vert.scrollTop != e && (this.vert.scrollTop = e), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert)
                    }, zeroWidthHack: function () {
                        var e = Eo && !To ? "12px" : "18px";
                        this.horiz.style.height = this.vert.style.width = e, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none", this.disableHoriz = new Ei, this.disableVert = new Ei
                    }, enableZeroWidthBar: function (e, t) {
                        function n() {
                            var r = e.getBoundingClientRect(), i = document.elementFromPoint(r.left + 1, r.bottom - 1);
                            i != e ? e.style.pointerEvents = "none" : t.set(1e3, n)
                        }

                        e.style.pointerEvents = "auto", t.set(1e3, n)
                    }, clear: function () {
                        var e = this.horiz.parentNode;
                        e.removeChild(this.horiz), e.removeChild(this.vert)
                    }
                }, m.prototype), g.prototype = Wi({
                    update: function () {
                        return {bottom: 0, right: 0}
                    }, setScrollLeft: function () {
                    }, setScrollTop: function () {
                    }, clear: function () {
                    }
                }, g.prototype), e.scrollbarModel = {"native": m, "null": g}, L.prototype.signal = function (e, t) {
                    Ni(e, t) && this.events.push(arguments)
                }, L.prototype.finish = function () {
                    for (var e = 0; e < this.events.length; e++)Pa.apply(null, this.events[e])
                };
                var Bo = e.Pos = function (e, t) {
                    return this instanceof Bo ? (this.line = e, void(this.ch = t)) : new Bo(e, t)
                }, _o = e.cmpPos = function (e, t) {
                    return e.line - t.line || e.ch - t.ch
                }, Fo = null;
                ne.prototype = Wi({
                    init: function (e) {
                        function t(e) {
                            if (!Ti(r, e)) {
                                if (r.somethingSelected()) Fo = {
                                    lineWise: !1,
                                    text: r.getSelections()
                                }, n.inaccurateSelection && (n.prevInput = "", n.inaccurateSelection = !1, o.value = Fo.text.join("\n"), Ua(o)); else {
                                    if (!r.options.lineWiseCopyCut)return;
                                    var t = ee(r);
                                    Fo = {
                                        lineWise: !0,
                                        text: t.text
                                    }, "cut" == e.type ? r.setSelections(t.ranges, null, Wa) : (n.prevInput = "", o.value = t.text.join("\n"), Ua(o))
                                }
                                "cut" == e.type && (r.state.cutIncoming = !0)
                            }
                        }

                        var n = this, r = this.cm, i = this.wrapper = re(), o = this.textarea = i.firstChild;
                        e.wrapper.insertBefore(i, e.wrapper.firstChild), No && (o.style.width = "0px"), Ea(o, "input", function () {
                            xo && bo >= 9 && n.hasSelection && (n.hasSelection = null), n.poll()
                        }), Ea(o, "paste", function (e) {
                            Ti(r, e) || J(e, r) || (r.state.pasteIncoming = !0, n.fastPoll())
                        }), Ea(o, "cut", t), Ea(o, "copy", t), Ea(e.scroller, "paste", function (t) {
                            Gt(e, t) || Ti(r, t) || (r.state.pasteIncoming = !0, n.focus())
                        }), Ea(e.lineSpace, "selectstart", function (t) {
                            Gt(e, t) || Ma(t)
                        }), Ea(o, "compositionstart", function () {
                            var e = r.getCursor("from");
                            n.composing && n.composing.range.clear(), n.composing = {
                                start: e,
                                range: r.markText(e, r.getCursor("to"), {className: "CodeMirror-composing"})
                            }
                        }), Ea(o, "compositionend", function () {
                            n.composing && (n.poll(), n.composing.range.clear(), n.composing = null)
                        })
                    }, prepareSelection: function () {
                        var e = this.cm, t = e.display, n = e.doc, r = De(e);
                        if (e.options.moveInputWithCursor) {
                            var i = dt(e, n.sel.primary().head, "div"), o = t.wrapper.getBoundingClientRect(),
                                a = t.lineDiv.getBoundingClientRect();
                            r.teTop = Math.max(0, Math.min(t.wrapper.clientHeight - 10, i.top + a.top - o.top)), r.teLeft = Math.max(0, Math.min(t.wrapper.clientWidth - 10, i.left + a.left - o.left))
                        }
                        return r
                    }, showSelection: function (e) {
                        var t = this.cm, n = t.display;
                        qi(n.cursorDiv, e.cursors), qi(n.selectionDiv, e.selection), null != e.teTop && (this.wrapper.style.top = e.teTop + "px", this.wrapper.style.left = e.teLeft + "px")
                    }, reset: function (e) {
                        if (!this.contextMenuPending) {
                            var t, n, r = this.cm, i = r.doc;
                            if (r.somethingSelected()) {
                                this.prevInput = "";
                                var o = i.sel.primary();
                                t = rl && (o.to().line - o.from().line > 100 || (n = r.getSelection()).length > 1e3);
                                var a = t ? "-" : n || r.getSelection();
                                this.textarea.value = a, r.state.focused && Ua(this.textarea), xo && bo >= 9 && (this.hasSelection = a)
                            } else e || (this.prevInput = this.textarea.value = "", xo && bo >= 9 && (this.hasSelection = null));
                            this.inaccurateSelection = t
                        }
                    }, getField: function () {
                        return this.textarea
                    }, supportsTouch: function () {
                        return !1
                    }, focus: function () {
                        if ("nocursor" != this.cm.options.readOnly && (!Ao || Gi() != this.textarea))try {
                            this.textarea.focus()
                        } catch (e) {
                        }
                    }, blur: function () {
                        this.textarea.blur()
                    }, resetPosition: function () {
                        this.wrapper.style.top = this.wrapper.style.left = 0;
                    }, receivedFocus: function () {
                        this.slowPoll()
                    }, slowPoll: function () {
                        var e = this;
                        e.pollingFast || e.polling.set(this.cm.options.pollInterval, function () {
                            e.poll(), e.cm.state.focused && e.slowPoll()
                        })
                    }, fastPoll: function () {
                        function e() {
                            var r = n.poll();
                            r || t ? (n.pollingFast = !1, n.slowPoll()) : (t = !0, n.polling.set(60, e))
                        }

                        var t = !1, n = this;
                        n.pollingFast = !0, n.polling.set(20, e)
                    }, poll: function () {
                        var e = this.cm, t = this.textarea, n = this.prevInput;
                        if (this.contextMenuPending || !e.state.focused || nl(t) && !n && !this.composing || e.isReadOnly() || e.options.disableInput || e.state.keySeq)return !1;
                        var r = t.value;
                        if (r == n && !e.somethingSelected())return !1;
                        if (xo && bo >= 9 && this.hasSelection === r || Eo && /[\uf700-\uf7ff]/.test(r))return e.display.input.reset(), !1;
                        if (e.doc.sel == e.display.selForContextMenu) {
                            var i = r.charCodeAt(0);
                            if (8203 != i || n || (n = ""), 8666 == i)return this.reset(), this.cm.execCommand("undo")
                        }
                        for (var o = 0,
                                 a = Math.min(n.length, r.length); a > o && n.charCodeAt(o) == r.charCodeAt(o);)++o;
                        var l = this;
                        return At(e, function () {
                            Z(e, r.slice(o), n.length - o, null, l.composing ? "*compose" : null), r.length > 1e3 || r.indexOf("\n") > -1 ? t.value = l.prevInput = "" : l.prevInput = r, l.composing && (l.composing.range.clear(), l.composing.range = e.markText(l.composing.start, e.getCursor("to"), {className: "CodeMirror-composing"}))
                        }), !0
                    }, ensurePolled: function () {
                        this.pollingFast && this.poll() && (this.pollingFast = !1)
                    }, onKeyPress: function () {
                        xo && bo >= 9 && (this.hasSelection = null), this.fastPoll()
                    }, onContextMenu: function (e) {
                        function t() {
                            if (null != a.selectionStart) {
                                var e = i.somethingSelected(), t = "" + (e ? a.value : "");
                                a.value = "", a.value = t, r.prevInput = e ? "" : "", a.selectionStart = 1, a.selectionEnd = t.length, o.selForContextMenu = i.doc.sel
                            }
                        }

                        function n() {
                            if (r.contextMenuPending = !1, r.wrapper.style.cssText = f, a.style.cssText = u, xo && 9 > bo && o.scrollbars.setScrollTop(o.scroller.scrollTop = s), null != a.selectionStart) {
                                (!xo || xo && 9 > bo) && t();
                                var e = 0, n = function () {
                                    o.selForContextMenu == i.doc.sel && 0 == a.selectionStart && a.selectionEnd > 0 && "" == r.prevInput ? Et(i, ua.selectAll)(i) : e++ < 10 ? o.detectingSelectAll = setTimeout(n, 500) : o.input.reset()
                                };
                                o.detectingSelectAll = setTimeout(n, 200)
                            }
                        }

                        var r = this, i = r.cm, o = i.display, a = r.textarea, l = Yt(i, e), s = o.scroller.scrollTop;
                        if (l && !Co) {
                            var c = i.options.resetSelectionOnContextMenu;
                            c && -1 == i.doc.sel.contains(l) && Et(i, Te)(i.doc, de(l), Wa);
                            var u = a.style.cssText, f = r.wrapper.style.cssText;
                            r.wrapper.style.cssText = "position: absolute";
                            var h = r.wrapper.getBoundingClientRect();
                            if (a.style.cssText = "position: absolute; width: 30px; height: 30px; top: " + (e.clientY - h.top - 5) + "px; left: " + (e.clientX - h.left - 5) + "px; z-index: 1000; background: " + (xo ? "rgba(255, 255, 255, .05)" : "transparent") + "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);", wo)var d = window.scrollY;
                            if (o.input.focus(), wo && window.scrollTo(null, d), o.input.reset(), i.somethingSelected() || (a.value = r.prevInput = " "), r.contextMenuPending = !0, o.selForContextMenu = i.doc.sel, clearTimeout(o.detectingSelectAll), xo && bo >= 9 && t(), Do) {
                                Aa(e);
                                var p = function () {
                                    Ia(window, "mouseup", p), setTimeout(n, 20)
                                };
                                Ea(window, "mouseup", p)
                            } else setTimeout(n, 50)
                        }
                    }, readOnlyChanged: function (e) {
                        e || this.reset()
                    }, setUneditable: Di, needsContentAttribute: !1
                }, ne.prototype), ie.prototype = Wi({
                    init: function (e) {
                        function t(e) {
                            if (!Ti(r, e)) {
                                if (r.somethingSelected()) Fo = {
                                    lineWise: !1,
                                    text: r.getSelections()
                                }, "cut" == e.type && r.replaceSelection("", null, "cut"); else {
                                    if (!r.options.lineWiseCopyCut)return;
                                    var t = ee(r);
                                    Fo = {lineWise: !0, text: t.text}, "cut" == e.type && r.operation(function () {
                                        r.setSelections(t.ranges, 0, Wa), r.replaceSelection("", null, "cut")
                                    })
                                }
                                if (e.clipboardData && !No) e.preventDefault(), e.clipboardData.clearData(), e.clipboardData.setData("text/plain", Fo.text.join("\n")); else {
                                    var n = re(), i = n.firstChild;
                                    r.display.lineSpace.insertBefore(n, r.display.lineSpace.firstChild), i.value = Fo.text.join("\n");
                                    var o = document.activeElement;
                                    Ua(i), setTimeout(function () {
                                        r.display.lineSpace.removeChild(n), o.focus()
                                    }, 50)
                                }
                            }
                        }

                        var n = this, r = n.cm, i = n.div = e.lineDiv;
                        te(i), Ea(i, "paste", function (e) {
                            Ti(r, e) || J(e, r)
                        }), Ea(i, "compositionstart", function (e) {
                            var t = e.data;
                            if (n.composing = {sel: r.doc.sel, data: t, startData: t}, t) {
                                var i = r.doc.sel.primary(), o = r.getLine(i.head.line),
                                    a = o.indexOf(t, Math.max(0, i.head.ch - t.length));
                                a > -1 && a <= i.head.ch && (n.composing.sel = de(Bo(i.head.line, a), Bo(i.head.line, a + t.length)))
                            }
                        }), Ea(i, "compositionupdate", function (e) {
                            n.composing.data = e.data
                        }), Ea(i, "compositionend", function (e) {
                            var t = n.composing;
                            t && (e.data == t.startData || /\u200b/.test(e.data) || (t.data = e.data), setTimeout(function () {
                                t.handled || n.applyComposition(t), n.composing == t && (n.composing = null)
                            }, 50))
                        }), Ea(i, "touchstart", function () {
                            n.forceCompositionEnd()
                        }), Ea(i, "input", function () {
                            n.composing || !r.isReadOnly() && n.pollContent() || At(n.cm, function () {
                                Dt(r)
                            })
                        }), Ea(i, "copy", t), Ea(i, "cut", t)
                    }, prepareSelection: function () {
                        var e = De(this.cm, !1);
                        return e.focus = this.cm.state.focused, e
                    }, showSelection: function (e, t) {
                        e && this.cm.display.view.length && ((e.focus || t) && this.showPrimarySelection(), this.showMultipleSelections(e))
                    }, showPrimarySelection: function () {
                        var e = window.getSelection(), t = this.cm.doc.sel.primary(),
                            n = le(this.cm, e.anchorNode, e.anchorOffset), r = le(this.cm, e.focusNode, e.focusOffset);
                        if (!n || n.bad || !r || r.bad || 0 != _o(K(n, r), t.from()) || 0 != _o(V(n, r), t.to())) {
                            var i = oe(this.cm, t.from()), o = oe(this.cm, t.to());
                            if (i || o) {
                                var a = this.cm.display.view, l = e.rangeCount && e.getRangeAt(0);
                                if (i) {
                                    if (!o) {
                                        var s = a[a.length - 1].measure, c = s.maps ? s.maps[s.maps.length - 1] : s.map;
                                        o = {node: c[c.length - 1], offset: c[c.length - 2] - c[c.length - 3]}
                                    }
                                } else i = {node: a[0].measure.map[2], offset: 0};
                                try {
                                    var u = qa(i.node, i.offset, o.offset, o.node)
                                } catch (f) {
                                }
                                u && (!go && this.cm.state.focused ? (e.collapse(i.node, i.offset), u.collapsed || e.addRange(u)) : (e.removeAllRanges(), e.addRange(u)), l && null == e.anchorNode ? e.addRange(l) : go && this.startGracePeriod()), this.rememberSelection()
                            }
                        }
                    }, startGracePeriod: function () {
                        var e = this;
                        clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function () {
                            e.gracePeriod = !1, e.selectionChanged() && e.cm.operation(function () {
                                e.cm.curOp.selectionChanged = !0
                            })
                        }, 20)
                    }, showMultipleSelections: function (e) {
                        qi(this.cm.display.cursorDiv, e.cursors), qi(this.cm.display.selectionDiv, e.selection)
                    }, rememberSelection: function () {
                        var e = window.getSelection();
                        this.lastAnchorNode = e.anchorNode, this.lastAnchorOffset = e.anchorOffset, this.lastFocusNode = e.focusNode, this.lastFocusOffset = e.focusOffset
                    }, selectionInEditor: function () {
                        var e = window.getSelection();
                        if (!e.rangeCount)return !1;
                        var t = e.getRangeAt(0).commonAncestorContainer;
                        return Va(this.div, t)
                    }, focus: function () {
                        "nocursor" != this.cm.options.readOnly && this.div.focus()
                    }, blur: function () {
                        this.div.blur()
                    }, getField: function () {
                        return this.div
                    }, supportsTouch: function () {
                        return !0
                    }, receivedFocus: function () {
                        function e() {
                            t.cm.state.focused && (t.pollSelection(), t.polling.set(t.cm.options.pollInterval, e))
                        }

                        var t = this;
                        this.selectionInEditor() ? this.pollSelection() : At(this.cm, function () {
                            t.cm.curOp.selectionChanged = !0
                        }), this.polling.set(this.cm.options.pollInterval, e)
                    }, selectionChanged: function () {
                        var e = window.getSelection();
                        return e.anchorNode != this.lastAnchorNode || e.anchorOffset != this.lastAnchorOffset || e.focusNode != this.lastFocusNode || e.focusOffset != this.lastFocusOffset
                    }, pollSelection: function () {
                        if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
                            var e = window.getSelection(), t = this.cm;
                            this.rememberSelection();
                            var n = le(t, e.anchorNode, e.anchorOffset), r = le(t, e.focusNode, e.focusOffset);
                            n && r && At(t, function () {
                                Te(t.doc, de(n, r), Wa), (n.bad || r.bad) && (t.curOp.selectionChanged = !0)
                            })
                        }
                    }, pollContent: function () {
                        var e = this.cm, t = e.display, n = e.doc.sel.primary(), r = n.from(), i = n.to();
                        if (r.line < t.viewFrom || i.line > t.viewTo - 1)return !1;
                        var o;
                        if (r.line == t.viewFrom || 0 == (o = Bt(e, r.line)))var a = ti(t.view[0].line),
                            l = t.view[0].node; else var a = ti(t.view[o].line), l = t.view[o - 1].node.nextSibling;
                        var s = Bt(e, i.line);
                        if (s == t.view.length - 1)var c = t.viewTo - 1,
                            u = t.lineDiv.lastChild; else var c = ti(t.view[s + 1].line) - 1,
                            u = t.view[s + 1].node.previousSibling;
                        for (var f = e.doc.splitLines(ce(e, l, u, a, c)),
                                 h = Jr(e.doc, Bo(a, 0), Bo(c, Zr(e.doc, c).text.length)); f.length > 1 && h.length > 1;)if (Ii(f) == Ii(h)) f.pop(), h.pop(), c--; else {
                            if (f[0] != h[0])break;
                            f.shift(), h.shift(), a++
                        }
                        for (var d = 0, p = 0, m = f[0], g = h[0],
                                 v = Math.min(m.length, g.length); v > d && m.charCodeAt(d) == g.charCodeAt(d);)++d;
                        for (var y = Ii(f), x = Ii(h),
                                 b = Math.min(y.length - (1 == f.length ? d : 0), x.length - (1 == h.length ? d : 0)); b > p && y.charCodeAt(y.length - p - 1) == x.charCodeAt(x.length - p - 1);)++p;
                        f[f.length - 1] = y.slice(0, y.length - p), f[0] = f[0].slice(d);
                        var w = Bo(a, d), k = Bo(c, h.length ? Ii(h).length - p : 0);
                        return f.length > 1 || f[0] || _o(w, k) ? (In(e.doc, f, w, k, "+input"), !0) : void 0
                    }, ensurePolled: function () {
                        this.forceCompositionEnd()
                    }, reset: function () {
                        this.forceCompositionEnd()
                    }, forceCompositionEnd: function () {
                        this.composing && !this.composing.handled && (this.applyComposition(this.composing), this.composing.handled = !0, this.div.blur(), this.div.focus())
                    }, applyComposition: function (e) {
                        this.cm.isReadOnly() ? Et(this.cm, Dt)(this.cm) : e.data && e.data != e.startData && Et(this.cm, Z)(this.cm, e.data, 0, e.sel)
                    }, setUneditable: function (e) {
                        e.contentEditable = "false"
                    }, onKeyPress: function (e) {
                        e.preventDefault(), this.cm.isReadOnly() || Et(this.cm, Z)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0)
                    }, readOnlyChanged: function (e) {
                        this.div.contentEditable = String("nocursor" != e)
                    }, onContextMenu: Di, resetPosition: Di, needsContentAttribute: !0
                }, ie.prototype), e.inputStyles = {
                    textarea: ne,
                    contenteditable: ie
                }, ue.prototype = {
                    primary: function () {
                        return this.ranges[this.primIndex]
                    }, equals: function (e) {
                        if (e == this)return !0;
                        if (e.primIndex != this.primIndex || e.ranges.length != this.ranges.length)return !1;
                        for (var t = 0; t < this.ranges.length; t++) {
                            var n = this.ranges[t], r = e.ranges[t];
                            if (0 != _o(n.anchor, r.anchor) || 0 != _o(n.head, r.head))return !1
                        }
                        return !0
                    }, deepCopy: function () {
                        for (var e = [],
                                 t = 0; t < this.ranges.length; t++)e[t] = new fe($(this.ranges[t].anchor), $(this.ranges[t].head));
                        return new ue(e, this.primIndex)
                    }, somethingSelected: function () {
                        for (var e = 0; e < this.ranges.length; e++)if (!this.ranges[e].empty())return !0;
                        return !1
                    }, contains: function (e, t) {
                        t || (t = e);
                        for (var n = 0; n < this.ranges.length; n++) {
                            var r = this.ranges[n];
                            if (_o(t, r.from()) >= 0 && _o(e, r.to()) <= 0)return n
                        }
                        return -1
                    }
                }, fe.prototype = {
                    from: function () {
                        return K(this.anchor, this.head)
                    }, to: function () {
                        return V(this.anchor, this.head)
                    }, empty: function () {
                        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
                    }
                };
                var zo, jo, Uo, qo = {left: 0, right: 0, top: 0, bottom: 0}, Go = null, Yo = 0, $o = 0, Vo = 0,
                    Ko = null;
                xo ? Ko = -.53 : go ? Ko = 15 : So ? Ko = -.7 : Lo && (Ko = -1 / 3);
                var Xo = function (e) {
                    var t = e.wheelDeltaX, n = e.wheelDeltaY;
                    return null == t && e.detail && e.axis == e.HORIZONTAL_AXIS && (t = e.detail), null == n && e.detail && e.axis == e.VERTICAL_AXIS ? n = e.detail : null == n && (n = e.wheelDelta), {
                        x: t,
                        y: n
                    }
                };
                e.wheelEventPixels = function (e) {
                    var t = Xo(e);
                    return t.x *= Ko, t.y *= Ko, t
                };
                var Zo = new Ei, Jo = null, Qo = e.changeEnd = function (e) {
                    return e.text ? Bo(e.from.line + e.text.length - 1, Ii(e.text).length + (1 == e.text.length ? e.from.ch : 0)) : e.to
                };
                e.prototype = {
                    constructor: e,
                    focus: function () {
                        window.focus(), this.display.input.focus()
                    },
                    setOption: function (e, t) {
                        var n = this.options, r = n[e];
                        n[e] == t && "mode" != e || (n[e] = t, ta.hasOwnProperty(e) && Et(this, ta[e])(this, t, r))
                    },
                    getOption: function (e) {
                        return this.options[e]
                    },
                    getDoc: function () {
                        return this.doc
                    },
                    addKeyMap: function (e, t) {
                        this.state.keyMaps[t ? "push" : "unshift"]($n(e))
                    },
                    removeKeyMap: function (e) {
                        for (var t = this.state.keyMaps,
                                 n = 0; n < t.length; ++n)if (t[n] == e || t[n].name == e)return t.splice(n, 1), !0
                    },
                    addOverlay: Ot(function (t, n) {
                        var r = t.token ? t : e.getMode(this.options, t);
                        if (r.startState)throw new Error("Overlays may not be stateful.");
                        this.state.overlays.push({
                            mode: r,
                            modeSpec: t,
                            opaque: n && n.opaque
                        }), this.state.modeGen++, Dt(this)
                    }),
                    removeOverlay: Ot(function (e) {
                        for (var t = this.state.overlays, n = 0; n < t.length; ++n) {
                            var r = t[n].modeSpec;
                            if (r == e || "string" == typeof e && r.name == e)return t.splice(n, 1), this.state.modeGen++, void Dt(this)
                        }
                    }),
                    indentLine: Ot(function (e, t, n) {
                        "string" != typeof t && "number" != typeof t && (t = null == t ? this.options.smartIndent ? "smart" : "prev" : t ? "add" : "subtract"), ve(this.doc, e) && Fn(this, e, t, n)
                    }),
                    indentSelection: Ot(function (e) {
                        for (var t = this.doc.sel.ranges, n = -1, r = 0; r < t.length; r++) {
                            var i = t[r];
                            if (i.empty()) i.head.line > n && (Fn(this, i.head.line, e, !0), n = i.head.line, r == this.doc.sel.primIndex && Bn(this)); else {
                                var o = i.from(), a = i.to(), l = Math.max(n, o.line);
                                n = Math.min(this.lastLine(), a.line - (a.ch ? 0 : 1)) + 1;
                                for (var s = l; n > s; ++s)Fn(this, s, e);
                                var c = this.doc.sel.ranges;
                                0 == o.ch && t.length == c.length && c[r].from().ch > 0 && ke(this.doc, r, new fe(o, c[r].to()), Wa)
                            }
                        }
                    }),
                    getTokenAt: function (e, t) {
                        return Ir(this, e, t)
                    },
                    getLineTokens: function (e, t) {
                        return Ir(this, Bo(e), t, !0)
                    },
                    getTokenTypeAt: function (e) {
                        e = me(this.doc, e);
                        var t, n = Dr(this, Zr(this.doc, e.line)), r = 0, i = (n.length - 1) / 2, o = e.ch;
                        if (0 == o) t = n[2]; else for (; ;) {
                            var a = r + i >> 1;
                            if ((a ? n[2 * a - 1] : 0) >= o) i = a; else {
                                if (!(n[2 * a + 1] < o)) {
                                    t = n[2 * a + 2];
                                    break
                                }
                                r = a + 1
                            }
                        }
                        var l = t ? t.indexOf("cm-overlay ") : -1;
                        return 0 > l ? t : 0 == l ? null : t.slice(0, l - 1)
                    },
                    getModeAt: function (t) {
                        var n = this.doc.mode;
                        return n.innerMode ? e.innerMode(n, this.getTokenAt(t).state).mode : n
                    },
                    getHelper: function (e, t) {
                        return this.getHelpers(e, t)[0]
                    },
                    getHelpers: function (e, t) {
                        var n = [];
                        if (!la.hasOwnProperty(t))return n;
                        var r = la[t], i = this.getModeAt(e);
                        if ("string" == typeof i[t]) r[i[t]] && n.push(r[i[t]]); else if (i[t])for (var o = 0; o < i[t].length; o++) {
                            var a = r[i[t][o]];
                            a && n.push(a)
                        } else i.helperType && r[i.helperType] ? n.push(r[i.helperType]) : r[i.name] && n.push(r[i.name]);
                        for (var o = 0; o < r._global.length; o++) {
                            var l = r._global[o];
                            l.pred(i, this) && -1 == Pi(n, l.val) && n.push(l.val)
                        }
                        return n
                    },
                    getStateAfter: function (e, t) {
                        var n = this.doc;
                        return e = pe(n, null == e ? n.first + n.size - 1 : e), je(this, e + 1, t)
                    },
                    cursorCoords: function (e, t) {
                        var n, r = this.doc.sel.primary();
                        return n = null == e ? r.head : "object" == typeof e ? me(this.doc, e) : e ? r.from() : r.to(), dt(this, n, t || "page")
                    },
                    charCoords: function (e, t) {
                        return ht(this, me(this.doc, e), t || "page")
                    },
                    coordsChar: function (e, t) {
                        return e = ft(this, e, t || "page"), gt(this, e.left, e.top)
                    },
                    lineAtHeight: function (e, t) {
                        return e = ft(this, {
                            top: e,
                            left: 0
                        }, t || "page").top, ni(this.doc, e + this.display.viewOffset)
                    },
                    heightAtLine: function (e, t) {
                        var n, r = !1;
                        if ("number" == typeof e) {
                            var i = this.doc.first + this.doc.size - 1;
                            e < this.doc.first ? e = this.doc.first : e > i && (e = i, r = !0), n = Zr(this.doc, e)
                        } else n = e;
                        return ut(this, n, {top: 0, left: 0}, t || "page").top + (r ? this.doc.height - ri(n) : 0)
                    },
                    defaultTextHeight: function () {
                        return yt(this.display)
                    },
                    defaultCharWidth: function () {
                        return xt(this.display)
                    },
                    setGutterMarker: Ot(function (e, t, n) {
                        return zn(this.doc, e, "gutter", function (e) {
                            var r = e.gutterMarkers || (e.gutterMarkers = {});
                            return r[t] = n, !n && Fi(r) && (e.gutterMarkers = null), !0
                        })
                    }),
                    clearGutter: Ot(function (e) {
                        var t = this, n = t.doc, r = n.first;
                        n.iter(function (n) {
                            n.gutterMarkers && n.gutterMarkers[e] && (n.gutterMarkers[e] = null, Ht(t, r, "gutter"), Fi(n.gutterMarkers) && (n.gutterMarkers = null)), ++r
                        })
                    }),
                    lineInfo: function (e) {
                        if ("number" == typeof e) {
                            if (!ve(this.doc, e))return null;
                            var t = e;
                            if (e = Zr(this.doc, e), !e)return null
                        } else {
                            var t = ti(e);
                            if (null == t)return null
                        }
                        return {
                            line: t,
                            handle: e,
                            text: e.text,
                            gutterMarkers: e.gutterMarkers,
                            textClass: e.textClass,
                            bgClass: e.bgClass,
                            wrapClass: e.wrapClass,
                            widgets: e.widgets
                        }
                    },
                    getViewport: function () {
                        return {from: this.display.viewFrom, to: this.display.viewTo}
                    },
                    addWidget: function (e, t, n, r, i) {
                        var o = this.display;
                        e = dt(this, me(this.doc, e));
                        var a = e.bottom, l = e.left;
                        if (t.style.position = "absolute", t.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(t), o.sizer.appendChild(t), "over" == r) a = e.top; else if ("above" == r || "near" == r) {
                            var s = Math.max(o.wrapper.clientHeight, this.doc.height),
                                c = Math.max(o.sizer.clientWidth, o.lineSpace.clientWidth);
                            ("above" == r || e.bottom + t.offsetHeight > s) && e.top > t.offsetHeight ? a = e.top - t.offsetHeight : e.bottom + t.offsetHeight <= s && (a = e.bottom), l + t.offsetWidth > c && (l = c - t.offsetWidth)
                        }
                        t.style.top = a + "px", t.style.left = t.style.right = "", "right" == i ? (l = o.sizer.clientWidth - t.offsetWidth, t.style.right = "0px") : ("left" == i ? l = 0 : "middle" == i && (l = (o.sizer.clientWidth - t.offsetWidth) / 2), t.style.left = l + "px"), n && Dn(this, l, a, l + t.offsetWidth, a + t.offsetHeight)
                    },
                    triggerOnKeyDown: Ot(hn),
                    triggerOnKeyPress: Ot(mn),
                    triggerOnKeyUp: pn,
                    execCommand: function (e) {
                        return ua.hasOwnProperty(e) ? ua[e].call(null, this) : void 0
                    },
                    triggerElectric: Ot(function (e) {
                        Q(this, e)
                    }),
                    findPosH: function (e, t, n, r) {
                        var i = 1;
                        0 > t && (i = -1, t = -t);
                        for (var o = 0, a = me(this.doc, e); t > o && (a = Un(this.doc, a, i, n, r), !a.hitSide); ++o);
                        return a
                    },
                    moveH: Ot(function (e, t) {
                        var n = this;
                        n.extendSelectionsBy(function (r) {
                            return n.display.shift || n.doc.extend || r.empty() ? Un(n.doc, r.head, e, t, n.options.rtlMoveVisually) : 0 > e ? r.from() : r.to()
                        }, _a)
                    }),
                    deleteH: Ot(function (e, t) {
                        var n = this.doc.sel, r = this.doc;
                        n.somethingSelected() ? r.replaceSelection("", null, "+delete") : jn(this, function (n) {
                            var i = Un(r, n.head, e, t, !1);
                            return 0 > e ? {from: i, to: n.head} : {from: n.head, to: i}
                        })
                    }),
                    findPosV: function (e, t, n, r) {
                        var i = 1, o = r;
                        0 > t && (i = -1, t = -t);
                        for (var a = 0, l = me(this.doc, e); t > a; ++a) {
                            var s = dt(this, l, "div");
                            if (null == o ? o = s.left : s.left = o, l = qn(this, s, i, n), l.hitSide)break
                        }
                        return l
                    },
                    moveV: Ot(function (e, t) {
                        var n = this, r = this.doc, i = [],
                            o = !n.display.shift && !r.extend && r.sel.somethingSelected();
                        if (r.extendSelectionsBy(function (a) {
                                if (o)return 0 > e ? a.from() : a.to();
                                var l = dt(n, a.head, "div");
                                null != a.goalColumn && (l.left = a.goalColumn), i.push(l.left);
                                var s = qn(n, l, e, t);
                                return "page" == t && a == r.sel.primary() && Wn(n, null, ht(n, s, "div").top - l.top), s
                            }, _a), i.length)for (var a = 0; a < r.sel.ranges.length; a++)r.sel.ranges[a].goalColumn = i[a]
                    }),
                    findWordAt: function (e) {
                        var t = this.doc, n = Zr(t, e.line).text, r = e.ch, i = e.ch;
                        if (n) {
                            var o = this.getHelper(e, "wordChars");
                            (e.xRel < 0 || i == n.length) && r ? --r : ++i;
                            for (var a = n.charAt(r), l = _i(a, o) ? function (e) {
                                return _i(e, o)
                            } : /\s/.test(a) ? function (e) {
                                return /\s/.test(e)
                            } : function (e) {
                                return !/\s/.test(e) && !_i(e)
                            }; r > 0 && l(n.charAt(r - 1));)--r;
                            for (; i < n.length && l(n.charAt(i));)++i
                        }
                        return new fe(Bo(e.line, r), Bo(e.line, i))
                    },
                    toggleOverwrite: function (e) {
                        null != e && e == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? Ja(this.display.cursorDiv, "CodeMirror-overwrite") : Za(this.display.cursorDiv, "CodeMirror-overwrite"), Pa(this, "overwriteToggle", this, this.state.overwrite))
                    },
                    hasFocus: function () {
                        return this.display.input.getField() == Gi()
                    },
                    isReadOnly: function () {
                        return !(!this.options.readOnly && !this.doc.cantEdit)
                    },
                    scrollTo: Ot(function (e, t) {
                        null == e && null == t || _n(this), null != e && (this.curOp.scrollLeft = e), null != t && (this.curOp.scrollTop = t)
                    }),
                    getScrollInfo: function () {
                        var e = this.display.scroller;
                        return {
                            left: e.scrollLeft,
                            top: e.scrollTop,
                            height: e.scrollHeight - Ye(this) - this.display.barHeight,
                            width: e.scrollWidth - Ye(this) - this.display.barWidth,
                            clientHeight: Ve(this),
                            clientWidth: $e(this)
                        }
                    },
                    scrollIntoView: Ot(function (e, t) {
                        if (null == e ? (e = {
                                from: this.doc.sel.primary().head,
                                to: null
                            }, null == t && (t = this.options.cursorScrollMargin)) : "number" == typeof e ? e = {
                                from: Bo(e, 0),
                                to: null
                            } : null == e.from && (e = {
                                    from: e,
                                    to: null
                                }), e.to || (e.to = e.from), e.margin = t || 0, null != e.from.line) _n(this), this.curOp.scrollToPos = e; else {
                            var n = Hn(this, Math.min(e.from.left, e.to.left), Math.min(e.from.top, e.to.top) - e.margin, Math.max(e.from.right, e.to.right), Math.max(e.from.bottom, e.to.bottom) + e.margin);
                            this.scrollTo(n.scrollLeft, n.scrollTop)
                        }
                    }),
                    setSize: Ot(function (e, t) {
                        function n(e) {
                            return "number" == typeof e || /^\d+$/.test(String(e)) ? e + "px" : e
                        }

                        var r = this;
                        null != e && (r.display.wrapper.style.width = n(e)), null != t && (r.display.wrapper.style.height = n(t)), r.options.lineWrapping && at(this);
                        var i = r.display.viewFrom;
                        r.doc.iter(i, r.display.viewTo, function (e) {
                            if (e.widgets)for (var t = 0; t < e.widgets.length; t++)if (e.widgets[t].noHScroll) {
                                Ht(r, i, "widget");
                                break
                            }
                            ++i
                        }), r.curOp.forceUpdate = !0, Pa(r, "refresh", this)
                    }),
                    operation: function (e) {
                        return At(this, e)
                    },
                    refresh: Ot(function () {
                        var e = this.display.cachedTextHeight;
                        Dt(this), this.curOp.forceUpdate = !0, lt(this), this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop), u(this), (null == e || Math.abs(e - yt(this.display)) > .5) && a(this), Pa(this, "refresh", this)
                    }),
                    swapDoc: Ot(function (e) {
                        var t = this.doc;
                        return t.cm = null, Xr(this, e), lt(this), this.display.input.reset(), this.scrollTo(e.scrollLeft, e.scrollTop), this.curOp.forceScroll = !0, Ci(this, "swapDoc", this, t), t
                    }),
                    getInputField: function () {
                        return this.display.input.getField()
                    },
                    getWrapperElement: function () {
                        return this.display.wrapper
                    },
                    getScrollerElement: function () {
                        return this.display.scroller
                    },
                    getGutterElement: function () {
                        return this.display.gutters
                    }
                }, Ai(e);
                var ea = e.defaults = {}, ta = e.optionHandlers = {}, na = e.Init = {
                    toString: function () {
                        return "CodeMirror.Init"
                    }
                };
                Gn("value", "", function (e, t) {
                    e.setValue(t)
                }, !0), Gn("mode", null, function (e, t) {
                    e.doc.modeOption = t, n(e)
                }, !0), Gn("indentUnit", 2, n, !0), Gn("indentWithTabs", !1), Gn("smartIndent", !0), Gn("tabSize", 4, function (e) {
                    r(e), lt(e), Dt(e)
                }, !0), Gn("lineSeparator", null, function (e, t) {
                    if (e.doc.lineSep = t, t) {
                        var n = [], r = e.doc.first;
                        e.doc.iter(function (e) {
                            for (var i = 0; ;) {
                                var o = e.text.indexOf(t, i);
                                if (-1 == o)break;
                                i = o + t.length, n.push(Bo(r, o))
                            }
                            r++
                        });
                        for (var i = n.length - 1; i >= 0; i--)In(e.doc, t, n[i], Bo(n[i].line, n[i].ch + t.length))
                    }
                }), Gn("specialChars", /[\u0000-\u001f\u007f\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function (t, n, r) {
                    t.state.specialChars = new RegExp(n.source + (n.test("	") ? "" : "|	"), "g"), r != e.Init && t.refresh()
                }), Gn("specialCharPlaceholder", _r, function (e) {
                    e.refresh()
                }, !0), Gn("electricChars", !0), Gn("inputStyle", Ao ? "contenteditable" : "textarea", function () {
                    throw new Error("inputStyle can not (yet) be changed in a running editor")
                }, !0), Gn("rtlMoveVisually", !Io), Gn("wholeLineUpdateBefore", !0), Gn("theme", "default", function (e) {
                    l(e), s(e)
                }, !0), Gn("keyMap", "default", function (t, n, r) {
                    var i = $n(n), o = r != e.Init && $n(r);
                    o && o.detach && o.detach(t, i), i.attach && i.attach(t, o || null)
                }), Gn("extraKeys", null), Gn("lineWrapping", !1, i, !0), Gn("gutters", [], function (e) {
                    d(e.options), s(e)
                }, !0), Gn("fixedGutter", !0, function (e, t) {
                    e.display.gutters.style.left = t ? C(e.display) + "px" : "0", e.refresh()
                }, !0), Gn("coverGutterNextToScrollbar", !1, function (e) {
                    y(e)
                }, !0), Gn("scrollbarStyle", "native", function (e) {
                    v(e), y(e), e.display.scrollbars.setScrollTop(e.doc.scrollTop), e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)
                }, !0), Gn("lineNumbers", !1, function (e) {
                    d(e.options), s(e)
                }, !0), Gn("firstLineNumber", 1, s, !0), Gn("lineNumberFormatter", function (e) {
                    return e
                }, s, !0), Gn("showCursorWhenSelecting", !1, Re, !0), Gn("resetSelectionOnContextMenu", !0), Gn("lineWiseCopyCut", !0), Gn("readOnly", !1, function (e, t) {
                    "nocursor" == t ? (yn(e), e.display.input.blur(), e.display.disabled = !0) : e.display.disabled = !1, e.display.input.readOnlyChanged(t)
                }), Gn("disableInput", !1, function (e, t) {
                    t || e.display.input.reset()
                }, !0), Gn("dragDrop", !0, Ut), Gn("allowDropFileTypes", null), Gn("cursorBlinkRate", 530), Gn("cursorScrollMargin", 0), Gn("cursorHeight", 1, Re, !0), Gn("singleCursorHeightPerLine", !0, Re, !0), Gn("workTime", 100), Gn("workDelay", 100), Gn("flattenSpans", !0, r, !0), Gn("addModeClass", !1, r, !0), Gn("pollInterval", 100), Gn("undoDepth", 200, function (e, t) {
                    e.doc.history.undoDepth = t
                }), Gn("historyEventDelay", 1250), Gn("viewportMargin", 10, function (e) {
                    e.refresh()
                }, !0), Gn("maxHighlightLength", 1e4, r, !0), Gn("moveInputWithCursor", !0, function (e, t) {
                    t || e.display.input.resetPosition()
                }), Gn("tabindex", null, function (e, t) {
                    e.display.input.getField().tabIndex = t || ""
                }), Gn("autofocus", null);
                var ra = e.modes = {}, ia = e.mimeModes = {};
                e.defineMode = function (t, n) {
                    e.defaults.mode || "null" == t || (e.defaults.mode = t), arguments.length > 2 && (n.dependencies = Array.prototype.slice.call(arguments, 2)), ra[t] = n
                }, e.defineMIME = function (e, t) {
                    ia[e] = t
                }, e.resolveMode = function (t) {
                    if ("string" == typeof t && ia.hasOwnProperty(t)) t = ia[t]; else if (t && "string" == typeof t.name && ia.hasOwnProperty(t.name)) {
                        var n = ia[t.name];
                        "string" == typeof n && (n = {name: n}), t = Hi(n, t), t.name = n.name
                    } else if ("string" == typeof t && /^[\w\-]+\/[\w\-]+\+xml$/.test(t))return e.resolveMode("application/xml");
                    return "string" == typeof t ? {name: t} : t || {name: "null"}
                }, e.getMode = function (t, n) {
                    var n = e.resolveMode(n), r = ra[n.name];
                    if (!r)return e.getMode(t, "text/plain");
                    var i = r(t, n);
                    if (oa.hasOwnProperty(n.name)) {
                        var o = oa[n.name];
                        for (var a in o)o.hasOwnProperty(a) && (i.hasOwnProperty(a) && (i["_" + a] = i[a]), i[a] = o[a])
                    }
                    if (i.name = n.name, n.helperType && (i.helperType = n.helperType), n.modeProps)for (var a in n.modeProps)i[a] = n.modeProps[a];
                    return i
                }, e.defineMode("null", function () {
                    return {
                        token: function (e) {
                            e.skipToEnd()
                        }
                    }
                }), e.defineMIME("text/plain", "null");
                var oa = e.modeExtensions = {};
                e.extendMode = function (e, t) {
                    var n = oa.hasOwnProperty(e) ? oa[e] : oa[e] = {};
                    Wi(t, n)
                }, e.defineExtension = function (t, n) {
                    e.prototype[t] = n
                }, e.defineDocExtension = function (e, t) {
                    Ca.prototype[e] = t
                }, e.defineOption = Gn;
                var aa = [];
                e.defineInitHook = function (e) {
                    aa.push(e)
                };
                var la = e.helpers = {};
                e.registerHelper = function (t, n, r) {
                    la.hasOwnProperty(t) || (la[t] = e[t] = {_global: []}), la[t][n] = r
                }, e.registerGlobalHelper = function (t, n, r, i) {
                    e.registerHelper(t, n, i), la[t]._global.push({pred: r, val: i})
                };
                var sa = e.copyState = function (e, t) {
                    if (t === !0)return t;
                    if (e.copyState)return e.copyState(t);
                    var n = {};
                    for (var r in t) {
                        var i = t[r];
                        i instanceof Array && (i = i.concat([])), n[r] = i
                    }
                    return n
                }, ca = e.startState = function (e, t, n) {
                    return e.startState ? e.startState(t, n) : !0
                };
                e.innerMode = function (e, t) {
                    for (; e.innerMode;) {
                        var n = e.innerMode(t);
                        if (!n || n.mode == e)break;
                        t = n.state, e = n.mode
                    }
                    return n || {mode: e, state: t}
                };
                var ua = e.commands = {
                    selectAll: function (e) {
                        e.setSelection(Bo(e.firstLine(), 0), Bo(e.lastLine()), Wa)
                    }, singleSelection: function (e) {
                        e.setSelection(e.getCursor("anchor"), e.getCursor("head"), Wa)
                    }, killLine: function (e) {
                        jn(e, function (t) {
                            if (t.empty()) {
                                var n = Zr(e.doc, t.head.line).text.length;
                                return t.head.ch == n && t.head.line < e.lastLine() ? {
                                    from: t.head,
                                    to: Bo(t.head.line + 1, 0)
                                } : {from: t.head, to: Bo(t.head.line, n)}
                            }
                            return {from: t.from(), to: t.to()}
                        })
                    }, deleteLine: function (e) {
                        jn(e, function (t) {
                            return {from: Bo(t.from().line, 0), to: me(e.doc, Bo(t.to().line + 1, 0))}
                        })
                    }, delLineLeft: function (e) {
                        jn(e, function (e) {
                            return {from: Bo(e.from().line, 0), to: e.from()}
                        })
                    }, delWrappedLineLeft: function (e) {
                        jn(e, function (t) {
                            var n = e.charCoords(t.head, "div").top + 5, r = e.coordsChar({left: 0, top: n}, "div");
                            return {from: r, to: t.from()}
                        })
                    }, delWrappedLineRight: function (e) {
                        jn(e, function (t) {
                            var n = e.charCoords(t.head, "div").top + 5,
                                r = e.coordsChar({left: e.display.lineDiv.offsetWidth + 100, top: n}, "div");
                            return {from: t.from(), to: r}
                        })
                    }, undo: function (e) {
                        e.undo()
                    }, redo: function (e) {
                        e.redo()
                    }, undoSelection: function (e) {
                        e.undoSelection()
                    }, redoSelection: function (e) {
                        e.redoSelection()
                    }, goDocStart: function (e) {
                        e.extendSelection(Bo(e.firstLine(), 0))
                    }, goDocEnd: function (e) {
                        e.extendSelection(Bo(e.lastLine()))
                    }, goLineStart: function (e) {
                        e.extendSelectionsBy(function (t) {
                            return oo(e, t.head.line)
                        }, {origin: "+move", bias: 1})
                    }, goLineStartSmart: function (e) {
                        e.extendSelectionsBy(function (t) {
                            return lo(e, t.head)
                        }, {origin: "+move", bias: 1})
                    }, goLineEnd: function (e) {
                        e.extendSelectionsBy(function (t) {
                            return ao(e, t.head.line)
                        }, {origin: "+move", bias: -1})
                    }, goLineRight: function (e) {
                        e.extendSelectionsBy(function (t) {
                            var n = e.charCoords(t.head, "div").top + 5;
                            return e.coordsChar({left: e.display.lineDiv.offsetWidth + 100, top: n}, "div")
                        }, _a)
                    }, goLineLeft: function (e) {
                        e.extendSelectionsBy(function (t) {
                            var n = e.charCoords(t.head, "div").top + 5;
                            return e.coordsChar({left: 0, top: n}, "div")
                        }, _a)
                    }, goLineLeftSmart: function (e) {
                        e.extendSelectionsBy(function (t) {
                            var n = e.charCoords(t.head, "div").top + 5, r = e.coordsChar({left: 0, top: n}, "div");
                            return r.ch < e.getLine(r.line).search(/\S/) ? lo(e, t.head) : r
                        }, _a)
                    }, goLineUp: function (e) {
                        e.moveV(-1, "line")
                    }, goLineDown: function (e) {
                        e.moveV(1, "line")
                    }, goPageUp: function (e) {
                        e.moveV(-1, "page")
                    }, goPageDown: function (e) {
                        e.moveV(1, "page")
                    }, goCharLeft: function (e) {
                        e.moveH(-1, "char")
                    }, goCharRight: function (e) {
                        e.moveH(1, "char")
                    }, goColumnLeft: function (e) {
                        e.moveH(-1, "column")
                    }, goColumnRight: function (e) {
                        e.moveH(1, "column")
                    }, goWordLeft: function (e) {
                        e.moveH(-1, "word")
                    }, goGroupRight: function (e) {
                        e.moveH(1, "group")
                    }, goGroupLeft: function (e) {
                        e.moveH(-1, "group")
                    }, goWordRight: function (e) {
                        e.moveH(1, "word")
                    }, delCharBefore: function (e) {
                        e.deleteH(-1, "char")
                    }, delCharAfter: function (e) {
                        e.deleteH(1, "char")
                    }, delWordBefore: function (e) {
                        e.deleteH(-1, "word")
                    }, delWordAfter: function (e) {
                        e.deleteH(1, "word")
                    }, delGroupBefore: function (e) {
                        e.deleteH(-1, "group")
                    }, delGroupAfter: function (e) {
                        e.deleteH(1, "group")
                    }, indentAuto: function (e) {
                        e.indentSelection("smart")
                    }, indentMore: function (e) {
                        e.indentSelection("add")
                    }, indentLess: function (e) {
                        e.indentSelection("subtract")
                    }, insertTab: function (e) {
                        e.replaceSelection("	")
                    }, insertSoftTab: function (e) {
                        for (var t = [], n = e.listSelections(), r = e.options.tabSize, i = 0; i < n.length; i++) {
                            var o = n[i].from(), a = Fa(e.getLine(o.line), o.ch, r);
                            t.push(Oi(r - a % r))
                        }
                        e.replaceSelections(t)
                    }, defaultTab: function (e) {
                        e.somethingSelected() ? e.indentSelection("add") : e.execCommand("insertTab")
                    }, transposeChars: function (e) {
                        At(e, function () {
                            for (var t = e.listSelections(), n = [], r = 0; r < t.length; r++) {
                                var i = t[r].head, o = Zr(e.doc, i.line).text;
                                if (o)if (i.ch == o.length && (i = new Bo(i.line, i.ch - 1)), i.ch > 0) i = new Bo(i.line, i.ch + 1), e.replaceRange(o.charAt(i.ch - 1) + o.charAt(i.ch - 2), Bo(i.line, i.ch - 2), i, "+transpose"); else if (i.line > e.doc.first) {
                                    var a = Zr(e.doc, i.line - 1).text;
                                    a && e.replaceRange(o.charAt(0) + e.doc.lineSeparator() + a.charAt(a.length - 1), Bo(i.line - 1, a.length - 1), Bo(i.line, 1), "+transpose")
                                }
                                n.push(new fe(i, i))
                            }
                            e.setSelections(n)
                        })
                    }, newlineAndIndent: function (e) {
                        At(e, function () {
                            for (var t = e.listSelections().length, n = 0; t > n; n++) {
                                var r = e.listSelections()[n];
                                e.replaceRange(e.doc.lineSeparator(), r.anchor, r.head, "+input"), e.indentLine(r.from().line + 1, null, !0)
                            }
                            Bn(e)
                        })
                    }, openLine: function (e) {
                        e.replaceSelection("\n", "start")
                    }, toggleOverwrite: function (e) {
                        e.toggleOverwrite()
                    }
                }, fa = e.keyMap = {};
                fa.basic = {
                    Left: "goCharLeft",
                    Right: "goCharRight",
                    Up: "goLineUp",
                    Down: "goLineDown",
                    End: "goLineEnd",
                    Home: "goLineStartSmart",
                    PageUp: "goPageUp",
                    PageDown: "goPageDown",
                    Delete: "delCharAfter",
                    Backspace: "delCharBefore",
                    "Shift-Backspace": "delCharBefore",
                    Tab: "defaultTab",
                    "Shift-Tab": "indentAuto",
                    Enter: "newlineAndIndent",
                    Insert: "toggleOverwrite",
                    Esc: "singleSelection"
                }, fa.pcDefault = {
                    "Ctrl-A": "selectAll",
                    "Ctrl-D": "deleteLine",
                    "Ctrl-Z": "undo",
                    "Shift-Ctrl-Z": "redo",
                    "Ctrl-Y": "redo",
                    "Ctrl-Home": "goDocStart",
                    "Ctrl-End": "goDocEnd",
                    "Ctrl-Up": "goLineUp",
                    "Ctrl-Down": "goLineDown",
                    "Ctrl-Left": "goGroupLeft",
                    "Ctrl-Right": "goGroupRight",
                    "Alt-Left": "goLineStart",
                    "Alt-Right": "goLineEnd",
                    "Ctrl-Backspace": "delGroupBefore",
                    "Ctrl-Delete": "delGroupAfter",
                    "Ctrl-S": "save",
                    "Ctrl-F": "find",
                    "Ctrl-G": "findNext",
                    "Shift-Ctrl-G": "findPrev",
                    "Shift-Ctrl-F": "replace",
                    "Shift-Ctrl-R": "replaceAll",
                    "Ctrl-[": "indentLess",
                    "Ctrl-]": "indentMore",
                    "Ctrl-U": "undoSelection",
                    "Shift-Ctrl-U": "redoSelection",
                    "Alt-U": "redoSelection",
                    fallthrough: "basic"
                }, fa.emacsy = {
                    "Ctrl-F": "goCharRight",
                    "Ctrl-B": "goCharLeft",
                    "Ctrl-P": "goLineUp",
                    "Ctrl-N": "goLineDown",
                    "Alt-F": "goWordRight",
                    "Alt-B": "goWordLeft",
                    "Ctrl-A": "goLineStart",
                    "Ctrl-E": "goLineEnd",
                    "Ctrl-V": "goPageDown",
                    "Shift-Ctrl-V": "goPageUp",
                    "Ctrl-D": "delCharAfter",
                    "Ctrl-H": "delCharBefore",
                    "Alt-D": "delWordAfter",
                    "Alt-Backspace": "delWordBefore",
                    "Ctrl-K": "killLine",
                    "Ctrl-T": "transposeChars",
                    "Ctrl-O": "openLine"
                }, fa.macDefault = {
                    "Cmd-A": "selectAll",
                    "Cmd-D": "deleteLine",
                    "Cmd-Z": "undo",
                    "Shift-Cmd-Z": "redo",
                    "Cmd-Y": "redo",
                    "Cmd-Home": "goDocStart",
                    "Cmd-Up": "goDocStart",
                    "Cmd-End": "goDocEnd",
                    "Cmd-Down": "goDocEnd",
                    "Alt-Left": "goGroupLeft",
                    "Alt-Right": "goGroupRight",
                    "Cmd-Left": "goLineLeft",
                    "Cmd-Right": "goLineRight",
                    "Alt-Backspace": "delGroupBefore",
                    "Ctrl-Alt-Backspace": "delGroupAfter",
                    "Alt-Delete": "delGroupAfter",
                    "Cmd-S": "save",
                    "Cmd-F": "find",
                    "Cmd-G": "findNext",
                    "Shift-Cmd-G": "findPrev",
                    "Cmd-Alt-F": "replace",
                    "Shift-Cmd-Alt-F": "replaceAll",
                    "Cmd-[": "indentLess",
                    "Cmd-]": "indentMore",
                    "Cmd-Backspace": "delWrappedLineLeft",
                    "Cmd-Delete": "delWrappedLineRight",
                    "Cmd-U": "undoSelection",
                    "Shift-Cmd-U": "redoSelection",
                    "Ctrl-Up": "goDocStart",
                    "Ctrl-Down": "goDocEnd",
                    fallthrough: ["basic", "emacsy"]
                }, fa["default"] = Eo ? fa.macDefault : fa.pcDefault, e.normalizeKeyMap = function (e) {
                    var t = {};
                    for (var n in e)if (e.hasOwnProperty(n)) {
                        var r = e[n];
                        if (/^(name|fallthrough|(de|at)tach)$/.test(n))continue;
                        if ("..." == r) {
                            delete e[n];
                            continue
                        }
                        for (var i = Ri(n.split(" "), Yn), o = 0; o < i.length; o++) {
                            var a, l;
                            o == i.length - 1 ? (l = i.join(" "), a = r) : (l = i.slice(0, o + 1).join(" "), a = "...");
                            var s = t[l];
                            if (s) {
                                if (s != a)throw new Error("Inconsistent bindings for " + l)
                            } else t[l] = a
                        }
                        delete e[n]
                    }
                    for (var c in t)e[c] = t[c];
                    return e
                };
                var ha = e.lookupKey = function (e, t, n, r) {
                    t = $n(t);
                    var i = t.call ? t.call(e, r) : t[e];
                    if (i === !1)return "nothing";
                    if ("..." === i)return "multi";
                    if (null != i && n(i))return "handled";
                    if (t.fallthrough) {
                        if ("[object Array]" != Object.prototype.toString.call(t.fallthrough))return ha(e, t.fallthrough, n, r);
                        for (var o = 0; o < t.fallthrough.length; o++) {
                            var a = ha(e, t.fallthrough[o], n, r);
                            if (a)return a
                        }
                    }
                }, da = e.isModifierKey = function (e) {
                    var t = "string" == typeof e ? e : ol[e.keyCode];
                    return "Ctrl" == t || "Alt" == t || "Shift" == t || "Mod" == t
                }, pa = e.keyName = function (e, t) {
                    if (Co && 34 == e.keyCode && e["char"])return !1;
                    var n = ol[e.keyCode], r = n;
                    return null == r || e.altGraphKey ? !1 : (e.altKey && "Alt" != n && (r = "Alt-" + r), (Ro ? e.metaKey : e.ctrlKey) && "Ctrl" != n && (r = "Ctrl-" + r), (Ro ? e.ctrlKey : e.metaKey) && "Cmd" != n && (r = "Cmd-" + r), !t && e.shiftKey && "Shift" != n && (r = "Shift-" + r), r)
                };
                e.fromTextArea = function (t, n) {
                    function r() {
                        t.value = c.getValue()
                    }

                    if (n = n ? Wi(n) : {}, n.value = t.value, !n.tabindex && t.tabIndex && (n.tabindex = t.tabIndex), !n.placeholder && t.placeholder && (n.placeholder = t.placeholder), null == n.autofocus) {
                        var i = Gi();
                        n.autofocus = i == t || null != t.getAttribute("autofocus") && i == document.body
                    }
                    if (t.form && (Ea(t.form, "submit", r), !n.leaveSubmitMethodAlone)) {
                        var o = t.form, a = o.submit;
                        try {
                            var l = o.submit = function () {
                                r(), o.submit = a, o.submit(), o.submit = l
                            }
                        } catch (s) {
                        }
                    }
                    n.finishInit = function (e) {
                        e.save = r, e.getTextArea = function () {
                            return t
                        }, e.toTextArea = function () {
                            e.toTextArea = isNaN, r(), t.parentNode.removeChild(e.getWrapperElement()), t.style.display = "", t.form && (Ia(t.form, "submit", r), "function" == typeof t.form.submit && (t.form.submit = a))
                        }
                    }, t.style.display = "none";
                    var c = e(function (e) {
                        t.parentNode.insertBefore(e, t.nextSibling)
                    }, n);
                    return c
                };
                var ma = e.StringStream = function (e, t) {
                    this.pos = this.start = 0, this.string = e, this.tabSize = t || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0
                };
                ma.prototype = {
                    eol: function () {
                        return this.pos >= this.string.length
                    }, sol: function () {
                        return this.pos == this.lineStart
                    }, peek: function () {
                        return this.string.charAt(this.pos) || void 0
                    }, next: function () {
                        return this.pos < this.string.length ? this.string.charAt(this.pos++) : void 0
                    }, eat: function (e) {
                        var t = this.string.charAt(this.pos);
                        if ("string" == typeof e)var n = t == e; else var n = t && (e.test ? e.test(t) : e(t));
                        return n ? (++this.pos, t) : void 0
                    }, eatWhile: function (e) {
                        for (var t = this.pos; this.eat(e););
                        return this.pos > t
                    }, eatSpace: function () {
                        for (var e = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;
                        return this.pos > e
                    }, skipToEnd: function () {
                        this.pos = this.string.length
                    }, skipTo: function (e) {
                        var t = this.string.indexOf(e, this.pos);
                        return t > -1 ? (this.pos = t, !0) : void 0
                    }, backUp: function (e) {
                        this.pos -= e
                    }, column: function () {
                        return this.lastColumnPos < this.start && (this.lastColumnValue = Fa(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? Fa(this.string, this.lineStart, this.tabSize) : 0)
                    }, indentation: function () {
                        return Fa(this.string, null, this.tabSize) - (this.lineStart ? Fa(this.string, this.lineStart, this.tabSize) : 0)
                    }, match: function (e, t, n) {
                        if ("string" != typeof e) {
                            var r = this.string.slice(this.pos).match(e);
                            return r && r.index > 0 ? null : (r && t !== !1 && (this.pos += r[0].length), r)
                        }
                        var i = function (e) {
                            return n ? e.toLowerCase() : e
                        }, o = this.string.substr(this.pos, e.length);
                        return i(o) == i(e) ? (t !== !1 && (this.pos += e.length), !0) : void 0
                    }, current: function () {
                        return this.string.slice(this.start, this.pos)
                    }, hideFirstChars: function (e, t) {
                        this.lineStart += e;
                        try {
                            return t()
                        } finally {
                            this.lineStart -= e
                        }
                    }
                };
                var ga = 0, va = e.TextMarker = function (e, t) {
                    this.lines = [], this.type = t, this.doc = e, this.id = ++ga
                };
                Ai(va), va.prototype.clear = function () {
                    if (!this.explicitlyCleared) {
                        var e = this.doc.cm, t = e && !e.curOp;
                        if (t && bt(e), Ni(this, "clear")) {
                            var n = this.find();
                            n && Ci(this, "clear", n.from, n.to)
                        }
                        for (var r = null, i = null, o = 0; o < this.lines.length; ++o) {
                            var a = this.lines[o], l = er(a.markedSpans, this);
                            e && !this.collapsed ? Ht(e, ti(a), "text") : e && (null != l.to && (i = ti(a)), null != l.from && (r = ti(a))), a.markedSpans = tr(a.markedSpans, l), null == l.from && this.collapsed && !kr(this.doc, a) && e && ei(a, yt(e.display))
                        }
                        if (e && this.collapsed && !e.options.lineWrapping)for (var o = 0; o < this.lines.length; ++o) {
                            var s = yr(this.lines[o]), c = f(s);
                            c > e.display.maxLineLength && (e.display.maxLine = s, e.display.maxLineLength = c, e.display.maxLineChanged = !0)
                        }
                        null != r && e && this.collapsed && Dt(e, r, i + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, e && Ae(e.doc)), e && Ci(e, "markerCleared", e, this), t && kt(e), this.parent && this.parent.clear()
                    }
                }, va.prototype.find = function (e, t) {
                    null == e && "bookmark" == this.type && (e = 1);
                    for (var n, r, i = 0; i < this.lines.length; ++i) {
                        var o = this.lines[i], a = er(o.markedSpans, this);
                        if (null != a.from && (n = Bo(t ? o : ti(o), a.from), -1 == e))return n;
                        if (null != a.to && (r = Bo(t ? o : ti(o), a.to), 1 == e))return r
                    }
                    return n && {from: n, to: r}
                }, va.prototype.changed = function () {
                    var e = this.find(-1, !0), t = this, n = this.doc.cm;
                    e && n && At(n, function () {
                        var r = e.line, i = ti(e.line), o = Qe(n, i);
                        if (o && (ot(o), n.curOp.selectionChanged = n.curOp.forceUpdate = !0), n.curOp.updateMaxLine = !0, !kr(t.doc, r) && null != t.height) {
                            var a = t.height;
                            t.height = null;
                            var l = Lr(t) - a;
                            l && ei(r, r.height + l)
                        }
                    })
                }, va.prototype.attachLine = function (e) {
                    if (!this.lines.length && this.doc.cm) {
                        var t = this.doc.cm.curOp;
                        t.maybeHiddenMarkers && -1 != Pi(t.maybeHiddenMarkers, this) || (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this)
                    }
                    this.lines.push(e)
                }, va.prototype.detachLine = function (e) {
                    if (this.lines.splice(Pi(this.lines, e), 1), !this.lines.length && this.doc.cm) {
                        var t = this.doc.cm.curOp;
                        (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this)
                    }
                };
                var ga = 0, ya = e.SharedTextMarker = function (e, t) {
                    this.markers = e, this.primary = t;
                    for (var n = 0; n < e.length; ++n)e[n].parent = this
                };
                Ai(ya), ya.prototype.clear = function () {
                    if (!this.explicitlyCleared) {
                        this.explicitlyCleared = !0;
                        for (var e = 0; e < this.markers.length; ++e)this.markers[e].clear();
                        Ci(this, "clear")
                    }
                }, ya.prototype.find = function (e, t) {
                    return this.primary.find(e, t)
                };
                var xa = e.LineWidget = function (e, t, n) {
                    if (n)for (var r in n)n.hasOwnProperty(r) && (this[r] = n[r]);
                    this.doc = e, this.node = t
                };
                Ai(xa), xa.prototype.clear = function () {
                    var e = this.doc.cm, t = this.line.widgets, n = this.line, r = ti(n);
                    if (null != r && t) {
                        for (var i = 0; i < t.length; ++i)t[i] == this && t.splice(i--, 1);
                        t.length || (n.widgets = null);
                        var o = Lr(this);
                        ei(n, Math.max(0, n.height - o)), e && At(e, function () {
                            Cr(e, n, -o), Ht(e, r, "widget")
                        })
                    }
                }, xa.prototype.changed = function () {
                    var e = this.height, t = this.doc.cm, n = this.line;
                    this.height = null;
                    var r = Lr(this) - e;
                    r && (ei(n, n.height + r), t && At(t, function () {
                        t.curOp.forceUpdate = !0, Cr(t, n, r)
                    }))
                };
                var ba = e.Line = function (e, t, n) {
                    this.text = e, ur(this, t), this.height = n ? n(this) : 1
                };
                Ai(ba), ba.prototype.lineNo = function () {
                    return ti(this)
                };
                var wa = {}, ka = {};
                $r.prototype = {
                    chunkSize: function () {
                        return this.lines.length
                    }, removeInner: function (e, t) {
                        for (var n = e, r = e + t; r > n; ++n) {
                            var i = this.lines[n];
                            this.height -= i.height, Nr(i), Ci(i, "delete")
                        }
                        this.lines.splice(e, t)
                    }, collapse: function (e) {
                        e.push.apply(e, this.lines)
                    }, insertInner: function (e, t, n) {
                        this.height += n, this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e));
                        for (var r = 0; r < t.length; ++r)t[r].parent = this
                    }, iterN: function (e, t, n) {
                        for (var r = e + t; r > e; ++e)if (n(this.lines[e]))return !0
                    }
                }, Vr.prototype = {
                    chunkSize: function () {
                        return this.size
                    }, removeInner: function (e, t) {
                        this.size -= t;
                        for (var n = 0; n < this.children.length; ++n) {
                            var r = this.children[n], i = r.chunkSize();
                            if (i > e) {
                                var o = Math.min(t, i - e), a = r.height;
                                if (r.removeInner(e, o), this.height -= a - r.height, i == o && (this.children.splice(n--, 1), r.parent = null), 0 == (t -= o))break;
                                e = 0
                            } else e -= i
                        }
                        if (this.size - t < 25 && (this.children.length > 1 || !(this.children[0] instanceof $r))) {
                            var l = [];
                            this.collapse(l), this.children = [new $r(l)], this.children[0].parent = this
                        }
                    }, collapse: function (e) {
                        for (var t = 0; t < this.children.length; ++t)this.children[t].collapse(e)
                    }, insertInner: function (e, t, n) {
                        this.size += t.length, this.height += n;
                        for (var r = 0; r < this.children.length; ++r) {
                            var i = this.children[r], o = i.chunkSize();
                            if (o >= e) {
                                if (i.insertInner(e, t, n), i.lines && i.lines.length > 50) {
                                    for (var a = i.lines.length % 25 + 25, l = a; l < i.lines.length;) {
                                        var s = new $r(i.lines.slice(l, l += 25));
                                        i.height -= s.height, this.children.splice(++r, 0, s), s.parent = this
                                    }
                                    i.lines = i.lines.slice(0, a), this.maybeSpill()
                                }
                                break
                            }
                            e -= o
                        }
                    }, maybeSpill: function () {
                        if (!(this.children.length <= 10)) {
                            var e = this;
                            do {
                                var t = e.children.splice(e.children.length - 5, 5), n = new Vr(t);
                                if (e.parent) {
                                    e.size -= n.size, e.height -= n.height;
                                    var r = Pi(e.parent.children, e);
                                    e.parent.children.splice(r + 1, 0, n)
                                } else {
                                    var i = new Vr(e.children);
                                    i.parent = e, e.children = [i, n], e = i
                                }
                                n.parent = e.parent
                            } while (e.children.length > 10);
                            e.parent.maybeSpill()
                        }
                    }, iterN: function (e, t, n) {
                        for (var r = 0; r < this.children.length; ++r) {
                            var i = this.children[r], o = i.chunkSize();
                            if (o > e) {
                                var a = Math.min(t, o - e);
                                if (i.iterN(e, a, n))return !0;
                                if (0 == (t -= a))break;
                                e = 0
                            } else e -= o
                        }
                    }
                };
                var Sa = 0, Ca = e.Doc = function (e, t, n, r) {
                    if (!(this instanceof Ca))return new Ca(e, t, n, r);
                    null == n && (n = 0), Vr.call(this, [new $r([new ba("", null)])]), this.first = n, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.frontier = n;
                    var i = Bo(n, 0);
                    this.sel = de(i), this.history = new oi(null), this.id = ++Sa, this.modeOption = t, this.lineSep = r, this.extend = !1, "string" == typeof e && (e = this.splitLines(e)), Yr(this, {
                        from: i,
                        to: i,
                        text: e
                    }), Te(this, de(i), Wa)
                };
                Ca.prototype = Hi(Vr.prototype, {
                    constructor: Ca, iter: function (e, t, n) {
                        n ? this.iterN(e - this.first, t - e, n) : this.iterN(this.first, this.first + this.size, e)
                    }, insert: function (e, t) {
                        for (var n = 0, r = 0; r < t.length; ++r)n += t[r].height;
                        this.insertInner(e - this.first, t, n)
                    }, remove: function (e, t) {
                        this.removeInner(e - this.first, t)
                    }, getValue: function (e) {
                        var t = Qr(this, this.first, this.first + this.size);
                        return e === !1 ? t : t.join(e || this.lineSeparator())
                    }, setValue: It(function (e) {
                        var t = Bo(this.first, 0), n = this.first + this.size - 1;
                        Tn(this, {
                            from: t,
                            to: Bo(n, Zr(this, n).text.length),
                            text: this.splitLines(e),
                            origin: "setValue",
                            full: !0
                        }, !0), Te(this, de(t))
                    }), replaceRange: function (e, t, n, r) {
                        t = me(this, t), n = n ? me(this, n) : t, In(this, e, t, n, r)
                    }, getRange: function (e, t, n) {
                        var r = Jr(this, me(this, e), me(this, t));
                        return n === !1 ? r : r.join(n || this.lineSeparator())
                    }, getLine: function (e) {
                        var t = this.getLineHandle(e);
                        return t && t.text
                    }, getLineHandle: function (e) {
                        return ve(this, e) ? Zr(this, e) : void 0
                    }, getLineNumber: function (e) {
                        return ti(e)
                    }, getLineHandleVisualStart: function (e) {
                        return "number" == typeof e && (e = Zr(this, e)), yr(e)
                    }, lineCount: function () {
                        return this.size
                    }, firstLine: function () {
                        return this.first
                    }, lastLine: function () {
                        return this.first + this.size - 1
                    }, clipPos: function (e) {
                        return me(this, e)
                    }, getCursor: function (e) {
                        var t, n = this.sel.primary();
                        return t = null == e || "head" == e ? n.head : "anchor" == e ? n.anchor : "end" == e || "to" == e || e === !1 ? n.to() : n.from()
                    }, listSelections: function () {
                        return this.sel.ranges
                    }, somethingSelected: function () {
                        return this.sel.somethingSelected()
                    }, setCursor: It(function (e, t, n) {
                        Se(this, me(this, "number" == typeof e ? Bo(e, t || 0) : e), null, n)
                    }), setSelection: It(function (e, t, n) {
                        Se(this, me(this, e), me(this, t || e), n)
                    }), extendSelection: It(function (e, t, n) {
                        be(this, me(this, e), t && me(this, t), n)
                    }), extendSelections: It(function (e, t) {
                        we(this, ye(this, e), t)
                    }), extendSelectionsBy: It(function (e, t) {
                        var n = Ri(this.sel.ranges, e);
                        we(this, ye(this, n), t)
                    }), setSelections: It(function (e, t, n) {
                        if (e.length) {
                            for (var r = 0,
                                     i = []; r < e.length; r++)i[r] = new fe(me(this, e[r].anchor), me(this, e[r].head));
                            null == t && (t = Math.min(e.length - 1, this.sel.primIndex)), Te(this, he(i, t), n)
                        }
                    }), addSelection: It(function (e, t, n) {
                        var r = this.sel.ranges.slice(0);
                        r.push(new fe(me(this, e), me(this, t || e))), Te(this, he(r, r.length - 1), n)
                    }), getSelection: function (e) {
                        for (var t, n = this.sel.ranges, r = 0; r < n.length; r++) {
                            var i = Jr(this, n[r].from(), n[r].to());
                            t = t ? t.concat(i) : i
                        }
                        return e === !1 ? t : t.join(e || this.lineSeparator())
                    }, getSelections: function (e) {
                        for (var t = [], n = this.sel.ranges, r = 0; r < n.length; r++) {
                            var i = Jr(this, n[r].from(), n[r].to());
                            e !== !1 && (i = i.join(e || this.lineSeparator())), t[r] = i
                        }
                        return t
                    }, replaceSelection: function (e, t, n) {
                        for (var r = [], i = 0; i < this.sel.ranges.length; i++)r[i] = e;
                        this.replaceSelections(r, t, n || "+input")
                    }, replaceSelections: It(function (e, t, n) {
                        for (var r = [], i = this.sel, o = 0; o < i.ranges.length; o++) {
                            var a = i.ranges[o];
                            r[o] = {from: a.from(), to: a.to(), text: this.splitLines(e[o]), origin: n}
                        }
                        for (var l = t && "end" != t && Cn(this, r, t), o = r.length - 1; o >= 0; o--)Tn(this, r[o]);
                        l ? Le(this, l) : this.cm && Bn(this.cm)
                    }), undo: It(function () {
                        Nn(this, "undo")
                    }), redo: It(function () {
                        Nn(this, "redo")
                    }), undoSelection: It(function () {
                        Nn(this, "undo", !0)
                    }), redoSelection: It(function () {
                        Nn(this, "redo", !0)
                    }), setExtending: function (e) {
                        this.extend = e
                    }, getExtending: function () {
                        return this.extend
                    }, historySize: function () {
                        for (var e = this.history, t = 0, n = 0, r = 0; r < e.done.length; r++)e.done[r].ranges || ++t;
                        for (var r = 0; r < e.undone.length; r++)e.undone[r].ranges || ++n;
                        return {undo: t, redo: n}
                    }, clearHistory: function () {
                        this.history = new oi(this.history.maxGeneration)
                    }, markClean: function () {
                        this.cleanGeneration = this.changeGeneration(!0)
                    }, changeGeneration: function (e) {
                        return e && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation
                    }, isClean: function (e) {
                        return this.history.generation == (e || this.cleanGeneration)
                    }, getHistory: function () {
                        return {done: gi(this.history.done), undone: gi(this.history.undone)}
                    }, setHistory: function (e) {
                        var t = this.history = new oi(this.history.maxGeneration);
                        t.done = gi(e.done.slice(0), null, !0), t.undone = gi(e.undone.slice(0), null, !0)
                    }, addLineClass: It(function (e, t, n) {
                        return zn(this, e, "gutter" == t ? "gutter" : "class", function (e) {
                            var r = "text" == t ? "textClass" : "background" == t ? "bgClass" : "gutter" == t ? "gutterClass" : "wrapClass";
                            if (e[r]) {
                                if (Yi(n).test(e[r]))return !1;
                                e[r] += " " + n
                            } else e[r] = n;
                            return !0
                        })
                    }), removeLineClass: It(function (e, t, n) {
                        return zn(this, e, "gutter" == t ? "gutter" : "class", function (e) {
                            var r = "text" == t ? "textClass" : "background" == t ? "bgClass" : "gutter" == t ? "gutterClass" : "wrapClass",
                                i = e[r];
                            if (!i)return !1;
                            if (null == n) e[r] = null; else {
                                var o = i.match(Yi(n));
                                if (!o)return !1;
                                var a = o.index + o[0].length;
                                e[r] = i.slice(0, o.index) + (o.index && a != i.length ? " " : "") + i.slice(a) || null
                            }
                            return !0
                        })
                    }), addLineWidget: It(function (e, t, n) {
                        return Tr(this, e, t, n)
                    }), removeLineWidget: function (e) {
                        e.clear()
                    }, markText: function (e, t, n) {
                        return Vn(this, me(this, e), me(this, t), n, n && n.type || "range")
                    }, setBookmark: function (e, t) {
                        var n = {
                            replacedWith: t && (null == t.nodeType ? t.widget : t),
                            insertLeft: t && t.insertLeft,
                            clearWhenEmpty: !1,
                            shared: t && t.shared,
                            handleMouseEvents: t && t.handleMouseEvents
                        };
                        return e = me(this, e), Vn(this, e, e, n, "bookmark")
                    }, findMarksAt: function (e) {
                        e = me(this, e);
                        var t = [], n = Zr(this, e.line).markedSpans;
                        if (n)for (var r = 0; r < n.length; ++r) {
                            var i = n[r];
                            (null == i.from || i.from <= e.ch) && (null == i.to || i.to >= e.ch) && t.push(i.marker.parent || i.marker)
                        }
                        return t
                    }, findMarks: function (e, t, n) {
                        e = me(this, e), t = me(this, t);
                        var r = [], i = e.line;
                        return this.iter(e.line, t.line + 1, function (o) {
                            var a = o.markedSpans;
                            if (a)for (var l = 0; l < a.length; l++) {
                                var s = a[l];
                                null != s.to && i == e.line && e.ch >= s.to || null == s.from && i != e.line || null != s.from && i == t.line && s.from >= t.ch || n && !n(s.marker) || r.push(s.marker.parent || s.marker)
                            }
                            ++i
                        }), r
                    }, getAllMarks: function () {
                        var e = [];
                        return this.iter(function (t) {
                            var n = t.markedSpans;
                            if (n)for (var r = 0; r < n.length; ++r)null != n[r].from && e.push(n[r].marker)
                        }), e
                    }, posFromIndex: function (e) {
                        var t, n = this.first, r = this.lineSeparator().length;
                        return this.iter(function (i) {
                            var o = i.text.length + r;
                            return o > e ? (t = e, !0) : (e -= o, void++n)
                        }), me(this, Bo(n, t))
                    }, indexFromPos: function (e) {
                        e = me(this, e);
                        var t = e.ch;
                        if (e.line < this.first || e.ch < 0)return 0;
                        var n = this.lineSeparator().length;
                        return this.iter(this.first, e.line, function (e) {
                            t += e.text.length + n
                        }), t
                    }, copy: function (e) {
                        var t = new Ca(Qr(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep);
                        return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = this.sel, t.extend = !1, e && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t
                    }, linkedDoc: function (e) {
                        e || (e = {});
                        var t = this.first, n = this.first + this.size;
                        null != e.from && e.from > t && (t = e.from), null != e.to && e.to < n && (n = e.to);
                        var r = new Ca(Qr(this, t, n), e.mode || this.modeOption, t, this.lineSep);
                        return e.sharedHist && (r.history = this.history), (this.linked || (this.linked = [])).push({
                            doc: r,
                            sharedHist: e.sharedHist
                        }), r.linked = [{doc: this, isParent: !0, sharedHist: e.sharedHist}], Zn(r, Xn(this)), r
                    }, unlinkDoc: function (t) {
                        if (t instanceof e && (t = t.doc), this.linked)for (var n = 0; n < this.linked.length; ++n) {
                            var r = this.linked[n];
                            if (r.doc == t) {
                                this.linked.splice(n, 1), t.unlinkDoc(this), Jn(Xn(this));
                                break
                            }
                        }
                        if (t.history == this.history) {
                            var i = [t.id];
                            Kr(t, function (e) {
                                i.push(e.id)
                            }, !0), t.history = new oi(null), t.history.done = gi(this.history.done, i), t.history.undone = gi(this.history.undone, i)
                        }
                    }, iterLinkedDocs: function (e) {
                        Kr(this, e)
                    }, getMode: function () {
                        return this.mode
                    }, getEditor: function () {
                        return this.cm
                    }, splitLines: function (e) {
                        return this.lineSep ? e.split(this.lineSep) : tl(e)
                    }, lineSeparator: function () {
                        return this.lineSep || "\n"
                    }
                }), Ca.prototype.eachLine = Ca.prototype.iter;
                var La = "iter insert remove copy getEditor constructor".split(" ");
                for (var Ta in Ca.prototype)Ca.prototype.hasOwnProperty(Ta) && Pi(La, Ta) < 0 && (e.prototype[Ta] = function (e) {
                    return function () {
                        return e.apply(this.doc, arguments)
                    }
                }(Ca.prototype[Ta]));
                Ai(Ca);
                var Ma = e.e_preventDefault = function (e) {
                    e.preventDefault ? e.preventDefault() : e.returnValue = !1
                }, Na = e.e_stopPropagation = function (e) {
                    e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0
                }, Aa = e.e_stop = function (e) {
                    Ma(e), Na(e)
                }, Ea = e.on = function (e, t, n) {
                    if (e.addEventListener) e.addEventListener(t, n, !1); else if (e.attachEvent) e.attachEvent("on" + t, n); else {
                        var r = e._handlers || (e._handlers = {}), i = r[t] || (r[t] = []);
                        i.push(n)
                    }
                }, Oa = [], Ia = e.off = function (e, t, n) {
                    if (e.removeEventListener) e.removeEventListener(t, n, !1); else if (e.detachEvent) e.detachEvent("on" + t, n); else for (var r = Si(e, t, !1),
                                                                                                                                                  i = 0; i < r.length; ++i)if (r[i] == n) {
                        r.splice(i, 1);
                        break
                    }
                }, Pa = e.signal = function (e, t) {
                    var n = Si(e, t, !0);
                    if (n.length)for (var r = Array.prototype.slice.call(arguments, 2),
                                          i = 0; i < n.length; ++i)n[i].apply(null, r)
                }, Ra = null, Da = 30, Ha = e.Pass = {
                    toString: function () {
                        return "CodeMirror.Pass"
                    }
                }, Wa = {scroll: !1}, Ba = {origin: "*mouse"}, _a = {origin: "+move"};
                Ei.prototype.set = function (e, t) {
                    clearTimeout(this.id), this.id = setTimeout(t, e)
                };
                var Fa = e.countColumn = function (e, t, n, r, i) {
                    null == t && (t = e.search(/[^\s\u00a0]/), -1 == t && (t = e.length));
                    for (var o = r || 0, a = i || 0; ;) {
                        var l = e.indexOf("	", o);
                        if (0 > l || l >= t)return a + (t - o);
                        a += l - o, a += n - a % n, o = l + 1
                    }
                }, za = e.findColumn = function (e, t, n) {
                    for (var r = 0, i = 0; ;) {
                        var o = e.indexOf("	", r);
                        -1 == o && (o = e.length);
                        var a = o - r;
                        if (o == e.length || i + a >= t)return r + Math.min(a, t - i);
                        if (i += o - r, i += n - i % n, r = o + 1, i >= t)return r
                    }
                }, ja = [""], Ua = function (e) {
                    e.select()
                };
                No ? Ua = function (e) {
                    e.selectionStart = 0, e.selectionEnd = e.value.length
                } : xo && (Ua = function (e) {
                        try {
                            e.select()
                        } catch (t) {
                        }
                    });
                var qa,
                    Ga = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,
                    Ya = e.isWordChar = function (e) {
                        return /\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || Ga.test(e))
                    },
                    $a = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
                qa = document.createRange ? function (e, t, n, r) {
                    var i = document.createRange();
                    return i.setEnd(r || e, n), i.setStart(e, t), i
                } : function (e, t, n) {
                    var r = document.body.createTextRange();
                    try {
                        r.moveToElementText(e.parentNode)
                    } catch (i) {
                        return r
                    }
                    return r.collapse(!0), r.moveEnd("character", n), r.moveStart("character", t), r
                };
                var Va = e.contains = function (e, t) {
                    if (3 == t.nodeType && (t = t.parentNode), e.contains)return e.contains(t);
                    do if (11 == t.nodeType && (t = t.host), t == e)return !0; while (t = t.parentNode)
                };
                xo && 11 > bo && (Gi = function () {
                    try {
                        return document.activeElement
                    } catch (e) {
                        return document.body
                    }
                });
                var Ka, Xa, Za = e.rmClass = function (e, t) {
                    var n = e.className, r = Yi(t).exec(n);
                    if (r) {
                        var i = n.slice(r.index + r[0].length);
                        e.className = n.slice(0, r.index) + (i ? r[1] + i : "")
                    }
                }, Ja = e.addClass = function (e, t) {
                    var n = e.className;
                    Yi(t).test(n) || (e.className += (n ? " " : "") + t)
                }, Qa = !1, el = function () {
                    if (xo && 9 > bo)return !1;
                    var e = ji("div");
                    return "draggable" in e || "dragDrop" in e
                }(), tl = e.splitLines = 3 != "\n\nb".split(/\n/).length ? function (e) {
                    for (var t = 0, n = [], r = e.length; r >= t;) {
                        var i = e.indexOf("\n", t);
                        -1 == i && (i = e.length);
                        var o = e.slice(t, "\r" == e.charAt(i - 1) ? i - 1 : i), a = o.indexOf("\r");
                        -1 != a ? (n.push(o.slice(0, a)), t += a + 1) : (n.push(o), t = i + 1)
                    }
                    return n
                } : function (e) {
                    return e.split(/\r\n?|\n/)
                }, nl = window.getSelection ? function (e) {
                    try {
                        return e.selectionStart != e.selectionEnd
                    } catch (t) {
                        return !1
                    }
                } : function (e) {
                    try {
                        var t = e.ownerDocument.selection.createRange()
                    } catch (n) {
                    }
                    return t && t.parentElement() == e ? 0 != t.compareEndPoints("StartToEnd", t) : !1
                }, rl = function () {
                    var e = ji("div");
                    return "oncopy" in e ? !0 : (e.setAttribute("oncopy", "return;"), "function" == typeof e.oncopy)
                }(), il = null, ol = e.keyNames = {
                    3: "Enter",
                    8: "Backspace",
                    9: "Tab",
                    13: "Enter",
                    16: "Shift",
                    17: "Ctrl",
                    18: "Alt",
                    19: "Pause",
                    20: "CapsLock",
                    27: "Esc",
                    32: "Space",
                    33: "PageUp",
                    34: "PageDown",
                    35: "End",
                    36: "Home",
                    37: "Left",
                    38: "Up",
                    39: "Right",
                    40: "Down",
                    44: "PrintScrn",
                    45: "Insert",
                    46: "Delete",
                    59: ";",
                    61: "=",
                    91: "Mod",
                    92: "Mod",
                    93: "Mod",
                    106: "*",
                    107: "=",
                    109: "-",
                    110: ".",
                    111: "/",
                    127: "Delete",
                    173: "-",
                    186: ";",
                    187: "=",
                    188: ",",
                    189: "-",
                    190: ".",
                    191: "/",
                    192: "`",
                    219: "[",
                    220: "\\",
                    221: "]",
                    222: "'",
                    63232: "Up",
                    63233: "Down",
                    63234: "Left",
                    63235: "Right",
                    63272: "Delete",
                    63273: "Home",
                    63275: "End",
                    63276: "PageUp",
                    63277: "PageDown",
                    63302: "Insert"
                };
                !function () {
                    for (var e = 0; 10 > e; e++)ol[e + 48] = ol[e + 96] = String(e);
                    for (var e = 65; 90 >= e; e++)ol[e] = String.fromCharCode(e);
                    for (var e = 1; 12 >= e; e++)ol[e + 111] = ol[e + 63235] = "F" + e
                }();
                var al, ll = function () {
                    function e(e) {
                        return 247 >= e ? n.charAt(e) : e >= 1424 && 1524 >= e ? "R" : e >= 1536 && 1773 >= e ? r.charAt(e - 1536) : e >= 1774 && 2220 >= e ? "r" : e >= 8192 && 8203 >= e ? "w" : 8204 == e ? "b" : "L"
                    }

                    function t(e, t, n) {
                        this.level = e, this.from = t, this.to = n
                    }

                    var n = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",
                        r = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm",
                        i = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, o = /[stwN]/, a = /[LRr]/, l = /[Lb1n]/,
                        s = /[1n]/, c = "L";
                    return function (n) {
                        if (!i.test(n))return !1;
                        for (var r, u = n.length, f = [], h = 0; u > h; ++h)f.push(r = e(n.charCodeAt(h)));
                        for (var h = 0, d = c; u > h; ++h) {
                            var r = f[h];
                            "m" == r ? f[h] = d : d = r
                        }
                        for (var h = 0, p = c; u > h; ++h) {
                            var r = f[h];
                            "1" == r && "r" == p ? f[h] = "n" : a.test(r) && (p = r, "r" == r && (f[h] = "R"))
                        }
                        for (var h = 1, d = f[0]; u - 1 > h; ++h) {
                            var r = f[h];
                            "+" == r && "1" == d && "1" == f[h + 1] ? f[h] = "1" : "," != r || d != f[h + 1] || "1" != d && "n" != d || (f[h] = d), d = r
                        }
                        for (var h = 0; u > h; ++h) {
                            var r = f[h];
                            if ("," == r) f[h] = "N"; else if ("%" == r) {
                                for (var m = h + 1; u > m && "%" == f[m]; ++m);
                                for (var g = h && "!" == f[h - 1] || u > m && "1" == f[m] ? "1" : "N",
                                         v = h; m > v; ++v)f[v] = g;
                                h = m - 1
                            }
                        }
                        for (var h = 0, p = c; u > h; ++h) {
                            var r = f[h];
                            "L" == p && "1" == r ? f[h] = "L" : a.test(r) && (p = r)
                        }
                        for (var h = 0; u > h; ++h)if (o.test(f[h])) {
                            for (var m = h + 1; u > m && o.test(f[m]); ++m);
                            for (var y = "L" == (h ? f[h - 1] : c), x = "L" == (u > m ? f[m] : c),
                                     g = y || x ? "L" : "R", v = h; m > v; ++v)f[v] = g;
                            h = m - 1
                        }
                        for (var b, w = [], h = 0; u > h;)if (l.test(f[h])) {
                            var k = h;
                            for (++h; u > h && l.test(f[h]); ++h);
                            w.push(new t(0, k, h))
                        } else {
                            var S = h, C = w.length;
                            for (++h; u > h && "L" != f[h]; ++h);
                            for (var v = S; h > v;)if (s.test(f[v])) {
                                v > S && w.splice(C, 0, new t(1, S, v));
                                var L = v;
                                for (++v; h > v && s.test(f[v]); ++v);
                                w.splice(C, 0, new t(2, L, v)), S = v
                            } else++v;
                            h > S && w.splice(C, 0, new t(1, S, h))
                        }
                        return 1 == w[0].level && (b = n.match(/^\s+/)) && (w[0].from = b[0].length, w.unshift(new t(0, 0, b[0].length))), 1 == Ii(w).level && (b = n.match(/\s+$/)) && (Ii(w).to -= b[0].length, w.push(new t(0, u - b[0].length, u))), 2 == w[0].level && w.unshift(new t(1, w[0].to, w[0].to)), w[0].level != Ii(w).level && w.push(new t(w[0].level, u, u)), w
                    }
                }();
                return e.version = "5.15.2", e
            })
        }, {}],
        11: [function (t, n, r) {
            !function (i) {
                "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror"), t("../markdown/markdown"), t("../../addon/mode/overlay")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror", "../markdown/markdown", "../../addon/mode/overlay"], i) : i(CodeMirror)
            }(function (e) {
                "use strict";
                var t = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?]))/i;
                e.defineMode("gfm", function (n, r) {
                    function i(e) {
                        return e.code = !1, null
                    }

                    var o = 0, a = {
                        startState: function () {
                            return {code: !1, codeBlock: !1, ateSpace: !1}
                        }, copyState: function (e) {
                            return {code: e.code, codeBlock: e.codeBlock, ateSpace: e.ateSpace}
                        }, token: function (e, n) {
                            if (n.combineTokens = null, n.codeBlock)return e.match(/^```+/) ? (n.codeBlock = !1, null) : (e.skipToEnd(), null);
                            if (e.sol() && (n.code = !1), e.sol() && e.match(/^```+/))return e.skipToEnd(), n.codeBlock = !0, null;
                            if ("`" === e.peek()) {
                                e.next();
                                var i = e.pos;
                                e.eatWhile("`");
                                var a = 1 + e.pos - i;
                                return n.code ? a === o && (n.code = !1) : (o = a, n.code = !0), null
                            }
                            if (n.code)return e.next(), null;
                            if (e.eatSpace())return n.ateSpace = !0, null;
                            if ((e.sol() || n.ateSpace) && (n.ateSpace = !1, r.gitHubSpice !== !1)) {
                                if (e.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?:[a-f0-9]{7,40}\b)/))return n.combineTokens = !0, "link";
                                if (e.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/))return n.combineTokens = !0, "link"
                            }
                            return e.match(t) && "](" != e.string.slice(e.start - 2, e.start) && (0 == e.start || /\W/.test(e.string.charAt(e.start - 1))) ? (n.combineTokens = !0, "link") : (e.next(), null)
                        }, blankLine: i
                    }, l = {underscoresBreakWords: !1, taskLists: !0, fencedCodeBlocks: "```", strikethrough: !0};
                    for (var s in r)l[s] = r[s];
                    return l.name = "markdown", e.overlayMode(e.getMode(n, l), a)
                }, "markdown"), e.defineMIME("text/x-gfm", "gfm")
            })
        }, {"../../addon/mode/overlay": 8, "../../lib/codemirror": 10, "../markdown/markdown": 12}],
        12: [function (t, n, r) {
            !function (i) {
                "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror"), t("../xml/xml"), t("../meta")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror", "../xml/xml", "../meta"], i) : i(CodeMirror)
            }(function (e) {
                "use strict";
                e.defineMode("markdown", function (t, n) {
                    function r(n) {
                        if (e.findModeByName) {
                            var r = e.findModeByName(n);
                            r && (n = r.mime || r.mimes[0])
                        }
                        var i = e.getMode(t, n);
                        return "null" == i.name ? null : i
                    }

                    function i(e, t, n) {
                        return t.f = t.inline = n, n(e, t)
                    }

                    function o(e, t, n) {
                        return t.f = t.block = n, n(e, t)
                    }

                    function a(e) {
                        return !e || !/\S/.test(e.string)
                    }

                    function l(e) {
                        return e.linkTitle = !1, e.em = !1, e.strong = !1, e.strikethrough = !1, e.quote = 0, e.indentedCode = !1, k && e.f == c && (e.f = p, e.block = s), e.trailingSpace = 0, e.trailingSpaceNewLine = !1, e.prevLine = e.thisLine, e.thisLine = null, null
                    }

                    function s(t, o) {
                        var l = t.sol(), s = o.list !== !1, c = o.indentedCode;
                        o.indentedCode = !1, s && (o.indentationDiff >= 0 ? (o.indentationDiff < 4 && (o.indentation -= o.indentationDiff), o.list = null) : o.indentation > 0 ? o.list = null : o.list = !1);
                        var f = null;
                        if (o.indentationDiff >= 4)return t.skipToEnd(), c || a(o.prevLine) ? (o.indentation -= 4, o.indentedCode = !0, S.code) : null;
                        if (t.eatSpace())return null;
                        if ((f = t.match(A)) && f[1].length <= 6)return o.header = f[1].length, n.highlightFormatting && (o.formatting = "header"), o.f = o.inline, h(o);
                        if (!(a(o.prevLine) || o.quote || s || c) && (f = t.match(E)))return o.header = "=" == f[0].charAt(0) ? 1 : 2, n.highlightFormatting && (o.formatting = "header"), o.f = o.inline, h(o);
                        if (t.eat(">"))return o.quote = l ? 1 : o.quote + 1, n.highlightFormatting && (o.formatting = "quote"), t.eatSpace(), h(o);
                        if ("[" === t.peek())return i(t, o, y);
                        if (t.match(L, !0))return o.hr = !0, S.hr;
                        if ((a(o.prevLine) || s) && (t.match(T, !1) || t.match(M, !1))) {
                            var d = null;
                            for (t.match(T, !0) ? d = "ul" : (t.match(M, !0), d = "ol"), o.indentation = t.column() + t.current().length, o.list = !0; o.listStack && t.column() < o.listStack[o.listStack.length - 1];)o.listStack.pop();
                            return o.listStack.push(o.indentation), n.taskLists && t.match(N, !1) && (o.taskList = !0), o.f = o.inline, n.highlightFormatting && (o.formatting = ["list", "list-" + d]), h(o)
                        }
                        return n.fencedCodeBlocks && (f = t.match(I, !0)) ? (o.fencedChars = f[1], o.localMode = r(f[2]), o.localMode && (o.localState = e.startState(o.localMode)), o.f = o.block = u, n.highlightFormatting && (o.formatting = "code-block"), o.code = -1, h(o)) : i(t, o, o.inline)
                    }

                    function c(t, n) {
                        var r = w.token(t, n.htmlState);
                        if (!k) {
                            var i = e.innerMode(w, n.htmlState);
                            ("xml" == i.mode.name && null === i.state.tagStart && !i.state.context && i.state.tokenize.isInText || n.md_inside && t.current().indexOf(">") > -1) && (n.f = p, n.block = s, n.htmlState = null)
                        }
                        return r
                    }

                    function u(e, t) {
                        return t.fencedChars && e.match(t.fencedChars, !1) ? (t.localMode = t.localState = null, t.f = t.block = f, null) : t.localMode ? t.localMode.token(e, t.localState) : (e.skipToEnd(), S.code)
                    }

                    function f(e, t) {
                        e.match(t.fencedChars), t.block = s, t.f = p, t.fencedChars = null, n.highlightFormatting && (t.formatting = "code-block"), t.code = 1;
                        var r = h(t);
                        return t.code = 0, r
                    }

                    function h(e) {
                        var t = [];
                        if (e.formatting) {
                            t.push(S.formatting), "string" == typeof e.formatting && (e.formatting = [e.formatting]);
                            for (var r = 0; r < e.formatting.length; r++)t.push(S.formatting + "-" + e.formatting[r]), "header" === e.formatting[r] && t.push(S.formatting + "-" + e.formatting[r] + "-" + e.header), "quote" === e.formatting[r] && (!n.maxBlockquoteDepth || n.maxBlockquoteDepth >= e.quote ? t.push(S.formatting + "-" + e.formatting[r] + "-" + e.quote) : t.push("error"))
                        }
                        if (e.taskOpen)return t.push("meta"), t.length ? t.join(" ") : null;
                        if (e.taskClosed)return t.push("property"), t.length ? t.join(" ") : null;
                        if (e.linkHref ? t.push(S.linkHref, "url") : (e.strong && t.push(S.strong), e.em && t.push(S.em), e.strikethrough && t.push(S.strikethrough), e.linkText && t.push(S.linkText), e.code && t.push(S.code)), e.header && t.push(S.header, S.header + "-" + e.header), e.quote && (t.push(S.quote), !n.maxBlockquoteDepth || n.maxBlockquoteDepth >= e.quote ? t.push(S.quote + "-" + e.quote) : t.push(S.quote + "-" + n.maxBlockquoteDepth)), e.list !== !1) {
                            var i = (e.listStack.length - 1) % 3;
                            i ? 1 === i ? t.push(S.list2) : t.push(S.list3) : t.push(S.list1)
                        }
                        return e.trailingSpaceNewLine ? t.push("trailing-space-new-line") : e.trailingSpace && t.push("trailing-space-" + (e.trailingSpace % 2 ? "a" : "b")), t.length ? t.join(" ") : null
                    }

                    function d(e, t) {
                        return e.match(O, !0) ? h(t) : void 0
                    }

                    function p(t, r) {
                        var i = r.text(t, r);
                        if ("undefined" != typeof i)return i;
                        if (r.list)return r.list = null, h(r);
                        if (r.taskList) {
                            var a = "x" !== t.match(N, !0)[1];
                            return a ? r.taskOpen = !0 : r.taskClosed = !0, n.highlightFormatting && (r.formatting = "task"), r.taskList = !1, h(r)
                        }
                        if (r.taskOpen = !1, r.taskClosed = !1, r.header && t.match(/^#+$/, !0))return n.highlightFormatting && (r.formatting = "header"),
                            h(r);
                        var l = t.sol(), s = t.next();
                        if (r.linkTitle) {
                            r.linkTitle = !1;
                            var u = s;
                            "(" === s && (u = ")"), u = (u + "").replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
                            var f = "^\\s*(?:[^" + u + "\\\\]+|\\\\\\\\|\\\\.)" + u;
                            if (t.match(new RegExp(f), !0))return S.linkHref
                        }
                        if ("`" === s) {
                            var d = r.formatting;
                            n.highlightFormatting && (r.formatting = "code"), t.eatWhile("`");
                            var p = t.current().length;
                            if (0 == r.code)return r.code = p, h(r);
                            if (p == r.code) {
                                var v = h(r);
                                return r.code = 0, v
                            }
                            return r.formatting = d, h(r)
                        }
                        if (r.code)return h(r);
                        if ("\\" === s && (t.next(), n.highlightFormatting)) {
                            var y = h(r), x = S.formatting + "-escape";
                            return y ? y + " " + x : x
                        }
                        if ("!" === s && t.match(/\[[^\]]*\] ?(?:\(|\[)/, !1))return t.match(/\[[^\]]*\]/), r.inline = r.f = g, S.image;
                        if ("[" === s && t.match(/[^\]]*\](\(.*\)| ?\[.*?\])/, !1))return r.linkText = !0, n.highlightFormatting && (r.formatting = "link"), h(r);
                        if ("]" === s && r.linkText && t.match(/\(.*?\)| ?\[.*?\]/, !1)) {
                            n.highlightFormatting && (r.formatting = "link");
                            var y = h(r);
                            return r.linkText = !1, r.inline = r.f = g, y
                        }
                        if ("<" === s && t.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, !1)) {
                            r.f = r.inline = m, n.highlightFormatting && (r.formatting = "link");
                            var y = h(r);
                            return y ? y += " " : y = "", y + S.linkInline
                        }
                        if ("<" === s && t.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, !1)) {
                            r.f = r.inline = m, n.highlightFormatting && (r.formatting = "link");
                            var y = h(r);
                            return y ? y += " " : y = "", y + S.linkEmail
                        }
                        if ("<" === s && t.match(/^(!--|\w)/, !1)) {
                            var b = t.string.indexOf(">", t.pos);
                            if (-1 != b) {
                                var k = t.string.substring(t.start, b);
                                /markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(k) && (r.md_inside = !0)
                            }
                            return t.backUp(1), r.htmlState = e.startState(w), o(t, r, c)
                        }
                        if ("<" === s && t.match(/^\/\w*?>/))return r.md_inside = !1, "tag";
                        var C = !1;
                        if (!n.underscoresBreakWords && "_" === s && "_" !== t.peek() && t.match(/(\w)/, !1)) {
                            var L = t.pos - 2;
                            if (L >= 0) {
                                var T = t.string.charAt(L);
                                "_" !== T && T.match(/(\w)/, !1) && (C = !0)
                            }
                        }
                        if ("*" === s || "_" === s && !C)if (l && " " === t.peek()); else {
                            if (r.strong === s && t.eat(s)) {
                                n.highlightFormatting && (r.formatting = "strong");
                                var v = h(r);
                                return r.strong = !1, v
                            }
                            if (!r.strong && t.eat(s))return r.strong = s, n.highlightFormatting && (r.formatting = "strong"), h(r);
                            if (r.em === s) {
                                n.highlightFormatting && (r.formatting = "em");
                                var v = h(r);
                                return r.em = !1, v
                            }
                            if (!r.em)return r.em = s, n.highlightFormatting && (r.formatting = "em"), h(r)
                        } else if (" " === s && (t.eat("*") || t.eat("_"))) {
                            if (" " === t.peek())return h(r);
                            t.backUp(1)
                        }
                        if (n.strikethrough)if ("~" === s && t.eatWhile(s)) {
                            if (r.strikethrough) {
                                n.highlightFormatting && (r.formatting = "strikethrough");
                                var v = h(r);
                                return r.strikethrough = !1, v
                            }
                            if (t.match(/^[^\s]/, !1))return r.strikethrough = !0, n.highlightFormatting && (r.formatting = "strikethrough"), h(r)
                        } else if (" " === s && t.match(/^~~/, !0)) {
                            if (" " === t.peek())return h(r);
                            t.backUp(2)
                        }
                        return " " === s && (t.match(/ +$/, !1) ? r.trailingSpace++ : r.trailingSpace && (r.trailingSpaceNewLine = !0)), h(r)
                    }

                    function m(e, t) {
                        var r = e.next();
                        if (">" === r) {
                            t.f = t.inline = p, n.highlightFormatting && (t.formatting = "link");
                            var i = h(t);
                            return i ? i += " " : i = "", i + S.linkInline
                        }
                        return e.match(/^[^>]+/, !0), S.linkInline
                    }

                    function g(e, t) {
                        if (e.eatSpace())return null;
                        var r = e.next();
                        return "(" === r || "[" === r ? (t.f = t.inline = v("(" === r ? ")" : "]", 0), n.highlightFormatting && (t.formatting = "link-string"), t.linkHref = !0, h(t)) : "error"
                    }

                    function v(e) {
                        return function (t, r) {
                            var i = t.next();
                            if (i === e) {
                                r.f = r.inline = p, n.highlightFormatting && (r.formatting = "link-string");
                                var o = h(r);
                                return r.linkHref = !1, o
                            }
                            return t.match(P[e]), r.linkHref = !0, h(r)
                        }
                    }

                    function y(e, t) {
                        return e.match(/^([^\]\\]|\\.)*\]:/, !1) ? (t.f = x, e.next(), n.highlightFormatting && (t.formatting = "link"), t.linkText = !0, h(t)) : i(e, t, p)
                    }

                    function x(e, t) {
                        if (e.match(/^\]:/, !0)) {
                            t.f = t.inline = b, n.highlightFormatting && (t.formatting = "link");
                            var r = h(t);
                            return t.linkText = !1, r
                        }
                        return e.match(/^([^\]\\]|\\.)+/, !0), S.linkText
                    }

                    function b(e, t) {
                        return e.eatSpace() ? null : (e.match(/^[^\s]+/, !0), void 0 === e.peek() ? t.linkTitle = !0 : e.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, !0), t.f = t.inline = p, S.linkHref + " url")
                    }

                    var w = e.getMode(t, "text/html"), k = "null" == w.name;
                    void 0 === n.highlightFormatting && (n.highlightFormatting = !1), void 0 === n.maxBlockquoteDepth && (n.maxBlockquoteDepth = 0), void 0 === n.underscoresBreakWords && (n.underscoresBreakWords = !0), void 0 === n.taskLists && (n.taskLists = !1), void 0 === n.strikethrough && (n.strikethrough = !1), void 0 === n.tokenTypeOverrides && (n.tokenTypeOverrides = {});
                    var S = {
                        header: "header",
                        code: "comment",
                        quote: "quote",
                        list1: "variable-2",
                        list2: "variable-3",
                        list3: "keyword",
                        hr: "hr",
                        image: "tag",
                        formatting: "formatting",
                        linkInline: "link",
                        linkEmail: "link",
                        linkText: "link",
                        linkHref: "string",
                        em: "em",
                        strong: "strong",
                        strikethrough: "strikethrough"
                    };
                    for (var C in S)S.hasOwnProperty(C) && n.tokenTypeOverrides[C] && (S[C] = n.tokenTypeOverrides[C]);
                    var L = /^([*\-_])(?:\s*\1){2,}\s*$/, T = /^[*\-+]\s+/, M = /^[0-9]+([.)])\s+/,
                        N = /^\[(x| )\](?=\s)/, A = n.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/,
                        E = /^ *(?:\={1,}|-{1,})\s*$/, O = /^[^#!\[\]*_\\<>` "'(~]+/,
                        I = new RegExp("^(" + (n.fencedCodeBlocks === !0 ? "~~~+|```+" : n.fencedCodeBlocks) + ")[ \\t]*([\\w+#-]*)"),
                        P = {
                            ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
                            "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\\]]|\\.)*\])*?(?=\])/
                        }, R = {
                            startState: function () {
                                return {
                                    f: s,
                                    prevLine: null,
                                    thisLine: null,
                                    block: s,
                                    htmlState: null,
                                    indentation: 0,
                                    inline: p,
                                    text: d,
                                    formatting: !1,
                                    linkText: !1,
                                    linkHref: !1,
                                    linkTitle: !1,
                                    code: 0,
                                    em: !1,
                                    strong: !1,
                                    header: 0,
                                    hr: !1,
                                    taskList: !1,
                                    list: !1,
                                    listStack: [],
                                    quote: 0,
                                    trailingSpace: 0,
                                    trailingSpaceNewLine: !1,
                                    strikethrough: !1,
                                    fencedChars: null
                                }
                            }, copyState: function (t) {
                                return {
                                    f: t.f,
                                    prevLine: t.prevLine,
                                    thisLine: t.thisLine,
                                    block: t.block,
                                    htmlState: t.htmlState && e.copyState(w, t.htmlState),
                                    indentation: t.indentation,
                                    localMode: t.localMode,
                                    localState: t.localMode ? e.copyState(t.localMode, t.localState) : null,
                                    inline: t.inline,
                                    text: t.text,
                                    formatting: !1,
                                    linkTitle: t.linkTitle,
                                    code: t.code,
                                    em: t.em,
                                    strong: t.strong,
                                    strikethrough: t.strikethrough,
                                    header: t.header,
                                    hr: t.hr,
                                    taskList: t.taskList,
                                    list: t.list,
                                    listStack: t.listStack.slice(0),
                                    quote: t.quote,
                                    indentedCode: t.indentedCode,
                                    trailingSpace: t.trailingSpace,
                                    trailingSpaceNewLine: t.trailingSpaceNewLine,
                                    md_inside: t.md_inside,
                                    fencedChars: t.fencedChars
                                }
                            }, token: function (e, t) {
                                if (t.formatting = !1, e != t.thisLine) {
                                    var n = t.header || t.hr;
                                    if (t.header = 0, t.hr = !1, e.match(/^\s*$/, !0) || n) {
                                        if (l(t), !n)return null;
                                        t.prevLine = null
                                    }
                                    t.prevLine = t.thisLine, t.thisLine = e, t.taskList = !1, t.trailingSpace = 0, t.trailingSpaceNewLine = !1, t.f = t.block;
                                    var r = e.match(/^\s*/, !0)[0].replace(/\t/g, "    ").length;
                                    if (t.indentationDiff = Math.min(r - t.indentation, 4), t.indentation = t.indentation + t.indentationDiff, r > 0)return null
                                }
                                return t.f(e, t)
                            }, innerMode: function (e) {
                                return e.block == c ? {state: e.htmlState, mode: w} : e.localState ? {
                                    state: e.localState,
                                    mode: e.localMode
                                } : {state: e, mode: R}
                            }, blankLine: l, getType: h, fold: "markdown"
                        };
                    return R
                }, "xml"), e.defineMIME("text/x-markdown", "markdown")
            })
        }, {"../../lib/codemirror": 10, "../meta": 13, "../xml/xml": 14}],
        13: [function (t, n, r) {
            !function (i) {
                "object" == typeof r && "object" == typeof n ? i(t("../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../lib/codemirror"], i) : i(CodeMirror)
            }(function (e) {
                "use strict";
                e.modeInfo = [{name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"]}, {
                    name: "PGP",
                    mimes: ["application/pgp", "application/pgp-keys", "application/pgp-signature"],
                    mode: "asciiarmor",
                    ext: ["pgp"]
                }, {name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"]}, {
                    name: "Asterisk",
                    mime: "text/x-asterisk",
                    mode: "asterisk",
                    file: /^extensions\.conf$/i
                }, {name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"]}, {
                    name: "C",
                    mime: "text/x-csrc",
                    mode: "clike",
                    ext: ["c", "h"]
                }, {
                    name: "C++",
                    mime: "text/x-c++src",
                    mode: "clike",
                    ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
                    alias: ["cpp"]
                }, {name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"]}, {
                    name: "C#",
                    mime: "text/x-csharp",
                    mode: "clike",
                    ext: ["cs"],
                    alias: ["csharp"]
                }, {
                    name: "Clojure",
                    mime: "text/x-clojure",
                    mode: "clojure",
                    ext: ["clj", "cljc", "cljx"]
                }, {
                    name: "ClojureScript",
                    mime: "text/x-clojurescript",
                    mode: "clojure",
                    ext: ["cljs"]
                }, {name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"]}, {
                    name: "CMake",
                    mime: "text/x-cmake",
                    mode: "cmake",
                    ext: ["cmake", "cmake.in"],
                    file: /^CMakeLists.txt$/
                }, {
                    name: "CoffeeScript",
                    mime: "text/x-coffeescript",
                    mode: "coffeescript",
                    ext: ["coffee"],
                    alias: ["coffee", "coffee-script"]
                }, {
                    name: "Common Lisp",
                    mime: "text/x-common-lisp",
                    mode: "commonlisp",
                    ext: ["cl", "lisp", "el"],
                    alias: ["lisp"]
                }, {
                    name: "Cypher",
                    mime: "application/x-cypher-query",
                    mode: "cypher",
                    ext: ["cyp", "cypher"]
                }, {
                    name: "Cython",
                    mime: "text/x-cython",
                    mode: "python",
                    ext: ["pyx", "pxd", "pxi"]
                }, {name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"]}, {
                    name: "CSS",
                    mime: "text/css",
                    mode: "css",
                    ext: ["css"]
                }, {name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"]}, {
                    name: "D",
                    mime: "text/x-d",
                    mode: "d",
                    ext: ["d"]
                }, {
                    name: "Dart",
                    mimes: ["application/dart", "text/x-dart"],
                    mode: "dart",
                    ext: ["dart"]
                }, {name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"]}, {
                    name: "Django",
                    mime: "text/x-django",
                    mode: "django"
                }, {
                    name: "Dockerfile",
                    mime: "text/x-dockerfile",
                    mode: "dockerfile",
                    file: /^Dockerfile$/
                }, {name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"]}, {
                    name: "Dylan",
                    mime: "text/x-dylan",
                    mode: "dylan",
                    ext: ["dylan", "dyl", "intr"]
                }, {name: "EBNF", mime: "text/x-ebnf", mode: "ebnf"}, {
                    name: "ECL",
                    mime: "text/x-ecl",
                    mode: "ecl",
                    ext: ["ecl"]
                }, {name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"]}, {
                    name: "Eiffel",
                    mime: "text/x-eiffel",
                    mode: "eiffel",
                    ext: ["e"]
                }, {name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"]}, {
                    name: "Embedded Javascript",
                    mime: "application/x-ejs",
                    mode: "htmlembedded",
                    ext: ["ejs"]
                }, {
                    name: "Embedded Ruby",
                    mime: "application/x-erb",
                    mode: "htmlembedded",
                    ext: ["erb"]
                }, {name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"]}, {
                    name: "Factor",
                    mime: "text/x-factor",
                    mode: "factor",
                    ext: ["factor"]
                }, {name: "FCL", mime: "text/x-fcl", mode: "fcl"}, {
                    name: "Forth",
                    mime: "text/x-forth",
                    mode: "forth",
                    ext: ["forth", "fth", "4th"]
                }, {
                    name: "Fortran",
                    mime: "text/x-fortran",
                    mode: "fortran",
                    ext: ["f", "for", "f77", "f90"]
                }, {name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"]}, {
                    name: "Gas",
                    mime: "text/x-gas",
                    mode: "gas",
                    ext: ["s"]
                }, {
                    name: "Gherkin",
                    mime: "text/x-feature",
                    mode: "gherkin",
                    ext: ["feature"]
                }, {
                    name: "GitHub Flavored Markdown",
                    mime: "text/x-gfm",
                    mode: "gfm",
                    file: /^(readme|contributing|history).md$/i
                }, {name: "Go", mime: "text/x-go", mode: "go", ext: ["go"]}, {
                    name: "Groovy",
                    mime: "text/x-groovy",
                    mode: "groovy",
                    ext: ["groovy", "gradle"]
                }, {name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"]}, {
                    name: "Haskell",
                    mime: "text/x-haskell",
                    mode: "haskell",
                    ext: ["hs"]
                }, {
                    name: "Haskell (Literate)",
                    mime: "text/x-literate-haskell",
                    mode: "haskell-literate",
                    ext: ["lhs"]
                }, {name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"]}, {
                    name: "HXML",
                    mime: "text/x-hxml",
                    mode: "haxe",
                    ext: ["hxml"]
                }, {
                    name: "ASP.NET",
                    mime: "application/x-aspx",
                    mode: "htmlembedded",
                    ext: ["aspx"],
                    alias: ["asp", "aspx"]
                }, {
                    name: "HTML",
                    mime: "text/html",
                    mode: "htmlmixed",
                    ext: ["html", "htm"],
                    alias: ["xhtml"]
                }, {name: "HTTP", mime: "message/http", mode: "http"}, {
                    name: "IDL",
                    mime: "text/x-idl",
                    mode: "idl",
                    ext: ["pro"]
                }, {name: "Jade", mime: "text/x-jade", mode: "jade", ext: ["jade"]}, {
                    name: "Java",
                    mime: "text/x-java",
                    mode: "clike",
                    ext: ["java"]
                }, {
                    name: "Java Server Pages",
                    mime: "application/x-jsp",
                    mode: "htmlembedded",
                    ext: ["jsp"],
                    alias: ["jsp"]
                }, {
                    name: "JavaScript",
                    mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
                    mode: "javascript",
                    ext: ["js"],
                    alias: ["ecmascript", "js", "node"]
                }, {
                    name: "JSON",
                    mimes: ["application/json", "application/x-json"],
                    mode: "javascript",
                    ext: ["json", "map"],
                    alias: ["json5"]
                }, {
                    name: "JSON-LD",
                    mime: "application/ld+json",
                    mode: "javascript",
                    ext: ["jsonld"],
                    alias: ["jsonld"]
                }, {name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"]}, {
                    name: "Jinja2",
                    mime: "null",
                    mode: "jinja2"
                }, {name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"]}, {
                    name: "Kotlin",
                    mime: "text/x-kotlin",
                    mode: "clike",
                    ext: ["kt"]
                }, {name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"]}, {
                    name: "LiveScript",
                    mime: "text/x-livescript",
                    mode: "livescript",
                    ext: ["ls"],
                    alias: ["ls"]
                }, {name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"]}, {
                    name: "Markdown",
                    mime: "text/x-markdown",
                    mode: "markdown",
                    ext: ["markdown", "md", "mkd"]
                }, {name: "mIRC", mime: "text/mirc", mode: "mirc"}, {
                    name: "MariaDB SQL",
                    mime: "text/x-mariadb",
                    mode: "sql"
                }, {
                    name: "Mathematica",
                    mime: "text/x-mathematica",
                    mode: "mathematica",
                    ext: ["m", "nb"]
                }, {name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"]}, {
                    name: "MUMPS",
                    mime: "text/x-mumps",
                    mode: "mumps",
                    ext: ["mps"]
                }, {name: "MS SQL", mime: "text/x-mssql", mode: "sql"}, {
                    name: "mbox",
                    mime: "application/mbox",
                    mode: "mbox",
                    ext: ["mbox"]
                }, {name: "MySQL", mime: "text/x-mysql", mode: "sql"}, {
                    name: "Nginx",
                    mime: "text/x-nginx-conf",
                    mode: "nginx",
                    file: /nginx.*\.conf$/i
                }, {name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"]}, {
                    name: "NTriples",
                    mime: "text/n-triples",
                    mode: "ntriples",
                    ext: ["nt"]
                }, {
                    name: "Objective C",
                    mime: "text/x-objectivec",
                    mode: "clike",
                    ext: ["m", "mm"],
                    alias: ["objective-c", "objc"]
                }, {
                    name: "OCaml",
                    mime: "text/x-ocaml",
                    mode: "mllike",
                    ext: ["ml", "mli", "mll", "mly"]
                }, {name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"]}, {
                    name: "Oz",
                    mime: "text/x-oz",
                    mode: "oz",
                    ext: ["oz"]
                }, {name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"]}, {
                    name: "PEG.js",
                    mime: "null",
                    mode: "pegjs",
                    ext: ["jsonld"]
                }, {name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"]}, {
                    name: "PHP",
                    mime: "application/x-httpd-php",
                    mode: "php",
                    ext: ["php", "php3", "php4", "php5", "phtml"]
                }, {name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"]}, {
                    name: "Plain Text",
                    mime: "text/plain",
                    mode: "null",
                    ext: ["txt", "text", "conf", "def", "list", "log"]
                }, {name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"]}, {
                    name: "PowerShell",
                    mime: "application/x-powershell",
                    mode: "powershell",
                    ext: ["ps1", "psd1", "psm1"]
                }, {
                    name: "Properties files",
                    mime: "text/x-properties",
                    mode: "properties",
                    ext: ["properties", "ini", "in"],
                    alias: ["ini", "properties"]
                }, {name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"]}, {
                    name: "Python",
                    mime: "text/x-python",
                    mode: "python",
                    ext: ["BUILD", "bzl", "py", "pyw"],
                    file: /^(BUCK|BUILD)$/
                }, {name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"]}, {
                    name: "Q",
                    mime: "text/x-q",
                    mode: "q",
                    ext: ["q"]
                }, {
                    name: "R",
                    mime: "text/x-rsrc",
                    mode: "r",
                    ext: ["r"],
                    alias: ["rscript"]
                }, {
                    name: "reStructuredText",
                    mime: "text/x-rst",
                    mode: "rst",
                    ext: ["rst"],
                    alias: ["rst"]
                }, {name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm"}, {
                    name: "RPM Spec",
                    mime: "text/x-rpm-spec",
                    mode: "rpm",
                    ext: ["spec"]
                }, {
                    name: "Ruby",
                    mime: "text/x-ruby",
                    mode: "ruby",
                    ext: ["rb"],
                    alias: ["jruby", "macruby", "rake", "rb", "rbx"]
                }, {name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"]}, {
                    name: "SAS",
                    mime: "text/x-sas",
                    mode: "sas",
                    ext: ["sas"]
                }, {name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"]}, {
                    name: "Scala",
                    mime: "text/x-scala",
                    mode: "clike",
                    ext: ["scala"]
                }, {name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"]}, {
                    name: "SCSS",
                    mime: "text/x-scss",
                    mode: "css",
                    ext: ["scss"]
                }, {
                    name: "Shell",
                    mime: "text/x-sh",
                    mode: "shell",
                    ext: ["sh", "ksh", "bash"],
                    alias: ["bash", "sh", "zsh"],
                    file: /^PKGBUILD$/
                }, {name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"]}, {
                    name: "Slim",
                    mimes: ["text/x-slim", "application/x-slim"],
                    mode: "slim",
                    ext: ["slim"]
                }, {name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"]}, {
                    name: "Smarty",
                    mime: "text/x-smarty",
                    mode: "smarty",
                    ext: ["tpl"]
                }, {name: "Solr", mime: "text/x-solr", mode: "solr"}, {
                    name: "Soy",
                    mime: "text/x-soy",
                    mode: "soy",
                    ext: ["soy"],
                    alias: ["closure template"]
                }, {
                    name: "SPARQL",
                    mime: "application/sparql-query",
                    mode: "sparql",
                    ext: ["rq", "sparql"],
                    alias: ["sparul"]
                }, {
                    name: "Spreadsheet",
                    mime: "text/x-spreadsheet",
                    mode: "spreadsheet",
                    alias: ["excel", "formula"]
                }, {name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"]}, {
                    name: "Squirrel",
                    mime: "text/x-squirrel",
                    mode: "clike",
                    ext: ["nut"]
                }, {name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"]}, {
                    name: "sTeX",
                    mime: "text/x-stex",
                    mode: "stex"
                }, {
                    name: "LaTeX",
                    mime: "text/x-latex",
                    mode: "stex",
                    ext: ["text", "ltx"],
                    alias: ["tex"]
                }, {name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v"]}, {
                    name: "Tcl",
                    mime: "text/x-tcl",
                    mode: "tcl",
                    ext: ["tcl"]
                }, {name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"]}, {
                    name: "TiddlyWiki ",
                    mime: "text/x-tiddlywiki",
                    mode: "tiddlywiki"
                }, {name: "Tiki wiki", mime: "text/tiki", mode: "tiki"}, {
                    name: "TOML",
                    mime: "text/x-toml",
                    mode: "toml",
                    ext: ["toml"]
                }, {name: "Tornado", mime: "text/x-tornado", mode: "tornado"}, {
                    name: "troff",
                    mime: "text/troff",
                    mode: "troff",
                    ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"]
                }, {
                    name: "TTCN",
                    mime: "text/x-ttcn",
                    mode: "ttcn",
                    ext: ["ttcn", "ttcn3", "ttcnpp"]
                }, {name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"]}, {
                    name: "Turtle",
                    mime: "text/turtle",
                    mode: "turtle",
                    ext: ["ttl"]
                }, {
                    name: "TypeScript",
                    mime: "application/typescript",
                    mode: "javascript",
                    ext: ["ts"],
                    alias: ["ts"]
                }, {name: "Twig", mime: "text/x-twig", mode: "twig"}, {
                    name: "Web IDL",
                    mime: "text/x-webidl",
                    mode: "webidl",
                    ext: ["webidl"]
                }, {name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"]}, {
                    name: "VBScript",
                    mime: "text/vbscript",
                    mode: "vbscript",
                    ext: ["vbs"]
                }, {name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"]}, {
                    name: "Verilog",
                    mime: "text/x-verilog",
                    mode: "verilog",
                    ext: ["v"]
                }, {name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"]}, {
                    name: "XML",
                    mimes: ["application/xml", "text/xml"],
                    mode: "xml",
                    ext: ["xml", "xsl", "xsd"],
                    alias: ["rss", "wsdl", "xsd"]
                }, {name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"]}, {
                    name: "Yacas",
                    mime: "text/x-yacas",
                    mode: "yacas",
                    ext: ["ys"]
                }, {
                    name: "YAML",
                    mime: "text/x-yaml",
                    mode: "yaml",
                    ext: ["yaml", "yml"],
                    alias: ["yml"]
                }, {name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"]}, {
                    name: "mscgen",
                    mime: "text/x-mscgen",
                    mode: "mscgen",
                    ext: ["mscgen", "mscin", "msc"]
                }, {name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"]}, {
                    name: "msgenny",
                    mime: "text/x-msgenny",
                    mode: "mscgen",
                    ext: ["msgenny"]
                }];
                for (var t = 0; t < e.modeInfo.length; t++) {
                    var n = e.modeInfo[t];
                    n.mimes && (n.mime = n.mimes[0])
                }
                e.findModeByMIME = function (t) {
                    t = t.toLowerCase();
                    for (var n = 0; n < e.modeInfo.length; n++) {
                        var r = e.modeInfo[n];
                        if (r.mime == t)return r;
                        if (r.mimes)for (var i = 0; i < r.mimes.length; i++)if (r.mimes[i] == t)return r
                    }
                }, e.findModeByExtension = function (t) {
                    for (var n = 0; n < e.modeInfo.length; n++) {
                        var r = e.modeInfo[n];
                        if (r.ext)for (var i = 0; i < r.ext.length; i++)if (r.ext[i] == t)return r
                    }
                }, e.findModeByFileName = function (t) {
                    for (var n = 0; n < e.modeInfo.length; n++) {
                        var r = e.modeInfo[n];
                        if (r.file && r.file.test(t))return r
                    }
                    var i = t.lastIndexOf("."), o = i > -1 && t.substring(i + 1, t.length);
                    return o ? e.findModeByExtension(o) : void 0
                }, e.findModeByName = function (t) {
                    t = t.toLowerCase();
                    for (var n = 0; n < e.modeInfo.length; n++) {
                        var r = e.modeInfo[n];
                        if (r.name.toLowerCase() == t)return r;
                        if (r.alias)for (var i = 0; i < r.alias.length; i++)if (r.alias[i].toLowerCase() == t)return r
                    }
                }
            })
        }, {"../lib/codemirror": 10}],
        14: [function (t, n, r) {
            !function (i) {
                "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror"], i) : i(CodeMirror)
            }(function (e) {
                "use strict";
                var t = {
                    autoSelfClosers: {
                        area: !0,
                        base: !0,
                        br: !0,
                        col: !0,
                        command: !0,
                        embed: !0,
                        frame: !0,
                        hr: !0,
                        img: !0,
                        input: !0,
                        keygen: !0,
                        link: !0,
                        meta: !0,
                        param: !0,
                        source: !0,
                        track: !0,
                        wbr: !0,
                        menuitem: !0
                    },
                    implicitlyClosed: {
                        dd: !0,
                        li: !0,
                        optgroup: !0,
                        option: !0,
                        p: !0,
                        rp: !0,
                        rt: !0,
                        tbody: !0,
                        td: !0,
                        tfoot: !0,
                        th: !0,
                        tr: !0
                    },
                    contextGrabbers: {
                        dd: {dd: !0, dt: !0},
                        dt: {dd: !0, dt: !0},
                        li: {li: !0},
                        option: {option: !0, optgroup: !0},
                        optgroup: {optgroup: !0},
                        p: {
                            address: !0,
                            article: !0,
                            aside: !0,
                            blockquote: !0,
                            dir: !0,
                            div: !0,
                            dl: !0,
                            fieldset: !0,
                            footer: !0,
                            form: !0,
                            h1: !0,
                            h2: !0,
                            h3: !0,
                            h4: !0,
                            h5: !0,
                            h6: !0,
                            header: !0,
                            hgroup: !0,
                            hr: !0,
                            menu: !0,
                            nav: !0,
                            ol: !0,
                            p: !0,
                            pre: !0,
                            section: !0,
                            table: !0,
                            ul: !0
                        },
                        rp: {rp: !0, rt: !0},
                        rt: {rp: !0, rt: !0},
                        tbody: {tbody: !0, tfoot: !0},
                        td: {td: !0, th: !0},
                        tfoot: {tbody: !0},
                        th: {td: !0, th: !0},
                        thead: {tbody: !0, tfoot: !0},
                        tr: {tr: !0}
                    },
                    doNotIndent: {pre: !0},
                    allowUnquoted: !0,
                    allowMissing: !0,
                    caseFold: !0
                }, n = {
                    autoSelfClosers: {},
                    implicitlyClosed: {},
                    contextGrabbers: {},
                    doNotIndent: {},
                    allowUnquoted: !1,
                    allowMissing: !1,
                    caseFold: !1
                };
                e.defineMode("xml", function (r, i) {
                    function o(e, t) {
                        function n(n) {
                            return t.tokenize = n, n(e, t)
                        }

                        var r = e.next();
                        if ("<" == r)return e.eat("!") ? e.eat("[") ? e.match("CDATA[") ? n(s("atom", "]]>")) : null : e.match("--") ? n(s("comment", "-->")) : e.match("DOCTYPE", !0, !0) ? (e.eatWhile(/[\w\._\-]/), n(c(1))) : null : e.eat("?") ? (e.eatWhile(/[\w\._\-]/), t.tokenize = s("meta", "?>"), "meta") : (T = e.eat("/") ? "closeTag" : "openTag", t.tokenize = a, "tag bracket");
                        if ("&" == r) {
                            var i;
                            return i = e.eat("#") ? e.eat("x") ? e.eatWhile(/[a-fA-F\d]/) && e.eat(";") : e.eatWhile(/[\d]/) && e.eat(";") : e.eatWhile(/[\w\.\-:]/) && e.eat(";"), i ? "atom" : "error"
                        }
                        return e.eatWhile(/[^&<]/), null
                    }

                    function a(e, t) {
                        var n = e.next();
                        if (">" == n || "/" == n && e.eat(">"))return t.tokenize = o, T = ">" == n ? "endTag" : "selfcloseTag", "tag bracket";
                        if ("=" == n)return T = "equals", null;
                        if ("<" == n) {
                            t.tokenize = o, t.state = d, t.tagName = t.tagStart = null;
                            var r = t.tokenize(e, t);
                            return r ? r + " tag error" : "tag error"
                        }
                        return /[\'\"]/.test(n) ? (t.tokenize = l(n), t.stringStartCol = e.column(), t.tokenize(e, t)) : (e.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/), "word")
                    }

                    function l(e) {
                        var t = function (t, n) {
                            for (; !t.eol();)if (t.next() == e) {
                                n.tokenize = a;
                                break
                            }
                            return "string"
                        };
                        return t.isInAttribute = !0, t
                    }

                    function s(e, t) {
                        return function (n, r) {
                            for (; !n.eol();) {
                                if (n.match(t)) {
                                    r.tokenize = o;
                                    break
                                }
                                n.next()
                            }
                            return e
                        }
                    }

                    function c(e) {
                        return function (t, n) {
                            for (var r; null != (r = t.next());) {
                                if ("<" == r)return n.tokenize = c(e + 1), n.tokenize(t, n);
                                if (">" == r) {
                                    if (1 == e) {
                                        n.tokenize = o;
                                        break
                                    }
                                    return n.tokenize = c(e - 1), n.tokenize(t, n)
                                }
                            }
                            return "meta"
                        }
                    }

                    function u(e, t, n) {
                        this.prev = e.context, this.tagName = t, this.indent = e.indented, this.startOfLine = n, (S.doNotIndent.hasOwnProperty(t) || e.context && e.context.noIndent) && (this.noIndent = !0)
                    }

                    function f(e) {
                        e.context && (e.context = e.context.prev)
                    }

                    function h(e, t) {
                        for (var n; ;) {
                            if (!e.context)return;
                            if (n = e.context.tagName, !S.contextGrabbers.hasOwnProperty(n) || !S.contextGrabbers[n].hasOwnProperty(t))return;
                            f(e)
                        }
                    }

                    function d(e, t, n) {
                        return "openTag" == e ? (n.tagStart = t.column(), p) : "closeTag" == e ? m : d
                    }

                    function p(e, t, n) {
                        return "word" == e ? (n.tagName = t.current(), M = "tag", y) : (M = "error", p)
                    }

                    function m(e, t, n) {
                        if ("word" == e) {
                            var r = t.current();
                            return n.context && n.context.tagName != r && S.implicitlyClosed.hasOwnProperty(n.context.tagName) && f(n), n.context && n.context.tagName == r || S.matchClosing === !1 ? (M = "tag", g) : (M = "tag error", v)
                        }
                        return M = "error", v
                    }

                    function g(e, t, n) {
                        return "endTag" != e ? (M = "error", g) : (f(n), d)
                    }

                    function v(e, t, n) {
                        return M = "error", g(e, t, n)
                    }

                    function y(e, t, n) {
                        if ("word" == e)return M = "attribute", x;
                        if ("endTag" == e || "selfcloseTag" == e) {
                            var r = n.tagName, i = n.tagStart;
                            return n.tagName = n.tagStart = null, "selfcloseTag" == e || S.autoSelfClosers.hasOwnProperty(r) ? h(n, r) : (h(n, r), n.context = new u(n, r, i == n.indented)), d
                        }
                        return M = "error", y
                    }

                    function x(e, t, n) {
                        return "equals" == e ? b : (S.allowMissing || (M = "error"), y(e, t, n))
                    }

                    function b(e, t, n) {
                        return "string" == e ? w : "word" == e && S.allowUnquoted ? (M = "string", y) : (M = "error", y(e, t, n))
                    }

                    function w(e, t, n) {
                        return "string" == e ? w : y(e, t, n)
                    }

                    var k = r.indentUnit, S = {}, C = i.htmlMode ? t : n;
                    for (var L in C)S[L] = C[L];
                    for (var L in i)S[L] = i[L];
                    var T, M;
                    return o.isInText = !0, {
                        startState: function (e) {
                            var t = {
                                tokenize: o,
                                state: d,
                                indented: e || 0,
                                tagName: null,
                                tagStart: null,
                                context: null
                            };
                            return null != e && (t.baseIndent = e), t
                        },
                        token: function (e, t) {
                            if (!t.tagName && e.sol() && (t.indented = e.indentation()), e.eatSpace())return null;
                            T = null;
                            var n = t.tokenize(e, t);
                            return (n || T) && "comment" != n && (M = null, t.state = t.state(T || n, e, t), M && (n = "error" == M ? n + " error" : M)), n
                        },
                        indent: function (t, n, r) {
                            var i = t.context;
                            if (t.tokenize.isInAttribute)return t.tagStart == t.indented ? t.stringStartCol + 1 : t.indented + k;
                            if (i && i.noIndent)return e.Pass;
                            if (t.tokenize != a && t.tokenize != o)return r ? r.match(/^(\s*)/)[0].length : 0;
                            if (t.tagName)return S.multilineTagIndentPastTag !== !1 ? t.tagStart + t.tagName.length + 2 : t.tagStart + k * (S.multilineTagIndentFactor || 1);
                            if (S.alignCDATA && /<!\[CDATA\[/.test(n))return 0;
                            var l = n && /^<(\/)?([\w_:\.-]*)/.exec(n);
                            if (l && l[1])for (; i;) {
                                if (i.tagName == l[2]) {
                                    i = i.prev;
                                    break
                                }
                                if (!S.implicitlyClosed.hasOwnProperty(i.tagName))break;
                                i = i.prev
                            } else if (l)for (; i;) {
                                var s = S.contextGrabbers[i.tagName];
                                if (!s || !s.hasOwnProperty(l[2]))break;
                                i = i.prev
                            }
                            for (; i && i.prev && !i.startOfLine;)i = i.prev;
                            return i ? i.indent + k : t.baseIndent || 0
                        },
                        electricInput: /<\/[\s\w:]+>$/,
                        blockCommentStart: "<!--",
                        blockCommentEnd: "-->",
                        configuration: S.htmlMode ? "html" : "xml",
                        helperType: S.htmlMode ? "html" : "xml",
                        skipAttribute: function (e) {
                            e.state == b && (e.state = y)
                        }
                    }
                }), e.defineMIME("text/xml", "xml"), e.defineMIME("application/xml", "xml"), e.mimeModes.hasOwnProperty("text/html") || e.defineMIME("text/html", {
                    name: "xml",
                    htmlMode: !0
                })
            })
        }, {"../../lib/codemirror": 10}],
        15: [function (e, t, n) {
            n.read = function (e, t, n, r, i) {
                var o, a, l = 8 * i - r - 1, s = (1 << l) - 1, c = s >> 1, u = -7, f = n ? i - 1 : 0, h = n ? -1 : 1,
                    d = e[t + f];
                for (f += h, o = d & (1 << -u) - 1, d >>= -u, u += l; u > 0; o = 256 * o + e[t + f], f += h, u -= 8);
                for (a = o & (1 << -u) - 1, o >>= -u, u += r; u > 0; a = 256 * a + e[t + f], f += h, u -= 8);
                if (0 === o) o = 1 - c; else {
                    if (o === s)return a ? NaN : (d ? -1 : 1) * (1 / 0);
                    a += Math.pow(2, r), o -= c
                }
                return (d ? -1 : 1) * a * Math.pow(2, o - r)
            }, n.write = function (e, t, n, r, i, o) {
                var a, l, s, c = 8 * o - i - 1, u = (1 << c) - 1, f = u >> 1,
                    h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : o - 1, p = r ? 1 : -1,
                    m = 0 > t || 0 === t && 0 > 1 / t ? 1 : 0;
                for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (l = isNaN(t) ? 1 : 0, a = u) : (a = Math.floor(Math.log(t) / Math.LN2), t * (s = Math.pow(2, -a)) < 1 && (a--, s *= 2), t += a + f >= 1 ? h / s : h * Math.pow(2, 1 - f), t * s >= 2 && (a++, s /= 2), a + f >= u ? (l = 0, a = u) : a + f >= 1 ? (l = (t * s - 1) * Math.pow(2, i), a += f) : (l = t * Math.pow(2, f - 1) * Math.pow(2, i), a = 0)); i >= 8; e[n + d] = 255 & l, d += p, l /= 256, i -= 8);
                for (a = a << i | l, c += i; c > 0; e[n + d] = 255 & a, d += p, a /= 256, c -= 8);
                e[n + d - p] |= 128 * m
            }
        }, {}],
        16: [function (e, t, n) {
            var r = {}.toString;
            t.exports = Array.isArray || function (e) {
                    return "[object Array]" == r.call(e)
                }
        }, {}],
        17: [function (t, n, r) {
            (function (t) {
                (function () {
                    function t(e) {
                        this.tokens = [], this.tokens.links = {}, this.options = e || h.defaults, this.rules = d.normal, this.options.gfm && (this.options.tables ? this.rules = d.tables : this.rules = d.gfm)
                    }

                    function i(e, t) {
                        if (this.options = t || h.defaults, this.links = e, this.rules = p.normal, this.renderer = this.options.renderer || new o, this.renderer.options = this.options, !this.links)throw new Error("Tokens array requires a `links` property.");
                        this.options.gfm ? this.options.breaks ? this.rules = p.breaks : this.rules = p.gfm : this.options.pedantic && (this.rules = p.pedantic)
                    }

                    function o(e) {
                        this.options = e || {}
                    }

                    function a(e) {
                        this.tokens = [], this.token = null, this.options = e || h.defaults, this.options.renderer = this.options.renderer || new o, this.renderer = this.options.renderer, this.renderer.options = this.options
                    }

                    function l(e, t) {
                        return e.replace(t ? /&/g : /&(?!#?\w+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;")
                    }

                    function s(e) {
                        return e.replace(/&([#\w]+);/g, function (e, t) {
                            return t = t.toLowerCase(), "colon" === t ? ":" : "#" === t.charAt(0) ? "x" === t.charAt(1) ? String.fromCharCode(parseInt(t.substring(2), 16)) : String.fromCharCode(+t.substring(1)) : ""
                        })
                    }

                    function c(e, t) {
                        return e = e.source, t = t || "", function n(r, i) {
                            return r ? (i = i.source || i, i = i.replace(/(^|[^\[])\^/g, "$1"), e = e.replace(r, i), n) : new RegExp(e, t)
                        }
                    }

                    function u() {
                    }

                    function f(e) {
                        for (var t, n, r = 1; r < arguments.length; r++) {
                            t = arguments[r];
                            for (n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
                        }
                        return e
                    }

                    function h(e, n, r) {
                        if (r || "function" == typeof n) {
                            r || (r = n, n = null), n = f({}, h.defaults, n || {});
                            var i, o, s = n.highlight, c = 0;
                            try {
                                i = t.lex(e, n)
                            } catch (u) {
                                return r(u)
                            }
                            o = i.length;
                            var d = function (e) {
                                if (e)return n.highlight = s, r(e);
                                var t;
                                try {
                                    t = a.parse(i, n)
                                } catch (o) {
                                    e = o
                                }
                                return n.highlight = s, e ? r(e) : r(null, t)
                            };
                            if (!s || s.length < 3)return d();
                            if (delete n.highlight, !o)return d();
                            for (; c < i.length; c++)!function (e) {
                                return "code" !== e.type ? --o || d() : s(e.text, e.lang, function (t, n) {
                                    return t ? d(t) : null == n || n === e.text ? --o || d() : (e.text = n, e.escaped = !0, void(--o || d()))
                                })
                            }(i[c])
                        } else try {
                            return n && (n = f({}, h.defaults, n)), a.parse(t.lex(e, n), n)
                        } catch (u) {
                            if (u.message += "\nPlease report this to https://github.com/chjj/marked.", (n || h.defaults).silent)return "<p>An error occured:</p><pre>" + l(u.message + "", !0) + "</pre>";
                            throw u
                        }
                    }

                    var d = {
                        newline: /^\n+/,
                        code: /^( {4}[^\n]+\n*)+/,
                        fences: u,
                        hr: /^( *[-*_]){3,} *(?:\n+|$)/,
                        heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
                        nptable: u,
                        lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
                        blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
                        list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
                        html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
                        def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
                        table: u,
                        paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
                        text: /^[^\n]+/
                    };
                    d.bullet = /(?:[*+-]|\d+\.)/, d.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/, d.item = c(d.item, "gm")(/bull/g, d.bullet)(), d.list = c(d.list)(/bull/g, d.bullet)("hr", "\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))")("def", "\\n+(?=" + d.def.source + ")")(), d.blockquote = c(d.blockquote)("def", d.def)(), d._tag = "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b", d.html = c(d.html)("comment", /<!--[\s\S]*?-->/)("closed", /<(tag)[\s\S]+?<\/\1>/)("closing", /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g, d._tag)(), d.paragraph = c(d.paragraph)("hr", d.hr)("heading", d.heading)("lheading", d.lheading)("blockquote", d.blockquote)("tag", "<" + d._tag)("def", d.def)(), d.normal = f({}, d), d.gfm = f({}, d.normal, {
                        fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
                        paragraph: /^/,
                        heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
                    }), d.gfm.paragraph = c(d.paragraph)("(?!", "(?!" + d.gfm.fences.source.replace("\\1", "\\2") + "|" + d.list.source.replace("\\1", "\\3") + "|")(), d.tables = f({}, d.gfm, {
                        nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
                        table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
                    }), t.rules = d, t.lex = function (e, n) {
                        var r = new t(n);
                        return r.lex(e)
                    }, t.prototype.lex = function (e) {
                        return e = e.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ").replace(/\u00a0/g, " ").replace(/\u2424/g, "\n"), this.token(e, !0)
                    }, t.prototype.token = function (e, t, n) {
                        for (var r, i, o, a, l, s, c, u, f,
                                 e = e.replace(/^ +$/gm, ""); e;)if ((o = this.rules.newline.exec(e)) && (e = e.substring(o[0].length), o[0].length > 1 && this.tokens.push({type: "space"})), o = this.rules.code.exec(e)) e = e.substring(o[0].length), o = o[0].replace(/^ {4}/gm, ""), this.tokens.push({
                            type: "code",
                            text: this.options.pedantic ? o : o.replace(/\n+$/, "")
                        }); else if (o = this.rules.fences.exec(e)) e = e.substring(o[0].length), this.tokens.push({
                            type: "code",
                            lang: o[2],
                            text: o[3] || ""
                        }); else if (o = this.rules.heading.exec(e)) e = e.substring(o[0].length), this.tokens.push({
                            type: "heading",
                            depth: o[1].length,
                            text: o[2]
                        }); else if (t && (o = this.rules.nptable.exec(e))) {
                            for (e = e.substring(o[0].length), s = {
                                type: "table",
                                header: o[1].replace(/^ *| *\| *$/g, "").split(/ *\| */),
                                align: o[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
                                cells: o[3].replace(/\n$/, "").split("\n")
                            }, u = 0; u < s.align.length; u++)/^ *-+: *$/.test(s.align[u]) ? s.align[u] = "right" : /^ *:-+: *$/.test(s.align[u]) ? s.align[u] = "center" : /^ *:-+ *$/.test(s.align[u]) ? s.align[u] = "left" : s.align[u] = null;
                            for (u = 0; u < s.cells.length; u++)s.cells[u] = s.cells[u].split(/ *\| */);
                            this.tokens.push(s)
                        } else if (o = this.rules.lheading.exec(e)) e = e.substring(o[0].length), this.tokens.push({
                            type: "heading",
                            depth: "=" === o[2] ? 1 : 2,
                            text: o[1]
                        }); else if (o = this.rules.hr.exec(e)) e = e.substring(o[0].length), this.tokens.push({type: "hr"}); else if (o = this.rules.blockquote.exec(e)) e = e.substring(o[0].length), this.tokens.push({type: "blockquote_start"}), o = o[0].replace(/^ *> ?/gm, ""), this.token(o, t, !0), this.tokens.push({type: "blockquote_end"}); else if (o = this.rules.list.exec(e)) {
                            for (e = e.substring(o[0].length), a = o[2], this.tokens.push({
                                type: "list_start",
                                ordered: a.length > 1
                            }), o = o[0].match(this.rules.item), r = !1, f = o.length, u = 0; f > u; u++)s = o[u], c = s.length, s = s.replace(/^ *([*+-]|\d+\.) +/, ""), ~s.indexOf("\n ") && (c -= s.length, s = this.options.pedantic ? s.replace(/^ {1,4}/gm, "") : s.replace(new RegExp("^ {1," + c + "}", "gm"), "")), this.options.smartLists && u !== f - 1 && (l = d.bullet.exec(o[u + 1])[0], a === l || a.length > 1 && l.length > 1 || (e = o.slice(u + 1).join("\n") + e, u = f - 1)), i = r || /\n\n(?!\s*$)/.test(s), u !== f - 1 && (r = "\n" === s.charAt(s.length - 1), i || (i = r)), this.tokens.push({type: i ? "loose_item_start" : "list_item_start"}), this.token(s, !1, n), this.tokens.push({type: "list_item_end"});
                            this.tokens.push({type: "list_end"})
                        } else if (o = this.rules.html.exec(e)) e = e.substring(o[0].length), this.tokens.push({
                            type: this.options.sanitize ? "paragraph" : "html",
                            pre: !this.options.sanitizer && ("pre" === o[1] || "script" === o[1] || "style" === o[1]),
                            text: o[0]
                        }); else if (!n && t && (o = this.rules.def.exec(e))) e = e.substring(o[0].length), this.tokens.links[o[1].toLowerCase()] = {
                            href: o[2],
                            title: o[3]
                        }; else if (t && (o = this.rules.table.exec(e))) {
                            for (e = e.substring(o[0].length), s = {
                                type: "table",
                                header: o[1].replace(/^ *| *\| *$/g, "").split(/ *\| */),
                                align: o[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
                                cells: o[3].replace(/(?: *\| *)?\n$/, "").split("\n")
                            }, u = 0; u < s.align.length; u++)/^ *-+: *$/.test(s.align[u]) ? s.align[u] = "right" : /^ *:-+: *$/.test(s.align[u]) ? s.align[u] = "center" : /^ *:-+ *$/.test(s.align[u]) ? s.align[u] = "left" : s.align[u] = null;
                            for (u = 0; u < s.cells.length; u++)s.cells[u] = s.cells[u].replace(/^ *\| *| *\| *$/g, "").split(/ *\| */);
                            this.tokens.push(s)
                        } else if (t && (o = this.rules.paragraph.exec(e))) e = e.substring(o[0].length), this.tokens.push({
                            type: "paragraph",
                            text: "\n" === o[1].charAt(o[1].length - 1) ? o[1].slice(0, -1) : o[1]
                        }); else if (o = this.rules.text.exec(e)) e = e.substring(o[0].length), this.tokens.push({
                            type: "text",
                            text: o[0]
                        }); else if (e)throw new Error("Infinite loop on byte: " + e.charCodeAt(0));
                        return this.tokens
                    };
                    var p = {
                        escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
                        autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
                        url: u,
                        tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
                        link: /^!?\[(inside)\]\(href\)/,
                        reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
                        nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
                        strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
                        em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
                        code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
                        br: /^ {2,}\n(?!\s*$)/,
                        del: u,
                        text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
                    };
                    p._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/, p._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/, p.link = c(p.link)("inside", p._inside)("href", p._href)(), p.reflink = c(p.reflink)("inside", p._inside)(), p.normal = f({}, p), p.pedantic = f({}, p.normal, {
                        strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
                        em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
                    }), p.gfm = f({}, p.normal, {
                        escape: c(p.escape)("])", "~|])")(),
                        url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
                        del: /^~~(?=\S)([\s\S]*?\S)~~/,
                        text: c(p.text)("]|", "~]|")("|", "|https?://|")()
                    }), p.breaks = f({}, p.gfm, {
                        br: c(p.br)("{2,}", "*")(),
                        text: c(p.gfm.text)("{2,}", "*")()
                    }), i.rules = p, i.output = function (e, t, n) {
                        var r = new i(t, n);
                        return r.output(e)
                    }, i.prototype.output = function (e) {
                        for (var t, n, r, i,
                                 o = ""; e;)if (i = this.rules.escape.exec(e)) e = e.substring(i[0].length), o += i[1]; else if (i = this.rules.autolink.exec(e)) e = e.substring(i[0].length), "@" === i[2] ? (n = ":" === i[1].charAt(6) ? this.mangle(i[1].substring(7)) : this.mangle(i[1]), r = this.mangle("mailto:") + n) : (n = l(i[1]), r = n), o += this.renderer.link(r, null, n); else if (this.inLink || !(i = this.rules.url.exec(e))) {
                            if (i = this.rules.tag.exec(e)) !this.inLink && /^<a /i.test(i[0]) ? this.inLink = !0 : this.inLink && /^<\/a>/i.test(i[0]) && (this.inLink = !1), e = e.substring(i[0].length), o += this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(i[0]) : l(i[0]) : i[0]; else if (i = this.rules.link.exec(e)) e = e.substring(i[0].length), this.inLink = !0, o += this.outputLink(i, {
                                href: i[2],
                                title: i[3]
                            }), this.inLink = !1; else if ((i = this.rules.reflink.exec(e)) || (i = this.rules.nolink.exec(e))) {
                                if (e = e.substring(i[0].length), t = (i[2] || i[1]).replace(/\s+/g, " "), t = this.links[t.toLowerCase()], !t || !t.href) {
                                    o += i[0].charAt(0), e = i[0].substring(1) + e;
                                    continue
                                }
                                this.inLink = !0, o += this.outputLink(i, t), this.inLink = !1
                            } else if (i = this.rules.strong.exec(e)) e = e.substring(i[0].length), o += this.renderer.strong(this.output(i[2] || i[1])); else if (i = this.rules.em.exec(e)) e = e.substring(i[0].length), o += this.renderer.em(this.output(i[2] || i[1])); else if (i = this.rules.code.exec(e)) e = e.substring(i[0].length), o += this.renderer.codespan(l(i[2], !0)); else if (i = this.rules.br.exec(e)) e = e.substring(i[0].length), o += this.renderer.br(); else if (i = this.rules.del.exec(e)) e = e.substring(i[0].length), o += this.renderer.del(this.output(i[1])); else if (i = this.rules.text.exec(e)) e = e.substring(i[0].length), o += this.renderer.text(l(this.smartypants(i[0]))); else if (e)throw new Error("Infinite loop on byte: " + e.charCodeAt(0))
                        } else e = e.substring(i[0].length), n = l(i[1]), r = n, o += this.renderer.link(r, null, n);
                        return o
                    }, i.prototype.outputLink = function (e, t) {
                        var n = l(t.href), r = t.title ? l(t.title) : null;
                        return "!" !== e[0].charAt(0) ? this.renderer.link(n, r, this.output(e[1])) : this.renderer.image(n, r, l(e[1]))
                    }, i.prototype.smartypants = function (e) {
                        return this.options.smartypants ? e.replace(/---/g, "").replace(/--/g, "").replace(/(^|[-\u2014\/(\[{"\s])'/g, "$1").replace(/'/g, "").replace(/(^|[-\u2014\/(\[{\u2018\s])"/g, "$1").replace(/"/g, "").replace(/\.{3}/g, "") : e
                    }, i.prototype.mangle = function (e) {
                        if (!this.options.mangle)return e;
                        for (var t, n = "", r = e.length,
                                 i = 0; r > i; i++)t = e.charCodeAt(i), Math.random() > .5 && (t = "x" + t.toString(16)), n += "&#" + t + ";";
                        return n
                    }, o.prototype.code = function (e, t, n) {
                        if (this.options.highlight) {
                            var r = this.options.highlight(e, t);
                            null != r && r !== e && (n = !0, e = r)
                        }
                        return t ? '<pre><code class="' + this.options.langPrefix + l(t, !0) + '">' + (n ? e : l(e, !0)) + "\n</code></pre>\n" : "<pre><code>" + (n ? e : l(e, !0)) + "\n</code></pre>"
                    }, o.prototype.blockquote = function (e) {
                        return "<blockquote>\n" + e + "</blockquote>\n"
                    }, o.prototype.html = function (e) {
                        return e
                    }, o.prototype.heading = function (e, t, n) {
                        return "<h" + t + ' id="' + this.options.headerPrefix + n.toLowerCase().replace(/[^\w]+/g, "-") + '">' + e + "</h" + t + ">\n"
                    }, o.prototype.hr = function () {
                        return this.options.xhtml ? "<hr/>\n" : "<hr>\n"
                    }, o.prototype.list = function (e, t) {
                        var n = t ? "ol" : "ul";
                        return "<" + n + ">\n" + e + "</" + n + ">\n"
                    }, o.prototype.listitem = function (e) {
                        return "<li>" + e + "</li>\n"
                    }, o.prototype.paragraph = function (e) {
                        return "<p>" + e + "</p>\n"
                    }, o.prototype.table = function (e, t) {
                        return "<table>\n<thead>\n" + e + "</thead>\n<tbody>\n" + t + "</tbody>\n</table>\n"
                    }, o.prototype.tablerow = function (e) {
                        return "<tr>\n" + e + "</tr>\n"
                    }, o.prototype.tablecell = function (e, t) {
                        var n = t.header ? "th" : "td",
                            r = t.align ? "<" + n + ' style="text-align:' + t.align + '">' : "<" + n + ">";
                        return r + e + "</" + n + ">\n"
                    }, o.prototype.strong = function (e) {
                        return "<strong>" + e + "</strong>"
                    }, o.prototype.em = function (e) {
                        return "<em>" + e + "</em>"
                    }, o.prototype.codespan = function (e) {
                        return "<code>" + e + "</code>"
                    }, o.prototype.br = function () {
                        return this.options.xhtml ? "<br/>" : "<br>"
                    }, o.prototype.del = function (e) {
                        return "<del>" + e + "</del>"
                    }, o.prototype.link = function (e, t, n) {
                        if (this.options.sanitize) {
                            try {
                                var r = decodeURIComponent(s(e)).replace(/[^\w:]/g, "").toLowerCase()
                            } catch (i) {
                                return ""
                            }
                            if (0 === r.indexOf("javascript:") || 0 === r.indexOf("vbscript:"))return ""
                        }
                        var o = '<a href="' + e + '"';
                        return t && (o += ' title="' + t + '"'), o += ">" + n + "</a>"
                    }, o.prototype.image = function (e, t, n) {
                        var r = '<img src="' + e + '" alt="' + n + '"';
                        return t && (r += ' title="' + t + '"'), r += this.options.xhtml ? "/>" : ">"
                    }, o.prototype.text = function (e) {
                        return e
                    }, a.parse = function (e, t, n) {
                        var r = new a(t, n);
                        return r.parse(e)
                    }, a.prototype.parse = function (e) {
                        this.inline = new i(e.links, this.options, this.renderer), this.tokens = e.reverse();
                        for (var t = ""; this.next();)t += this.tok();
                        return t
                    }, a.prototype.next = function () {
                        return this.token = this.tokens.pop()
                    }, a.prototype.peek = function () {
                        return this.tokens[this.tokens.length - 1] || 0
                    }, a.prototype.parseText = function () {
                        for (var e = this.token.text; "text" === this.peek().type;)e += "\n" + this.next().text;
                        return this.inline.output(e)
                    }, a.prototype.tok = function () {
                        switch (this.token.type) {
                            case"space":
                                return "";
                            case"hr":
                                return this.renderer.hr();
                            case"heading":
                                return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, this.token.text);
                            case"code":
                                return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
                            case"table":
                                var e, t, n, r, i, o = "", a = "";
                                for (n = "", e = 0; e < this.token.header.length; e++)r = {
                                    header: !0,
                                    align: this.token.align[e]
                                }, n += this.renderer.tablecell(this.inline.output(this.token.header[e]), {
                                    header: !0,
                                    align: this.token.align[e]
                                });
                                for (o += this.renderer.tablerow(n), e = 0; e < this.token.cells.length; e++) {
                                    for (t = this.token.cells[e], n = "", i = 0; i < t.length; i++)n += this.renderer.tablecell(this.inline.output(t[i]), {
                                        header: !1,
                                        align: this.token.align[i]
                                    });
                                    a += this.renderer.tablerow(n)
                                }
                                return this.renderer.table(o, a);
                            case"blockquote_start":
                                for (var a = ""; "blockquote_end" !== this.next().type;)a += this.tok();
                                return this.renderer.blockquote(a);
                            case"list_start":
                                for (var a = "",
                                         l = this.token.ordered; "list_end" !== this.next().type;)a += this.tok();
                                return this.renderer.list(a, l);
                            case"list_item_start":
                                for (var a = ""; "list_item_end" !== this.next().type;)a += "text" === this.token.type ? this.parseText() : this.tok();
                                return this.renderer.listitem(a);
                            case"loose_item_start":
                                for (var a = ""; "list_item_end" !== this.next().type;)a += this.tok();
                                return this.renderer.listitem(a);
                            case"html":
                                var s = this.token.pre || this.options.pedantic ? this.token.text : this.inline.output(this.token.text);
                                return this.renderer.html(s);
                            case"paragraph":
                                return this.renderer.paragraph(this.inline.output(this.token.text));
                            case"text":
                                return this.renderer.paragraph(this.parseText())
                        }
                    }, u.exec = u, h.options = h.setOptions = function (e) {
                        return f(h.defaults, e), h
                    }, h.defaults = {
                        gfm: !0,
                        tables: !0,
                        breaks: !1,
                        pedantic: !1,
                        sanitize: !1,
                        sanitizer: null,
                        mangle: !0,
                        smartLists: !1,
                        silent: !1,
                        highlight: null,
                        langPrefix: "lang-",
                        smartypants: !1,
                        headerPrefix: "",
                        renderer: new o,
                        xhtml: !1
                    }, h.Parser = a, h.parser = a.parse, h.Renderer = o, h.Lexer = t, h.lexer = t.lex, h.InlineLexer = i, h.inlineLexer = i.output, h.parse = h, "undefined" != typeof n && "object" == typeof r ? n.exports = h : "function" == typeof e && e.amd ? e(function () {
                        return h
                    }) : this.marked = h
                }).call(function () {
                    return this || ("undefined" != typeof window ? window : t)
                }())
            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
        }, {}],
        18: [function (e, t, n) {
            (function (n, r) {
                "use strict";
                var i = function (e, t, n, i) {
                    if (i = i || {}, this.dictionary = null, this.rules = {}, this.dictionaryTable = {}, this.compoundRules = [], this.compoundRuleCodes = {}, this.replacementTable = [], this.flags = i.flags || {}, e) {
                        if (this.dictionary = e, "undefined" != typeof window && "chrome" in window && "extension" in window.chrome && "getURL" in window.chrome.extension) t || (t = this._readFile(chrome.extension.getURL("lib/typo/dictionaries/" + e + "/" + e + ".aff"))), n || (n = this._readFile(chrome.extension.getURL("lib/typo/dictionaries/" + e + "/" + e + ".dic"))); else {
                            if (i.dictionaryPath)var o = i.dictionaryPath; else if ("undefined" != typeof r)var o = r + "/dictionaries"; else var o = "./dictionaries";
                            t || (t = this._readFile(o + "/" + e + "/" + e + ".aff")), n || (n = this._readFile(o + "/" + e + "/" + e + ".dic"))
                        }
                        this.rules = this._parseAFF(t), this.compoundRuleCodes = {};
                        for (var a = 0, l = this.compoundRules.length; l > a; a++)for (var s = this.compoundRules[a],
                                                                                           c = 0,
                                                                                           u = s.length; u > c; c++)this.compoundRuleCodes[s[c]] = [];
                        "ONLYINCOMPOUND" in this.flags && (this.compoundRuleCodes[this.flags.ONLYINCOMPOUND] = []), this.dictionaryTable = this._parseDIC(n);
                        for (var a in this.compoundRuleCodes)0 == this.compoundRuleCodes[a].length && delete this.compoundRuleCodes[a];
                        for (var a = 0, l = this.compoundRules.length; l > a; a++) {
                            for (var f = this.compoundRules[a], h = "", c = 0, u = f.length; u > c; c++) {
                                var d = f[c];
                                h += d in this.compoundRuleCodes ? "(" + this.compoundRuleCodes[d].join("|") + ")" : d
                            }
                            this.compoundRules[a] = new RegExp(h, "i")
                        }
                    }
                    return this
                };
                i.prototype = {
                    load: function (e) {
                        for (var t in e)this[t] = e[t];
                        return this
                    }, _readFile: function (t, r) {
                        if (r || (r = "utf8"), "undefined" != typeof XMLHttpRequest) {
                            var i = new XMLHttpRequest;
                            return i.open("GET", t, !1), i.overrideMimeType && i.overrideMimeType("text/plain; charset=" + r), i.send(null), i.responseText
                        }
                        if ("undefined" != typeof e) {
                            var o = e("fs");
                            try {
                                if (o.existsSync(t)) {
                                    var a = o.statSync(t), l = o.openSync(t, "r"), s = new n(a.size);
                                    return o.readSync(l, s, 0, s.length, null), s.toString(r, 0, s.length)
                                }
                                console.log("Path " + t + " does not exist.")
                            } catch (c) {
                                return console.log(c), ""
                            }
                        }
                    }, _parseAFF: function (e) {
                        var t = {};
                        e = this._removeAffixComments(e);
                        for (var n = e.split("\n"), r = 0, i = n.length; i > r; r++) {
                            var o = n[r], a = o.split(/\s+/), l = a[0];
                            if ("PFX" == l || "SFX" == l) {
                                for (var s = a[1], c = a[2], u = parseInt(a[3], 10), f = [], h = r + 1,
                                         d = r + 1 + u; d > h; h++) {
                                    var o = n[h], p = o.split(/\s+/), m = p[2], g = p[3].split("/"), v = g[0];
                                    "0" === v && (v = "");
                                    var y = this.parseRuleCodes(g[1]), x = p[4], b = {};
                                    b.add = v, y.length > 0 && (b.continuationClasses = y), "." !== x && ("SFX" === l ? b.match = new RegExp(x + "$") : b.match = new RegExp("^" + x)), "0" != m && ("SFX" === l ? b.remove = new RegExp(m + "$") : b.remove = m), f.push(b)
                                }
                                t[s] = {type: l, combineable: "Y" == c, entries: f}, r += u
                            } else if ("COMPOUNDRULE" === l) {
                                for (var u = parseInt(a[1], 10), h = r + 1, d = r + 1 + u; d > h; h++) {
                                    var o = n[h], p = o.split(/\s+/);
                                    this.compoundRules.push(p[1])
                                }
                                r += u
                            } else if ("REP" === l) {
                                var p = o.split(/\s+/);
                                3 === p.length && this.replacementTable.push([p[1], p[2]])
                            } else this.flags[l] = a[1]
                        }
                        return t
                    }, _removeAffixComments: function (e) {
                        return e = e.replace(/#.*$/gm, ""), e = e.replace(/^\s\s*/m, "").replace(/\s\s*$/m, ""), e = e.replace(/\n{2,}/g, "\n"), e = e.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
                    }, _parseDIC: function (e) {
                        function t(e, t) {
                            e in r && "object" == typeof r[e] || (r[e] = []), r[e].push(t)
                        }

                        e = this._removeDicComments(e);
                        for (var n = e.split("\n"), r = {}, i = 1, o = n.length; o > i; i++) {
                            var a = n[i], l = a.split("/", 2), s = l[0];
                            if (l.length > 1) {
                                var c = this.parseRuleCodes(l[1]);
                                "NEEDAFFIX" in this.flags && -1 != c.indexOf(this.flags.NEEDAFFIX) || t(s, c);
                                for (var u = 0, f = c.length; f > u; u++) {
                                    var h = c[u], d = this.rules[h];
                                    if (d)for (var p = this._applyRule(s, d), m = 0, g = p.length; g > m; m++) {
                                        var v = p[m];
                                        if (t(v, []), d.combineable)for (var y = u + 1; f > y; y++) {
                                            var x = c[y], b = this.rules[x];
                                            if (b && b.combineable && d.type != b.type)for (var w = this._applyRule(v, b),
                                                                                                k = 0,
                                                                                                S = w.length; S > k; k++) {
                                                var C = w[k];
                                                t(C, [])
                                            }
                                        }
                                    }
                                    h in this.compoundRuleCodes && this.compoundRuleCodes[h].push(s)
                                }
                            } else t(s.trim(), [])
                        }
                        return r
                    }, _removeDicComments: function (e) {
                        return e = e.replace(/^\t.*$/gm, "")
                    }, parseRuleCodes: function (e) {
                        if (!e)return [];
                        if (!("FLAG" in this.flags))return e.split("");
                        if ("long" === this.flags.FLAG) {
                            for (var t = [], n = 0, r = e.length; r > n; n += 2)t.push(e.substr(n, 2));
                            return t
                        }
                        return "num" === this.flags.FLAG ? textCode.split(",") : void 0
                    }, _applyRule: function (e, t) {
                        for (var n = t.entries, r = [], i = 0, o = n.length; o > i; i++) {
                            var a = n[i];
                            if (!a.match || e.match(a.match)) {
                                var l = e;
                                if (a.remove && (l = l.replace(a.remove, "")), "SFX" === t.type ? l += a.add : l = a.add + l, r.push(l), "continuationClasses" in a)for (var s = 0,
                                                                                                                                                                             c = a.continuationClasses.length; c > s; s++) {
                                    var u = this.rules[a.continuationClasses[s]];
                                    u && (r = r.concat(this._applyRule(l, u)))
                                }
                            }
                        }
                        return r
                    }, check: function (e) {
                        var t = e.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
                        if (this.checkExact(t))return !0;
                        if (t.toUpperCase() === t) {
                            var n = t[0] + t.substring(1).toLowerCase();
                            if (this.hasFlag(n, "KEEPCASE"))return !1;
                            if (this.checkExact(n))return !0
                        }
                        var r = t.toLowerCase();
                        if (r !== t) {
                            if (this.hasFlag(r, "KEEPCASE"))return !1;
                            if (this.checkExact(r))return !0
                        }
                        return !1
                    }, checkExact: function (e) {
                        var t = this.dictionaryTable[e];
                        if ("undefined" == typeof t) {
                            if ("COMPOUNDMIN" in this.flags && e.length >= this.flags.COMPOUNDMIN)for (var n = 0,
                                                                                                           r = this.compoundRules.length; r > n; n++)if (e.match(this.compoundRules[n]))return !0;
                            return !1
                        }
                        if ("object" == typeof t) {
                            for (var n = 0,
                                     r = t.length; r > n; n++)if (!this.hasFlag(e, "ONLYINCOMPOUND", t[n]))return !0;
                            return !1
                        }
                    }, hasFlag: function (e, t, n) {
                        if (t in this.flags) {
                            if ("undefined" == typeof n)var n = Array.prototype.concat.apply([], this.dictionaryTable[e]);
                            if (n && -1 !== n.indexOf(this.flags[t]))return !0
                        }
                        return !1
                    }, alphabet: "", suggest: function (e, t) {
                        function n(e) {
                            for (var t = [], n = 0, r = e.length; r > n; n++) {
                                for (var i = e[n], o = [], a = 0,
                                         l = i.length + 1; l > a; a++)o.push([i.substring(0, a), i.substring(a, i.length)]);
                                for (var s = [], a = 0, l = o.length; l > a; a++) {
                                    var u = o[a];
                                    u[1] && s.push(u[0] + u[1].substring(1))
                                }
                                for (var f = [], a = 0, l = o.length; l > a; a++) {
                                    var u = o[a];
                                    u[1].length > 1 && f.push(u[0] + u[1][1] + u[1][0] + u[1].substring(2))
                                }
                                for (var h = [], a = 0, l = o.length; l > a; a++) {
                                    var u = o[a];
                                    if (u[1])for (var d = 0,
                                                      p = c.alphabet.length; p > d; d++)h.push(u[0] + c.alphabet[d] + u[1].substring(1))
                                }
                                for (var m = [], a = 0, l = o.length; l > a; a++) {
                                    var u = o[a];
                                    if (u[1])for (var d = 0,
                                                      p = c.alphabet.length; p > d; d++)h.push(u[0] + c.alphabet[d] + u[1])
                                }
                                t = t.concat(s), t = t.concat(f), t = t.concat(h), t = t.concat(m)
                            }
                            return t
                        }

                        function r(e) {
                            for (var t = [], n = 0; n < e.length; n++)c.check(e[n]) && t.push(e[n]);
                            return t
                        }

                        function i(e) {
                            function i(e, t) {
                                return e[1] < t[1] ? -1 : 1
                            }

                            for (var o = n([e]), a = n(o), l = r(o).concat(r(a)), s = {}, u = 0,
                                     f = l.length; f > u; u++)l[u] in s ? s[l[u]] += 1 : s[l[u]] = 1;
                            var h = [];
                            for (var u in s)h.push([u, s[u]]);
                            h.sort(i).reverse();
                            for (var d = [], u = 0,
                                     f = Math.min(t, h.length); f > u; u++)c.hasFlag(h[u][0], "NOSUGGEST") || d.push(h[u][0]);
                            return d
                        }

                        if (t || (t = 5), this.check(e))return [];
                        for (var o = 0, a = this.replacementTable.length; a > o; o++) {
                            var l = this.replacementTable[o];
                            if (-1 !== e.indexOf(l[0])) {
                                var s = e.replace(l[0], l[1]);
                                if (this.check(s))return [s]
                            }
                        }
                        var c = this;
                        return c.alphabet = "abcdefghijklmnopqrstuvwxyz", i(e)
                    }
                }, "undefined" != typeof t && (t.exports = i)
            }).call(this, e("buffer").Buffer, "/node_modules/typo-js")
        }, {buffer: 3, fs: 2}],
        19: [function (e, t, n) {
            var r = e("codemirror");
            r.commands.tabAndIndentMarkdownList = function (e) {
                var t = e.listSelections(), n = t[0].head, r = e.getStateAfter(n.line), i = r.list !== !1;
                if (i)return void e.execCommand("indentMore");
                if (e.options.indentWithTabs) e.execCommand("insertTab"); else {
                    var o = Array(e.options.tabSize + 1).join(" ");
                    e.replaceSelection(o)
                }
            }, r.commands.shiftTabAndUnindentMarkdownList = function (e) {
                var t = e.listSelections(), n = t[0].head, r = e.getStateAfter(n.line), i = r.list !== !1;
                if (i)return void e.execCommand("indentLess");
                if (e.options.indentWithTabs) e.execCommand("insertTab"); else {
                    var o = Array(e.options.tabSize + 1).join(" ");
                    e.replaceSelection(o)
                }
            }
        }, {codemirror: 10}],
        20: [function (e, t, n) {
            "use strict";
            function r(e) {
                return e = U ? e.replace("Ctrl", "Cmd") : e.replace("Cmd", "Ctrl")
            }

            function i(e, t, n) {
                e = e || {};
                var r = document.createElement("a");
                return t = void 0 == t ? !0 : t, e.title && t && (r.title = a(e.title, e.action, n), U && (r.title = r.title.replace("Ctrl", ""), r.title = r.title.replace("Alt", ""))), r.tabIndex = -1, r.className = e.className, r
            }

            function o() {
                var e = document.createElement("i");
                return e.className = "separator", e.innerHTML = "|", e
            }

            function a(e, t, n) {
                var i, o = e;
                return t && (i = Y(t), n[i] && (o += " (" + r(n[i]) + ")")), o
            }

            function l(e, t) {
                t = t || e.getCursor("start");
                var n = e.getTokenAt(t);
                if (!n.type)return {};
                for (var r, i, o = n.type.split(" "), a = {},
                         l = 0; l < o.length; l++)r = o[l], "strong" === r ? a.bold = !0 : "variable-2" === r ? (i = e.getLine(t.line), /^\s*\d+\.\s/.test(i) ? a["ordered-list"] = !0 : a["unordered-list"] = !0) : "atom" === r ? a.quote = !0 : "em" === r ? a.italic = !0 : "quote" === r ? a.quote = !0 : "strikethrough" === r ? a.strikethrough = !0 : "comment" === r ? a.code = !0 : "link" === r ? a.link = !0 : "tag" === r ? a.image = !0 : r.match(/^header(\-[1-6])?$/) && (a[r.replace("header", "heading")] = !0);
                return a
            }

            function s(e) {
                var t = e.codemirror;
                t.setOption("fullScreen", !t.getOption("fullScreen")), t.getOption("fullScreen") ? (V = document.body.style.overflow, document.body.style.overflow = "hidden") : document.body.style.overflow = V;
                var n = t.getWrapperElement();
                /fullscreen/.test(n.previousSibling.className) ? n.previousSibling.className = n.previousSibling.className.replace(/\s*fullscreen\b/, "") : n.previousSibling.className += " fullscreen";
                var r = e.toolbarElements.fullscreen;
                /active/.test(r.className) ? r.className = r.className.replace(/\s*active\s*/g, "") : r.className += " active";
                var i = t.getWrapperElement().nextSibling;
                /editor-preview-active-side/.test(i.className) && N(e)
            }

            function c(e) {
                P(e, "bold", e.options.blockStyles.bold)
            }

            function u(e) {
                P(e, "italic", e.options.blockStyles.italic)
            }

            function f(e) {
                P(e, "strikethrough", "~~")
            }

            function h(e) {
                function t(e) {
                    if ("object" != typeof e)throw"fencing_line() takes a 'line' object (not a line number, or line text).  Got: " + typeof e + ": " + e;
                    return e.styles && e.styles[2] && -1 !== e.styles[2].indexOf("formatting-code-block")
                }

                function n(e) {
                    return e.state.base.base || e.state.base
                }

                function r(e, r, i, o, a) {
                    i = i || e.getLineHandle(r), o = o || e.getTokenAt({
                            line: r,
                            ch: 1
                        }), a = a || !!i.text && e.getTokenAt({line: r, ch: i.text.length - 1});
                    var l = o.type ? o.type.split(" ") : [];
                    return a && n(a).indentedCode ? "indented" : -1 === l.indexOf("comment") ? !1 : n(o).fencedChars || n(a).fencedChars || t(i) ? "fenced" : "single"
                }

                function i(e, t, n, r) {
                    var i = t.line + 1, o = n.line + 1, a = t.line !== n.line, l = r + "\n", s = "\n" + r;
                    a && o++, a && 0 === n.ch && (s = r + "\n", o--), E(e, !1, [l, s]), e.setSelection({
                        line: i,
                        ch: 0
                    }, {line: o, ch: 0})
                }

                var o, a, l, s = e.options.blockStyles.code, c = e.codemirror, u = c.getCursor("start"),
                    f = c.getCursor("end"), h = c.getTokenAt({line: u.line, ch: u.ch || 1}),
                    d = c.getLineHandle(u.line), p = r(c, u.line, d, h);
                if ("single" === p) {
                    var m = d.text.slice(0, u.ch).replace("`", ""), g = d.text.slice(u.ch).replace("`", "");
                    c.replaceRange(m + g, {line: u.line, ch: 0}, {
                        line: u.line,
                        ch: 99999999999999
                    }), u.ch--, u !== f && f.ch--, c.setSelection(u, f), c.focus()
                } else if ("fenced" === p)if (u.line !== f.line || u.ch !== f.ch) {
                    for (o = u.line; o >= 0 && (d = c.getLineHandle(o), !t(d)); o--);
                    var v, y, x, b, w = c.getTokenAt({line: o, ch: 1}), k = n(w).fencedChars;
                    t(c.getLineHandle(u.line)) ? (v = "", y = u.line) : t(c.getLineHandle(u.line - 1)) ? (v = "", y = u.line - 1) : (v = k + "\n", y = u.line), t(c.getLineHandle(f.line)) ? (x = "", b = f.line, 0 === f.ch && (b += 1)) : 0 !== f.ch && t(c.getLineHandle(f.line + 1)) ? (x = "", b = f.line + 1) : (x = k + "\n", b = f.line + 1), 0 === f.ch && (b -= 1), c.operation(function () {
                        c.replaceRange(x, {line: b, ch: 0}, {line: b + (x ? 0 : 1), ch: 0}), c.replaceRange(v, {
                            line: y,
                            ch: 0
                        }, {line: y + (v ? 0 : 1), ch: 0})
                    }), c.setSelection({line: y + (v ? 1 : 0), ch: 0}, {line: b + (v ? 1 : -1), ch: 0}), c.focus()
                } else {
                    var S = u.line;
                    if (t(c.getLineHandle(u.line)) && ("fenced" === r(c, u.line + 1) ? (o = u.line, S = u.line + 1) : (a = u.line, S = u.line - 1)), void 0 === o)for (o = S; o >= 0 && (d = c.getLineHandle(o), !t(d)); o--);
                    if (void 0 === a)for (l = c.lineCount(), a = S; l > a && (d = c.getLineHandle(a), !t(d)); a++);
                    c.operation(function () {
                        c.replaceRange("", {line: o, ch: 0}, {line: o + 1, ch: 0}), c.replaceRange("", {
                            line: a - 1,
                            ch: 0
                        }, {line: a, ch: 0})
                    }), c.focus()
                } else if ("indented" === p) {
                    if (u.line !== f.line || u.ch !== f.ch) o = u.line, a = f.line, 0 === f.ch && a--; else {
                        for (o = u.line; o >= 0; o--)if (d = c.getLineHandle(o), !d.text.match(/^\s*$/) && "indented" !== r(c, o, d)) {
                            o += 1;
                            break
                        }
                        for (l = c.lineCount(), a = u.line; l > a; a++)if (d = c.getLineHandle(a), !d.text.match(/^\s*$/) && "indented" !== r(c, a, d)) {
                            a -= 1;
                            break
                        }
                    }
                    var C = c.getLineHandle(a + 1), L = C && c.getTokenAt({line: a + 1, ch: C.text.length - 1}),
                        T = L && n(L).indentedCode;
                    T && c.replaceRange("\n", {line: a + 1, ch: 0});
                    for (var M = o; a >= M; M++)c.indentLine(M, "subtract");
                    c.focus()
                } else {
                    var N = u.line === f.line && u.ch === f.ch && 0 === u.ch, A = u.line !== f.line;
                    N || A ? i(c, u, f, s) : E(c, !1, ["`", "`"])
                }
            }

            function d(e) {
                var t = e.codemirror;
                I(t, "quote")
            }

            function p(e) {
                var t = e.codemirror;
                O(t, "smaller")
            }

            function m(e) {
                var t = e.codemirror;
                O(t, "bigger")
            }

            function g(e) {
                var t = e.codemirror;
                O(t, void 0, 1)
            }

            function v(e) {
                var t = e.codemirror;
                O(t, void 0, 2)
            }

            function y(e) {
                var t = e.codemirror;
                O(t, void 0, 3)
            }

            function x(e) {
                var t = e.codemirror;
                I(t, "unordered-list")
            }

            function b(e) {
                var t = e.codemirror;
                I(t, "ordered-list")
            }

            function w(e) {
                var t = e.codemirror;
                R(t)
            }

            function k(e) {
                var t = e.codemirror, n = l(t), r = e.options, i = "http://";
                return r.promptURLs && (i = prompt(r.promptTexts.link), !i) ? !1 : void E(t, n.link, r.insertTexts.link, i)
            }

            function S(e) {
                var t = e.codemirror, n = l(t), r = e.options, i = "http://";
                return r.promptURLs && (i = prompt(r.promptTexts.image), !i) ? !1 : void E(t, n.image, r.insertTexts.image, i)
            }

            function C(e) {
                var t = e.codemirror, n = l(t), r = e.options;
                E(t, n.table, r.insertTexts.table)
            }

            function L(e) {
                var t = e.codemirror, n = l(t), r = e.options;
                E(t, n.image, r.insertTexts.horizontalRule)
            }

            function T(e) {
                var t = e.codemirror;
                t.undo(), t.focus()
            }

            function M(e) {
                var t = e.codemirror;
                t.redo(), t.focus()
            }

            function N(e) {
                var t = e.codemirror, n = t.getWrapperElement(), r = n.nextSibling,
                    i = e.toolbarElements["side-by-side"], o = !1;
                /editor-preview-active-side/.test(r.className) ? (r.className = r.className.replace(/\s*editor-preview-active-side\s*/g, ""), i.className = i.className.replace(/\s*active\s*/g, ""), n.className = n.className.replace(/\s*CodeMirror-sided\s*/g, " ")) : (setTimeout(function () {
                    t.getOption("fullScreen") || s(e), r.className += " editor-preview-active-side"
                }, 1), i.className += " active", n.className += " CodeMirror-sided", o = !0);
                var a = n.lastChild;
                if (/editor-preview-active/.test(a.className)) {
                    a.className = a.className.replace(/\s*editor-preview-active\s*/g, "");
                    var l = e.toolbarElements.preview, c = n.previousSibling;
                    l.className = l.className.replace(/\s*active\s*/g, ""), c.className = c.className.replace(/\s*disabled-for-preview*/g, "")
                }
                var u = function () {
                    r.innerHTML = e.options.previewRender(e.value(), r)
                };
                t.sideBySideRenderingFunction || (t.sideBySideRenderingFunction = u), o ? (r.innerHTML = e.options.previewRender(e.value(), r), t.on("update", t.sideBySideRenderingFunction)) : t.off("update", t.sideBySideRenderingFunction), t.refresh()
            }

            function A(e) {
                var t = e.codemirror, n = t.getWrapperElement(), r = n.previousSibling,
                    i = e.options.toolbar ? e.toolbarElements.preview : !1, o = n.lastChild;
                o && /editor-preview/.test(o.className) || (o = document.createElement("div"), o.className = "editor-preview", n.appendChild(o)), /editor-preview-active/.test(o.className) ? (o.className = o.className.replace(/\s*editor-preview-active\s*/g, ""), i && (i.className = i.className.replace(/\s*active\s*/g, ""), r.className = r.className.replace(/\s*disabled-for-preview*/g, ""))) : (setTimeout(function () {
                    o.className += " editor-preview-active"
                }, 1), i && (i.className += " active", r.className += " disabled-for-preview")), o.innerHTML = e.options.previewRender(e.value(), o);
                var a = t.getWrapperElement().nextSibling;
                /editor-preview-active-side/.test(a.className) && N(e)
            }

            function E(e, t, n, r) {
                if (!/editor-preview-active/.test(e.getWrapperElement().lastChild.className)) {
                    var i, o = n[0], a = n[1], l = e.getCursor("start"), s = e.getCursor("end");
                    r && (a = a.replace("#url#", r)), t ? (i = e.getLine(l.line), o = i.slice(0, l.ch), a = i.slice(l.ch), e.replaceRange(o + a, {
                        line: l.line,
                        ch: 0
                    })) : (i = e.getSelection(), e.replaceSelection(o + i + a), l.ch += o.length, l !== s && (s.ch += o.length)), e.setSelection(l, s), e.focus()
                }
            }

            function O(e, t, n) {
                if (!/editor-preview-active/.test(e.getWrapperElement().lastChild.className)) {
                    for (var r = e.getCursor("start"), i = e.getCursor("end"),
                             o = r.line; o <= i.line; o++)!function (r) {
                        var i = e.getLine(r), o = i.search(/[^#]/);
                        i = void 0 !== t ? 0 >= o ? "bigger" == t ? "###### " + i : "# " + i : 6 == o && "smaller" == t ? i.substr(7) : 1 == o && "bigger" == t ? i.substr(2) : "bigger" == t ? i.substr(1) : "#" + i : 1 == n ? 0 >= o ? "# " + i : o == n ? i.substr(o + 1) : "# " + i.substr(o + 1) : 2 == n ? 0 >= o ? "## " + i : o == n ? i.substr(o + 1) : "## " + i.substr(o + 1) : 0 >= o ? "### " + i : o == n ? i.substr(o + 1) : "### " + i.substr(o + 1), e.replaceRange(i, {
                            line: r,
                            ch: 0
                        }, {line: r, ch: 99999999999999})
                    }(o);
                    e.focus()
                }
            }

            function I(e, t) {
                if (!/editor-preview-active/.test(e.getWrapperElement().lastChild.className)) {
                    for (var n = l(e), r = e.getCursor("start"), i = e.getCursor("end"), o = {
                            quote: /^(\s*)\>\s+/,
                            "unordered-list": /^(\s*)(\*|\-|\+)\s+/,
                            "ordered-list": /^(\s*)\d+\.\s+/
                        }, a = {quote: "> ", "unordered-list": "* ", "ordered-list": "1. "},
                             s = r.line; s <= i.line; s++)!function (r) {
                        var i = e.getLine(r);
                        i = n[t] ? i.replace(o[t], "$1") : a[t] + i, e.replaceRange(i, {line: r, ch: 0}, {
                            line: r,
                            ch: 99999999999999
                        })
                    }(s);
                    e.focus()
                }
            }

            function P(e, t, n, r) {
                if (!/editor-preview-active/.test(e.codemirror.getWrapperElement().lastChild.className)) {
                    r = "undefined" == typeof r ? n : r;
                    var i, o = e.codemirror, a = l(o), s = n, c = r, u = o.getCursor("start"), f = o.getCursor("end");
                    a[t] ? (i = o.getLine(u.line), s = i.slice(0, u.ch), c = i.slice(u.ch), "bold" == t ? (s = s.replace(/(\*\*|__)(?![\s\S]*(\*\*|__))/, ""), c = c.replace(/(\*\*|__)/, "")) : "italic" == t ? (s = s.replace(/(\*|_)(?![\s\S]*(\*|_))/, ""), c = c.replace(/(\*|_)/, "")) : "strikethrough" == t && (s = s.replace(/(\*\*|~~)(?![\s\S]*(\*\*|~~))/, ""), c = c.replace(/(\*\*|~~)/, "")), o.replaceRange(s + c, {
                        line: u.line,
                        ch: 0
                    }, {
                        line: u.line,
                        ch: 99999999999999
                    }), "bold" == t || "strikethrough" == t ? (u.ch -= 2, u !== f && (f.ch -= 2)) : "italic" == t && (u.ch -= 1, u !== f && (f.ch -= 1))) : (i = o.getSelection(), "bold" == t ? (i = i.split("**").join(""), i = i.split("__").join("")) : "italic" == t ? (i = i.split("*").join(""), i = i.split("_").join("")) : "strikethrough" == t && (i = i.split("~~").join("")), o.replaceSelection(s + i + c), u.ch += n.length, f.ch = u.ch + i.length), o.setSelection(u, f), o.focus()
                }
            }

            function R(e) {
                if (!/editor-preview-active/.test(e.getWrapperElement().lastChild.className))for (var t,
                                                                                                      n = e.getCursor("start"),
                                                                                                      r = e.getCursor("end"),
                                                                                                      i = n.line; i <= r.line; i++)t = e.getLine(i), t = t.replace(/^[ ]*([# ]+|\*|\-|[> ]+|[0-9]+(.|\)))[ ]*/, ""), e.replaceRange(t, {
                    line: i,
                    ch: 0
                }, {line: i, ch: 99999999999999})
            }

            function D(e, t) {
                for (var n in t)t.hasOwnProperty(n) && (t[n] instanceof Array ? e[n] = t[n].concat(e[n] instanceof Array ? e[n] : []) : null !== t[n] && "object" == typeof t[n] && t[n].constructor === Object ? e[n] = D(e[n] || {}, t[n]) : e[n] = t[n]);
                return e
            }

            function H(e) {
                for (var t = 1; t < arguments.length; t++)e = D(e, arguments[t]);
                return e
            }

            function W(e) {
                var t = /[a-zA-Z0-9_\u0392-\u03c9\u0410-\u04F9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g,
                    n = e.match(t), r = 0;
                if (null === n)return r;
                for (var i = 0; i < n.length; i++)r += n[i].charCodeAt(0) >= 19968 ? n[i].length : 1;
                return r
            }

            function B(e) {
                e = e || {}, e.parent = this;
                var t = !0;
                if (e.autoDownloadFontAwesome === !1 && (t = !1), e.autoDownloadFontAwesome !== !0)for (var n = document.styleSheets,
                                                                                                            r = 0; r < n.length; r++)n[r].href && n[r].href.indexOf("//maxcdn.bootstrapcdn.com/font-awesome/") > -1 && (t = !1);
                if (t) {
                    var i = document.createElement("link");
                    i.rel = "stylesheet", i.href = "https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css", document.getElementsByTagName("head")[0].appendChild(i)
                }
                if (e.element) this.element = e.element; else if (null === e.element)return void console.log("SimpleMDE: Error. No element was found.");
                if (void 0 === e.toolbar) {
                    e.toolbar = [];
                    for (var o in K)K.hasOwnProperty(o) && (-1 != o.indexOf("separator-") && e.toolbar.push("|"), (K[o]["default"] === !0 || e.showIcons && e.showIcons.constructor === Array && -1 != e.showIcons.indexOf(o)) && e.toolbar.push(o))
                }
                e.hasOwnProperty("status") || (e.status = ["autosave", "lines", "words", "cursor"]), e.previewRender || (e.previewRender = function (e) {
                    return this.parent.markdown(e)
                }), e.parsingConfig = H({highlightFormatting: !0}, e.parsingConfig || {}), e.insertTexts = H({}, X, e.insertTexts || {}), e.promptTexts = Z, e.blockStyles = H({}, J, e.blockStyles || {}), e.shortcuts = H({}, G, e.shortcuts || {}), void 0 != e.autosave && void 0 != e.autosave.unique_id && "" != e.autosave.unique_id && (e.autosave.uniqueId = e.autosave.unique_id), this.options = e, this.render(), !e.initialValue || this.options.autosave && this.options.autosave.foundSavedValue === !0 || this.value(e.initialValue)
            }

            function _() {
                if ("object" != typeof localStorage)return !1;
                try {
                    localStorage.setItem("smde_localStorage", 1), localStorage.removeItem("smde_localStorage")
                } catch (e) {
                    return !1
                }
                return !0
            }

            var F = e("codemirror");
            e("codemirror/addon/edit/continuelist.js"), e("./codemirror/tablist"), e("codemirror/addon/display/fullscreen.js"), e("codemirror/mode/markdown/markdown.js"), e("codemirror/addon/mode/overlay.js"), e("codemirror/addon/display/placeholder.js"), e("codemirror/addon/selection/mark-selection.js"), e("codemirror/mode/gfm/gfm.js"), e("codemirror/mode/xml/xml.js");
            var z = e("codemirror-spell-checker"), j = e("marked"), U = /Mac/.test(navigator.platform), q = {
                toggleBold: c,
                toggleItalic: u,
                drawLink: k,
                toggleHeadingSmaller: p,
                toggleHeadingBigger: m,
                drawImage: S,
                toggleBlockquote: d,
                toggleOrderedList: b,
                toggleUnorderedList: x,
                toggleCodeBlock: h,
                togglePreview: A,
                toggleStrikethrough: f,
                toggleHeading1: g,
                toggleHeading2: v,
                toggleHeading3: y,
                cleanBlock: w,
                drawTable: C,
                drawHorizontalRule: L,
                undo: T,
                redo: M,
                toggleSideBySide: N,
                toggleFullScreen: s
            }, G = {
                toggleBold: "Cmd-B",
                toggleItalic: "Cmd-I",
                drawLink: "Cmd-K",
                toggleHeadingSmaller: "Cmd-H",
                toggleHeadingBigger: "Shift-Cmd-H",
                cleanBlock: "Cmd-E",
                drawImage: "Cmd-Alt-I",
                toggleBlockquote: "Cmd-'",
                toggleOrderedList: "Cmd-Alt-L",
                toggleUnorderedList: "Cmd-L",
                toggleCodeBlock: "Cmd-Alt-C",
                togglePreview: "Cmd-P",
                toggleSideBySide: "F9",
                toggleFullScreen: "F11"
            }, Y = function (e) {
                for (var t in q)if (q[t] === e)return t;
                return null
            }, $ = function () {
                var e = !1;
                return function (t) {
                    (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0);
                }(navigator.userAgent || navigator.vendor || window.opera), e
            }, V = "", K = {
                bold: {name: "bold", action: c, className: "fa fa-bold", title: "Bold", "default": !0},
                italic: {name: "italic", action: u, className: "fa fa-italic", title: "Italic", "default": !0},
                strikethrough: {
                    name: "strikethrough",
                    action: f,
                    className: "fa fa-strikethrough",
                    title: "Strikethrough"
                },
                heading: {name: "heading", action: p, className: "fa fa-header", title: "Heading", "default": !0},
                "heading-smaller": {
                    name: "heading-smaller",
                    action: p,
                    className: "fa fa-header fa-header-x fa-header-smaller",
                    title: "Smaller Heading"
                },
                "heading-bigger": {
                    name: "heading-bigger",
                    action: m,
                    className: "fa fa-header fa-header-x fa-header-bigger",
                    title: "Bigger Heading"
                },
                "heading-1": {
                    name: "heading-1",
                    action: g,
                    className: "fa fa-header fa-header-x fa-header-1",
                    title: "Big Heading"
                },
                "heading-2": {
                    name: "heading-2",
                    action: v,
                    className: "fa fa-header fa-header-x fa-header-2",
                    title: "Medium Heading"
                },
                "heading-3": {
                    name: "heading-3",
                    action: y,
                    className: "fa fa-header fa-header-x fa-header-3",
                    title: "Small Heading"
                },
                "separator-1": {name: "separator-1"},
                code: {name: "code", action: h, className: "fa fa-code", title: "Code"},
                quote: {name: "quote", action: d, className: "fa fa-quote-left", title: "Quote", "default": !0},
                "unordered-list": {
                    name: "unordered-list",
                    action: x,
                    className: "fa fa-list-ul",
                    title: "Generic List",
                    "default": !0
                },
                "ordered-list": {
                    name: "ordered-list",
                    action: b,
                    className: "fa fa-list-ol",
                    title: "Numbered List",
                    "default": !0
                },
                "clean-block": {
                    name: "clean-block",
                    action: w,
                    className: "fa fa-eraser fa-clean-block",
                    title: "Clean block"
                },
                "separator-2": {name: "separator-2"},
                link: {name: "link", action: k, className: "fa fa-link", title: "Create Link", "default": !0},
                image: {name: "image", action: function(editor){
                    modal({
                        url: editor.options.imagesModalUrl,
                        init: editor.options.imagesModalInit,
                        success: {
                            callback: function(){
                                var t = editor.codemirror, n = l(t), r = editor.options, i = "";

                                    var selected = document.querySelectorAll('#images-row .images-square.selected');
                                    selected.forEach(function(element){

                                        E(t, n.image, ["![", "](\"" + element.getAttribute('data-image')+ ")\n\n    "], i)
                                    })

                            }
                        }

                    })

                }, className: "fa fa-picture-o", title: "Insert Image", "default": !0},
                table: {name: "table", action: C, className: "fa fa-table", title: "Insert Table"},
                "horizontal-rule": {
                    name: "horizontal-rule",
                    action: L,
                    className: "fa fa-minus",
                    title: "Insert Horizontal Line"
                },
                "separator-3": {name: "separator-3"},
                preview: {
                    name: "preview",
                    action: A,
                    className: "fa fa-eye no-disable",
                    title: "Toggle Preview",
                    "default": !0
                },
                "side-by-side": {
                    name: "side-by-side",
                    action: N,
                    className: "fa fa-columns no-disable no-mobile",
                    title: "Toggle Side by Side",
                    "default": !0
                },
                fullscreen: {
                    name: "fullscreen",
                    action: s,
                    className: "fa fa-arrows-alt no-disable no-mobile",
                    title: "Toggle Fullscreen",
                    "default": !0
                },
                "separator-4": {name: "separator-4"},
                guide: {
                    name: "guide",
                    action: "https://simplemde.com/markdown-guide",
                    className: "fa fa-question-circle",
                    title: "Markdown Guide",
                    "default": !0
                },
                "separator-5": {name: "separator-5"},
                undo: {name: "undo", action: T, className: "fa fa-undo no-disable", title: "Undo"},
                redo: {name: "redo", action: M, className: "fa fa-repeat no-disable", title: "Redo"}
            }, X = {
                link: ["[", "](#url#)"],
                image: ["![](", "#url#)"],
                table: ["", "\n\n| Column 1 | Column 2 | Column 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n"],
                horizontalRule: ["", "\n\n-----\n\n"]
            }, Z = {link: "URL for the link:", image: "URL of the image:"}, J = {bold: "**", code: "```", italic: "*"};
            B.prototype.markdown = function (e) {
                if (j) {
                    var t = {};
                    return this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === !1 ? t.breaks = !1 : t.breaks = !0, this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === !0 && window.hljs && (t.highlight = function (e) {
                        return window.hljs.highlightAuto(e).value
                    }), j.setOptions(t), j(e)
                }
            }, B.prototype.render = function (e) {
                if (e || (e = this.element || document.getElementsByTagName("textarea")[0]), !this._rendered || this._rendered !== e) {
                    this.element = e;
                    var t = this.options, n = this, i = {};
                    for (var o in t.shortcuts)null !== t.shortcuts[o] && null !== q[o] && !function (e) {
                        i[r(t.shortcuts[e])] = function () {
                            q[e](n)
                        }
                    }(o);
                    i.Enter = "newlineAndIndentContinueMarkdownList", i.Tab = "tabAndIndentMarkdownList", i["Shift-Tab"] = "shiftTabAndUnindentMarkdownList", i.Esc = function (e) {
                        e.getOption("fullScreen") && s(n)
                    }, document.addEventListener("keydown", function (e) {
                        e = e || window.event, 27 == e.keyCode && n.codemirror.getOption("fullScreen") && s(n)
                    }, !1);
                    var a, l;
                    if (t.spellChecker !== !1 ? (a = "spell-checker", l = t.parsingConfig, l.name = "gfm", l.gitHubSpice = !1, z({codeMirrorInstance: F})) : (a = t.parsingConfig, a.name = "gfm", a.gitHubSpice = !1), this.codemirror = F.fromTextArea(e, {
                            mode: a,
                            backdrop: l,
                            theme: "paper",
                            tabSize: void 0 != t.tabSize ? t.tabSize : 2,
                            indentUnit: void 0 != t.tabSize ? t.tabSize : 2,
                            indentWithTabs: t.indentWithTabs !== !1,
                            lineNumbers: !1,
                            autofocus: t.autofocus === !0,
                            extraKeys: i,
                            lineWrapping: t.lineWrapping !== !1,
                            allowDropFileTypes: ["text/plain"],
                            placeholder: t.placeholder || e.getAttribute("placeholder") || "",
                            styleSelectedText: void 0 != t.styleSelectedText ? t.styleSelectedText : !0
                        }), t.forceSync === !0) {
                        var c = this.codemirror;
                        c.on("change", function () {
                            c.save()
                        })
                    }
                    this.gui = {}, t.toolbar !== !1 && (this.gui.toolbar = this.createToolbar()), t.status !== !1 && (this.gui.statusbar = this.createStatusbar()), void 0 != t.autosave && t.autosave.enabled === !0 && this.autosave(), this.gui.sideBySide = this.createSideBySide(), this._rendered = this.element;
                    var u = this.codemirror;
                    setTimeout(function () {
                        u.refresh()
                    }.bind(u), 0)
                }
            }, B.prototype.autosave = function () {
                if (_()) {
                    var e = this;
                    if (void 0 == this.options.autosave.uniqueId || "" == this.options.autosave.uniqueId)return void console.log("SimpleMDE: You must set a uniqueId to use the autosave feature");
                    null != e.element.form && void 0 != e.element.form && e.element.form.addEventListener("submit", function () {
                        localStorage.removeItem("smde_" + e.options.autosave.uniqueId)
                    }), this.options.autosave.loaded !== !0 && ("string" == typeof localStorage.getItem("smde_" + this.options.autosave.uniqueId) && "" != localStorage.getItem("smde_" + this.options.autosave.uniqueId) && (this.codemirror.setValue(localStorage.getItem("smde_" + this.options.autosave.uniqueId)), this.options.autosave.foundSavedValue = !0), this.options.autosave.loaded = !0), localStorage.setItem("smde_" + this.options.autosave.uniqueId, e.value());
                    var t = document.getElementById("autosaved");
                    if (null != t && void 0 != t && "" != t) {
                        var n = new Date, r = n.getHours(), i = n.getMinutes(), o = "am", a = r;
                        a >= 12 && (a = r - 12, o = "pm"), 0 == a && (a = 12), i = 10 > i ? "0" + i : i, t.innerHTML = "Autosaved: " + a + ":" + i + " " + o
                    }
                    this.autosaveTimeoutId = setTimeout(function () {
                        e.autosave()
                    }, this.options.autosave.delay || 1e4)
                } else console.log("SimpleMDE: localStorage not available, cannot autosave")
            }, B.prototype.clearAutosavedValue = function () {
                if (_()) {
                    if (void 0 == this.options.autosave || void 0 == this.options.autosave.uniqueId || "" == this.options.autosave.uniqueId)return void console.log("SimpleMDE: You must set a uniqueId to clear the autosave value");
                    localStorage.removeItem("smde_" + this.options.autosave.uniqueId)
                } else console.log("SimpleMDE: localStorage not available, cannot autosave")
            }, B.prototype.createSideBySide = function () {
                var e = this.codemirror, t = e.getWrapperElement(), n = t.nextSibling;
                n && /editor-preview-side/.test(n.className) || (n = document.createElement("div"), n.className = "editor-preview-side", t.parentNode.insertBefore(n, t.nextSibling));
                var r = !1, i = !1;
                return e.on("scroll", function (e) {
                    if (r)return void(r = !1);
                    i = !0;
                    var t = e.getScrollInfo().height - e.getScrollInfo().clientHeight,
                        o = parseFloat(e.getScrollInfo().top) / t, a = (n.scrollHeight - n.clientHeight) * o;
                    n.scrollTop = a
                }), n.onscroll = function () {
                    if (i)return void(i = !1);
                    r = !0;
                    var t = n.scrollHeight - n.clientHeight, o = parseFloat(n.scrollTop) / t,
                        a = (e.getScrollInfo().height - e.getScrollInfo().clientHeight) * o;
                    e.scrollTo(0, a)
                }, n
            }, B.prototype.createToolbar = function (e) {
                if (e = e || this.options.toolbar, e && 0 !== e.length) {
                    var t;
                    for (t = 0; t < e.length; t++)void 0 != K[e[t]] && (e[t] = K[e[t]]);
                    var n = document.createElement("div");
                    n.className = "editor-toolbar";
                    var r = this, a = {};
                    for (r.toolbar = e, t = 0; t < e.length; t++)if (("guide" != e[t].name || r.options.toolbarGuideIcon !== !1) && !(r.options.hideIcons && -1 != r.options.hideIcons.indexOf(e[t].name) || ("fullscreen" == e[t].name || "side-by-side" == e[t].name) && $())) {
                        if ("|" === e[t]) {
                            for (var s = !1,
                                     c = t + 1; c < e.length; c++)"|" === e[c] || r.options.hideIcons && -1 != r.options.hideIcons.indexOf(e[c].name) || (s = !0);
                            if (!s)continue
                        }
                        !function (e) {
                            var t;
                            t = "|" === e ? o() : i(e, r.options.toolbarTips, r.options.shortcuts), e.action && ("function" == typeof e.action ? t.onclick = function (t) {
                                t.preventDefault(), e.action(r)
                            } : "string" == typeof e.action && (t.href = e.action, t.target = "_blank")), a[e.name || e] = t, n.appendChild(t)
                        }(e[t])
                    }
                    r.toolbarElements = a;
                    var u = this.codemirror;
                    u.on("cursorActivity", function () {
                        var e = l(u);
                        for (var t in a)!function (t) {
                            var n = a[t];
                            e[t] ? n.className += " active" : "fullscreen" != t && "side-by-side" != t && (n.className = n.className.replace(/\s*active\s*/g, ""))
                        }(t)
                    });
                    var f = u.getWrapperElement();
                    return f.parentNode.insertBefore(n, f), n
                }
            }, B.prototype.createStatusbar = function (e) {
                e = e || this.options.status;
                var t = this.options, n = this.codemirror;
                if (e && 0 !== e.length) {
                    var r, i, o, a = [];
                    for (r = 0; r < e.length; r++)if (i = void 0, o = void 0, "object" == typeof e[r]) a.push({
                        className: e[r].className,
                        defaultValue: e[r].defaultValue,
                        onUpdate: e[r].onUpdate
                    }); else {
                        var l = e[r];
                        "words" === l ? (o = function (e) {
                            e.innerHTML = W(n.getValue())
                        }, i = function (e) {
                            e.innerHTML = W(n.getValue())
                        }) : "lines" === l ? (o = function (e) {
                            e.innerHTML = n.lineCount()
                        }, i = function (e) {
                            e.innerHTML = n.lineCount()
                        }) : "cursor" === l ? (o = function (e) {
                            e.innerHTML = "0:0"
                        }, i = function (e) {
                            var t = n.getCursor();
                            e.innerHTML = t.line + ":" + t.ch
                        }) : "autosave" === l && (o = function (e) {
                                void 0 != t.autosave && t.autosave.enabled === !0 && e.setAttribute("id", "autosaved")
                            }), a.push({className: l, defaultValue: o, onUpdate: i})
                    }
                    var s = document.createElement("div");
                    for (s.className = "editor-statusbar", r = 0; r < a.length; r++) {
                        var c = a[r], u = document.createElement("span");
                        u.className = c.className, "function" == typeof c.defaultValue && c.defaultValue(u), "function" == typeof c.onUpdate && this.codemirror.on("update", function (e, t) {
                            return function () {
                                t.onUpdate(e)
                            }
                        }(u, c)), s.appendChild(u)
                    }
                    var f = this.codemirror.getWrapperElement();
                    return f.parentNode.insertBefore(s, f.nextSibling), s
                }
            }, B.prototype.value = function (e) {
                return void 0 === e ? this.codemirror.getValue() : (this.codemirror.getDoc().setValue(e), this)
            }, B.toggleBold = c, B.toggleItalic = u, B.toggleStrikethrough = f, B.toggleBlockquote = d, B.toggleHeadingSmaller = p, B.toggleHeadingBigger = m, B.toggleHeading1 = g, B.toggleHeading2 = v, B.toggleHeading3 = y, B.toggleCodeBlock = h, B.toggleUnorderedList = x, B.toggleOrderedList = b, B.cleanBlock = w, B.drawLink = k, B.drawImage = S, B.drawTable = C, B.drawHorizontalRule = L, B.undo = T, B.redo = M, B.togglePreview = A, B.toggleSideBySide = N, B.toggleFullScreen = s, B.prototype.toggleBold = function () {
                c(this)
            }, B.prototype.toggleItalic = function () {
                u(this)
            }, B.prototype.toggleStrikethrough = function () {
                f(this)
            }, B.prototype.toggleBlockquote = function () {
                d(this)
            }, B.prototype.toggleHeadingSmaller = function () {
                p(this)
            }, B.prototype.toggleHeadingBigger = function () {
                m(this)
            }, B.prototype.toggleHeading1 = function () {
                g(this)
            }, B.prototype.toggleHeading2 = function () {
                v(this)
            }, B.prototype.toggleHeading3 = function () {
                y(this)
            }, B.prototype.toggleCodeBlock = function () {
                h(this)
            }, B.prototype.toggleUnorderedList = function () {
                x(this)
            }, B.prototype.toggleOrderedList = function () {
                b(this)
            }, B.prototype.cleanBlock = function () {
                w(this)
            }, B.prototype.drawLink = function () {
                k(this)
            }, B.prototype.drawImage = function () {
                S(this)
            }, B.prototype.drawTable = function () {
                C(this)
            }, B.prototype.drawHorizontalRule = function () {
                L(this)
            }, B.prototype.undo = function () {
                T(this)
            }, B.prototype.redo = function () {
                M(this)
            }, B.prototype.togglePreview = function () {
                A(this)
            }, B.prototype.toggleSideBySide = function () {
                N(this)
            }, B.prototype.toggleFullScreen = function () {
                s(this)
            }, B.prototype.isPreviewActive = function () {
                var e = this.codemirror, t = e.getWrapperElement(), n = t.lastChild;
                return /editor-preview-active/.test(n.className)
            }, B.prototype.isSideBySideActive = function () {
                var e = this.codemirror, t = e.getWrapperElement(), n = t.nextSibling;
                return /editor-preview-active-side/.test(n.className)
            }, B.prototype.isFullscreenActive = function () {
                var e = this.codemirror;
                return e.getOption("fullScreen")
            }, B.prototype.getState = function () {
                var e = this.codemirror;
                return l(e)
            }, B.prototype.toTextArea = function () {
                var e = this.codemirror, t = e.getWrapperElement();
                t.parentNode && (this.gui.toolbar && t.parentNode.removeChild(this.gui.toolbar), this.gui.statusbar && t.parentNode.removeChild(this.gui.statusbar), this.gui.sideBySide && t.parentNode.removeChild(this.gui.sideBySide)), e.toTextArea(), this.autosaveTimeoutId && (clearTimeout(this.autosaveTimeoutId), this.autosaveTimeoutId = void 0, this.clearAutosavedValue())
            }, t.exports = B
        }, {
            "./codemirror/tablist": 19,
            codemirror: 10,
            "codemirror-spell-checker": 4,
            "codemirror/addon/display/fullscreen.js": 5,
            "codemirror/addon/display/placeholder.js": 6,
            "codemirror/addon/edit/continuelist.js": 7,
            "codemirror/addon/mode/overlay.js": 8,
            "codemirror/addon/selection/mark-selection.js": 9,
            "codemirror/mode/gfm/gfm.js": 11,
            "codemirror/mode/markdown/markdown.js": 12,
            "codemirror/mode/xml/xml.js": 14,
            marked: 17
        }]
    }, {}, [20])(20)
});
/*
 * jQuery Iframe Transport Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* global define, require, window, document */

;(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS:
        factory(require('jquery'));
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    // Helper variable to create unique names for the transport iframes:
    var counter = 0;

    // The iframe transport accepts four additional options:
    // options.fileInput: a jQuery collection of file input fields
    // options.paramName: the parameter name for the file form data,
    //  overrides the name property of the file input field(s),
    //  can be a string or an array of strings.
    // options.formData: an array of objects with name and value properties,
    //  equivalent to the return data of .serializeArray(), e.g.:
    //  [{name: 'a', value: 1}, {name: 'b', value: 2}]
    // options.initialIframeSrc: the URL of the initial iframe src,
    //  by default set to "javascript:false;"
    $.ajaxTransport('iframe', function (options) {
        if (options.async) {
            // javascript:false as initial iframe src
            // prevents warning popups on HTTPS in IE6:
            /*jshint scripturl: true */
            var initialIframeSrc = options.initialIframeSrc || 'javascript:false;',
            /*jshint scripturl: false */
                form,
                iframe,
                addParamChar;
            return {
                send: function (_, completeCallback) {
                    form = $('<form style="display:none;"></form>');
                    form.attr('accept-charset', options.formAcceptCharset);
                    addParamChar = /\?/.test(options.url) ? '&' : '?';
                    // XDomainRequest only supports GET and POST:
                    if (options.type === 'DELETE') {
                        options.url = options.url + addParamChar + '_method=DELETE';
                        options.type = 'POST';
                    } else if (options.type === 'PUT') {
                        options.url = options.url + addParamChar + '_method=PUT';
                        options.type = 'POST';
                    } else if (options.type === 'PATCH') {
                        options.url = options.url + addParamChar + '_method=PATCH';
                        options.type = 'POST';
                    }
                    // IE versions below IE8 cannot set the name property of
                    // elements that have already been added to the DOM,
                    // so we set the name along with the iframe HTML markup:
                    counter += 1;
                    iframe = $(
                        '<iframe src="' + initialIframeSrc +
                            '" name="iframe-transport-' + counter + '"></iframe>'
                    ).bind('load', function () {
                        var fileInputClones,
                            paramNames = $.isArray(options.paramName) ?
                                    options.paramName : [options.paramName];
                        iframe
                            .unbind('load')
                            .bind('load', function () {
                                var response;
                                // Wrap in a try/catch block to catch exceptions thrown
                                // when trying to access cross-domain iframe contents:
                                try {
                                    response = iframe.contents();
                                    // Google Chrome and Firefox do not throw an
                                    // exception when calling iframe.contents() on
                                    // cross-domain requests, so we unify the response:
                                    if (!response.length || !response[0].firstChild) {
                                        throw new Error();
                                    }
                                } catch (e) {
                                    response = undefined;
                                }
                                // The complete callback returns the
                                // iframe content document as response object:
                                completeCallback(
                                    200,
                                    'success',
                                    {'iframe': response}
                                );
                                // Fix for IE endless progress bar activity bug
                                // (happens on form submits to iframe targets):
                                $('<iframe src="' + initialIframeSrc + '"></iframe>')
                                    .appendTo(form);
                                window.setTimeout(function () {
                                    // Removing the form in a setTimeout call
                                    // allows Chrome's developer tools to display
                                    // the response result
                                    form.remove();
                                }, 0);
                            });
                        form
                            .prop('target', iframe.prop('name'))
                            .prop('action', options.url)
                            .prop('method', options.type);
                        if (options.formData) {
                            $.each(options.formData, function (index, field) {
                                $('<input type="hidden"/>')
                                    .prop('name', field.name)
                                    .val(field.value)
                                    .appendTo(form);
                            });
                        }
                        if (options.fileInput && options.fileInput.length &&
                                options.type === 'POST') {
                            fileInputClones = options.fileInput.clone();
                            // Insert a clone for each file input field:
                            options.fileInput.after(function (index) {
                                return fileInputClones[index];
                            });
                            if (options.paramName) {
                                options.fileInput.each(function (index) {
                                    $(this).prop(
                                        'name',
                                        paramNames[index] || options.paramName
                                    );
                                });
                            }
                            // Appending the file input fields to the hidden form
                            // removes them from their original location:
                            form
                                .append(options.fileInput)
                                .prop('enctype', 'multipart/form-data')
                                // enctype must be set as encoding for IE:
                                .prop('encoding', 'multipart/form-data');
                            // Remove the HTML5 form attribute from the input(s):
                            options.fileInput.removeAttr('form');
                        }
                        form.submit();
                        // Insert the file input fields at their original location
                        // by replacing the clones with the originals:
                        if (fileInputClones && fileInputClones.length) {
                            options.fileInput.each(function (index, input) {
                                var clone = $(fileInputClones[index]);
                                // Restore the original name and form properties:
                                $(input)
                                    .prop('name', clone.prop('name'))
                                    .attr('form', clone.attr('form'));
                                clone.replaceWith(input);
                            });
                        }
                    });
                    form.append(iframe).appendTo(document.body);
                },
                abort: function () {
                    if (iframe) {
                        // javascript:false as iframe src aborts the request
                        // and prevents warning popups on HTTPS in IE6.
                        // concat is used to avoid the "Script URL" JSLint error:
                        iframe
                            .unbind('load')
                            .prop('src', initialIframeSrc);
                    }
                    if (form) {
                        form.remove();
                    }
                }
            };
        }
    });

    // The iframe transport returns the iframe content document as response.
    // The following adds converters from iframe to text, json, html, xml
    // and script.
    // Please note that the Content-Type for JSON responses has to be text/plain
    // or text/html, if the browser doesn't include application/json in the
    // Accept header, else IE will show a download dialog.
    // The Content-Type for XML responses on the other hand has to be always
    // application/xml or text/xml, so IE properly parses the XML response.
    // See also
    // https://github.com/blueimp/jQuery-File-Upload/wiki/Setup#content-type-negotiation
    $.ajaxSetup({
        converters: {
            'iframe text': function (iframe) {
                return iframe && $(iframe[0].body).text();
            },
            'iframe json': function (iframe) {
                return iframe && $.parseJSON($(iframe[0].body).text());
            },
            'iframe html': function (iframe) {
                return iframe && $(iframe[0].body).html();
            },
            'iframe xml': function (iframe) {
                var xmlDoc = iframe && iframe[0];
                return xmlDoc && $.isXMLDoc(xmlDoc) ? xmlDoc :
                        $.parseXML((xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml) ||
                            $(xmlDoc.body).html());
            },
            'iframe script': function (iframe) {
                return iframe && $.globalEval($(iframe[0].body).text());
            }
        }
    });

}));

/*
 * jQuery File Upload Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* jshint nomen:false */
/* global define, require, window, document, location, Blob, FormData */

;(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'jquery-ui/widget'
        ], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS:
        factory(
            require('jquery'),
            require('./vendor/jquery.ui.widget')
        );
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    // Detect file input support, based on
    // http://viljamis.com/blog/2012/file-upload-support-on-mobile/
    $.support.fileInput = !(new RegExp(
        // Handle devices which give false positives for the feature detection:
        '(Android (1\\.[0156]|2\\.[01]))' +
            '|(Windows Phone (OS 7|8\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' +
            '|(w(eb)?OSBrowser)|(webOS)' +
            '|(Kindle/(1\\.0|2\\.[05]|3\\.0))'
    ).test(window.navigator.userAgent) ||
        // Feature detection for all other devices:
        $('<input type="file">').prop('disabled'));

    // The FileReader API is not actually used, but works as feature detection,
    // as some Safari versions (5?) support XHR file uploads via the FormData API,
    // but not non-multipart XHR file uploads.
    // window.XMLHttpRequestUpload is not available on IE10, so we check for
    // window.ProgressEvent instead to detect XHR2 file upload capability:
    $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);
    $.support.xhrFormDataFileUpload = !!window.FormData;

    // Detect support for Blob slicing (required for chunked uploads):
    $.support.blobSlice = window.Blob && (Blob.prototype.slice ||
        Blob.prototype.webkitSlice || Blob.prototype.mozSlice);

    // Helper function to create drag handlers for dragover/dragenter/dragleave:
    function getDragHandler(type) {
        var isDragOver = type === 'dragover';
        return function (e) {
            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
            var dataTransfer = e.dataTransfer;
            if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1 &&
                    this._trigger(
                        type,
                        $.Event(type, {delegatedEvent: e})
                    ) !== false) {
                e.preventDefault();
                if (isDragOver) {
                    dataTransfer.dropEffect = 'copy';
                }
            }
        };
    }

    // The fileupload widget listens for change events on file input fields defined
    // via fileInput setting and paste or drop events of the given dropZone.
    // In addition to the default jQuery Widget methods, the fileupload widget
    // exposes the "add" and "send" methods, to add or directly send files using
    // the fileupload API.
    // By default, files added via file input selection, paste, drag & drop or
    // "add" method are uploaded immediately, but it is possible to override
    // the "add" callback option to queue file uploads.
    $.widget('blueimp.fileupload', {

        options: {
            // The drop target element(s), by the default the complete document.
            // Set to null to disable drag & drop support:
            dropZone: $(document),
            // The paste target element(s), by the default undefined.
            // Set to a DOM node or jQuery object to enable file pasting:
            pasteZone: undefined,
            // The file input field(s), that are listened to for change events.
            // If undefined, it is set to the file input fields inside
            // of the widget element on plugin initialization.
            // Set to null to disable the change listener.
            fileInput: undefined,
            // By default, the file input field is replaced with a clone after
            // each input field change event. This is required for iframe transport
            // queues and allows change events to be fired for the same file
            // selection, but can be disabled by setting the following option to false:
            replaceFileInput: true,
            // The parameter name for the file form data (the request argument name).
            // If undefined or empty, the name property of the file input field is
            // used, or "files[]" if the file input name property is also empty,
            // can be a string or an array of strings:
            paramName: undefined,
            // By default, each file of a selection is uploaded using an individual
            // request for XHR type uploads. Set to false to upload file
            // selections in one request each:
            singleFileUploads: true,
            // To limit the number of files uploaded with one XHR request,
            // set the following option to an integer greater than 0:
            limitMultiFileUploads: undefined,
            // The following option limits the number of files uploaded with one
            // XHR request to keep the request size under or equal to the defined
            // limit in bytes:
            limitMultiFileUploadSize: undefined,
            // Multipart file uploads add a number of bytes to each uploaded file,
            // therefore the following option adds an overhead for each file used
            // in the limitMultiFileUploadSize configuration:
            limitMultiFileUploadSizeOverhead: 512,
            // Set the following option to true to issue all file upload requests
            // in a sequential order:
            sequentialUploads: false,
            // To limit the number of concurrent uploads,
            // set the following option to an integer greater than 0:
            limitConcurrentUploads: undefined,
            // Set the following option to true to force iframe transport uploads:
            forceIframeTransport: false,
            // Set the following option to the location of a redirect url on the
            // origin server, for cross-domain iframe transport uploads:
            redirect: undefined,
            // The parameter name for the redirect url, sent as part of the form
            // data and set to 'redirect' if this option is empty:
            redirectParamName: undefined,
            // Set the following option to the location of a postMessage window,
            // to enable postMessage transport uploads:
            postMessage: undefined,
            // By default, XHR file uploads are sent as multipart/form-data.
            // The iframe transport is always using multipart/form-data.
            // Set to false to enable non-multipart XHR uploads:
            multipart: true,
            // To upload large files in smaller chunks, set the following option
            // to a preferred maximum chunk size. If set to 0, null or undefined,
            // or the browser does not support the required Blob API, files will
            // be uploaded as a whole.
            maxChunkSize: undefined,
            // When a non-multipart upload or a chunked multipart upload has been
            // aborted, this option can be used to resume the upload by setting
            // it to the size of the already uploaded bytes. This option is most
            // useful when modifying the options object inside of the "add" or
            // "send" callbacks, as the options are cloned for each file upload.
            uploadedBytes: undefined,
            // By default, failed (abort or error) file uploads are removed from the
            // global progress calculation. Set the following option to false to
            // prevent recalculating the global progress data:
            recalculateProgress: true,
            // Interval in milliseconds to calculate and trigger progress events:
            progressInterval: 100,
            // Interval in milliseconds to calculate progress bitrate:
            bitrateInterval: 500,
            // By default, uploads are started automatically when adding files:
            autoUpload: true,

            // Error and info messages:
            messages: {
                uploadedBytes: 'Uploaded bytes exceed file size'
            },

            // Translation function, gets the message key to be translated
            // and an object with context specific data as arguments:
            i18n: function (message, context) {
                message = this.messages[message] || message.toString();
                if (context) {
                    $.each(context, function (key, value) {
                        message = message.replace('{' + key + '}', value);
                    });
                }
                return message;
            },

            // Additional form data to be sent along with the file uploads can be set
            // using this option, which accepts an array of objects with name and
            // value properties, a function returning such an array, a FormData
            // object (for XHR file uploads), or a simple object.
            // The form of the first fileInput is given as parameter to the function:
            formData: function (form) {
                return form.serializeArray();
            },

            // The add callback is invoked as soon as files are added to the fileupload
            // widget (via file input selection, drag & drop, paste or add API call).
            // If the singleFileUploads option is enabled, this callback will be
            // called once for each file in the selection for XHR file uploads, else
            // once for each file selection.
            //
            // The upload starts when the submit method is invoked on the data parameter.
            // The data object contains a files property holding the added files
            // and allows you to override plugin options as well as define ajax settings.
            //
            // Listeners for this callback can also be bound the following way:
            // .bind('fileuploadadd', func);
            //
            // data.submit() returns a Promise object and allows to attach additional
            // handlers using jQuery's Deferred callbacks:
            // data.submit().done(func).fail(func).always(func);
            add: function (e, data) {
                if (e.isDefaultPrevented()) {
                    return false;
                }
                if (data.autoUpload || (data.autoUpload !== false &&
                        $(this).fileupload('option', 'autoUpload'))) {
                    data.process().done(function () {
                        data.submit();
                    });
                }
            },

            // Other callbacks:

            // Callback for the submit event of each file upload:
            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);

            // Callback for the start of each file upload request:
            // send: function (e, data) {}, // .bind('fileuploadsend', func);

            // Callback for successful uploads:
            // done: function (e, data) {}, // .bind('fileuploaddone', func);

            // Callback for failed (abort or error) uploads:
            // fail: function (e, data) {}, // .bind('fileuploadfail', func);

            // Callback for completed (success, abort or error) requests:
            // always: function (e, data) {}, // .bind('fileuploadalways', func);

            // Callback for upload progress events:
            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);

            // Callback for global upload progress events:
            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);

            // Callback for uploads start, equivalent to the global ajaxStart event:
            // start: function (e) {}, // .bind('fileuploadstart', func);

            // Callback for uploads stop, equivalent to the global ajaxStop event:
            // stop: function (e) {}, // .bind('fileuploadstop', func);

            // Callback for change events of the fileInput(s):
            // change: function (e, data) {}, // .bind('fileuploadchange', func);

            // Callback for paste events to the pasteZone(s):
            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);

            // Callback for drop events of the dropZone(s):
            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);

            // Callback for dragover events of the dropZone(s):
            // dragover: function (e) {}, // .bind('fileuploaddragover', func);

            // Callback for the start of each chunk upload request:
            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);

            // Callback for successful chunk uploads:
            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);

            // Callback for failed (abort or error) chunk uploads:
            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);

            // Callback for completed (success, abort or error) chunk upload requests:
            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);

            // The plugin options are used as settings object for the ajax calls.
            // The following are jQuery ajax settings required for the file uploads:
            processData: false,
            contentType: false,
            cache: false,
            timeout: 0
        },

        // A list of options that require reinitializing event listeners and/or
        // special initialization code:
        _specialOptions: [
            'fileInput',
            'dropZone',
            'pasteZone',
            'multipart',
            'forceIframeTransport'
        ],

        _blobSlice: $.support.blobSlice && function () {
            var slice = this.slice || this.webkitSlice || this.mozSlice;
            return slice.apply(this, arguments);
        },

        _BitrateTimer: function () {
            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());
            this.loaded = 0;
            this.bitrate = 0;
            this.getBitrate = function (now, loaded, interval) {
                var timeDiff = now - this.timestamp;
                if (!this.bitrate || !interval || timeDiff > interval) {
                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
                    this.loaded = loaded;
                    this.timestamp = now;
                }
                return this.bitrate;
            };
        },

        _isXHRUpload: function (options) {
            return !options.forceIframeTransport &&
                ((!options.multipart && $.support.xhrFileUpload) ||
                $.support.xhrFormDataFileUpload);
        },

        _getFormData: function (options) {
            var formData;
            if ($.type(options.formData) === 'function') {
                return options.formData(options.form);
            }
            if ($.isArray(options.formData)) {
                return options.formData;
            }
            if ($.type(options.formData) === 'object') {
                formData = [];
                $.each(options.formData, function (name, value) {
                    formData.push({name: name, value: value});
                });
                return formData;
            }
            return [];
        },

        _getTotal: function (files) {
            var total = 0;
            $.each(files, function (index, file) {
                total += file.size || 1;
            });
            return total;
        },

        _initProgressObject: function (obj) {
            var progress = {
                loaded: 0,
                total: 0,
                bitrate: 0
            };
            if (obj._progress) {
                $.extend(obj._progress, progress);
            } else {
                obj._progress = progress;
            }
        },

        _initResponseObject: function (obj) {
            var prop;
            if (obj._response) {
                for (prop in obj._response) {
                    if (obj._response.hasOwnProperty(prop)) {
                        delete obj._response[prop];
                    }
                }
            } else {
                obj._response = {};
            }
        },

        _onProgress: function (e, data) {
            if (e.lengthComputable) {
                var now = ((Date.now) ? Date.now() : (new Date()).getTime()),
                    loaded;
                if (data._time && data.progressInterval &&
                        (now - data._time < data.progressInterval) &&
                        e.loaded !== e.total) {
                    return;
                }
                data._time = now;
                loaded = Math.floor(
                    e.loaded / e.total * (data.chunkSize || data._progress.total)
                ) + (data.uploadedBytes || 0);
                // Add the difference from the previously loaded state
                // to the global loaded counter:
                this._progress.loaded += (loaded - data._progress.loaded);
                this._progress.bitrate = this._bitrateTimer.getBitrate(
                    now,
                    this._progress.loaded,
                    data.bitrateInterval
                );
                data._progress.loaded = data.loaded = loaded;
                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(
                    now,
                    loaded,
                    data.bitrateInterval
                );
                // Trigger a custom progress event with a total data property set
                // to the file size(s) of the current upload and a loaded data
                // property calculated accordingly:
                this._trigger(
                    'progress',
                    $.Event('progress', {delegatedEvent: e}),
                    data
                );
                // Trigger a global progress event for all current file uploads,
                // including ajax calls queued for sequential file uploads:
                this._trigger(
                    'progressall',
                    $.Event('progressall', {delegatedEvent: e}),
                    this._progress
                );
            }
        },

        _initProgressListener: function (options) {
            var that = this,
                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
            // Accesss to the native XHR object is required to add event listeners
            // for the upload progress event:
            if (xhr.upload) {
                $(xhr.upload).bind('progress', function (e) {
                    var oe = e.originalEvent;
                    // Make sure the progress event properties get copied over:
                    e.lengthComputable = oe.lengthComputable;
                    e.loaded = oe.loaded;
                    e.total = oe.total;
                    that._onProgress(e, options);
                });
                options.xhr = function () {
                    return xhr;
                };
            }
        },

        _isInstanceOf: function (type, obj) {
            // Cross-frame instanceof check
            return Object.prototype.toString.call(obj) === '[object ' + type + ']';
        },

        _initXHRData: function (options) {
            var that = this,
                formData,
                file = options.files[0],
                // Ignore non-multipart setting if not supported:
                multipart = options.multipart || !$.support.xhrFileUpload,
                paramName = $.type(options.paramName) === 'array' ?
                    options.paramName[0] : options.paramName;
            options.headers = $.extend({}, options.headers);
            if (options.contentRange) {
                options.headers['Content-Range'] = options.contentRange;
            }
            if (!multipart || options.blob || !this._isInstanceOf('File', file)) {
                options.headers['Content-Disposition'] = 'attachment; filename="' +
                    encodeURI(file.name) + '"';
            }
            if (!multipart) {
                options.contentType = file.type || 'application/octet-stream';
                options.data = options.blob || file;
            } else if ($.support.xhrFormDataFileUpload) {
                if (options.postMessage) {
                    // window.postMessage does not allow sending FormData
                    // objects, so we just add the File/Blob objects to
                    // the formData array and let the postMessage window
                    // create the FormData object out of this array:
                    formData = this._getFormData(options);
                    if (options.blob) {
                        formData.push({
                            name: paramName,
                            value: options.blob
                        });
                    } else {
                        $.each(options.files, function (index, file) {
                            formData.push({
                                name: ($.type(options.paramName) === 'array' &&
                                    options.paramName[index]) || paramName,
                                value: file
                            });
                        });
                    }
                } else {
                    if (that._isInstanceOf('FormData', options.formData)) {
                        formData = options.formData;
                    } else {
                        formData = new FormData();
                        $.each(this._getFormData(options), function (index, field) {
                            formData.append(field.name, field.value);
                        });
                    }
                    if (options.blob) {
                        formData.append(paramName, options.blob, file.name);
                    } else {
                        $.each(options.files, function (index, file) {
                            // This check allows the tests to run with
                            // dummy objects:
                            if (that._isInstanceOf('File', file) ||
                                    that._isInstanceOf('Blob', file)) {
                                formData.append(
                                    ($.type(options.paramName) === 'array' &&
                                        options.paramName[index]) || paramName,
                                    file,
                                    file.uploadName || file.name
                                );
                            }
                        });
                    }
                }
                options.data = formData;
            }
            // Blob reference is not needed anymore, free memory:
            options.blob = null;
        },

        _initIframeSettings: function (options) {
            var targetHost = $('<a></a>').prop('href', options.url).prop('host');
            // Setting the dataType to iframe enables the iframe transport:
            options.dataType = 'iframe ' + (options.dataType || '');
            // The iframe transport accepts a serialized array as form data:
            options.formData = this._getFormData(options);
            // Add redirect url to form data on cross-domain uploads:
            if (options.redirect && targetHost && targetHost !== location.host) {
                options.formData.push({
                    name: options.redirectParamName || 'redirect',
                    value: options.redirect
                });
            }
        },

        _initDataSettings: function (options) {
            if (this._isXHRUpload(options)) {
                if (!this._chunkedUpload(options, true)) {
                    if (!options.data) {
                        this._initXHRData(options);
                    }
                    this._initProgressListener(options);
                }
                if (options.postMessage) {
                    // Setting the dataType to postmessage enables the
                    // postMessage transport:
                    options.dataType = 'postmessage ' + (options.dataType || '');
                }
            } else {
                this._initIframeSettings(options);
            }
        },

        _getParamName: function (options) {
            var fileInput = $(options.fileInput),
                paramName = options.paramName;
            if (!paramName) {
                paramName = [];
                fileInput.each(function () {
                    var input = $(this),
                        name = input.prop('name') || 'files[]',
                        i = (input.prop('files') || [1]).length;
                    while (i) {
                        paramName.push(name);
                        i -= 1;
                    }
                });
                if (!paramName.length) {
                    paramName = [fileInput.prop('name') || 'files[]'];
                }
            } else if (!$.isArray(paramName)) {
                paramName = [paramName];
            }
            return paramName;
        },

        _initFormSettings: function (options) {
            // Retrieve missing options from the input field and the
            // associated form, if available:
            if (!options.form || !options.form.length) {
                options.form = $(options.fileInput.prop('form'));
                // If the given file input doesn't have an associated form,
                // use the default widget file input's form:
                if (!options.form.length) {
                    options.form = $(this.options.fileInput.prop('form'));
                }
            }
            options.paramName = this._getParamName(options);
            if (!options.url) {
                options.url = options.form.prop('action') || location.href;
            }
            // The HTTP request method must be "POST" or "PUT":
            options.type = (options.type ||
                ($.type(options.form.prop('method')) === 'string' &&
                    options.form.prop('method')) || ''
                ).toUpperCase();
            if (options.type !== 'POST' && options.type !== 'PUT' &&
                    options.type !== 'PATCH') {
                options.type = 'POST';
            }
            if (!options.formAcceptCharset) {
                options.formAcceptCharset = options.form.attr('accept-charset');
            }
        },

        _getAJAXSettings: function (data) {
            var options = $.extend({}, this.options, data);
            this._initFormSettings(options);
            this._initDataSettings(options);
            return options;
        },

        // jQuery 1.6 doesn't provide .state(),
        // while jQuery 1.8+ removed .isRejected() and .isResolved():
        _getDeferredState: function (deferred) {
            if (deferred.state) {
                return deferred.state();
            }
            if (deferred.isResolved()) {
                return 'resolved';
            }
            if (deferred.isRejected()) {
                return 'rejected';
            }
            return 'pending';
        },

        // Maps jqXHR callbacks to the equivalent
        // methods of the given Promise object:
        _enhancePromise: function (promise) {
            promise.success = promise.done;
            promise.error = promise.fail;
            promise.complete = promise.always;
            return promise;
        },

        // Creates and returns a Promise object enhanced with
        // the jqXHR methods abort, success, error and complete:
        _getXHRPromise: function (resolveOrReject, context, args) {
            var dfd = $.Deferred(),
                promise = dfd.promise();
            context = context || this.options.context || promise;
            if (resolveOrReject === true) {
                dfd.resolveWith(context, args);
            } else if (resolveOrReject === false) {
                dfd.rejectWith(context, args);
            }
            promise.abort = dfd.promise;
            return this._enhancePromise(promise);
        },

        // Adds convenience methods to the data callback argument:
        _addConvenienceMethods: function (e, data) {
            var that = this,
                getPromise = function (args) {
                    return $.Deferred().resolveWith(that, args).promise();
                };
            data.process = function (resolveFunc, rejectFunc) {
                if (resolveFunc || rejectFunc) {
                    data._processQueue = this._processQueue =
                        (this._processQueue || getPromise([this])).then(
                            function () {
                                if (data.errorThrown) {
                                    return $.Deferred()
                                        .rejectWith(that, [data]).promise();
                                }
                                return getPromise(arguments);
                            }
                        ).then(resolveFunc, rejectFunc);
                }
                return this._processQueue || getPromise([this]);
            };
            data.submit = function () {
                if (this.state() !== 'pending') {
                    data.jqXHR = this.jqXHR =
                        (that._trigger(
                            'submit',
                            $.Event('submit', {delegatedEvent: e}),
                            this
                        ) !== false) && that._onSend(e, this);
                }
                return this.jqXHR || that._getXHRPromise();
            };
            data.abort = function () {
                if (this.jqXHR) {
                    return this.jqXHR.abort();
                }
                this.errorThrown = 'abort';
                that._trigger('fail', null, this);
                return that._getXHRPromise(false);
            };
            data.state = function () {
                if (this.jqXHR) {
                    return that._getDeferredState(this.jqXHR);
                }
                if (this._processQueue) {
                    return that._getDeferredState(this._processQueue);
                }
            };
            data.processing = function () {
                return !this.jqXHR && this._processQueue && that
                    ._getDeferredState(this._processQueue) === 'pending';
            };
            data.progress = function () {
                return this._progress;
            };
            data.response = function () {
                return this._response;
            };
        },

        // Parses the Range header from the server response
        // and returns the uploaded bytes:
        _getUploadedBytes: function (jqXHR) {
            var range = jqXHR.getResponseHeader('Range'),
                parts = range && range.split('-'),
                upperBytesPos = parts && parts.length > 1 &&
                    parseInt(parts[1], 10);
            return upperBytesPos && upperBytesPos + 1;
        },

        // Uploads a file in multiple, sequential requests
        // by splitting the file up in multiple blob chunks.
        // If the second parameter is true, only tests if the file
        // should be uploaded in chunks, but does not invoke any
        // upload requests:
        _chunkedUpload: function (options, testOnly) {
            options.uploadedBytes = options.uploadedBytes || 0;
            var that = this,
                file = options.files[0],
                fs = file.size,
                ub = options.uploadedBytes,
                mcs = options.maxChunkSize || fs,
                slice = this._blobSlice,
                dfd = $.Deferred(),
                promise = dfd.promise(),
                jqXHR,
                upload;
            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||
                    options.data) {
                return false;
            }
            if (testOnly) {
                return true;
            }
            if (ub >= fs) {
                file.error = options.i18n('uploadedBytes');
                return this._getXHRPromise(
                    false,
                    options.context,
                    [null, 'error', file.error]
                );
            }
            // The chunk upload method:
            upload = function () {
                // Clone the options object for each chunk upload:
                var o = $.extend({}, options),
                    currentLoaded = o._progress.loaded;
                o.blob = slice.call(
                    file,
                    ub,
                    ub + mcs,
                    file.type
                );
                // Store the current chunk size, as the blob itself
                // will be dereferenced after data processing:
                o.chunkSize = o.blob.size;
                // Expose the chunk bytes position range:
                o.contentRange = 'bytes ' + ub + '-' +
                    (ub + o.chunkSize - 1) + '/' + fs;
                // Process the upload data (the blob and potential form data):
                that._initXHRData(o);
                // Add progress listeners for this chunk upload:
                that._initProgressListener(o);
                jqXHR = ((that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||
                        that._getXHRPromise(false, o.context))
                    .done(function (result, textStatus, jqXHR) {
                        ub = that._getUploadedBytes(jqXHR) ||
                            (ub + o.chunkSize);
                        // Create a progress event if no final progress event
                        // with loaded equaling total has been triggered
                        // for this chunk:
                        if (currentLoaded + o.chunkSize - o._progress.loaded) {
                            that._onProgress($.Event('progress', {
                                lengthComputable: true,
                                loaded: ub - o.uploadedBytes,
                                total: ub - o.uploadedBytes
                            }), o);
                        }
                        options.uploadedBytes = o.uploadedBytes = ub;
                        o.result = result;
                        o.textStatus = textStatus;
                        o.jqXHR = jqXHR;
                        that._trigger('chunkdone', null, o);
                        that._trigger('chunkalways', null, o);
                        if (ub < fs) {
                            // File upload not yet complete,
                            // continue with the next chunk:
                            upload();
                        } else {
                            dfd.resolveWith(
                                o.context,
                                [result, textStatus, jqXHR]
                            );
                        }
                    })
                    .fail(function (jqXHR, textStatus, errorThrown) {
                        o.jqXHR = jqXHR;
                        o.textStatus = textStatus;
                        o.errorThrown = errorThrown;
                        that._trigger('chunkfail', null, o);
                        that._trigger('chunkalways', null, o);
                        dfd.rejectWith(
                            o.context,
                            [jqXHR, textStatus, errorThrown]
                        );
                    });
            };
            this._enhancePromise(promise);
            promise.abort = function () {
                return jqXHR.abort();
            };
            upload();
            return promise;
        },

        _beforeSend: function (e, data) {
            if (this._active === 0) {
                // the start callback is triggered when an upload starts
                // and no other uploads are currently running,
                // equivalent to the global ajaxStart event:
                this._trigger('start');
                // Set timer for global bitrate progress calculation:
                this._bitrateTimer = new this._BitrateTimer();
                // Reset the global progress values:
                this._progress.loaded = this._progress.total = 0;
                this._progress.bitrate = 0;
            }
            // Make sure the container objects for the .response() and
            // .progress() methods on the data object are available
            // and reset to their initial state:
            this._initResponseObject(data);
            this._initProgressObject(data);
            data._progress.loaded = data.loaded = data.uploadedBytes || 0;
            data._progress.total = data.total = this._getTotal(data.files) || 1;
            data._progress.bitrate = data.bitrate = 0;
            this._active += 1;
            // Initialize the global progress values:
            this._progress.loaded += data.loaded;
            this._progress.total += data.total;
        },

        _onDone: function (result, textStatus, jqXHR, options) {
            var total = options._progress.total,
                response = options._response;
            if (options._progress.loaded < total) {
                // Create a progress event if no final progress event
                // with loaded equaling total has been triggered:
                this._onProgress($.Event('progress', {
                    lengthComputable: true,
                    loaded: total,
                    total: total
                }), options);
            }
            response.result = options.result = result;
            response.textStatus = options.textStatus = textStatus;
            response.jqXHR = options.jqXHR = jqXHR;
            this._trigger('done', null, options);
        },

        _onFail: function (jqXHR, textStatus, errorThrown, options) {
            var response = options._response;
            if (options.recalculateProgress) {
                // Remove the failed (error or abort) file upload from
                // the global progress calculation:
                this._progress.loaded -= options._progress.loaded;
                this._progress.total -= options._progress.total;
            }
            response.jqXHR = options.jqXHR = jqXHR;
            response.textStatus = options.textStatus = textStatus;
            response.errorThrown = options.errorThrown = errorThrown;
            this._trigger('fail', null, options);
        },

        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
            // jqXHRorResult, textStatus and jqXHRorError are added to the
            // options object via done and fail callbacks
            this._trigger('always', null, options);
        },

        _onSend: function (e, data) {
            if (!data.submit) {
                this._addConvenienceMethods(e, data);
            }
            var that = this,
                jqXHR,
                aborted,
                slot,
                pipe,
                options = that._getAJAXSettings(data),
                send = function () {
                    that._sending += 1;
                    // Set timer for bitrate progress calculation:
                    options._bitrateTimer = new that._BitrateTimer();
                    jqXHR = jqXHR || (
                        ((aborted || that._trigger(
                            'send',
                            $.Event('send', {delegatedEvent: e}),
                            options
                        ) === false) &&
                        that._getXHRPromise(false, options.context, aborted)) ||
                        that._chunkedUpload(options) || $.ajax(options)
                    ).done(function (result, textStatus, jqXHR) {
                        that._onDone(result, textStatus, jqXHR, options);
                    }).fail(function (jqXHR, textStatus, errorThrown) {
                        that._onFail(jqXHR, textStatus, errorThrown, options);
                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {
                        that._onAlways(
                            jqXHRorResult,
                            textStatus,
                            jqXHRorError,
                            options
                        );
                        that._sending -= 1;
                        that._active -= 1;
                        if (options.limitConcurrentUploads &&
                                options.limitConcurrentUploads > that._sending) {
                            // Start the next queued upload,
                            // that has not been aborted:
                            var nextSlot = that._slots.shift();
                            while (nextSlot) {
                                if (that._getDeferredState(nextSlot) === 'pending') {
                                    nextSlot.resolve();
                                    break;
                                }
                                nextSlot = that._slots.shift();
                            }
                        }
                        if (that._active === 0) {
                            // The stop callback is triggered when all uploads have
                            // been completed, equivalent to the global ajaxStop event:
                            that._trigger('stop');
                        }
                    });
                    return jqXHR;
                };
            this._beforeSend(e, options);
            if (this.options.sequentialUploads ||
                    (this.options.limitConcurrentUploads &&
                    this.options.limitConcurrentUploads <= this._sending)) {
                if (this.options.limitConcurrentUploads > 1) {
                    slot = $.Deferred();
                    this._slots.push(slot);
                    pipe = slot.then(send);
                } else {
                    this._sequence = this._sequence.then(send, send);
                    pipe = this._sequence;
                }
                // Return the piped Promise object, enhanced with an abort method,
                // which is delegated to the jqXHR object of the current upload,
                // and jqXHR callbacks mapped to the equivalent Promise methods:
                pipe.abort = function () {
                    aborted = [undefined, 'abort', 'abort'];
                    if (!jqXHR) {
                        if (slot) {
                            slot.rejectWith(options.context, aborted);
                        }
                        return send();
                    }
                    return jqXHR.abort();
                };
                return this._enhancePromise(pipe);
            }
            return send();
        },

        _onAdd: function (e, data) {
            var that = this,
                result = true,
                options = $.extend({}, this.options, data),
                files = data.files,
                filesLength = files.length,
                limit = options.limitMultiFileUploads,
                limitSize = options.limitMultiFileUploadSize,
                overhead = options.limitMultiFileUploadSizeOverhead,
                batchSize = 0,
                paramName = this._getParamName(options),
                paramNameSet,
                paramNameSlice,
                fileSet,
                i,
                j = 0;
            if (!filesLength) {
                return false;
            }
            if (limitSize && files[0].size === undefined) {
                limitSize = undefined;
            }
            if (!(options.singleFileUploads || limit || limitSize) ||
                    !this._isXHRUpload(options)) {
                fileSet = [files];
                paramNameSet = [paramName];
            } else if (!(options.singleFileUploads || limitSize) && limit) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < filesLength; i += limit) {
                    fileSet.push(files.slice(i, i + limit));
                    paramNameSlice = paramName.slice(i, i + limit);
                    if (!paramNameSlice.length) {
                        paramNameSlice = paramName;
                    }
                    paramNameSet.push(paramNameSlice);
                }
            } else if (!options.singleFileUploads && limitSize) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < filesLength; i = i + 1) {
                    batchSize += files[i].size + overhead;
                    if (i + 1 === filesLength ||
                            ((batchSize + files[i + 1].size + overhead) > limitSize) ||
                            (limit && i + 1 - j >= limit)) {
                        fileSet.push(files.slice(j, i + 1));
                        paramNameSlice = paramName.slice(j, i + 1);
                        if (!paramNameSlice.length) {
                            paramNameSlice = paramName;
                        }
                        paramNameSet.push(paramNameSlice);
                        j = i + 1;
                        batchSize = 0;
                    }
                }
            } else {
                paramNameSet = paramName;
            }
            data.originalFiles = files;
            $.each(fileSet || files, function (index, element) {
                var newData = $.extend({}, data);
                newData.files = fileSet ? element : [element];
                newData.paramName = paramNameSet[index];
                that._initResponseObject(newData);
                that._initProgressObject(newData);
                that._addConvenienceMethods(e, newData);
                result = that._trigger(
                    'add',
                    $.Event('add', {delegatedEvent: e}),
                    newData
                );
                return result;
            });
            return result;
        },

        _replaceFileInput: function (data) {
            var input = data.fileInput,
                inputClone = input.clone(true),
                restoreFocus = input.is(document.activeElement);
            // Add a reference for the new cloned file input to the data argument:
            data.fileInputClone = inputClone;
            $('<form></form>').append(inputClone)[0].reset();
            // Detaching allows to insert the fileInput on another form
            // without loosing the file input value:
            input.after(inputClone).detach();
            // If the fileInput had focus before it was detached,
            // restore focus to the inputClone.
            if (restoreFocus) {
                inputClone.focus();
            }
            // Avoid memory leaks with the detached file input:
            $.cleanData(input.unbind('remove'));
            // Replace the original file input element in the fileInput
            // elements set with the clone, which has been copied including
            // event handlers:
            this.options.fileInput = this.options.fileInput.map(function (i, el) {
                if (el === input[0]) {
                    return inputClone[0];
                }
                return el;
            });
            // If the widget has been initialized on the file input itself,
            // override this.element with the file input clone:
            if (input[0] === this.element[0]) {
                this.element = inputClone;
            }
        },

        _handleFileTreeEntry: function (entry, path) {
            var that = this,
                dfd = $.Deferred(),
                entries = [],
                dirReader,
                errorHandler = function (e) {
                    if (e && !e.entry) {
                        e.entry = entry;
                    }
                    // Since $.when returns immediately if one
                    // Deferred is rejected, we use resolve instead.
                    // This allows valid files and invalid items
                    // to be returned together in one set:
                    dfd.resolve([e]);
                },
                successHandler = function (entries) {
                    that._handleFileTreeEntries(
                        entries,
                        path + entry.name + '/'
                    ).done(function (files) {
                        dfd.resolve(files);
                    }).fail(errorHandler);
                },
                readEntries = function () {
                    dirReader.readEntries(function (results) {
                        if (!results.length) {
                            successHandler(entries);
                        } else {
                            entries = entries.concat(results);
                            readEntries();
                        }
                    }, errorHandler);
                };
            path = path || '';
            if (entry.isFile) {
                if (entry._file) {
                    // Workaround for Chrome bug #149735
                    entry._file.relativePath = path;
                    dfd.resolve(entry._file);
                } else {
                    entry.file(function (file) {
                        file.relativePath = path;
                        dfd.resolve(file);
                    }, errorHandler);
                }
            } else if (entry.isDirectory) {
                dirReader = entry.createReader();
                readEntries();
            } else {
                // Return an empy list for file system items
                // other than files or directories:
                dfd.resolve([]);
            }
            return dfd.promise();
        },

        _handleFileTreeEntries: function (entries, path) {
            var that = this;
            return $.when.apply(
                $,
                $.map(entries, function (entry) {
                    return that._handleFileTreeEntry(entry, path);
                })
            ).then(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _getDroppedFiles: function (dataTransfer) {
            dataTransfer = dataTransfer || {};
            var items = dataTransfer.items;
            if (items && items.length && (items[0].webkitGetAsEntry ||
                    items[0].getAsEntry)) {
                return this._handleFileTreeEntries(
                    $.map(items, function (item) {
                        var entry;
                        if (item.webkitGetAsEntry) {
                            entry = item.webkitGetAsEntry();
                            if (entry) {
                                // Workaround for Chrome bug #149735:
                                entry._file = item.getAsFile();
                            }
                            return entry;
                        }
                        return item.getAsEntry();
                    })
                );
            }
            return $.Deferred().resolve(
                $.makeArray(dataTransfer.files)
            ).promise();
        },

        _getSingleFileInputFiles: function (fileInput) {
            fileInput = $(fileInput);
            var entries = fileInput.prop('webkitEntries') ||
                    fileInput.prop('entries'),
                files,
                value;
            if (entries && entries.length) {
                return this._handleFileTreeEntries(entries);
            }
            files = $.makeArray(fileInput.prop('files'));
            if (!files.length) {
                value = fileInput.prop('value');
                if (!value) {
                    return $.Deferred().resolve([]).promise();
                }
                // If the files property is not available, the browser does not
                // support the File API and we add a pseudo File object with
                // the input value as name with path information removed:
                files = [{name: value.replace(/^.*\\/, '')}];
            } else if (files[0].name === undefined && files[0].fileName) {
                // File normalization for Safari 4 and Firefox 3:
                $.each(files, function (index, file) {
                    file.name = file.fileName;
                    file.size = file.fileSize;
                });
            }
            return $.Deferred().resolve(files).promise();
        },

        _getFileInputFiles: function (fileInput) {
            if (!(fileInput instanceof $) || fileInput.length === 1) {
                return this._getSingleFileInputFiles(fileInput);
            }
            return $.when.apply(
                $,
                $.map(fileInput, this._getSingleFileInputFiles)
            ).then(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _onChange: function (e) {
            var that = this,
                data = {
                    fileInput: $(e.target),
                    form: $(e.target.form)
                };
            this._getFileInputFiles(data.fileInput).always(function (files) {
                data.files = files;
                if (that.options.replaceFileInput) {
                    that._replaceFileInput(data);
                }
                if (that._trigger(
                        'change',
                        $.Event('change', {delegatedEvent: e}),
                        data
                    ) !== false) {
                    that._onAdd(e, data);
                }
            });
        },

        _onPaste: function (e) {
            var items = e.originalEvent && e.originalEvent.clipboardData &&
                    e.originalEvent.clipboardData.items,
                data = {files: []};
            if (items && items.length) {
                $.each(items, function (index, item) {
                    var file = item.getAsFile && item.getAsFile();
                    if (file) {
                        data.files.push(file);
                    }
                });
                if (this._trigger(
                        'paste',
                        $.Event('paste', {delegatedEvent: e}),
                        data
                    ) !== false) {
                    this._onAdd(e, data);
                }
            }
        },

        _onDrop: function (e) {
            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
            var that = this,
                dataTransfer = e.dataTransfer,
                data = {};
            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                e.preventDefault();
                this._getDroppedFiles(dataTransfer).always(function (files) {
                    data.files = files;
                    if (that._trigger(
                            'drop',
                            $.Event('drop', {delegatedEvent: e}),
                            data
                        ) !== false) {
                        that._onAdd(e, data);
                    }
                });
            }
        },

        _onDragOver: getDragHandler('dragover'),

        _onDragEnter: getDragHandler('dragenter'),

        _onDragLeave: getDragHandler('dragleave'),

        _initEventHandlers: function () {
            if (this._isXHRUpload(this.options)) {
                this._on(this.options.dropZone, {
                    dragover: this._onDragOver,
                    drop: this._onDrop,
                    // event.preventDefault() on dragenter is required for IE10+:
                    dragenter: this._onDragEnter,
                    // dragleave is not required, but added for completeness:
                    dragleave: this._onDragLeave
                });
                this._on(this.options.pasteZone, {
                    paste: this._onPaste
                });
            }
            if ($.support.fileInput) {
                this._on(this.options.fileInput, {
                    change: this._onChange
                });
            }
        },

        _destroyEventHandlers: function () {
            this._off(this.options.dropZone, 'dragenter dragleave dragover drop');
            this._off(this.options.pasteZone, 'paste');
            this._off(this.options.fileInput, 'change');
        },

        _destroy: function () {
            this._destroyEventHandlers();
        },

        _setOption: function (key, value) {
            var reinit = $.inArray(key, this._specialOptions) !== -1;
            if (reinit) {
                this._destroyEventHandlers();
            }
            this._super(key, value);
            if (reinit) {
                this._initSpecialOptions();
                this._initEventHandlers();
            }
        },

        _initSpecialOptions: function () {
            var options = this.options;
            if (options.fileInput === undefined) {
                options.fileInput = this.element.is('input[type="file"]') ?
                        this.element : this.element.find('input[type="file"]');
            } else if (!(options.fileInput instanceof $)) {
                options.fileInput = $(options.fileInput);
            }
            if (!(options.dropZone instanceof $)) {
                options.dropZone = $(options.dropZone);
            }
            if (!(options.pasteZone instanceof $)) {
                options.pasteZone = $(options.pasteZone);
            }
        },

        _getRegExp: function (str) {
            var parts = str.split('/'),
                modifiers = parts.pop();
            parts.shift();
            return new RegExp(parts.join('/'), modifiers);
        },

        _isRegExpOption: function (key, value) {
            return key !== 'url' && $.type(value) === 'string' &&
                /^\/.*\/[igm]{0,3}$/.test(value);
        },

        _initDataAttributes: function () {
            var that = this,
                options = this.options,
                data = this.element.data();
            // Initialize options set via HTML5 data-attributes:
            $.each(
                this.element[0].attributes,
                function (index, attr) {
                    var key = attr.name.toLowerCase(),
                        value;
                    if (/^data-/.test(key)) {
                        // Convert hyphen-ated key to camelCase:
                        key = key.slice(5).replace(/-[a-z]/g, function (str) {
                            return str.charAt(1).toUpperCase();
                        });
                        value = data[key];
                        if (that._isRegExpOption(key, value)) {
                            value = that._getRegExp(value);
                        }
                        options[key] = value;
                    }
                }
            );
        },

        _create: function () {
            this._initDataAttributes();
            this._initSpecialOptions();
            this._slots = [];
            this._sequence = this._getXHRPromise(true);
            this._sending = this._active = 0;
            this._initProgressObject(this);
            this._initEventHandlers();
        },

        // This method is exposed to the widget API and allows to query
        // the number of active uploads:
        active: function () {
            return this._active;
        },

        // This method is exposed to the widget API and allows to query
        // the widget upload progress.
        // It returns an object with loaded, total and bitrate properties
        // for the running uploads:
        progress: function () {
            return this._progress;
        },

        // This method is exposed to the widget API and allows adding files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files property and can contain additional options:
        // .fileupload('add', {files: filesList});
        add: function (data) {
            var that = this;
            if (!data || this.options.disabled) {
                return;
            }
            if (data.fileInput && !data.files) {
                this._getFileInputFiles(data.fileInput).always(function (files) {
                    data.files = files;
                    that._onAdd(null, data);
                });
            } else {
                data.files = $.makeArray(data.files);
                this._onAdd(null, data);
            }
        },

        // This method is exposed to the widget API and allows sending files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files or fileInput property and can contain additional options:
        // .fileupload('send', {files: filesList});
        // The method returns a Promise object for the file upload call.
        send: function (data) {
            if (data && !this.options.disabled) {
                if (data.fileInput && !data.files) {
                    var that = this,
                        dfd = $.Deferred(),
                        promise = dfd.promise(),
                        jqXHR,
                        aborted;
                    promise.abort = function () {
                        aborted = true;
                        if (jqXHR) {
                            return jqXHR.abort();
                        }
                        dfd.reject(null, 'abort', 'abort');
                        return promise;
                    };
                    this._getFileInputFiles(data.fileInput).always(
                        function (files) {
                            if (aborted) {
                                return;
                            }
                            if (!files.length) {
                                dfd.reject();
                                return;
                            }
                            data.files = files;
                            jqXHR = that._onSend(null, data);
                            jqXHR.then(
                                function (result, textStatus, jqXHR) {
                                    dfd.resolve(result, textStatus, jqXHR);
                                },
                                function (jqXHR, textStatus, errorThrown) {
                                    dfd.reject(jqXHR, textStatus, errorThrown);
                                }
                            );
                        }
                    );
                    return this._enhancePromise(promise);
                }
                data.files = $.makeArray(data.files);
                if (data.files.length) {
                    return this._onSend(null, data);
                }
            }
            return this._getXHRPromise(false, data && data.context);
        }

    });

}));

/* =========================================================
 * bootstrap-datepicker.js
 * Repo: https://github.com/uxsolutions/bootstrap-datepicker/
 * Demo: https://eternicode.github.io/bootstrap-datepicker/
 * Docs: https://bootstrap-datepicker.readthedocs.org/
 * =========================================================
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

(function(factory){
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        factory(require('jquery'));
    } else {
        factory(jQuery);
    }
}(function($, undefined){
	function UTCDate(){
		return new Date(Date.UTC.apply(Date, arguments));
	}
	function UTCToday(){
		var today = new Date();
		return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
	}
	function isUTCEquals(date1, date2) {
		return (
			date1.getUTCFullYear() === date2.getUTCFullYear() &&
			date1.getUTCMonth() === date2.getUTCMonth() &&
			date1.getUTCDate() === date2.getUTCDate()
		);
	}
	function alias(method, deprecationMsg){
		return function(){
			if (deprecationMsg !== undefined) {
				$.fn.datepicker.deprecated(deprecationMsg);
			}

			return this[method].apply(this, arguments);
		};
	}
	function isValidDate(d) {
		return d && !isNaN(d.getTime());
	}

	var DateArray = (function(){
		var extras = {
			get: function(i){
				return this.slice(i)[0];
			},
			contains: function(d){
				// Array.indexOf is not cross-browser;
				// $.inArray doesn't work with Dates
				var val = d && d.valueOf();
				for (var i=0, l=this.length; i < l; i++)
          // Use date arithmetic to allow dates with different times to match
          if (0 <= this[i].valueOf() - val && this[i].valueOf() - val < 1000*60*60*24)
						return i;
				return -1;
			},
			remove: function(i){
				this.splice(i,1);
			},
			replace: function(new_array){
				if (!new_array)
					return;
				if (!$.isArray(new_array))
					new_array = [new_array];
				this.clear();
				this.push.apply(this, new_array);
			},
			clear: function(){
				this.length = 0;
			},
			copy: function(){
				var a = new DateArray();
				a.replace(this);
				return a;
			}
		};

		return function(){
			var a = [];
			a.push.apply(a, arguments);
			$.extend(a, extras);
			return a;
		};
	})();


	// Picker object

	var Datepicker = function(element, options){
		$.data(element, 'datepicker', this);
		this._process_options(options);

		this.dates = new DateArray();
		this.viewDate = this.o.defaultViewDate;
		this.focusDate = null;

		this.element = $(element);
		this.isInput = this.element.is('input');
		this.inputField = this.isInput ? this.element : this.element.find('input');
		this.component = this.element.hasClass('date') ? this.element.find('.add-on, .input-group-addon, .btn') : false;
		if (this.component && this.component.length === 0)
			this.component = false;
		this.isInline = !this.component && this.element.is('div');

		this.picker = $(DPGlobal.template);

		// Checking templates and inserting
		if (this._check_template(this.o.templates.leftArrow)) {
			this.picker.find('.prev').html(this.o.templates.leftArrow);
		}

		if (this._check_template(this.o.templates.rightArrow)) {
			this.picker.find('.next').html(this.o.templates.rightArrow);
		}

		this._buildEvents();
		this._attachEvents();

		if (this.isInline){
			this.picker.addClass('datepicker-inline').appendTo(this.element);
		}
		else {
			this.picker.addClass('datepicker-dropdown dropdown-menu');
		}

		if (this.o.rtl){
			this.picker.addClass('datepicker-rtl');
		}

		if (this.o.calendarWeeks) {
			this.picker.find('.datepicker-days .datepicker-switch, thead .datepicker-title, tfoot .today, tfoot .clear')
				.attr('colspan', function(i, val){
					return Number(val) + 1;
				});
		}

		this._process_options({
			startDate: this._o.startDate,
			endDate: this._o.endDate,
			daysOfWeekDisabled: this.o.daysOfWeekDisabled,
			daysOfWeekHighlighted: this.o.daysOfWeekHighlighted,
			datesDisabled: this.o.datesDisabled
		});

		this._allow_update = false;
		this.setViewMode(this.o.startView);
		this._allow_update = true;

		this.fillDow();
		this.fillMonths();

		this.update();

		if (this.isInline){
			this.show();
		}
	};

	Datepicker.prototype = {
		constructor: Datepicker,

		_resolveViewName: function(view){
			$.each(DPGlobal.viewModes, function(i, viewMode){
				if (view === i || $.inArray(view, viewMode.names) !== -1){
					view = i;
					return false;
				}
			});

			return view;
		},

		_resolveDaysOfWeek: function(daysOfWeek){
			if (!$.isArray(daysOfWeek))
				daysOfWeek = daysOfWeek.split(/[,\s]*/);
			return $.map(daysOfWeek, Number);
		},

		_check_template: function(tmp){
			try {
				// If empty
				if (tmp === undefined || tmp === "") {
					return false;
				}
				// If no html, everything ok
				if ((tmp.match(/[<>]/g) || []).length <= 0) {
					return true;
				}
				// Checking if html is fine
				var jDom = $(tmp);
				return jDom.length > 0;
			}
			catch (ex) {
				return false;
			}
		},

		_process_options: function(opts){
			// Store raw options for reference
			this._o = $.extend({}, this._o, opts);
			// Processed options
			var o = this.o = $.extend({}, this._o);

			// Check if "de-DE" style date is available, if not language should
			// fallback to 2 letter code eg "de"
			var lang = o.language;
			if (!dates[lang]){
				lang = lang.split('-')[0];
				if (!dates[lang])
					lang = defaults.language;
			}
			o.language = lang;

			// Retrieve view index from any aliases
			o.startView = this._resolveViewName(o.startView);
			o.minViewMode = this._resolveViewName(o.minViewMode);
			o.maxViewMode = this._resolveViewName(o.maxViewMode);

			// Check view is between min and max
			o.startView = Math.max(this.o.minViewMode, Math.min(this.o.maxViewMode, o.startView));

			// true, false, or Number > 0
			if (o.multidate !== true){
				o.multidate = Number(o.multidate) || false;
				if (o.multidate !== false)
					o.multidate = Math.max(0, o.multidate);
			}
			o.multidateSeparator = String(o.multidateSeparator);

			o.weekStart %= 7;
			o.weekEnd = (o.weekStart + 6) % 7;

			var format = DPGlobal.parseFormat(o.format);
			if (o.startDate !== -Infinity){
				if (!!o.startDate){
					if (o.startDate instanceof Date)
						o.startDate = this._local_to_utc(this._zero_time(o.startDate));
					else
						o.startDate = DPGlobal.parseDate(o.startDate, format, o.language, o.assumeNearbyYear);
				}
				else {
					o.startDate = -Infinity;
				}
			}
			if (o.endDate !== Infinity){
				if (!!o.endDate){
					if (o.endDate instanceof Date)
						o.endDate = this._local_to_utc(this._zero_time(o.endDate));
					else
						o.endDate = DPGlobal.parseDate(o.endDate, format, o.language, o.assumeNearbyYear);
				}
				else {
					o.endDate = Infinity;
				}
			}

			o.daysOfWeekDisabled = this._resolveDaysOfWeek(o.daysOfWeekDisabled||[]);
			o.daysOfWeekHighlighted = this._resolveDaysOfWeek(o.daysOfWeekHighlighted||[]);

			o.datesDisabled = o.datesDisabled||[];
			if (!$.isArray(o.datesDisabled)) {
				o.datesDisabled = o.datesDisabled.split(',');
			}
			o.datesDisabled = $.map(o.datesDisabled, function(d){
				return DPGlobal.parseDate(d, format, o.language, o.assumeNearbyYear);
			});

			var plc = String(o.orientation).toLowerCase().split(/\s+/g),
				_plc = o.orientation.toLowerCase();
			plc = $.grep(plc, function(word){
				return /^auto|left|right|top|bottom$/.test(word);
			});
			o.orientation = {x: 'auto', y: 'auto'};
			if (!_plc || _plc === 'auto')
				; // no action
			else if (plc.length === 1){
				switch (plc[0]){
					case 'top':
					case 'bottom':
						o.orientation.y = plc[0];
						break;
					case 'left':
					case 'right':
						o.orientation.x = plc[0];
						break;
				}
			}
			else {
				_plc = $.grep(plc, function(word){
					return /^left|right$/.test(word);
				});
				o.orientation.x = _plc[0] || 'auto';

				_plc = $.grep(plc, function(word){
					return /^top|bottom$/.test(word);
				});
				o.orientation.y = _plc[0] || 'auto';
			}
			if (o.defaultViewDate instanceof Date || typeof o.defaultViewDate === 'string') {
				o.defaultViewDate = DPGlobal.parseDate(o.defaultViewDate, format, o.language, o.assumeNearbyYear);
			} else if (o.defaultViewDate) {
				var year = o.defaultViewDate.year || new Date().getFullYear();
				var month = o.defaultViewDate.month || 0;
				var day = o.defaultViewDate.day || 1;
				o.defaultViewDate = UTCDate(year, month, day);
			} else {
				o.defaultViewDate = UTCToday();
			}
		},
		_events: [],
		_secondaryEvents: [],
		_applyEvents: function(evs){
			for (var i=0, el, ch, ev; i < evs.length; i++){
				el = evs[i][0];
				if (evs[i].length === 2){
					ch = undefined;
					ev = evs[i][1];
				} else if (evs[i].length === 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.on(ev, ch);
			}
		},
		_unapplyEvents: function(evs){
			for (var i=0, el, ev, ch; i < evs.length; i++){
				el = evs[i][0];
				if (evs[i].length === 2){
					ch = undefined;
					ev = evs[i][1];
				} else if (evs[i].length === 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.off(ev, ch);
			}
		},
		_buildEvents: function(){
            var events = {
                keyup: $.proxy(function(e){
                    if ($.inArray(e.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) === -1)
                        this.update();
                }, this),
                keydown: $.proxy(this.keydown, this),
                paste: $.proxy(this.paste, this)
            };

            if (this.o.showOnFocus === true) {
                events.focus = $.proxy(this.show, this);
            }

            if (this.isInput) { // single input
                this._events = [
                    [this.element, events]
                ];
            }
            // component: input + button
            else if (this.component && this.inputField.length) {
                this._events = [
                    // For components that are not readonly, allow keyboard nav
                    [this.inputField, events],
                    [this.component, {
                        click: $.proxy(this.show, this)
                    }]
                ];
            }
			else {
				this._events = [
					[this.element, {
						click: $.proxy(this.show, this),
						keydown: $.proxy(this.keydown, this)
					}]
				];
			}
			this._events.push(
				// Component: listen for blur on element descendants
				[this.element, '*', {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}],
				// Input: listen for blur on element
				[this.element, {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}]
			);

			if (this.o.immediateUpdates) {
				// Trigger input updates immediately on changed year/month
				this._events.push([this.element, {
					'changeYear changeMonth': $.proxy(function(e){
						this.update(e.date);
					}, this)
				}]);
			}

			this._secondaryEvents = [
				[this.picker, {
					click: $.proxy(this.click, this)
				}],
				[this.picker, '.prev, .next', {
					click: $.proxy(this.navArrowsClick, this)
				}],
				[this.picker, '.day:not(.disabled)', {
					click: $.proxy(this.dayCellClick, this)
				}],
				[$(window), {
					resize: $.proxy(this.place, this)
				}],
				[$(document), {
					'mousedown touchstart': $.proxy(function(e){
						// Clicked outside the datepicker, hide it
						if (!(
							this.element.is(e.target) ||
							this.element.find(e.target).length ||
							this.picker.is(e.target) ||
							this.picker.find(e.target).length ||
							this.isInline
						)){
							this.hide();
						}
					}, this)
				}]
			];
		},
		_attachEvents: function(){
			this._detachEvents();
			this._applyEvents(this._events);
		},
		_detachEvents: function(){
			this._unapplyEvents(this._events);
		},
		_attachSecondaryEvents: function(){
			this._detachSecondaryEvents();
			this._applyEvents(this._secondaryEvents);
		},
		_detachSecondaryEvents: function(){
			this._unapplyEvents(this._secondaryEvents);
		},
		_trigger: function(event, altdate){
			var date = altdate || this.dates.get(-1),
				local_date = this._utc_to_local(date);

			this.element.trigger({
				type: event,
				date: local_date,
				viewMode: this.viewMode,
				dates: $.map(this.dates, this._utc_to_local),
				format: $.proxy(function(ix, format){
					if (arguments.length === 0){
						ix = this.dates.length - 1;
						format = this.o.format;
					} else if (typeof ix === 'string'){
						format = ix;
						ix = this.dates.length - 1;
					}
					format = format || this.o.format;
					var date = this.dates.get(ix);
					return DPGlobal.formatDate(date, format, this.o.language);
				}, this)
			});
		},

		show: function(){
			if (this.inputField.prop('disabled') || (this.inputField.prop('readonly') && this.o.enableOnReadonly === false))
				return;
			if (!this.isInline)
				this.picker.appendTo(this.o.container);
			this.place();
			this.picker.show();
			this._attachSecondaryEvents();
			this._trigger('show');
			if ((window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && this.o.disableTouchKeyboard) {
				$(this.element).blur();
			}
			return this;
		},

		hide: function(){
			if (this.isInline || !this.picker.is(':visible'))
				return this;
			this.focusDate = null;
			this.picker.hide().detach();
			this._detachSecondaryEvents();
			this.setViewMode(this.o.startView);

			if (this.o.forceParse && this.inputField.val())
				this.setValue();
			this._trigger('hide');
			return this;
		},

		destroy: function(){
			this.hide();
			this._detachEvents();
			this._detachSecondaryEvents();
			this.picker.remove();
			delete this.element.data().datepicker;
			if (!this.isInput){
				delete this.element.data().date;
			}
			return this;
		},

		paste: function(e){
			var dateString;
			if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.types
				&& $.inArray('text/plain', e.originalEvent.clipboardData.types) !== -1) {
				dateString = e.originalEvent.clipboardData.getData('text/plain');
			} else if (window.clipboardData) {
				dateString = window.clipboardData.getData('Text');
			} else {
				return;
			}
			this.setDate(dateString);
			this.update();
			e.preventDefault();
		},

		_utc_to_local: function(utc){
			if (!utc) {
				return utc;
			}

			var local = new Date(utc.getTime() + (utc.getTimezoneOffset() * 60000));

			if (local.getTimezoneOffset() !== utc.getTimezoneOffset()) {
				local = new Date(utc.getTime() + (local.getTimezoneOffset() * 60000));
			}

			return local;
		},
		_local_to_utc: function(local){
			return local && new Date(local.getTime() - (local.getTimezoneOffset()*60000));
		},
		_zero_time: function(local){
			return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
		},
		_zero_utc_time: function(utc){
			return utc && UTCDate(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate());
		},

		getDates: function(){
			return $.map(this.dates, this._utc_to_local);
		},

		getUTCDates: function(){
			return $.map(this.dates, function(d){
				return new Date(d);
			});
		},

		getDate: function(){
			return this._utc_to_local(this.getUTCDate());
		},

		getUTCDate: function(){
			var selected_date = this.dates.get(-1);
			if (selected_date !== undefined) {
				return new Date(selected_date);
			} else {
				return null;
			}
		},

		clearDates: function(){
			this.inputField.val('');
			this.update();
			this._trigger('changeDate');

			if (this.o.autoclose) {
				this.hide();
			}
		},

		setDates: function(){
			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
			this.update.apply(this, args);
			this._trigger('changeDate');
			this.setValue();
			return this;
		},

		setUTCDates: function(){
			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
			this.setDates.apply(this, $.map(args, this._utc_to_local));
			return this;
		},

		setDate: alias('setDates'),
		setUTCDate: alias('setUTCDates'),
		remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead'),

		setValue: function(){
			var formatted = this.getFormattedDate();
			this.inputField.val(formatted);
			return this;
		},

		getFormattedDate: function(format){
			if (format === undefined)
				format = this.o.format;

			var lang = this.o.language;
			return $.map(this.dates, function(d){
				return DPGlobal.formatDate(d, format, lang);
			}).join(this.o.multidateSeparator);
		},

		getStartDate: function(){
			return this.o.startDate;
		},

		setStartDate: function(startDate){
			this._process_options({startDate: startDate});
			this.update();
			this.updateNavArrows();
			return this;
		},

		getEndDate: function(){
			return this.o.endDate;
		},

		setEndDate: function(endDate){
			this._process_options({endDate: endDate});
			this.update();
			this.updateNavArrows();
			return this;
		},

		setDaysOfWeekDisabled: function(daysOfWeekDisabled){
			this._process_options({daysOfWeekDisabled: daysOfWeekDisabled});
			this.update();
			return this;
		},

		setDaysOfWeekHighlighted: function(daysOfWeekHighlighted){
			this._process_options({daysOfWeekHighlighted: daysOfWeekHighlighted});
			this.update();
			return this;
		},

		setDatesDisabled: function(datesDisabled){
			this._process_options({datesDisabled: datesDisabled});
			this.update();
			return this;
		},

		place: function(){
			if (this.isInline)
				return this;
			var calendarWidth = this.picker.outerWidth(),
				calendarHeight = this.picker.outerHeight(),
				visualPadding = 10,
				container = $(this.o.container),
				windowWidth = container.width(),
				scrollTop = this.o.container === 'body' ? $(document).scrollTop() : container.scrollTop(),
				appendOffset = container.offset();

			var parentsZindex = [0];
			this.element.parents().each(function(){
				var itemZIndex = $(this).css('z-index');
				if (itemZIndex !== 'auto' && Number(itemZIndex) !== 0) parentsZindex.push(Number(itemZIndex));
			});
			var zIndex = Math.max.apply(Math, parentsZindex) + this.o.zIndexOffset;
			var offset = this.component ? this.component.parent().offset() : this.element.offset();
			var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
			var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
			var left = offset.left - appendOffset.left;
			var top = offset.top - appendOffset.top;

			if (this.o.container !== 'body') {
				top += scrollTop;
			}

			this.picker.removeClass(
				'datepicker-orient-top datepicker-orient-bottom '+
				'datepicker-orient-right datepicker-orient-left'
			);

			if (this.o.orientation.x !== 'auto'){
				this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
				if (this.o.orientation.x === 'right')
					left -= calendarWidth - width;
			}
			// auto x orientation is best-placement: if it crosses a window
			// edge, fudge it sideways
			else {
				if (offset.left < 0) {
					// component is outside the window on the left side. Move it into visible range
					this.picker.addClass('datepicker-orient-left');
					left -= offset.left - visualPadding;
				} else if (left + calendarWidth > windowWidth) {
					// the calendar passes the widow right edge. Align it to component right side
					this.picker.addClass('datepicker-orient-right');
					left += width - calendarWidth;
				} else {
					if (this.o.rtl) {
						// Default to right
						this.picker.addClass('datepicker-orient-right');
					} else {
						// Default to left
						this.picker.addClass('datepicker-orient-left');
					}
				}
			}

			// auto y orientation is best-situation: top or bottom, no fudging,
			// decision based on which shows more of the calendar
			var yorient = this.o.orientation.y,
				top_overflow;
			if (yorient === 'auto'){
				top_overflow = -scrollTop + top - calendarHeight;
				yorient = top_overflow < 0 ? 'bottom' : 'top';
			}

			this.picker.addClass('datepicker-orient-' + yorient);
			if (yorient === 'top')
				top -= calendarHeight + parseInt(this.picker.css('padding-top'));
			else
				top += height;

			if (this.o.rtl) {
				var right = windowWidth - (left + width);
				this.picker.css({
					top: top,
					right: right,
					zIndex: zIndex
				});
			} else {
				this.picker.css({
					top: top,
					left: left,
					zIndex: zIndex
				});
			}
			return this;
		},

		_allow_update: true,
		update: function(){
			if (!this._allow_update)
				return this;

			var oldDates = this.dates.copy(),
				dates = [],
				fromArgs = false;
			if (arguments.length){
				$.each(arguments, $.proxy(function(i, date){
					if (date instanceof Date)
						date = this._local_to_utc(date);
					dates.push(date);
				}, this));
				fromArgs = true;
			} else {
				dates = this.isInput
						? this.element.val()
						: this.element.data('date') || this.inputField.val();
				if (dates && this.o.multidate)
					dates = dates.split(this.o.multidateSeparator);
				else
					dates = [dates];
				delete this.element.data().date;
			}

			dates = $.map(dates, $.proxy(function(date){
				return DPGlobal.parseDate(date, this.o.format, this.o.language, this.o.assumeNearbyYear);
			}, this));
			dates = $.grep(dates, $.proxy(function(date){
				return (
					!this.dateWithinRange(date) ||
					!date
				);
			}, this), true);
			this.dates.replace(dates);

			if (this.o.updateViewDate) {
				if (this.dates.length)
					this.viewDate = new Date(this.dates.get(-1));
				else if (this.viewDate < this.o.startDate)
					this.viewDate = new Date(this.o.startDate);
				else if (this.viewDate > this.o.endDate)
					this.viewDate = new Date(this.o.endDate);
				else
					this.viewDate = this.o.defaultViewDate;
			}

			if (fromArgs){
				// setting date by clicking
				this.setValue();
				this.element.change();
			}
			else if (this.dates.length){
				// setting date by typing
				if (String(oldDates) !== String(this.dates) && fromArgs) {
					this._trigger('changeDate');
					this.element.change();
				}
			}
			if (!this.dates.length && oldDates.length) {
				this._trigger('clearDate');
				this.element.change();
			}

			this.fill();
			return this;
		},

		fillDow: function(){
      if (this.o.showWeekDays) {
			var dowCnt = this.o.weekStart,
				html = '<tr>';
			if (this.o.calendarWeeks){
				html += '<th class="cw">&#160;</th>';
			}
			while (dowCnt < this.o.weekStart + 7){
				html += '<th class="dow';
        if ($.inArray(dowCnt, this.o.daysOfWeekDisabled) !== -1)
          html += ' disabled';
        html += '">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';
			}
			html += '</tr>';
			this.picker.find('.datepicker-days thead').append(html);
      }
		},

		fillMonths: function(){
      var localDate = this._utc_to_local(this.viewDate);
			var html = '';
			var focused;
			for (var i = 0; i < 12; i++){
				focused = localDate && localDate.getMonth() === i ? ' focused' : '';
				html += '<span class="month' + focused + '">' + dates[this.o.language].monthsShort[i] + '</span>';
			}
			this.picker.find('.datepicker-months td').html(html);
		},

		setRange: function(range){
			if (!range || !range.length)
				delete this.range;
			else
				this.range = $.map(range, function(d){
					return d.valueOf();
				});
			this.fill();
		},

		getClassNames: function(date){
			var cls = [],
				year = this.viewDate.getUTCFullYear(),
				month = this.viewDate.getUTCMonth(),
				today = UTCToday();
			if (date.getUTCFullYear() < year || (date.getUTCFullYear() === year && date.getUTCMonth() < month)){
				cls.push('old');
			} else if (date.getUTCFullYear() > year || (date.getUTCFullYear() === year && date.getUTCMonth() > month)){
				cls.push('new');
			}
			if (this.focusDate && date.valueOf() === this.focusDate.valueOf())
				cls.push('focused');
			// Compare internal UTC date with UTC today, not local today
			if (this.o.todayHighlight && isUTCEquals(date, today)) {
				cls.push('today');
			}
			if (this.dates.contains(date) !== -1)
				cls.push('active');
			if (!this.dateWithinRange(date)){
				cls.push('disabled');
			}
			if (this.dateIsDisabled(date)){
				cls.push('disabled', 'disabled-date');
			}
			if ($.inArray(date.getUTCDay(), this.o.daysOfWeekHighlighted) !== -1){
				cls.push('highlighted');
			}

			if (this.range){
				if (date > this.range[0] && date < this.range[this.range.length-1]){
					cls.push('range');
				}
				if ($.inArray(date.valueOf(), this.range) !== -1){
					cls.push('selected');
				}
				if (date.valueOf() === this.range[0]){
          cls.push('range-start');
        }
        if (date.valueOf() === this.range[this.range.length-1]){
          cls.push('range-end');
        }
			}
			return cls;
		},

		_fill_yearsView: function(selector, cssClass, factor, year, startYear, endYear, beforeFn){
			var html = '';
			var step = factor / 10;
			var view = this.picker.find(selector);
			var startVal = Math.floor(year / factor) * factor;
			var endVal = startVal + step * 9;
			var focusedVal = Math.floor(this.viewDate.getFullYear() / step) * step;
			var selected = $.map(this.dates, function(d){
				return Math.floor(d.getUTCFullYear() / step) * step;
			});

			var classes, tooltip, before;
			for (var currVal = startVal - step; currVal <= endVal + step; currVal += step) {
				classes = [cssClass];
				tooltip = null;

				if (currVal === startVal - step) {
					classes.push('old');
				} else if (currVal === endVal + step) {
					classes.push('new');
				}
				if ($.inArray(currVal, selected) !== -1) {
					classes.push('active');
				}
				if (currVal < startYear || currVal > endYear) {
					classes.push('disabled');
				}
				if (currVal === focusedVal) {
				  classes.push('focused');
        }

				if (beforeFn !== $.noop) {
					before = beforeFn(new Date(currVal, 0, 1));
					if (before === undefined) {
						before = {};
					} else if (typeof before === 'boolean') {
						before = {enabled: before};
					} else if (typeof before === 'string') {
						before = {classes: before};
					}
					if (before.enabled === false) {
						classes.push('disabled');
					}
					if (before.classes) {
						classes = classes.concat(before.classes.split(/\s+/));
					}
					if (before.tooltip) {
						tooltip = before.tooltip;
					}
				}

				html += '<span class="' + classes.join(' ') + '"' + (tooltip ? ' title="' + tooltip + '"' : '') + '>' + currVal + '</span>';
			}

			view.find('.datepicker-switch').text(startVal + '-' + endVal);
			view.find('td').html(html);
		},

		fill: function(){
			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth(),
				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
				todaytxt = dates[this.o.language].today || dates['en'].today || '',
				cleartxt = dates[this.o.language].clear || dates['en'].clear || '',
				titleFormat = dates[this.o.language].titleFormat || dates['en'].titleFormat,
				tooltip,
				before;
			if (isNaN(year) || isNaN(month))
				return;
			this.picker.find('.datepicker-days .datepicker-switch')
						.text(DPGlobal.formatDate(d, titleFormat, this.o.language));
			this.picker.find('tfoot .today')
						.text(todaytxt)
						.css('display', this.o.todayBtn === true || this.o.todayBtn === 'linked' ? 'table-cell' : 'none');
			this.picker.find('tfoot .clear')
						.text(cleartxt)
						.css('display', this.o.clearBtn === true ? 'table-cell' : 'none');
			this.picker.find('thead .datepicker-title')
						.text(this.o.title)
						.css('display', typeof this.o.title === 'string' && this.o.title !== '' ? 'table-cell' : 'none');
			this.updateNavArrows();
			this.fillMonths();
			var prevMonth = UTCDate(year, month, 0),
				day = prevMonth.getUTCDate();
			prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);
			var nextMonth = new Date(prevMonth);
			if (prevMonth.getUTCFullYear() < 100){
        nextMonth.setUTCFullYear(prevMonth.getUTCFullYear());
      }
			nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
			nextMonth = nextMonth.valueOf();
			var html = [];
			var weekDay, clsName;
			while (prevMonth.valueOf() < nextMonth){
				weekDay = prevMonth.getUTCDay();
				if (weekDay === this.o.weekStart){
					html.push('<tr>');
					if (this.o.calendarWeeks){
						// ISO 8601: First week contains first thursday.
						// ISO also states week starts on Monday, but we can be more abstract here.
						var
							// Start of current week: based on weekstart/current date
							ws = new Date(+prevMonth + (this.o.weekStart - weekDay - 7) % 7 * 864e5),
							// Thursday of this week
							th = new Date(Number(ws) + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
							// First Thursday of year, year from thursday
							yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),
							// Calendar week: ms between thursdays, div ms per day, div 7 days
							calWeek = (th - yth) / 864e5 / 7 + 1;
						html.push('<td class="cw">'+ calWeek +'</td>');
					}
				}
				clsName = this.getClassNames(prevMonth);
				clsName.push('day');

				var content = prevMonth.getUTCDate();

				if (this.o.beforeShowDay !== $.noop){
					before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
					if (before === undefined)
						before = {};
					else if (typeof before === 'boolean')
						before = {enabled: before};
					else if (typeof before === 'string')
						before = {classes: before};
					if (before.enabled === false)
						clsName.push('disabled');
					if (before.classes)
						clsName = clsName.concat(before.classes.split(/\s+/));
					if (before.tooltip)
						tooltip = before.tooltip;
					if (before.content)
						content = before.content;
				}

				//Check if uniqueSort exists (supported by jquery >=1.12 and >=2.2)
				//Fallback to unique function for older jquery versions
				if ($.isFunction($.uniqueSort)) {
					clsName = $.uniqueSort(clsName);
				} else {
					clsName = $.unique(clsName);
				}

				html.push('<td class="'+clsName.join(' ')+'"' + (tooltip ? ' title="'+tooltip+'"' : '') + ' data-date="' + prevMonth.getTime().toString() + '">' + content + '</td>');
				tooltip = null;
				if (weekDay === this.o.weekEnd){
					html.push('</tr>');
				}
				prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
			}
			this.picker.find('.datepicker-days tbody').html(html.join(''));

			var monthsTitle = dates[this.o.language].monthsTitle || dates['en'].monthsTitle || 'Months';
			var months = this.picker.find('.datepicker-months')
						.find('.datepicker-switch')
							.text(this.o.maxViewMode < 2 ? monthsTitle : year)
							.end()
						.find('tbody span').removeClass('active');

			$.each(this.dates, function(i, d){
				if (d.getUTCFullYear() === year)
					months.eq(d.getUTCMonth()).addClass('active');
			});

			if (year < startYear || year > endYear){
				months.addClass('disabled');
			}
			if (year === startYear){
				months.slice(0, startMonth).addClass('disabled');
			}
			if (year === endYear){
				months.slice(endMonth+1).addClass('disabled');
			}

			if (this.o.beforeShowMonth !== $.noop){
				var that = this;
				$.each(months, function(i, month){
          var moDate = new Date(year, i, 1);
          var before = that.o.beforeShowMonth(moDate);
					if (before === undefined)
						before = {};
					else if (typeof before === 'boolean')
						before = {enabled: before};
					else if (typeof before === 'string')
						before = {classes: before};
					if (before.enabled === false && !$(month).hasClass('disabled'))
					    $(month).addClass('disabled');
					if (before.classes)
					    $(month).addClass(before.classes);
					if (before.tooltip)
					    $(month).prop('title', before.tooltip);
				});
			}

			// Generating decade/years picker
			this._fill_yearsView(
				'.datepicker-years',
				'year',
				10,
				year,
				startYear,
				endYear,
				this.o.beforeShowYear
			);

			// Generating century/decades picker
			this._fill_yearsView(
				'.datepicker-decades',
				'decade',
				100,
				year,
				startYear,
				endYear,
				this.o.beforeShowDecade
			);

			// Generating millennium/centuries picker
			this._fill_yearsView(
				'.datepicker-centuries',
				'century',
				1000,
				year,
				startYear,
				endYear,
				this.o.beforeShowCentury
			);
		},

		updateNavArrows: function(){
			if (!this._allow_update)
				return;

			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth(),
				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
				prevIsDisabled,
				nextIsDisabled,
				factor = 1;
			switch (this.viewMode){
				case 4:
					factor *= 10;
					/* falls through */
				case 3:
					factor *= 10;
					/* falls through */
				case 2:
					factor *= 10;
					/* falls through */
				case 1:
					prevIsDisabled = Math.floor(year / factor) * factor <= startYear;
					nextIsDisabled = Math.floor(year / factor) * factor + factor > endYear;
					break;
				case 0:
					prevIsDisabled = year <= startYear && month <= startMonth;
					nextIsDisabled = year >= endYear && month >= endMonth;
					break;
			}

			this.picker.find('.prev').toggleClass('disabled', prevIsDisabled);
			this.picker.find('.next').toggleClass('disabled', nextIsDisabled);
		},

		click: function(e){
			e.preventDefault();
			e.stopPropagation();

			var target, dir, day, year, month;
			target = $(e.target);

			// Clicked on the switch
			if (target.hasClass('datepicker-switch') && this.viewMode !== this.o.maxViewMode){
				this.setViewMode(this.viewMode + 1);
			}

			// Clicked on today button
			if (target.hasClass('today') && !target.hasClass('day')){
				this.setViewMode(0);
				this._setDate(UTCToday(), this.o.todayBtn === 'linked' ? null : 'view');
			}

			// Clicked on clear button
			if (target.hasClass('clear')){
				this.clearDates();
			}

			if (!target.hasClass('disabled')){
				// Clicked on a month, year, decade, century
				if (target.hasClass('month')
						|| target.hasClass('year')
						|| target.hasClass('decade')
						|| target.hasClass('century')) {
					this.viewDate.setUTCDate(1);

					day = 1;
					if (this.viewMode === 1){
						month = target.parent().find('span').index(target);
						year = this.viewDate.getUTCFullYear();
						this.viewDate.setUTCMonth(month);
					} else {
						month = 0;
						year = Number(target.text());
						this.viewDate.setUTCFullYear(year);
					}

					this._trigger(DPGlobal.viewModes[this.viewMode - 1].e, this.viewDate);

					if (this.viewMode === this.o.minViewMode){
						this._setDate(UTCDate(year, month, day));
					} else {
						this.setViewMode(this.viewMode - 1);
						this.fill();
					}
				}
			}

			if (this.picker.is(':visible') && this._focused_from){
				this._focused_from.focus();
			}
			delete this._focused_from;
		},

		dayCellClick: function(e){
			var $target = $(e.currentTarget);
			var timestamp = $target.data('date');
			var date = new Date(timestamp);

			if (this.o.updateViewDate) {
				if (date.getUTCFullYear() !== this.viewDate.getUTCFullYear()) {
					this._trigger('changeYear', this.viewDate);
				}

				if (date.getUTCMonth() !== this.viewDate.getUTCMonth()) {
					this._trigger('changeMonth', this.viewDate);
				}
			}
			this._setDate(date);
		},

		// Clicked on prev or next
		navArrowsClick: function(e){
			var $target = $(e.currentTarget);
			var dir = $target.hasClass('prev') ? -1 : 1;
			if (this.viewMode !== 0){
				dir *= DPGlobal.viewModes[this.viewMode].navStep * 12;
			}
			this.viewDate = this.moveMonth(this.viewDate, dir);
			this._trigger(DPGlobal.viewModes[this.viewMode].e, this.viewDate);
			this.fill();
		},

		_toggle_multidate: function(date){
			var ix = this.dates.contains(date);
			if (!date){
				this.dates.clear();
			}

			if (ix !== -1){
				if (this.o.multidate === true || this.o.multidate > 1 || this.o.toggleActive){
					this.dates.remove(ix);
				}
			} else if (this.o.multidate === false) {
				this.dates.clear();
				this.dates.push(date);
			}
			else {
				this.dates.push(date);
			}

			if (typeof this.o.multidate === 'number')
				while (this.dates.length > this.o.multidate)
					this.dates.remove(0);
		},

		_setDate: function(date, which){
			if (!which || which === 'date')
				this._toggle_multidate(date && new Date(date));
			if ((!which && this.o.updateViewDate) || which === 'view')
				this.viewDate = date && new Date(date);

			this.fill();
			this.setValue();
			if (!which || which !== 'view') {
				this._trigger('changeDate');
			}
			this.inputField.trigger('change');
			if (this.o.autoclose && (!which || which === 'date')){
				this.hide();
			}
		},

		moveDay: function(date, dir){
			var newDate = new Date(date);
			newDate.setUTCDate(date.getUTCDate() + dir);

			return newDate;
		},

		moveWeek: function(date, dir){
			return this.moveDay(date, dir * 7);
		},

		moveMonth: function(date, dir){
			if (!isValidDate(date))
				return this.o.defaultViewDate;
			if (!dir)
				return date;
			var new_date = new Date(date.valueOf()),
				day = new_date.getUTCDate(),
				month = new_date.getUTCMonth(),
				mag = Math.abs(dir),
				new_month, test;
			dir = dir > 0 ? 1 : -1;
			if (mag === 1){
				test = dir === -1
					// If going back one month, make sure month is not current month
					// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
					? function(){
						return new_date.getUTCMonth() === month;
					}
					// If going forward one month, make sure month is as expected
					// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
					: function(){
						return new_date.getUTCMonth() !== new_month;
					};
				new_month = month + dir;
				new_date.setUTCMonth(new_month);
				// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
				new_month = (new_month + 12) % 12;
			}
			else {
				// For magnitudes >1, move one month at a time...
				for (var i=0; i < mag; i++)
					// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
					new_date = this.moveMonth(new_date, dir);
				// ...then reset the day, keeping it in the new month
				new_month = new_date.getUTCMonth();
				new_date.setUTCDate(day);
				test = function(){
					return new_month !== new_date.getUTCMonth();
				};
			}
			// Common date-resetting loop -- if date is beyond end of month, make it
			// end of month
			while (test()){
				new_date.setUTCDate(--day);
				new_date.setUTCMonth(new_month);
			}
			return new_date;
		},

		moveYear: function(date, dir){
			return this.moveMonth(date, dir*12);
		},

		moveAvailableDate: function(date, dir, fn){
			do {
				date = this[fn](date, dir);

				if (!this.dateWithinRange(date))
					return false;

				fn = 'moveDay';
			}
			while (this.dateIsDisabled(date));

			return date;
		},

		weekOfDateIsDisabled: function(date){
			return $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1;
		},

		dateIsDisabled: function(date){
			return (
				this.weekOfDateIsDisabled(date) ||
				$.grep(this.o.datesDisabled, function(d){
					return isUTCEquals(date, d);
				}).length > 0
			);
		},

		dateWithinRange: function(date){
			return date >= this.o.startDate && date <= this.o.endDate;
		},

		keydown: function(e){
			if (!this.picker.is(':visible')){
				if (e.keyCode === 40 || e.keyCode === 27) { // allow down to re-show picker
					this.show();
					e.stopPropagation();
        }
				return;
			}
			var dateChanged = false,
				dir, newViewDate,
				focusDate = this.focusDate || this.viewDate;
			switch (e.keyCode){
				case 27: // escape
					if (this.focusDate){
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.fill();
					}
					else
						this.hide();
					e.preventDefault();
					e.stopPropagation();
					break;
				case 37: // left
				case 38: // up
				case 39: // right
				case 40: // down
					if (!this.o.keyboardNavigation || this.o.daysOfWeekDisabled.length === 7)
						break;
					dir = e.keyCode === 37 || e.keyCode === 38 ? -1 : 1;
          if (this.viewMode === 0) {
  					if (e.ctrlKey){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');

  						if (newViewDate)
  							this._trigger('changeYear', this.viewDate);
  					} else if (e.shiftKey){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');

  						if (newViewDate)
  							this._trigger('changeMonth', this.viewDate);
  					} else if (e.keyCode === 37 || e.keyCode === 39){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveDay');
  					} else if (!this.weekOfDateIsDisabled(focusDate)){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveWeek');
  					}
          } else if (this.viewMode === 1) {
            if (e.keyCode === 38 || e.keyCode === 40) {
              dir = dir * 4;
            }
            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');
          } else if (this.viewMode === 2) {
            if (e.keyCode === 38 || e.keyCode === 40) {
              dir = dir * 4;
            }
            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');
          }
					if (newViewDate){
						this.focusDate = this.viewDate = newViewDate;
						this.setValue();
						this.fill();
						e.preventDefault();
					}
					break;
				case 13: // enter
					if (!this.o.forceParse)
						break;
					focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;
					if (this.o.keyboardNavigation) {
						this._toggle_multidate(focusDate);
						dateChanged = true;
					}
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.setValue();
					this.fill();
					if (this.picker.is(':visible')){
						e.preventDefault();
						e.stopPropagation();
						if (this.o.autoclose)
							this.hide();
					}
					break;
				case 9: // tab
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.fill();
					this.hide();
					break;
			}
			if (dateChanged){
				if (this.dates.length)
					this._trigger('changeDate');
				else
					this._trigger('clearDate');
				this.inputField.trigger('change');
			}
		},

		setViewMode: function(viewMode){
			this.viewMode = viewMode;
			this.picker
				.children('div')
				.hide()
				.filter('.datepicker-' + DPGlobal.viewModes[this.viewMode].clsName)
					.show();
			this.updateNavArrows();
      this._trigger('changeViewMode', new Date(this.viewDate));
		}
	};

	var DateRangePicker = function(element, options){
		$.data(element, 'datepicker', this);
		this.element = $(element);
		this.inputs = $.map(options.inputs, function(i){
			return i.jquery ? i[0] : i;
		});
		delete options.inputs;

		this.keepEmptyValues = options.keepEmptyValues;
		delete options.keepEmptyValues;

		datepickerPlugin.call($(this.inputs), options)
			.on('changeDate', $.proxy(this.dateUpdated, this));

		this.pickers = $.map(this.inputs, function(i){
			return $.data(i, 'datepicker');
		});
		this.updateDates();
	};
	DateRangePicker.prototype = {
		updateDates: function(){
			this.dates = $.map(this.pickers, function(i){
				return i.getUTCDate();
			});
			this.updateRanges();
		},
		updateRanges: function(){
			var range = $.map(this.dates, function(d){
				return d.valueOf();
			});
			$.each(this.pickers, function(i, p){
				p.setRange(range);
			});
		},
		clearDates: function(){
			$.each(this.pickers, function(i, p){
				p.clearDates();
			});
		},
		dateUpdated: function(e){
			// `this.updating` is a workaround for preventing infinite recursion
			// between `changeDate` triggering and `setUTCDate` calling.  Until
			// there is a better mechanism.
			if (this.updating)
				return;
			this.updating = true;

			var dp = $.data(e.target, 'datepicker');

			if (dp === undefined) {
				return;
			}

			var new_date = dp.getUTCDate(),
				keep_empty_values = this.keepEmptyValues,
				i = $.inArray(e.target, this.inputs),
				j = i - 1,
				k = i + 1,
				l = this.inputs.length;
			if (i === -1)
				return;

			$.each(this.pickers, function(i, p){
				if (!p.getUTCDate() && (p === dp || !keep_empty_values))
					p.setUTCDate(new_date);
			});

			if (new_date < this.dates[j]){
				// Date being moved earlier/left
				while (j >= 0 && new_date < this.dates[j]){
					this.pickers[j--].setUTCDate(new_date);
				}
			} else if (new_date > this.dates[k]){
				// Date being moved later/right
				while (k < l && new_date > this.dates[k]){
					this.pickers[k++].setUTCDate(new_date);
				}
			}
			this.updateDates();

			delete this.updating;
		},
		destroy: function(){
			$.map(this.pickers, function(p){ p.destroy(); });
			$(this.inputs).off('changeDate', this.dateUpdated);
			delete this.element.data().datepicker;
		},
		remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead')
	};

	function opts_from_el(el, prefix){
		// Derive options from element data-attrs
		var data = $(el).data(),
			out = {}, inkey,
			replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])');
		prefix = new RegExp('^' + prefix.toLowerCase());
		function re_lower(_,a){
			return a.toLowerCase();
		}
		for (var key in data)
			if (prefix.test(key)){
				inkey = key.replace(replace, re_lower);
				out[inkey] = data[key];
			}
		return out;
	}

	function opts_from_locale(lang){
		// Derive options from locale plugins
		var out = {};
		// Check if "de-DE" style date is available, if not language should
		// fallback to 2 letter code eg "de"
		if (!dates[lang]){
			lang = lang.split('-')[0];
			if (!dates[lang])
				return;
		}
		var d = dates[lang];
		$.each(locale_opts, function(i,k){
			if (k in d)
				out[k] = d[k];
		});
		return out;
	}

	var old = $.fn.datepicker;
	var datepickerPlugin = function(option){
		var args = Array.apply(null, arguments);
		args.shift();
		var internal_return;
		this.each(function(){
			var $this = $(this),
				data = $this.data('datepicker'),
				options = typeof option === 'object' && option;
			if (!data){
				var elopts = opts_from_el(this, 'date'),
					// Preliminary otions
					xopts = $.extend({}, defaults, elopts, options),
					locopts = opts_from_locale(xopts.language),
					// Options priority: js args, data-attrs, locales, defaults
					opts = $.extend({}, defaults, locopts, elopts, options);
				if ($this.hasClass('input-daterange') || opts.inputs){
					$.extend(opts, {
						inputs: opts.inputs || $this.find('input').toArray()
					});
					data = new DateRangePicker(this, opts);
				}
				else {
					data = new Datepicker(this, opts);
				}
				$this.data('datepicker', data);
			}
			if (typeof option === 'string' && typeof data[option] === 'function'){
				internal_return = data[option].apply(data, args);
			}
		});

		if (
			internal_return === undefined ||
			internal_return instanceof Datepicker ||
			internal_return instanceof DateRangePicker
		)
			return this;

		if (this.length > 1)
			throw new Error('Using only allowed for the collection of a single element (' + option + ' function)');
		else
			return internal_return;
	};
	$.fn.datepicker = datepickerPlugin;

	var defaults = $.fn.datepicker.defaults = {
		assumeNearbyYear: false,
		autoclose: false,
		beforeShowDay: $.noop,
		beforeShowMonth: $.noop,
		beforeShowYear: $.noop,
		beforeShowDecade: $.noop,
		beforeShowCentury: $.noop,
		calendarWeeks: false,
		clearBtn: false,
		toggleActive: false,
		daysOfWeekDisabled: [],
		daysOfWeekHighlighted: [],
		datesDisabled: [],
		endDate: Infinity,
		forceParse: true,
		format: 'mm/dd/yyyy',
		keepEmptyValues: false,
		keyboardNavigation: true,
		language: 'en',
		minViewMode: 0,
		maxViewMode: 4,
		multidate: false,
		multidateSeparator: ',',
		orientation: "auto",
		rtl: false,
		startDate: -Infinity,
		startView: 0,
		todayBtn: false,
		todayHighlight: false,
		updateViewDate: true,
		weekStart: 0,
		disableTouchKeyboard: false,
		enableOnReadonly: true,
		showOnFocus: true,
		zIndexOffset: 10,
		container: 'body',
		immediateUpdates: false,
		title: '',
		templates: {
			leftArrow: '&#x00AB;',
			rightArrow: '&#x00BB;'
		},
    showWeekDays: true
	};
	var locale_opts = $.fn.datepicker.locale_opts = [
		'format',
		'rtl',
		'weekStart'
	];
	$.fn.datepicker.Constructor = Datepicker;
	var dates = $.fn.datepicker.dates = {
		en: {
			days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
			daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
			daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
			months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
			monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			today: "Today",
			clear: "Clear",
			titleFormat: "MM yyyy"
		}
	};

	var DPGlobal = {
		viewModes: [
			{
				names: ['days', 'month'],
				clsName: 'days',
				e: 'changeMonth'
			},
			{
				names: ['months', 'year'],
				clsName: 'months',
				e: 'changeYear',
				navStep: 1
			},
			{
				names: ['years', 'decade'],
				clsName: 'years',
				e: 'changeDecade',
				navStep: 10
			},
			{
				names: ['decades', 'century'],
				clsName: 'decades',
				e: 'changeCentury',
				navStep: 100
			},
			{
				names: ['centuries', 'millennium'],
				clsName: 'centuries',
				e: 'changeMillennium',
				navStep: 1000
			}
		],
		validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
		nonpunctuation: /[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,
		parseFormat: function(format){
			if (typeof format.toValue === 'function' && typeof format.toDisplay === 'function')
                return format;
            // IE treats \0 as a string end in inputs (truncating the value),
			// so it's a bad format delimiter, anyway
			var separators = format.replace(this.validParts, '\0').split('\0'),
				parts = format.match(this.validParts);
			if (!separators || !separators.length || !parts || parts.length === 0){
				throw new Error("Invalid date format.");
			}
			return {separators: separators, parts: parts};
		},
		parseDate: function(date, format, language, assumeNearby){
			if (!date)
				return undefined;
			if (date instanceof Date)
				return date;
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			if (format.toValue)
				return format.toValue(date, format, language);
			var fn_map = {
					d: 'moveDay',
					m: 'moveMonth',
					w: 'moveWeek',
					y: 'moveYear'
				},
				dateAliases = {
					yesterday: '-1d',
					today: '+0d',
					tomorrow: '+1d'
				},
				parts, part, dir, i, fn;
			if (date in dateAliases){
				date = dateAliases[date];
			}
			if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/i.test(date)){
				parts = date.match(/([\-+]\d+)([dmwy])/gi);
				date = new Date();
				for (i=0; i < parts.length; i++){
					part = parts[i].match(/([\-+]\d+)([dmwy])/i);
					dir = Number(part[1]);
					fn = fn_map[part[2].toLowerCase()];
					date = Datepicker.prototype[fn](date, dir);
				}
				return Datepicker.prototype._zero_utc_time(date);
			}

			parts = date && date.match(this.nonpunctuation) || [];

			function applyNearbyYear(year, threshold){
				if (threshold === true)
					threshold = 10;

				// if year is 2 digits or less, than the user most likely is trying to get a recent century
				if (year < 100){
					year += 2000;
					// if the new year is more than threshold years in advance, use last century
					if (year > ((new Date()).getFullYear()+threshold)){
						year -= 100;
					}
				}

				return year;
			}

			var parsed = {},
				setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
				setters_map = {
					yyyy: function(d,v){
						return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v);
					},
					m: function(d,v){
						if (isNaN(d))
							return d;
						v -= 1;
						while (v < 0) v += 12;
						v %= 12;
						d.setUTCMonth(v);
						while (d.getUTCMonth() !== v)
							d.setUTCDate(d.getUTCDate()-1);
						return d;
					},
					d: function(d,v){
						return d.setUTCDate(v);
					}
				},
				val, filtered;
			setters_map['yy'] = setters_map['yyyy'];
			setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
			setters_map['dd'] = setters_map['d'];
			date = UTCToday();
			var fparts = format.parts.slice();
			// Remove noop parts
			if (parts.length !== fparts.length){
				fparts = $(fparts).filter(function(i,p){
					return $.inArray(p, setters_order) !== -1;
				}).toArray();
			}
			// Process remainder
			function match_part(){
				var m = this.slice(0, parts[i].length),
					p = parts[i].slice(0, m.length);
				return m.toLowerCase() === p.toLowerCase();
			}
			if (parts.length === fparts.length){
				var cnt;
				for (i=0, cnt = fparts.length; i < cnt; i++){
					val = parseInt(parts[i], 10);
					part = fparts[i];
					if (isNaN(val)){
						switch (part){
							case 'MM':
								filtered = $(dates[language].months).filter(match_part);
								val = $.inArray(filtered[0], dates[language].months) + 1;
								break;
							case 'M':
								filtered = $(dates[language].monthsShort).filter(match_part);
								val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
								break;
						}
					}
					parsed[part] = val;
				}
				var _date, s;
				for (i=0; i < setters_order.length; i++){
					s = setters_order[i];
					if (s in parsed && !isNaN(parsed[s])){
						_date = new Date(date);
						setters_map[s](_date, parsed[s]);
						if (!isNaN(_date))
							date = _date;
					}
				}
			}
			return date;
		},
		formatDate: function(date, format, language){
			if (!date)
				return '';
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			if (format.toDisplay)
                return format.toDisplay(date, format, language);
            var val = {
				d: date.getUTCDate(),
				D: dates[language].daysShort[date.getUTCDay()],
				DD: dates[language].days[date.getUTCDay()],
				m: date.getUTCMonth() + 1,
				M: dates[language].monthsShort[date.getUTCMonth()],
				MM: dates[language].months[date.getUTCMonth()],
				yy: date.getUTCFullYear().toString().substring(2),
				yyyy: date.getUTCFullYear()
			};
			val.dd = (val.d < 10 ? '0' : '') + val.d;
			val.mm = (val.m < 10 ? '0' : '') + val.m;
			date = [];
			var seps = $.extend([], format.separators);
			for (var i=0, cnt = format.parts.length; i <= cnt; i++){
				if (seps.length)
					date.push(seps.shift());
				date.push(val[format.parts[i]]);
			}
			return date.join('');
		},
		headTemplate: '<thead>'+
			              '<tr>'+
			                '<th colspan="7" class="datepicker-title"></th>'+
			              '</tr>'+
							'<tr>'+
								'<th class="prev">'+defaults.templates.leftArrow+'</th>'+
								'<th colspan="5" class="datepicker-switch"></th>'+
								'<th class="next">'+defaults.templates.rightArrow+'</th>'+
							'</tr>'+
						'</thead>',
		contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
		footTemplate: '<tfoot>'+
							'<tr>'+
								'<th colspan="7" class="today"></th>'+
							'</tr>'+
							'<tr>'+
								'<th colspan="7" class="clear"></th>'+
							'</tr>'+
						'</tfoot>'
	};
	DPGlobal.template = '<div class="datepicker">'+
							'<div class="datepicker-days">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									'<tbody></tbody>'+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-months">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-years">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-decades">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-centuries">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
						'</div>';

	$.fn.datepicker.DPGlobal = DPGlobal;


	/* DATEPICKER NO CONFLICT
	* =================== */

	$.fn.datepicker.noConflict = function(){
		$.fn.datepicker = old;
		return this;
	};

	/* DATEPICKER VERSION
	 * =================== */
	$.fn.datepicker.version = '1.8.0';

	$.fn.datepicker.deprecated = function(msg){
		var console = window.console;
		if (console && console.warn) {
			console.warn('DEPRECATED: ' + msg);
		}
	};


	/* DATEPICKER DATA-API
	* ================== */

	$(document).on(
		'focus.datepicker.data-api click.datepicker.data-api',
		'[data-provide="datepicker"]',
		function(e){
			var $this = $(this);
			if ($this.data('datepicker'))
				return;
			e.preventDefault();
			// component click requires us to explicitly show it
			datepickerPlugin.call($this, 'show');
		}
	);
	$(function(){
		datepickerPlugin.call($('[data-provide="datepicker-inline"]'));
	});

}));

/**
 * Slovak translation for bootstrap-datepicker
 * Marek Lichtner <marek@licht.sk>
 * Fixes by Michal Remi <michal.remis@gmail.com>
 */
;(function($){
	$.fn.datepicker.dates["sk"] = {
		days: ["Nedea", "Pondelok", "Utorok", "Streda", "tvrtok", "Piatok", "Sobota"],
		daysShort: ["Ned", "Pon", "Uto", "Str", "tv", "Pia", "Sob"],
		daysMin: ["Ne", "Po", "Ut", "St", "t", "Pia", "So"],
		months: ["Janur", "Februr", "Marec", "Aprl", "Mj", "Jn", "Jl", "August", "September", "Oktber", "November", "December"],
		monthsShort: ["Jan", "Feb", "Mar", "Apr", "Mj", "Jn", "Jl", "Aug", "Sep", "Okt", "Nov", "Dec"],
		today: "Dnes",
		clear: "Vymaza",
		weekStart: 1,
		format: "d.m.yyyy"
	};
}(jQuery));

/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--){d[e(c)]=k[c]||e(c)}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('K M;I(M)1S 2U("2a\'t 4k M 4K 2g 3l 4G 4H");(6(){6 r(f,e){I(!M.1R(f))1S 3m("3s 15 4R");K a=f.1w;f=M(f.1m,t(f)+(e||""));I(a)f.1w={1m:a.1m,19:a.19?a.19.1a(0):N};H f}6 t(f){H(f.1J?"g":"")+(f.4s?"i":"")+(f.4p?"m":"")+(f.4v?"x":"")+(f.3n?"y":"")}6 B(f,e,a,b){K c=u.L,d,h,g;v=R;5K{O(;c--;){g=u[c];I(a&g.3r&&(!g.2p||g.2p.W(b))){g.2q.12=e;I((h=g.2q.X(f))&&h.P===e){d={3k:g.2b.W(b,h,a),1C:h};1N}}}}5v(i){1S i}5q{v=11}H d}6 p(f,e,a){I(3b.Z.1i)H f.1i(e,a);O(a=a||0;a<f.L;a++)I(f[a]===e)H a;H-1}M=6(f,e){K a=[],b=M.1B,c=0,d,h;I(M.1R(f)){I(e!==1d)1S 3m("2a\'t 5r 5I 5F 5B 5C 15 5E 5p");H r(f)}I(v)1S 2U("2a\'t W 3l M 59 5m 5g 5x 5i");e=e||"";O(d={2N:11,19:[],2K:6(g){H e.1i(g)>-1},3d:6(g){e+=g}};c<f.L;)I(h=B(f,c,b,d)){a.U(h.3k);c+=h.1C[0].L||1}Y I(h=n.X.W(z[b],f.1a(c))){a.U(h[0]);c+=h[0].L}Y{h=f.3a(c);I(h==="[")b=M.2I;Y I(h==="]")b=M.1B;a.U(h);c++}a=15(a.1K(""),n.Q.W(e,w,""));a.1w={1m:f,19:d.2N?d.19:N};H a};M.3v="1.5.0";M.2I=1;M.1B=2;K C=/\\$(?:(\\d\\d?|[$&`\'])|{([$\\w]+)})/g,w=/[^5h]+|([\\s\\S])(?=[\\s\\S]*\\1)/g,A=/^(?:[?*+]|{\\d+(?:,\\d*)?})\\??/,v=11,u=[],n={X:15.Z.X,1A:15.Z.1A,1C:1r.Z.1C,Q:1r.Z.Q,1e:1r.Z.1e},x=n.X.W(/()??/,"")[1]===1d,D=6(){K f=/^/g;n.1A.W(f,"");H!f.12}(),y=6(){K f=/x/g;n.Q.W("x",f,"");H!f.12}(),E=15.Z.3n!==1d,z={};z[M.2I]=/^(?:\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\29-26-f]{2}|u[\\29-26-f]{4}|c[A-3o-z]|[\\s\\S]))/;z[M.1B]=/^(?:\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\29-26-f]{2}|u[\\29-26-f]{4}|c[A-3o-z]|[\\s\\S])|\\(\\?[:=!]|[?*+]\\?|{\\d+(?:,\\d*)?}\\??)/;M.1h=6(f,e,a,b){u.U({2q:r(f,"g"+(E?"y":"")),2b:e,3r:a||M.1B,2p:b||N})};M.2n=6(f,e){K a=f+"/"+(e||"");H M.2n[a]||(M.2n[a]=M(f,e))};M.3c=6(f){H r(f,"g")};M.5l=6(f){H f.Q(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g,"\\\\$&")};M.5e=6(f,e,a,b){e=r(e,"g"+(b&&E?"y":""));e.12=a=a||0;f=e.X(f);H b?f&&f.P===a?f:N:f};M.3q=6(){M.1h=6(){1S 2U("2a\'t 55 1h 54 3q")}};M.1R=6(f){H 53.Z.1q.W(f)==="[2m 15]"};M.3p=6(f,e,a,b){O(K c=r(e,"g"),d=-1,h;h=c.X(f);){a.W(b,h,++d,f,c);c.12===h.P&&c.12++}I(e.1J)e.12=0};M.57=6(f,e){H 6 a(b,c){K d=e[c].1I?e[c]:{1I:e[c]},h=r(d.1I,"g"),g=[],i;O(i=0;i<b.L;i++)M.3p(b[i],h,6(k){g.U(d.3j?k[d.3j]||"":k[0])});H c===e.L-1||!g.L?g:a(g,c+1)}([f],0)};15.Z.1p=6(f,e){H J.X(e[0])};15.Z.W=6(f,e){H J.X(e)};15.Z.X=6(f){K e=n.X.1p(J,14),a;I(e){I(!x&&e.L>1&&p(e,"")>-1){a=15(J.1m,n.Q.W(t(J),"g",""));n.Q.W(f.1a(e.P),a,6(){O(K c=1;c<14.L-2;c++)I(14[c]===1d)e[c]=1d})}I(J.1w&&J.1w.19)O(K b=1;b<e.L;b++)I(a=J.1w.19[b-1])e[a]=e[b];!D&&J.1J&&!e[0].L&&J.12>e.P&&J.12--}H e};I(!D)15.Z.1A=6(f){(f=n.X.W(J,f))&&J.1J&&!f[0].L&&J.12>f.P&&J.12--;H!!f};1r.Z.1C=6(f){M.1R(f)||(f=15(f));I(f.1J){K e=n.1C.1p(J,14);f.12=0;H e}H f.X(J)};1r.Z.Q=6(f,e){K a=M.1R(f),b,c;I(a&&1j e.58()==="3f"&&e.1i("${")===-1&&y)H n.Q.1p(J,14);I(a){I(f.1w)b=f.1w.19}Y f+="";I(1j e==="6")c=n.Q.W(J,f,6(){I(b){14[0]=1f 1r(14[0]);O(K d=0;d<b.L;d++)I(b[d])14[0][b[d]]=14[d+1]}I(a&&f.1J)f.12=14[14.L-2]+14[0].L;H e.1p(N,14)});Y{c=J+"";c=n.Q.W(c,f,6(){K d=14;H n.Q.W(e,C,6(h,g,i){I(g)5b(g){24"$":H"$";24"&":H d[0];24"`":H d[d.L-1].1a(0,d[d.L-2]);24"\'":H d[d.L-1].1a(d[d.L-2]+d[0].L);5a:i="";g=+g;I(!g)H h;O(;g>d.L-3;){i=1r.Z.1a.W(g,-1)+i;g=1Q.3i(g/10)}H(g?d[g]||"":"$")+i}Y{g=+i;I(g<=d.L-3)H d[g];g=b?p(b,i):-1;H g>-1?d[g+1]:h}})})}I(a&&f.1J)f.12=0;H c};1r.Z.1e=6(f,e){I(!M.1R(f))H n.1e.1p(J,14);K a=J+"",b=[],c=0,d,h;I(e===1d||+e<0)e=5D;Y{e=1Q.3i(+e);I(!e)H[]}O(f=M.3c(f);d=f.X(a);){I(f.12>c){b.U(a.1a(c,d.P));d.L>1&&d.P<a.L&&3b.Z.U.1p(b,d.1a(1));h=d[0].L;c=f.12;I(b.L>=e)1N}f.12===d.P&&f.12++}I(c===a.L){I(!n.1A.W(f,"")||h)b.U("")}Y b.U(a.1a(c));H b.L>e?b.1a(0,e):b};M.1h(/\\(\\?#[^)]*\\)/,6(f){H n.1A.W(A,f.2S.1a(f.P+f[0].L))?"":"(?:)"});M.1h(/\\((?!\\?)/,6(){J.19.U(N);H"("});M.1h(/\\(\\?<([$\\w]+)>/,6(f){J.19.U(f[1]);J.2N=R;H"("});M.1h(/\\\\k<([\\w$]+)>/,6(f){K e=p(J.19,f[1]);H e>-1?"\\\\"+(e+1)+(3R(f.2S.3a(f.P+f[0].L))?"":"(?:)"):f[0]});M.1h(/\\[\\^?]/,6(f){H f[0]==="[]"?"\\\\b\\\\B":"[\\\\s\\\\S]"});M.1h(/^\\(\\?([5A]+)\\)/,6(f){J.3d(f[1]);H""});M.1h(/(?:\\s+|#.*)+/,6(f){H n.1A.W(A,f.2S.1a(f.P+f[0].L))?"":"(?:)"},M.1B,6(){H J.2K("x")});M.1h(/\\./,6(){H"[\\\\s\\\\S]"},M.1B,6(){H J.2K("s")})})();1j 2e!="1d"&&(2e.M=M);K 1v=6(){6 r(a,b){a.1l.1i(b)!=-1||(a.1l+=" "+b)}6 t(a){H a.1i("3e")==0?a:"3e"+a}6 B(a){H e.1Y.2A[t(a)]}6 p(a,b,c){I(a==N)H N;K d=c!=R?a.3G:[a.2G],h={"#":"1c",".":"1l"}[b.1o(0,1)]||"3h",g,i;g=h!="3h"?b.1o(1):b.5u();I((a[h]||"").1i(g)!=-1)H a;O(a=0;d&&a<d.L&&i==N;a++)i=p(d[a],b,c);H i}6 C(a,b){K c={},d;O(d 2g a)c[d]=a[d];O(d 2g b)c[d]=b[d];H c}6 w(a,b,c,d){6 h(g){g=g||1P.5y;I(!g.1F){g.1F=g.52;g.3N=6(){J.5w=11}}c.W(d||1P,g)}a.3g?a.3g("4U"+b,h):a.4y(b,h,11)}6 A(a,b){K c=e.1Y.2j,d=N;I(c==N){c={};O(K h 2g e.1U){K g=e.1U[h];d=g.4x;I(d!=N){g.1V=h.4w();O(g=0;g<d.L;g++)c[d[g]]=h}}e.1Y.2j=c}d=e.1U[c[a]];d==N&&b!=11&&1P.1X(e.13.1x.1X+(e.13.1x.3E+a));H d}6 v(a,b){O(K c=a.1e("\\n"),d=0;d<c.L;d++)c[d]=b(c[d],d);H c.1K("\\n")}6 u(a,b){I(a==N||a.L==0||a=="\\n")H a;a=a.Q(/</g,"&1y;");a=a.Q(/ {2,}/g,6(c){O(K d="",h=0;h<c.L-1;h++)d+=e.13.1W;H d+" "});I(b!=N)a=v(a,6(c){I(c.L==0)H"";K d="";c=c.Q(/^(&2s;| )+/,6(h){d=h;H""});I(c.L==0)H d;H d+\'<17 1g="\'+b+\'">\'+c+"</17>"});H a}6 n(a,b){a.1e("\\n");O(K c="",d=0;d<50;d++)c+="                    ";H a=v(a,6(h){I(h.1i("\\t")==-1)H h;O(K g=0;(g=h.1i("\\t"))!=-1;)h=h.1o(0,g)+c.1o(0,b-g%b)+h.1o(g+1,h.L);H h})}6 x(a){H a.Q(/^\\s+|\\s+$/g,"")}6 D(a,b){I(a.P<b.P)H-1;Y I(a.P>b.P)H 1;Y I(a.L<b.L)H-1;Y I(a.L>b.L)H 1;H 0}6 y(a,b){6 c(k){H k[0]}O(K d=N,h=[],g=b.2D?b.2D:c;(d=b.1I.X(a))!=N;){K i=g(d,b);I(1j i=="3f")i=[1f e.2L(i,d.P,b.23)];h=h.1O(i)}H h}6 E(a){K b=/(.*)((&1G;|&1y;).*)/;H a.Q(e.3A.3M,6(c){K d="",h=N;I(h=b.X(c)){c=h[1];d=h[2]}H\'<a 2h="\'+c+\'">\'+c+"</a>"+d})}6 z(){O(K a=1E.36("1k"),b=[],c=0;c<a.L;c++)a[c].3s=="20"&&b.U(a[c]);H b}6 f(a){a=a.1F;K b=p(a,".20",R);a=p(a,".3O",R);K c=1E.4i("3t");I(!(!a||!b||p(a,"3t"))){B(b.1c);r(b,"1m");O(K d=a.3G,h=[],g=0;g<d.L;g++)h.U(d[g].4z||d[g].4A);h=h.1K("\\r");c.39(1E.4D(h));a.39(c);c.2C();c.4C();w(c,"4u",6(){c.2G.4E(c);b.1l=b.1l.Q("1m","")})}}I(1j 3F!="1d"&&1j M=="1d")M=3F("M").M;K e={2v:{"1g-27":"","2i-1s":1,"2z-1s-2t":11,1M:N,1t:N,"42-45":R,"43-22":4,1u:R,16:R,"3V-17":R,2l:11,"41-40":R,2k:11,"1z-1k":11},13:{1W:"&2s;",2M:R,46:11,44:11,34:"4n",1x:{21:"4o 1m",2P:"?",1X:"1v\\n\\n",3E:"4r\'t 4t 1D O: ",4g:"4m 4B\'t 51 O 1z-1k 4F: ",37:\'<!4T 1z 4S "-//4V//3H 4W 1.0 4Z//4Y" "1Z://2y.3L.3K/4X/3I/3H/3I-4P.4J"><1z 4I="1Z://2y.3L.3K/4L/5L"><3J><4N 1Z-4M="5G-5M" 6K="2O/1z; 6J=6I-8" /><1t>6L 1v</1t></3J><3B 1L="25-6M:6Q,6P,6O,6N-6F;6y-2f:#6x;2f:#6w;25-22:6v;2O-3D:3C;"><T 1L="2O-3D:3C;3w-32:1.6z;"><T 1L="25-22:6A-6E;">1v</T><T 1L="25-22:.6C;3w-6B:6R;"><T>3v 3.0.76 (72 73 3x)</T><T><a 2h="1Z://3u.2w/1v" 1F="38" 1L="2f:#3y">1Z://3u.2w/1v</a></T><T>70 17 6U 71.</T><T>6T 6X-3x 6Y 6D.</T></T><T>6t 61 60 J 1k, 5Z <a 2h="6u://2y.62.2w/63-66/65?64=5X-5W&5P=5O" 1L="2f:#3y">5R</a> 5V <2R/>5U 5T 5S!</T></T></3B></1z>\'}},1Y:{2j:N,2A:{}},1U:{},3A:{6n:/\\/\\*[\\s\\S]*?\\*\\//2c,6m:/\\/\\/.*$/2c,6l:/#.*$/2c,6k:/"([^\\\\"\\n]|\\\\.)*"/g,6o:/\'([^\\\\\'\\n]|\\\\.)*\'/g,6p:1f M(\'"([^\\\\\\\\"]|\\\\\\\\.)*"\',"3z"),6s:1f M("\'([^\\\\\\\\\']|\\\\\\\\.)*\'","3z"),6q:/(&1y;|<)!--[\\s\\S]*?--(&1G;|>)/2c,3M:/\\w+:\\/\\/[\\w-.\\/?%&=:@;]*/g,6a:{18:/(&1y;|<)\\?=?/g,1b:/\\?(&1G;|>)/g},69:{18:/(&1y;|<)%=?/g,1b:/%(&1G;|>)/g},6d:{18:/(&1y;|<)\\s*1k.*?(&1G;|>)/2T,1b:/(&1y;|<)\\/\\s*1k\\s*(&1G;|>)/2T}},16:{1H:6(a){6 b(i,k){H e.16.2o(i,k,e.13.1x[k])}O(K c=\'<T 1g="16">\',d=e.16.2x,h=d.2X,g=0;g<h.L;g++)c+=(d[h[g]].1H||b)(a,h[g]);c+="</T>";H c},2o:6(a,b,c){H\'<2W><a 2h="#" 1g="6e 6h\'+b+" "+b+\'">\'+c+"</a></2W>"},2b:6(a){K b=a.1F,c=b.1l||"";b=B(p(b,".20",R).1c);K d=6(h){H(h=15(h+"6f(\\\\w+)").X(c))?h[1]:N}("6g");b&&d&&e.16.2x[d].2B(b);a.3N()},2x:{2X:["21","2P"],21:{1H:6(a){I(a.V("2l")!=R)H"";K b=a.V("1t");H e.16.2o(a,"21",b?b:e.13.1x.21)},2B:6(a){a=1E.6j(t(a.1c));a.1l=a.1l.Q("47","")}},2P:{2B:6(){K a="68=0";a+=", 18="+(31.30-33)/2+", 32="+(31.2Z-2Y)/2+", 30=33, 2Z=2Y";a=a.Q(/^,/,"");a=1P.6Z("","38",a);a.2C();K b=a.1E;b.6W(e.13.1x.37);b.6V();a.2C()}}}},35:6(a,b){K c;I(b)c=[b];Y{c=1E.36(e.13.34);O(K d=[],h=0;h<c.L;h++)d.U(c[h]);c=d}c=c;d=[];I(e.13.2M)c=c.1O(z());I(c.L===0)H d;O(h=0;h<c.L;h++){O(K g=c[h],i=a,k=c[h].1l,j=3W 0,l={},m=1f M("^\\\\[(?<2V>(.*?))\\\\]$"),s=1f M("(?<27>[\\\\w-]+)\\\\s*:\\\\s*(?<1T>[\\\\w-%#]+|\\\\[.*?\\\\]|\\".*?\\"|\'.*?\')\\\\s*;?","g");(j=s.X(k))!=N;){K o=j.1T.Q(/^[\'"]|[\'"]$/g,"");I(o!=N&&m.1A(o)){o=m.X(o);o=o.2V.L>0?o.2V.1e(/\\s*,\\s*/):[]}l[j.27]=o}g={1F:g,1n:C(i,l)};g.1n.1D!=N&&d.U(g)}H d},1M:6(a,b){K c=J.35(a,b),d=N,h=e.13;I(c.L!==0)O(K g=0;g<c.L;g++){b=c[g];K i=b.1F,k=b.1n,j=k.1D,l;I(j!=N){I(k["1z-1k"]=="R"||e.2v["1z-1k"]==R){d=1f e.4l(j);j="4O"}Y I(d=A(j))d=1f d;Y 6H;l=i.3X;I(h.2M){l=l;K m=x(l),s=11;I(m.1i("<![6G[")==0){m=m.4h(9);s=R}K o=m.L;I(m.1i("]]\\>")==o-3){m=m.4h(0,o-3);s=R}l=s?m:l}I((i.1t||"")!="")k.1t=i.1t;k.1D=j;d.2Q(k);b=d.2F(l);I((i.1c||"")!="")b.1c=i.1c;i.2G.74(b,i)}}},2E:6(a){w(1P,"4k",6(){e.1M(a)})}};e.2E=e.2E;e.1M=e.1M;e.2L=6(a,b,c){J.1T=a;J.P=b;J.L=a.L;J.23=c;J.1V=N};e.2L.Z.1q=6(){H J.1T};e.4l=6(a){6 b(j,l){O(K m=0;m<j.L;m++)j[m].P+=l}K c=A(a),d,h=1f e.1U.5Y,g=J,i="2F 1H 2Q".1e(" ");I(c!=N){d=1f c;O(K k=0;k<i.L;k++)(6(){K j=i[k];g[j]=6(){H h[j].1p(h,14)}})();d.28==N?1P.1X(e.13.1x.1X+(e.13.1x.4g+a)):h.2J.U({1I:d.28.17,2D:6(j){O(K l=j.17,m=[],s=d.2J,o=j.P+j.18.L,F=d.28,q,G=0;G<s.L;G++){q=y(l,s[G]);b(q,o);m=m.1O(q)}I(F.18!=N&&j.18!=N){q=y(j.18,F.18);b(q,j.P);m=m.1O(q)}I(F.1b!=N&&j.1b!=N){q=y(j.1b,F.1b);b(q,j.P+j[0].5Q(j.1b));m=m.1O(q)}O(j=0;j<m.L;j++)m[j].1V=c.1V;H m}})}};e.4j=6(){};e.4j.Z={V:6(a,b){K c=J.1n[a];c=c==N?b:c;K d={"R":R,"11":11}[c];H d==N?c:d},3Y:6(a){H 1E.4i(a)},4c:6(a,b){K c=[];I(a!=N)O(K d=0;d<a.L;d++)I(1j a[d]=="2m")c=c.1O(y(b,a[d]));H J.4e(c.6b(D))},4e:6(a){O(K b=0;b<a.L;b++)I(a[b]!==N)O(K c=a[b],d=c.P+c.L,h=b+1;h<a.L&&a[b]!==N;h++){K g=a[h];I(g!==N)I(g.P>d)1N;Y I(g.P==c.P&&g.L>c.L)a[b]=N;Y I(g.P>=c.P&&g.P<d)a[h]=N}H a},4d:6(a){K b=[],c=2u(J.V("2i-1s"));v(a,6(d,h){b.U(h+c)});H b},3U:6(a){K b=J.V("1M",[]);I(1j b!="2m"&&b.U==N)b=[b];a:{a=a.1q();K c=3W 0;O(c=c=1Q.6c(c||0,0);c<b.L;c++)I(b[c]==a){b=c;1N a}b=-1}H b!=-1},2r:6(a,b,c){a=["1s","6i"+b,"P"+a,"6r"+(b%2==0?1:2).1q()];J.3U(b)&&a.U("67");b==0&&a.U("1N");H\'<T 1g="\'+a.1K(" ")+\'">\'+c+"</T>"},3Q:6(a,b){K c="",d=a.1e("\\n").L,h=2u(J.V("2i-1s")),g=J.V("2z-1s-2t");I(g==R)g=(h+d-1).1q().L;Y I(3R(g)==R)g=0;O(K i=0;i<d;i++){K k=b?b[i]:h+i,j;I(k==0)j=e.13.1W;Y{j=g;O(K l=k.1q();l.L<j;)l="0"+l;j=l}a=j;c+=J.2r(i,k,a)}H c},49:6(a,b){a=x(a);K c=a.1e("\\n");J.V("2z-1s-2t");K d=2u(J.V("2i-1s"));a="";O(K h=J.V("1D"),g=0;g<c.L;g++){K i=c[g],k=/^(&2s;|\\s)+/.X(i),j=N,l=b?b[g]:d+g;I(k!=N){j=k[0].1q();i=i.1o(j.L);j=j.Q(" ",e.13.1W)}i=x(i);I(i.L==0)i=e.13.1W;a+=J.2r(g,l,(j!=N?\'<17 1g="\'+h+\' 5N">\'+j+"</17>":"")+i)}H a},4f:6(a){H a?"<4a>"+a+"</4a>":""},4b:6(a,b){6 c(l){H(l=l?l.1V||g:g)?l+" ":""}O(K d=0,h="",g=J.V("1D",""),i=0;i<b.L;i++){K k=b[i],j;I(!(k===N||k.L===0)){j=c(k);h+=u(a.1o(d,k.P-d),j+"48")+u(k.1T,j+k.23);d=k.P+k.L+(k.75||0)}}h+=u(a.1o(d),c()+"48");H h},1H:6(a){K b="",c=["20"],d;I(J.V("2k")==R)J.1n.16=J.1n.1u=11;1l="20";J.V("2l")==R&&c.U("47");I((1u=J.V("1u"))==11)c.U("6S");c.U(J.V("1g-27"));c.U(J.V("1D"));a=a.Q(/^[ ]*[\\n]+|[\\n]*[ ]*$/g,"").Q(/\\r/g," ");b=J.V("43-22");I(J.V("42-45")==R)a=n(a,b);Y{O(K h="",g=0;g<b;g++)h+=" ";a=a.Q(/\\t/g,h)}a=a;a:{b=a=a;h=/<2R\\s*\\/?>|&1y;2R\\s*\\/?&1G;/2T;I(e.13.46==R)b=b.Q(h,"\\n");I(e.13.44==R)b=b.Q(h,"");b=b.1e("\\n");h=/^\\s*/;g=4Q;O(K i=0;i<b.L&&g>0;i++){K k=b[i];I(x(k).L!=0){k=h.X(k);I(k==N){a=a;1N a}g=1Q.4q(k[0].L,g)}}I(g>0)O(i=0;i<b.L;i++)b[i]=b[i].1o(g);a=b.1K("\\n")}I(1u)d=J.4d(a);b=J.4c(J.2J,a);b=J.4b(a,b);b=J.49(b,d);I(J.V("41-40"))b=E(b);1j 2H!="1d"&&2H.3S&&2H.3S.1C(/5s/)&&c.U("5t");H b=\'<T 1c="\'+t(J.1c)+\'" 1g="\'+c.1K(" ")+\'">\'+(J.V("16")?e.16.1H(J):"")+\'<3Z 5z="0" 5H="0" 5J="0">\'+J.4f(J.V("1t"))+"<3T><3P>"+(1u?\'<2d 1g="1u">\'+J.3Q(a)+"</2d>":"")+\'<2d 1g="17"><T 1g="3O">\'+b+"</T></2d></3P></3T></3Z></T>"},2F:6(a){I(a===N)a="";J.17=a;K b=J.3Y("T");b.3X=J.1H(a);J.V("16")&&w(p(b,".16"),"5c",e.16.2b);J.V("3V-17")&&w(p(b,".17"),"56",f);H b},2Q:6(a){J.1c=""+1Q.5d(1Q.5n()*5k).1q();e.1Y.2A[t(J.1c)]=J;J.1n=C(e.2v,a||{});I(J.V("2k")==R)J.1n.16=J.1n.1u=11},5j:6(a){a=a.Q(/^\\s+|\\s+$/g,"").Q(/\\s+/g,"|");H"\\\\b(?:"+a+")\\\\b"},5f:6(a){J.28={18:{1I:a.18,23:"1k"},1b:{1I:a.1b,23:"1k"},17:1f M("(?<18>"+a.18.1m+")(?<17>.*?)(?<1b>"+a.1b.1m+")","5o")}}};H e}();1j 2e!="1d"&&(2e.1v=1v);',62,441,'||||||function|||||||||||||||||||||||||||||||||||||return|if|this|var|length|XRegExp|null|for|index|replace|true||div|push|getParam|call|exec|else|prototype||false|lastIndex|config|arguments|RegExp|toolbar|code|left|captureNames|slice|right|id|undefined|split|new|class|addToken|indexOf|typeof|script|className|source|params|substr|apply|toString|String|line|title|gutter|SyntaxHighlighter|_xregexp|strings|lt|html|test|OUTSIDE_CLASS|match|brush|document|target|gt|getHtml|regex|global|join|style|highlight|break|concat|window|Math|isRegExp|throw|value|brushes|brushName|space|alert|vars|http|syntaxhighlighter|expandSource|size|css|case|font|Fa|name|htmlScript|dA|can|handler|gm|td|exports|color|in|href|first|discoveredBrushes|light|collapse|object|cache|getButtonHtml|trigger|pattern|getLineHtml|nbsp|numbers|parseInt|defaults|com|items|www|pad|highlighters|execute|focus|func|all|getDiv|parentNode|navigator|INSIDE_CLASS|regexList|hasFlag|Match|useScriptTags|hasNamedCapture|text|help|init|br|input|gi|Error|values|span|list|250|height|width|screen|top|500|tagName|findElements|getElementsByTagName|aboutDialog|_blank|appendChild|charAt|Array|copyAsGlobal|setFlag|highlighter_|string|attachEvent|nodeName|floor|backref|output|the|TypeError|sticky|Za|iterate|freezeTokens|scope|type|textarea|alexgorbatchev|version|margin|2010|005896|gs|regexLib|body|center|align|noBrush|require|childNodes|DTD|xhtml1|head|org|w3|url|preventDefault|container|tr|getLineNumbersHtml|isNaN|userAgent|tbody|isLineHighlighted|quick|void|innerHTML|create|table|links|auto|smart|tab|stripBrs|tabs|bloggerMode|collapsed|plain|getCodeLinesHtml|caption|getMatchesHtml|findMatches|figureOutLineNumbers|removeNestedMatches|getTitleHtml|brushNotHtmlScript|substring|createElement|Highlighter|load|HtmlScript|Brush|pre|expand|multiline|min|Can|ignoreCase|find|blur|extended|toLowerCase|aliases|addEventListener|innerText|textContent|wasn|select|createTextNode|removeChild|option|same|frame|xmlns|dtd|twice|1999|equiv|meta|htmlscript|transitional|1E3|expected|PUBLIC|DOCTYPE|on|W3C|XHTML|TR|EN|Transitional||configured|srcElement|Object|after|run|dblclick|matchChain|valueOf|constructor|default|switch|click|round|execAt|forHtmlScript|token|gimy|functions|getKeywords|1E6|escape|within|random|sgi|another|finally|supply|MSIE|ie|toUpperCase|catch|returnValue|definition|event|border|imsx|constructing|one|Infinity|from|when|Content|cellpadding|flags|cellspacing|try|xhtml|Type|spaces|2930402|hosted_button_id|lastIndexOf|donate|active|development|keep|to|xclick|_s|Xml|please|like|you|paypal|cgi|cmd|webscr|bin|highlighted|scrollbars|aspScriptTags|phpScriptTags|sort|max|scriptScriptTags|toolbar_item|_|command|command_|number|getElementById|doubleQuotedString|singleLinePerlComments|singleLineCComments|multiLineCComments|singleQuotedString|multiLineDoubleQuotedString|xmlComments|alt|multiLineSingleQuotedString|If|https|1em|000|fff|background|5em|xx|bottom|75em|Gorbatchev|large|serif|CDATA|continue|utf|charset|content|About|family|sans|Helvetica|Arial|Geneva|3em|nogutter|Copyright|syntax|close|write|2004|Alex|open|JavaScript|highlighter|July|02|replaceChild|offset|83'.split('|'),0,{}))

/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
;(function()
{
	// CommonJS
	typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter : null;

	function Brush()
	{
		// Copyright 2006 Shin, YoungJin
	
		var datatypes =	'ATOM BOOL BOOLEAN BYTE CHAR COLORREF DWORD DWORDLONG DWORD_PTR ' +
						'DWORD32 DWORD64 FLOAT HACCEL HALF_PTR HANDLE HBITMAP HBRUSH ' +
						'HCOLORSPACE HCONV HCONVLIST HCURSOR HDC HDDEDATA HDESK HDROP HDWP ' +
						'HENHMETAFILE HFILE HFONT HGDIOBJ HGLOBAL HHOOK HICON HINSTANCE HKEY ' +
						'HKL HLOCAL HMENU HMETAFILE HMODULE HMONITOR HPALETTE HPEN HRESULT ' +
						'HRGN HRSRC HSZ HWINSTA HWND INT INT_PTR INT32 INT64 LANGID LCID LCTYPE ' +
						'LGRPID LONG LONGLONG LONG_PTR LONG32 LONG64 LPARAM LPBOOL LPBYTE LPCOLORREF ' +
						'LPCSTR LPCTSTR LPCVOID LPCWSTR LPDWORD LPHANDLE LPINT LPLONG LPSTR LPTSTR ' +
						'LPVOID LPWORD LPWSTR LRESULT PBOOL PBOOLEAN PBYTE PCHAR PCSTR PCTSTR PCWSTR ' +
						'PDWORDLONG PDWORD_PTR PDWORD32 PDWORD64 PFLOAT PHALF_PTR PHANDLE PHKEY PINT ' +
						'PINT_PTR PINT32 PINT64 PLCID PLONG PLONGLONG PLONG_PTR PLONG32 PLONG64 POINTER_32 ' +
						'POINTER_64 PSHORT PSIZE_T PSSIZE_T PSTR PTBYTE PTCHAR PTSTR PUCHAR PUHALF_PTR ' +
						'PUINT PUINT_PTR PUINT32 PUINT64 PULONG PULONGLONG PULONG_PTR PULONG32 PULONG64 ' +
						'PUSHORT PVOID PWCHAR PWORD PWSTR SC_HANDLE SC_LOCK SERVICE_STATUS_HANDLE SHORT ' +
						'SIZE_T SSIZE_T TBYTE TCHAR UCHAR UHALF_PTR UINT UINT_PTR UINT32 UINT64 ULONG ' +
						'ULONGLONG ULONG_PTR ULONG32 ULONG64 USHORT USN VOID WCHAR WORD WPARAM WPARAM WPARAM ' +
						'char bool short int __int32 __int64 __int8 __int16 long float double __wchar_t ' +
						'clock_t _complex _dev_t _diskfree_t div_t ldiv_t _exception _EXCEPTION_POINTERS ' +
						'FILE _finddata_t _finddatai64_t _wfinddata_t _wfinddatai64_t __finddata64_t ' +
						'__wfinddata64_t _FPIEEE_RECORD fpos_t _HEAPINFO _HFILE lconv intptr_t ' +
						'jmp_buf mbstate_t _off_t _onexit_t _PNH ptrdiff_t _purecall_handler ' +
						'sig_atomic_t size_t _stat __stat64 _stati64 terminate_function ' +
						'time_t __time64_t _timeb __timeb64 tm uintptr_t _utimbuf ' +
						'va_list wchar_t wctrans_t wctype_t wint_t signed';

		var keywords =	'break case catch class const __finally __exception __try ' +
						'const_cast continue private public protected __declspec ' +
						'default delete deprecated dllexport dllimport do dynamic_cast ' +
						'else enum explicit extern if for friend goto inline ' +
						'mutable naked namespace new noinline noreturn nothrow ' +
						'register reinterpret_cast return selectany ' +
						'sizeof static static_cast struct switch template this ' +
						'thread throw true false try typedef typeid typename union ' +
						'using uuid virtual void volatile whcar_t while';
					
		var functions =	'assert isalnum isalpha iscntrl isdigit isgraph islower isprint' +
						'ispunct isspace isupper isxdigit tolower toupper errno localeconv ' +
						'setlocale acos asin atan atan2 ceil cos cosh exp fabs floor fmod ' +
						'frexp ldexp log log10 modf pow sin sinh sqrt tan tanh jmp_buf ' +
						'longjmp setjmp raise signal sig_atomic_t va_arg va_end va_start ' +
						'clearerr fclose feof ferror fflush fgetc fgetpos fgets fopen ' +
						'fprintf fputc fputs fread freopen fscanf fseek fsetpos ftell ' +
						'fwrite getc getchar gets perror printf putc putchar puts remove ' +
						'rename rewind scanf setbuf setvbuf sprintf sscanf tmpfile tmpnam ' +
						'ungetc vfprintf vprintf vsprintf abort abs atexit atof atoi atol ' +
						'bsearch calloc div exit free getenv labs ldiv malloc mblen mbstowcs ' +
						'mbtowc qsort rand realloc srand strtod strtol strtoul system ' +
						'wcstombs wctomb memchr memcmp memcpy memmove memset strcat strchr ' +
						'strcmp strcoll strcpy strcspn strerror strlen strncat strncmp ' +
						'strncpy strpbrk strrchr strspn strstr strtok strxfrm asctime ' +
						'clock ctime difftime gmtime localtime mktime strftime time';

		this.regexList = [
			{ regex: SyntaxHighlighter.regexLib.singleLineCComments,	css: 'comments' },			// one line comments
			{ regex: SyntaxHighlighter.regexLib.multiLineCComments,		css: 'comments' },			// multiline comments
			{ regex: SyntaxHighlighter.regexLib.doubleQuotedString,		css: 'string' },			// strings
			{ regex: SyntaxHighlighter.regexLib.singleQuotedString,		css: 'string' },			// strings
			{ regex: /^ *#.*/gm,										css: 'preprocessor' },
			{ regex: new RegExp(this.getKeywords(datatypes), 'gm'),		css: 'color1 bold' },
			{ regex: new RegExp(this.getKeywords(functions), 'gm'),		css: 'functions bold' },
			{ regex: new RegExp(this.getKeywords(keywords), 'gm'),		css: 'keyword bold' }
			];
	};

	Brush.prototype	= new SyntaxHighlighter.Highlighter();
	Brush.aliases	= ['cpp', 'c'];

	SyntaxHighlighter.brushes.Cpp = Brush;

	// CommonJS
	typeof(exports) != 'undefined' ? exports.Brush = Brush : null;
})();

/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
;(function()
{
	// CommonJS
	typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter : null;

	function Brush()
	{
		var keywords =	'abstract assert boolean break byte case catch char class const ' +
						'continue default do double else enum extends ' +
						'false final finally float for goto if implements import ' +
						'instanceof int interface long native new null ' +
						'package private protected public return ' +
						'short static strictfp super switch synchronized this throw throws true ' +
						'transient try void volatile while';

		this.regexList = [
			{ regex: SyntaxHighlighter.regexLib.singleLineCComments,	css: 'comments' },		// one line comments
			{ regex: /\/\*([^\*][\s\S]*)?\*\//gm,						css: 'comments' },	 	// multiline comments
			{ regex: /\/\*(?!\*\/)\*[\s\S]*?\*\//gm,					css: 'preprocessor' },	// documentation comments
			{ regex: SyntaxHighlighter.regexLib.doubleQuotedString,		css: 'string' },		// strings
			{ regex: SyntaxHighlighter.regexLib.singleQuotedString,		css: 'string' },		// strings
			{ regex: /\b([\d]+(\.[\d]+)?|0x[a-f0-9]+)\b/gi,				css: 'value' },			// numbers
			{ regex: /(?!\@interface\b)\@[\$\w]+\b/g,					css: 'color1' },		// annotation @anno
			{ regex: /\@interface\b/g,									css: 'color2' },		// @interface keyword
			{ regex: new RegExp(this.getKeywords(keywords), 'gm'),		css: 'keyword' }		// java keyword
			];

		this.forHtmlScript({
			left	: /(&lt;|<)%[@!=]?/g, 
			right	: /%(&gt;|>)/g 
		});
	};

	Brush.prototype	= new SyntaxHighlighter.Highlighter();
	Brush.aliases	= ['java'];

	SyntaxHighlighter.brushes.Java = Brush;

	// CommonJS
	typeof(exports) != 'undefined' ? exports.Brush = Brush : null;
})();

$(function() {

    if($('.md-editor').length == 0) return;

    var simplemde = new SimpleMDE({
        element: $content[0],
        spellChecker: false,
        imagesModalUrl: imagesModalUrl,
        imagesModalInit: function () {
            $('#images-upload a').click(function () {
                // console.log('klik upload');
                $(this).parent().find('input').click();
            });

            $('#images-row > div').not('#images-empty').each(function (index, element) {

                initImageSelector($(element));

            });

            $('#images-upload').fileupload({

                // This element will accept file drag/drop uploading
                // dropZone: $('#upload-drop'),
                dataType: 'json',
                autoUpload: true,
                maxChunkSize: 1000000,
                method: "POST",
                sequentialUploads: true,
                loader: false,

                // This function is called when a file is added to the queue;
                // either via the browse button, or via drag/drop:
                start: function (e, data) {
                    e.stopPropagation();
                    e.preventDefault();


                    var progress =
                        '<div id="images-progress-bar" class="progress">' +
                        '<div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width:0%">' +
                        '<span class="sr-only">0%</span>' +
                        '</div>' +
                        '</div>' +
                        '<div id="images-progress-val">0%</div>';

                    $('#images-upload').after(progress);
                },

                add: function (e, data) {

                    var jqXHR = data.submit();
                },

                fail: function (e, data) {
                    console.log(e);

                    return;
                },

                done: function (e, data) {
                    var modalUrl = imageModalThumb.replace('?', data.result.code);
                    var articleUrl = imageArticleThumb.replace('?', data.result.code);

                    $.ajax({
                        url: modalUrl
                    }).done(function (data) {
                        $element = $(data);
                        $('.media-file-loader').last().replaceWith($element);

                        $('#images-empty').remove();
                        $('#images-row').append($element);

                        initImageSelector($element);
                    }).error(function (msg) {
                        console.log("chyba pocas zobrazovanie uploadnuteho suboru");
                    })

                    $.ajax({
                        url: articleUrl
                    }).done(function (data) {
                        $element = $(data);
                        $('#articleImages ul').append($element);


                    }).error(function (msg) {
                        console.log("chyba pocas zobrazovanie uploadnuteho suboru");
                    })
                },

                progressall: function (e, data) {
                    var progress = parseInt(data.loaded / data.total * 100, 10);

                    $progressBar = $('#images-progress-bar');
                    $progressVal = $('#images-progress-val');

                    $progressBar.css({width: progress + '%'}).find('.sr-only').html(progress + '%');
                    $progressVal.html(progress + '%');

                    if (progress == 100) {
                        $progressBar.addClass('progress-bar-success');
                        window.setTimeout(function () {
                            $progressBar.remove();
                            $progressVal.remove();
                        }, 3000);
                    }
                }
            });

            // Prevent the default action when a file is dropped on the window
            $(document).on('drop dragover', function (e) {
                e.preventDefault();
            });
        },

    });

    simplemde.codemirror.on('refresh', function () {
        if ($(simplemde.element).closest('.form-group').find('.CodeMirror').hasClass('CodeMirror-fullscreen')) {
            var width = $('#content-navigation').width();
            $('#content-navigation').css({
                'position': 'fixed',
                'top': '90px',
                'width': width + 'px',
                'margin': 0
            });

            $('.navbar').addClass('navbar-bg');

        } else {
            $('#content-navigation').removeAttr('style');

            if ($(window).scrollTop() > 20) {
                $('.navbar').addClass('navbar-bg');
            }
            else {
                $('.navbar').removeClass('navbar-bg');
            }
        }
    });

    simplemde.codemirror.on("change", function () {
        if ($noDescCheck.is(':checked')) {
            $descText.val(simplemde.value().substring(0, descLength));
        }
    });

    $noDescCheck.change(function () {

        if ($noDescCheck.is(':checked')) {
            console.log('checked');
            $descText.attr('disabled', true)

            $descText.val(simplemde.value().trim().substring(0, descLength));

        } else {
            console.log('not checked');
            $descText.removeAttr('disabled');
        }
    });

    function initImageSelector($element) {
        $element.find('.images-square').click(function () {
            $image = $(this);

            $image.closest('#images-row').find('.images-square').removeClass('selected');

            $image.addClass('selected');
        });
    }

    $(document).on('click', '.image-delete', function (e) {
        e.preventDefault();
        e.stopPropagation();

        var $link = $(this);

        $.ajax({
            url: $link.attr('href'),
            method: 'delete'
        }).done(function (data) {
            console.log(data);
            $link.closest('li').remove();

        }).error(function (jqXHR) {
            console.log(jqXHR);
        })


    })


});
$(function() {
    setTimeout(function () {
        $('#flash div.alert').not('.alert-important').hide("slide", { direction: "right" }, 1000);
    },3000);
});



$(document).on('click', '.btn-modal', function (e) {
    e.preventDefault();
    e.stopPropagation();

    var $link = $(e.target).closest('a');

    $.ajax({
        url: $link.attr('href')
    }).done(function (data) {
        var $modal = $(data);

        $('body').append($modal);
        $modal.modal();

        $modal.find('.btn.cancel').click(function () {
            if (typeof (options.cancel.callback) === 'function') {
                options.cancel.callback();
            }
        });

        $modal.find('.btn.success').click(function () {
            if (typeof (options.success.callback) === 'function') {
                options.success.callback();
            }

            $modal.modal('hide');
        });

        $modal.on('hidden.bs.modal', function (e) {
            $modal.remove();
            $('.modal-backdrop').remove();
        })
    }).error(function () {

    });
});


function alert(options) {
    var $modal =
        $('<div class="modal fade" tabindex="-1" role="dialog">' +
            '<div class="modal-dialog" role="document">' +
            '<div class="modal-content">' +
            '<div class="modal-header">' +
            '<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>' +
            '<h4 class="modal-title">' + options.title + '</h4>' +
            '</div>' +
            '<div class="modal-body">' + options.body + '</div>' +
            '<div class="modal-footer">' +
            '<button type="button" class="btn cancel btn-' + options.cancel.class + '" data-dismiss="modal">' + options.cancel.title + '</button>' +
            '<button type="button" class="btn success btn-' + options.success.class + '">' + options.success.title + '</button>' +
            '</div>' +
            '</div>' +
            '</div>' +
            '</div>');


    $('body').append($modal);
    $modal.modal();

    $modal.find('.btn.cancel').click(function () {
        if (typeof (options.cancel.callback) === 'function') {
            options.cancel.callback();
        }
        ;

    });

    $modal.find('.btn.success').click(function () {
        if (typeof (options.success.callback) === 'function') {
            options.success.callback();
        }
        ;
        $modal.modal('hide');
    });

    $modal.on('hidden.bs.modal', function (e) {
        $modal.remove();
    })
}

function modal(options) {
    $.ajax({
        url: options.url,
    }).done(function (data) {
        var $modal = $(data);

        $('body').append($modal);
        $modal.modal('show');

        if (typeof (options.init) === 'function') {
            options.init();
        }

        $modal.find('.btn.cancel').click(function () {
            if (typeof (options.cancel.callback) === 'function') {
                options.cancel.callback();
            }
            ;

        });

        $modal.find('.btn.success').click(function () {
            if (typeof (options.success.callback) === 'function') {
                options.success.callback();
            }
            ;
            $modal.modal('hide');
        });

        $modal.on('hidden.bs.modal', function (e) {
            $modal.remove();
            $('.modal-backdrop').remove();
        })
    }).error(function () {

    });


}
$(window).scroll(function () {
    var scroll   = $(window).scrollTop();
    var $sidebar = $('.sidebar-wrapper');

    if (scroll > 20) {
        $('.navbar').addClass('navbar-bg');
    }
    else {
        $('.navbar').removeClass('navbar-bg');
    }

});
$(window).load(function () {
    var scroll = $(window).scrollTop();
    if (scroll > 20) {
        $('.navbar').addClass('navbar-bg');
    }
    else {
        $('.navbar').removeClass('navbar-bg');
    }

});

$.ajaxSetup({
	headers: {'X-CSRF-Token': $('meta[name=_token]').attr('content')}
});

$('.js-select').select2();

$('.datepicker').datepicker({
    language: 'sk',
    format: 'dd. mm. yyyy',
});

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5qcyIsImpxdWVyeS11aS5qcyIsImJvb3RzdHJhcC5qcyIsInNlbGVjdDIuanMiLCJzaW1wbGVtZGUuanMiLCJqcXVlcnkuaWZyYW1lLXRyYW5zcG9ydC5qcyIsImpxdWVyeS5maWxldXBsb2FkLmpzIiwiYm9vdHN0cmFwLWRhdGVwaWNrZXIuanMiLCJib290c3RyYXAtZGF0ZXBpY2tlci5zay5qcyIsInNoQ29yZS5qcyIsInNoQnJ1c2hDcHAuanMiLCJzaEJydXNoSmF2YS5qcyIsIm1kLWVkaXRvci5qcyIsIm1vZGFscy1hbGVydHMuanMiLCJuYXZiYXIuanMiLCJzY3JpcHQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNybFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDenFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcHlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ppUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzE4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaGdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMi40XG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDUtMjBUMTc6MjNaXG4gKi9cblxuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cbiAgICBpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuICAgICAgICAvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG4gICAgICAgIC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG4gICAgICAgIC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG4gICAgICAgIC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuICAgICAgICAvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuICAgICAgICAvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG4gICAgICAgIC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cbiAgICAgICAgICAgIGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcbiAgICAgICAgICAgIGZ1bmN0aW9uKCB3ICkge1xuICAgICAgICAgICAgICAgIGlmICggIXcuZG9jdW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoIHcgKTtcbiAgICAgICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeSggZ2xvYmFsICk7XG4gICAgfVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXG4vLyBDYW4ndCBiZSBpbiBzdHJpY3QgbW9kZSwgc2V2ZXJhbCBsaWJzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXG4vLyB0aGUgc3RhY2sgdmlhIGFyZ3VtZW50cy5jYWxsZXIuY2FsbGVlIGFuZCBGaXJlZm94IGRpZXMgaWZcbi8vIHlvdSB0cnkgdG8gdHJhY2UgdGhyb3VnaCBcInVzZSBzdHJpY3RcIiBjYWxsIGNoYWlucy4gKCMxMzMzNSlcbi8vXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGFyciA9IFtdO1xuXG4gICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG4gICAgdmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG4gICAgdmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbiAgICB2YXIgcHVzaCA9IGFyci5wdXNoO1xuXG4gICAgdmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxuICAgIHZhciBjbGFzczJ0eXBlID0ge307XG5cbiAgICB2YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG4gICAgdmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgICB2YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxuICAgIHZhclxuICAgICAgICB2ZXJzaW9uID0gXCIyLjIuNFwiLFxuXG4gICAgICAgIC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG4gICAgICAgIGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuICAgICAgICAgICAgLy8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG4gICAgICAgICAgICAvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1BcbiAgICAgICAgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cbiAgICAgICAgLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG4gICAgICAgIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG4gICAgICAgIHJkYXNoQWxwaGEgPSAvLShbXFxkYS16XSkvZ2ksXG5cbiAgICAgICAgLy8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuICAgICAgICBmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9O1xuXG4gICAgalF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG4gICAgICAgIGpxdWVyeTogdmVyc2lvbixcblxuICAgICAgICBjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3JcbiAgICAgICAgc2VsZWN0b3I6IFwiXCIsXG5cbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG4gICAgICAgIGxlbmd0aDogMCxcblxuICAgICAgICB0b0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuICAgICAgICAvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtICE9IG51bGwgP1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuICAgICAgICAgICAgICAgICggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcbiAgICAgICAgICAgICAgICBzbGljZS5jYWxsKCB0aGlzICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuICAgICAgICAvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcbiAgICAgICAgcHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG4gICAgICAgICAgICB2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG4gICAgICAgICAgICByZXQucHJldk9iamVjdCA9IHRoaXM7XG4gICAgICAgICAgICByZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cbiAgICAgICAgZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuICAgICAgICAgICAgfSApICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXJzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcSggMCApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoIC0xICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXE6IGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICAgICAgLy8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG4gICAgICAgIHB1c2g6IHB1c2gsXG4gICAgICAgIHNvcnQ6IGFyci5zb3J0LFxuICAgICAgICBzcGxpY2U6IGFyci5zcGxpY2VcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG4gICAgICAgICAgICBpID0gMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBkZWVwID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuICAgICAgICAgICAgZGVlcCA9IHRhcmdldDtcblxuICAgICAgICAgICAgLy8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcbiAgICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgICAgICBpZiAoIGkgPT09IGxlbmd0aCApIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgaWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG4gICAgICAgICAgICAgICAgZm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbIG5hbWUgXTtcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvcHlJc0FycmF5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0gY29weTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQoIHtcblxuICAgICAgICAvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2VcbiAgICAgICAgZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuICAgICAgICAvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuICAgICAgICBpc1JlYWR5OiB0cnVlLFxuXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBub29wOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuICAgICAgICBpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAgICAgICAvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG4gICAgICAgICAgICAvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG4gICAgICAgICAgICAvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cbiAgICAgICAgICAgIC8vIGFkZGluZyAxIGNvcnJlY3RzIGxvc3Mgb2YgcHJlY2lzaW9uIGZyb20gcGFyc2VGbG9hdCAoIzE1MTAwKVxuICAgICAgICAgICAgdmFyIHJlYWxTdHJpbmdPYmogPSBvYmogJiYgb2JqLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gIWpRdWVyeS5pc0FycmF5KCBvYmogKSAmJiAoIHJlYWxTdHJpbmdPYmogLSBwYXJzZUZsb2F0KCByZWFsU3RyaW5nT2JqICkgKyAxICkgPj0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgICAgdmFyIGtleTtcblxuICAgICAgICAgICAgLy8gTm90IHBsYWluIG9iamVjdHM6XG4gICAgICAgICAgICAvLyAtIEFueSBvYmplY3Qgb3IgdmFsdWUgd2hvc2UgaW50ZXJuYWwgW1tDbGFzc11dIHByb3BlcnR5IGlzIG5vdCBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICAgICAgICAvLyAtIERPTSBub2Rlc1xuICAgICAgICAgICAgLy8gLSB3aW5kb3dcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LnR5cGUoIG9iaiApICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuICAgICAgICAgICAgaWYgKCBvYmouY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duLmNhbGwoIG9iaiwgXCJjb25zdHJ1Y3RvclwiICkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duLmNhbGwoIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgfHwge30sIFwiaXNQcm90b3R5cGVPZlwiICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcbiAgICAgICAgICAgIC8vIGlmIGxhc3Qgb25lIGlzIG93biwgdGhlbiBhbGwgcHJvcGVydGllcyBhcmUgb3duXG4gICAgICAgICAgICBmb3IgKCBrZXkgaW4gb2JqICkge31cblxuICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGhhc093bi5jYWxsKCBvYmosIGtleSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICAgIGZvciAoIG5hbWUgaW4gb2JqICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgICAgICBpZiAoIG9iaiA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogKyBcIlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMCwgaU9TPDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG4gICAgICAgICAgICAgICAgY2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb2JqO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG4gICAgICAgIGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuICAgICAgICAgICAgdmFyIHNjcmlwdCxcbiAgICAgICAgICAgICAgICBpbmRpcmVjdCA9IGV2YWw7XG5cbiAgICAgICAgICAgIGNvZGUgPSBqUXVlcnkudHJpbSggY29kZSApO1xuXG4gICAgICAgICAgICBpZiAoIGNvZGUgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29kZSBpbmNsdWRlcyBhIHZhbGlkLCBwcm9sb2d1ZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgIC8vIHN0cmljdCBtb2RlIHByYWdtYSwgZXhlY3V0ZSBjb2RlIGJ5IGluamVjdGluZyBhXG4gICAgICAgICAgICAgICAgLy8gc2NyaXB0IHRhZyBpbnRvIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICBpZiAoIGNvZGUuaW5kZXhPZiggXCJ1c2Ugc3RyaWN0XCIgKSA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQudGV4dCA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhdm9pZCB0aGUgRE9NIG5vZGUgY3JlYXRpb24sIGluc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmVtb3ZhbCBieSB1c2luZyBhbiBpbmRpcmVjdCBnbG9iYWwgZXZhbFxuXG4gICAgICAgICAgICAgICAgICAgIGluZGlyZWN0KCBjb2RlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbiAgICAgICAgLy8gU3VwcG9ydDogSUU5LTExK1xuICAgICAgICAvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG4gICAgICAgIGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCwgaSA9IDA7XG5cbiAgICAgICAgICAgIGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoIGkgaW4gb2JqICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG4gICAgICAgIHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgXCJcIiA6XG4gICAgICAgICAgICAgICAgKCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgICBtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKCBhcnIgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBhcnIgXSA6IGFyclxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbCggcmV0LCBhcnIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICAgICAgaSA9IGZpcnN0Lmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0Lmxlbmd0aCA9IGk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgfSxcblxuICAgICAgICBncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tJbnZlcnNlLFxuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG4gICAgICAgICAgICAvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG4gICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgICBtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgsIHZhbHVlLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIHJldCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuICAgICAgICAgICAgaWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICggaSBpbiBlbGVtcyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcbiAgICAgICAgZ3VpZDogMSxcblxuICAgICAgICAvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbiAgICAgICAgLy8gYXJndW1lbnRzLlxuICAgICAgICBwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgdmFyIHRtcCwgYXJncywgcHJveHk7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gZm5bIGNvbnRleHQgXTtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gZm47XG4gICAgICAgICAgICAgICAgZm4gPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG4gICAgICAgICAgICAvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2ltdWxhdGVkIGJpbmRcbiAgICAgICAgICAgIGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcbiAgICAgICAgICAgIHByb3h5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG4gICAgICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbm93OiBEYXRlLm5vdyxcblxuICAgICAgICAvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcbiAgICAgICAgLy8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cbiAgICAgICAgc3VwcG9ydDogc3VwcG9ydFxuICAgIH0gKTtcblxuLy8gSlNIaW50IHdvdWxkIGVycm9yIG9uIHRoaXMgY29kZSBkdWUgdG8gdGhlIFN5bWJvbCBub3QgYmVpbmcgZGVmaW5lZCBpbiBFUzUuXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuanNoaW50cmMgd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBqdXN0IGRpc2FibGUgSlNIaW50IGZvciB0aGVzZVxuLy8gdGhyZWUgbGluZXMuXG4gICAgLyoganNoaW50IGlnbm9yZTogc3RhcnQgKi9cbiAgICBpZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcbiAgICAgICAgalF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG4gICAgfVxuICAgIC8qIGpzaGludCBpZ25vcmU6IGVuZCAqL1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbiAgICBqUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuICAgICAgICBmdW5jdGlvbiggaSwgbmFtZSApIHtcbiAgICAgICAgICAgIGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9ICk7XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IGlPUyA4LjIgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuICAgICAgICAvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG4gICAgICAgIC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuICAgICAgICAvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG4gICAgICAgIHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuICAgICAgICAgICAgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuICAgICAgICBpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgIHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG4gICAgfVxuICAgIHZhciBTaXp6bGUgPVxuICAgICAgICAvKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjIuMVxuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNS0xMC0xN1xuICovXG4gICAgICAgIChmdW5jdGlvbiggd2luZG93ICkge1xuXG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBzdXBwb3J0LFxuICAgICAgICAgICAgICAgIEV4cHIsXG4gICAgICAgICAgICAgICAgZ2V0VGV4dCxcbiAgICAgICAgICAgICAgICBpc1hNTCxcbiAgICAgICAgICAgICAgICB0b2tlbml6ZSxcbiAgICAgICAgICAgICAgICBjb21waWxlLFxuICAgICAgICAgICAgICAgIHNlbGVjdCxcbiAgICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0LFxuICAgICAgICAgICAgICAgIHNvcnRJbnB1dCxcbiAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUsXG5cbiAgICAgICAgICAgICAgICAvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG4gICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZG9jRWxlbSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudElzSFRNTCxcbiAgICAgICAgICAgICAgICByYnVnZ3lRU0EsXG4gICAgICAgICAgICAgICAgcmJ1Z2d5TWF0Y2hlcyxcbiAgICAgICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zLFxuXG4gICAgICAgICAgICAgICAgLy8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuICAgICAgICAgICAgICAgIGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGRpcnJ1bnMgPSAwLFxuICAgICAgICAgICAgICAgIGRvbmUgPSAwLFxuICAgICAgICAgICAgICAgIGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgICAgICAgIHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgICAgICAgIGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgICAgICAgIHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGEgPT09IGIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzXG4gICAgICAgICAgICAgICAgTUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuICAgICAgICAgICAgICAgIC8vIEluc3RhbmNlIG1ldGhvZHNcbiAgICAgICAgICAgICAgICBoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGFyciA9IFtdLFxuICAgICAgICAgICAgICAgIHBvcCA9IGFyci5wb3AsXG4gICAgICAgICAgICAgICAgcHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcbiAgICAgICAgICAgICAgICBwdXNoID0gYXJyLnB1c2gsXG4gICAgICAgICAgICAgICAgc2xpY2UgPSBhcnIuc2xpY2UsXG4gICAgICAgICAgICAgICAgLy8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG4gICAgICAgICAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuICAgICAgICAgICAgICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcXFx4MDAtXFxcXHhhMF0pK1wiLFxuXG4gICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmF0b3IgKGNhcHR1cmUgMilcbiAgICAgICAgICAgICAgICAgICAgXCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcbiAgICAgICAgICAgICAgICAgICAgXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgICAgICBcIipcXFxcXVwiLFxuXG4gICAgICAgICAgICAgICAgcHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuICAgICAgICAgICAgICAgICAgICBcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG4gICAgICAgICAgICAgICAgICAgIFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuICAgICAgICAgICAgICAgICAgICBcIi4qXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIilcXFxcKXwpXCIsXG5cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG4gICAgICAgICAgICAgICAgcndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG4gICAgICAgICAgICAgICAgcnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG4gICAgICAgICAgICAgICAgcmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG4gICAgICAgICAgICAgICAgcmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cbiAgICAgICAgICAgICAgICByYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG4gICAgICAgICAgICAgICAgcnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcbiAgICAgICAgICAgICAgICByaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cbiAgICAgICAgICAgICAgICBtYXRjaEV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuICAgICAgICAgICAgICAgICAgICBcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG4gICAgICAgICAgICAgICAgICAgIFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgXCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuICAgICAgICAgICAgICAgICAgICBcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcbiAgICAgICAgICAgICAgICAgICAgXCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgXCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG4gICAgICAgICAgICAgICAgICAgIFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG4gICAgICAgICAgICAgICAgcmhlYWRlciA9IC9eaFxcZCQvaSxcblxuICAgICAgICAgICAgICAgIHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG4gICAgICAgICAgICAgICAgLy8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgcnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG4gICAgICAgICAgICAgICAgcnNpYmxpbmcgPSAvWyt+XS8sXG4gICAgICAgICAgICAgICAgcmVzY2FwZSA9IC8nfFxcXFwvZyxcblxuICAgICAgICAgICAgICAgIC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICBydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuICAgICAgICAgICAgICAgIGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveDwyNFxuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdoIDwgMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQk1QIGNvZGVwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBVc2VkIGZvciBpZnJhbWVzXG4gICAgICAgICAgICAgICAgLy8gU2VlIHNldERvY3VtZW50KClcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcbiAgICAgICAgICAgICAgICAvLyBlcnJvciBpbiBJRVxuICAgICAgICAgICAgICAgIHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICAoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG4gICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuICAgICAgICAgICAgICAgIC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcbiAgICAgICAgICAgICAgICBhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xuICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgICAgICAgICAgcHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcbiAgICAgICAgICAgICAgICB2YXIgbSwgaSwgZWxlbSwgbmlkLCBuaWRzZWxlY3QsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcbiAgICAgICAgICAgICAgICBpZiAoICFzZWVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudCggY29udGV4dCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlVHlwZSA9PT0gOSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uaWQgPT09IG0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR5cGUgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGFzcyBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN1cHBvcnQucXNhICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD04XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaWQgPSBuaWQucmVwbGFjZSggcmVzY2FwZSwgXCJcXFxcJCZcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBncm91cHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaWRzZWxlY3QgPSByaWRlbnRpZmllci50ZXN0KCBuaWQgKSA/IFwiI1wiICsgbmlkIDogXCJbaWQ9J1wiICsgbmlkICsgXCInXVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwc1tpXSA9IG5pZHNlbGVjdCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbmV3U2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KCByZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggcXNhRXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBbGwgb3RoZXJzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gICAgICAgICAgICAgKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAgICAgICAgICAgICAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1NylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcbiAgICAgICAgICAgICAgICBmblsgZXhwYW5kbyBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBkaXYgYW5kIGV4cGVjdHMgYSBib29sZWFuIHJlc3VsdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZm4oIGRpdiApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRpdi5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGRpdiApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG4gICAgICAgICAgICAgICAgICAgIGRpdiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuICAgICAgICAgICAgICAgIHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG4gICAgICAgICAgICAgICAgICAgIGkgPSBhcnIubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgIEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICAgICAgICAgICAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyID0gYiAmJiBhLFxuICAgICAgICAgICAgICAgICAgICBkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCB+Yi5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAoIH5hLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKCBkaWZmICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuICAgICAgICAgICAgICAgIGlmICggY3VyICkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjdXIgPT09IGIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPyAxIDogLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQgPSArYXJndW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbiAgICAgICAgICAgIH1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbiAgICAgICAgICAgIHN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERldGVjdHMgWE1MIG5vZGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICAgICAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3RcbiAgICAgICAgICAgICAgICAvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcbiAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0NvbXBhcmUsIHBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICBkb2N1bWVudCA9IGRvYztcbiAgICAgICAgICAgICAgICBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcbiAgICAgICAgICAgICAgICBpZiAoIChwYXJlbnQgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgcGFyZW50LnRvcCAhPT0gcGFyZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHBhcmVudC5hZGRFdmVudExpc3RlbmVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHBhcmVudC5hdHRhY2hFdmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDhcbiAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcbiAgICAgICAgICAgICAgICBzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwiaVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWRpdi5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxuICAgICAgICAgICAgICAgIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8MTBcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcbiAgICAgICAgICAgICAgICAvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtYXRpY2FsbHktc2V0IG5hbWVzLFxuICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuICAgICAgICAgICAgICAgIHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pZCA9IGV4cGFuZG87XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSUQgZmluZCBhbmQgZmlsdGVyXG4gICAgICAgICAgICAgICAgaWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0gPyBbIG0gXSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU2LzdcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgRXhwci5maW5kW1wiSURcIl07XG5cbiAgICAgICAgICAgICAgICAgICAgRXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUYWdcbiAgICAgICAgICAgICAgICBFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGFnID09PSBcIipcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIENsYXNzXG4gICAgICAgICAgICAgICAgRXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgICAgICAgICAvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cbiAgICAgICAgICAgICAgICAvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuICAgICAgICAgICAgICAgIHJidWdneU1hdGNoZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuICAgICAgICAgICAgICAgIC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG4gICAgICAgICAgICAgICAgcmJ1Z2d5UVNBID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGQgUVNBIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXYucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCBcImRpdlwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuY2FsbCggZGl2LCBcIltzIT0nJ106eFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuICAgICAgICAgICAgICAgIHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cbiAgICAgICAgICAgICAgICAvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgICAgICAgICAgaGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG4gICAgICAgICAgICAgICAgLy8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG4gICAgICAgICAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG4gICAgICAgICAgICAgICAgLy8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcbiAgICAgICAgICAgICAgICBjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggYSwgYiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZG93bi5jb250YWlucyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggYSwgYiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBiID09PSBhICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcbiAgICAgICAgICAgICAgICBzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGEgPT09IGIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb21wYXJlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNjb25uZWN0ZWQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29tcGFyZSAmIDEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3J0SW5wdXQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBhLCBiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBhID09PSBiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVwID0gYS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1cCA9IGIucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcCA9IFsgYSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJwID0gWyBiIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFhdXAgfHwgIWJ1cCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPT09IGRvY3VtZW50ID8gMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXAgPyAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVwID8gMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRJbnB1dCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXAudW5zaGlmdCggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJwLnVuc2hpZnQoIGN1ciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KCBlbGVtICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG4gICAgICAgICAgICAgICAgZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuICAgICAgICAgICAgICAgICAgICAhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcbiAgICAgICAgICAgICAgICAgICAgKCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuICAgICAgICAgICAgICAgICAgICAoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgaW4gSUUgOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudCggY29udGV4dCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudCggZWxlbSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgdmFsIDpcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC52YWx1ZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG4gICAgICAgICAgICAgICAgc29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuICAgICAgICAgICAgICAgIGlmICggaGFzRHVwbGljYXRlICkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGotLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG4gICAgICAgICAgICAgICAgc29ydElucHV0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlLFxuICAgICAgICAgICAgICAgICAgICByZXQgPSBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhbm9kZVR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBnZXRUZXh0KCBub2RlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1MylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgICAgICAgICBjYWNoZUxlbmd0aDogNTAsXG5cbiAgICAgICAgICAgICAgICBjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaEV4cHIsXG5cbiAgICAgICAgICAgICAgICBhdHRySGFuZGxlOiB7fSxcblxuICAgICAgICAgICAgICAgIGZpbmQ6IHt9LFxuXG4gICAgICAgICAgICAgICAgcmVsYXRpdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgXCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgXCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuICAgICAgICAgICAgICAgICAgICBcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHByZUZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICBcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbWF0Y2hbM10gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleGNlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hbM10gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcblxuICAgICAgICAgICAgICAgICAgICBcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZXN1bHQgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW9wZXJhdG9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcGFyZW50ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNpbXBsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGRpciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9mVHlwZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB1c2VDYWNoZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkaWZmID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggb2ZUeXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytkaWZmICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdXNlQ2FjaGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlID09PSBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmIC09IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKCBhcmd1bWVudCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZm4ubGVuZ3RoID4gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHBzZXVkb3M6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG4gICAgICAgICAgICAgICAgICAgIFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHNlZWQubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRbMF0gPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0WzBdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuICAgICAgICAgICAgICAgICAgICBcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1MYW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5sYW5nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1pc2NlbGxhbmVvdXNcbiAgICAgICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBCb29sZWFuIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgXCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZGlzYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGVudHNcbiAgICAgICAgICAgICAgICAgICAgXCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgXCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgXCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgMCBdO1xuICAgICAgICAgICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgICAgICAgICBcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBsZW5ndGggLSAxIF07XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuICAgICAgICAgICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgICAgICAgICBcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IC0taSA+PSAwOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG4gICAgICAgICAgICBmb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcbiAgICAgICAgICAgICAgICBFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuICAgICAgICAgICAgICAgIEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG4gICAgICAgICAgICB9XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuICAgICAgICAgICAgZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG4gICAgICAgICAgICBzZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbiAgICAgICAgICAgIEV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbiAgICAgICAgICAgIHRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuICAgICAgICAgICAgICAgIGlmICggY2FjaGVkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNvRmFyID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgZ3JvdXBzID0gW107XG4gICAgICAgICAgICAgICAgcHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBzb0ZhciApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5hdG9yc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXRjaGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXM6IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIW1hdGNoZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZU9ubHkgP1xuICAgICAgICAgICAgICAgICAgICBzb0Zhci5sZW5ndGggOlxuICAgICAgICAgICAgICAgICAgICBzb0ZhciA/XG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHRva2Vuc1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBsZW4gPSB0b2tlbnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuICAgICAgICAgICAgICAgIHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcbiAgICAgICAgICAgICAgICAgICAgZG9uZU5hbWUgPSBkb25lKys7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsgZGlyIF0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVyc1swXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgbmV3VW5tYXRjaGVkID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXBwZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5wdXNoKCBpICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1VubWF0Y2hlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgIGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuICAgICAgICAgICAgICAgICAgICBwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wLCBpLCBlbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlTWFwID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0TWFwID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtcyxcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJJbjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcG9zdEZpbHRlclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHBvc3RGaWx0ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHRlbXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBvc3RGaW5kZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBvc3RGaW5kZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuICAgICAgICAgICAgICAgIHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG4gICAgICAgICAgICAgICAgICAgIGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG4gICAgICAgICAgICAgICAgICAgIGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuICAgICAgICAgICAgICAgICAgICBtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9IF07XG5cbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gKytpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0TWF0Y2hlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPiAxICYmIHRvU2VsZWN0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuICAgICAgICAgICAgICAgIHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgICAgIGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgICAgICBzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSwgaiwgbWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvdXRlcm1vc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbCA9ICFkb2N1bWVudElzSFRNTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb3V0ZXJtb3N0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBieVNldCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDb3VudCArPSBpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtZXJpY2FsbHkgemVyby5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG91dGVybW9zdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVubWF0Y2hlZDtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBieVNldCA/XG4gICAgICAgICAgICAgICAgICAgIG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuICAgICAgICAgICAgICAgICAgICBzdXBlck1hdGNoZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZXJzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoICFjYWNoZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoICFtYXRjaCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAgICAgICAgICAgICAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gICAgICAgICAgICAgKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuICAgICAgICAgICAgICAgIC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcbiAgICAgICAgICAgICAgICBpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnQuZ2V0QnlJZCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFjb250ZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG4gICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoc2VlZCA9IGZpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG4gICAgICAgICAgICAgICAgKCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuICAgICAgICAgICAgICAgICAgICBzZWVkLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAhZG9jdW1lbnRJc0hUTUwsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICAgICFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbiAgICAgICAgICAgIHN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuICAgICAgICAgICAgc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuICAgICAgICAgICAgc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuICAgICAgICAgICAgc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdjEgKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG4gICAgICAgICAgICB9KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbiAgICAgICAgICAgIGlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuICAgICAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG4gICAgICAgICAgICAgICAgfSkgKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFpc1hNTCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuICAgICAgICAgICAgaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG4gICAgICAgICAgICAgICAgfSkgKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuICAgICAgICAgICAgaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXYuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSApIHtcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWw7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWlzWE1MICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gU2l6emxlO1xuXG4gICAgICAgIH0pKCB3aW5kb3cgKTtcblxuXG5cbiAgICBqUXVlcnkuZmluZCA9IFNpenpsZTtcbiAgICBqUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG4gICAgalF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xuICAgIGpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xuICAgIGpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG4gICAgalF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xuICAgIGpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG5cbiAgICB2YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gW10sXG4gICAgICAgICAgICB0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgd2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG4gICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH07XG5cblxuICAgIHZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IFtdO1xuXG4gICAgICAgIGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG4gICAgICAgICAgICBpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2goIG4gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH07XG5cblxuICAgIHZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG4gICAgdmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbXFx3LV0rKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyApO1xuXG5cblxuICAgIHZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG4gICAgZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG4gICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG4gICAgICAgICAgICAgICAgLyoganNoaW50IC1XMDE4ICovXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgIGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuICAgICAgICB9ICk7XG4gICAgfVxuXG4gICAgalF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuICAgICAgICB2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cbiAgICAgICAgaWYgKCBub3QgKSB7XG4gICAgICAgICAgICBleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cbiAgICAgICAgICAgIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG4gICAgICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuICAgICAgICAgICAgfSApICk7XG4gICAgfTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcmV0ID0gW10sXG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5lZWRlZCBiZWNhdXNlICQoIHNlbGVjdG9yLCBjb250ZXh0ICkgYmVjb21lcyAkKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKVxuICAgICAgICAgICAgcmV0ID0gdGhpcy5wdXNoU3RhY2soIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldCApO1xuICAgICAgICAgICAgcmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuICAgICAgICB9LFxuICAgICAgICBub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICByZXR1cm4gISF3aW5ub3coXG4gICAgICAgICAgICAgICAgdGhpcyxcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcbiAgICAgICAgICAgICAgICAvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG4gICAgICAgICAgICAgICAgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggc2VsZWN0b3IgKSA6XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yIHx8IFtdLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxuICAgIHZhciByb290alF1ZXJ5LFxuXG4gICAgICAgIC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG4gICAgICAgIC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcbiAgICAgICAgLy8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG4gICAgICAgIHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0qKSkkLyxcblxuICAgICAgICBpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2gsIGVsZW07XG5cbiAgICAgICAgICAgIC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuICAgICAgICAgICAgaWYgKCAhc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuICAgICAgICAgICAgLy8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuICAgICAgICAgICAgcm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcbiAgICAgICAgICAgICAgICBpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoWyAxIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsgMSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKCNpZClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBCbGFja2JlcnJ5IDQuNlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ0VCSUQgcmV0dXJucyBub2RlcyBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICgjNjk2MylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWyAwIF0gPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgLy8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuICAgICAgICAgICAgfSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpc1sgMCBdID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuICAgICAgICAgICAgfSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IoIGpRdWVyeSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHNlbGVjdG9yLmNvbnRleHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuICAgICAgICB9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG4gICAgaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbiAgICByb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbiAgICB2YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cbiAgICAgICAgLy8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcbiAgICAgICAgZ3VhcmFudGVlZFVuaXF1ZSA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgICAgICAgICAgY29udGVudHM6IHRydWUsXG4gICAgICAgICAgICBuZXh0OiB0cnVlLFxuICAgICAgICAgICAgcHJldjogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgICAgICBoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG4gICAgICAgICAgICAgICAgbCA9IHRhcmdldHMubGVuZ3RoO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICB2YXIgY3VyLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGwgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gW10sXG4gICAgICAgICAgICAgICAgcG9zID0gcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSB8fCB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCBzZWxlY3RvcnMsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0ICkgOlxuICAgICAgICAgICAgICAgICAgICAwO1xuXG4gICAgICAgICAgICBmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgZm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHBvcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2goIGN1ciApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcbiAgICAgICAgaW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG4gICAgICAgICAgICAvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuICAgICAgICAgICAgaWYgKCAhZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluZGV4IGluIHNlbGVjdG9yXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuICAgICAgICAgICAgICAgIGpRdWVyeS51bmlxdWVTb3J0KFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuICAgICAgICAgICAgICAgIHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBmdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcbiAgICAgICAgd2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH1cblxuICAgIGpRdWVyeS5lYWNoKCB7XG4gICAgICAgIHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuICAgICAgICB9LFxuICAgICAgICBwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuICAgICAgICB9LFxuICAgICAgICBwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuICAgICAgICAgICAgcmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuICAgICAgICBqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG4gICAgICAgICAgICBpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVudGlsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRlc1xuICAgICAgICAgICAgICAgIGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuICAgICAgICAgICAgICAgIGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcbiAgICAgICAgfTtcbiAgICB9ICk7XG4gICAgdmFyIHJub3R3aGl0ZSA9ICggL1xcUysvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbiAgICBmdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgIGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG4gICAgICAgICAgICBvYmplY3RbIGZsYWcgXSA9IHRydWU7XG4gICAgICAgIH0gKTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xuICAgIGpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgICAgICAvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG4gICAgICAgIC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcbiAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG4gICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG4gICAgICAgIHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG4gICAgICAgICAgICBmaXJpbmcsXG5cbiAgICAgICAgICAgIC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG4gICAgICAgICAgICBtZW1vcnksXG5cbiAgICAgICAgICAgIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG4gICAgICAgICAgICBmaXJlZCxcblxuICAgICAgICAgICAgLy8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuICAgICAgICAgICAgbG9ja2VkLFxuXG4gICAgICAgICAgICAvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuICAgICAgICAgICAgbGlzdCA9IFtdLFxuXG4gICAgICAgICAgICAvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuICAgICAgICAgICAgcXVldWUgPSBbXSxcblxuICAgICAgICAgICAgLy8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG4gICAgICAgICAgICBmaXJpbmdJbmRleCA9IC0xLFxuXG4gICAgICAgICAgICAvLyBGaXJlIGNhbGxiYWNrc1xuICAgICAgICAgICAgZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgLy8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG4gICAgICAgICAgICAgICAgbG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG4gICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuICAgICAgICAgICAgICAgIGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1vcnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcbiAgICAgICAgICAgICAgICBpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb3J5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmlyaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuICAgICAgICAgICAgICAgIGlmICggbG9ja2VkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtZW1vcnkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3RcbiAgICAgICAgICAgIHNlbGYgPSB7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBsaXN0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgKCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goIGFyZyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZCggYXJnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICkoIGFyZ3VtZW50cyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmluZ0luZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgICAgIC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24oIGZuICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4gP1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggbGlzdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuICAgICAgICAgICAgICAgIC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuICAgICAgICAgICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbWVtb3J5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhbGlzdDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZSAuZmlyZVxuICAgICAgICAgICAgICAgIC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuICAgICAgICAgICAgICAgIGxvY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFtZW1vcnkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbWVtb3J5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxvY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWxvY2tlZDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhbG9ja2VkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaCggYXJncyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZmlyaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICBmaXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2VcbiAgICAgICAgICAgICAgICBmaXJlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWZpcmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuXG4gICAgalF1ZXJ5LmV4dGVuZCgge1xuXG4gICAgICAgIERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcbiAgICAgICAgICAgIHZhciB0dXBsZXMgPSBbXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgXCJyZXNvbHZlZFwiIF0sXG4gICAgICAgICAgICAgICAgICAgIFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCBcInJlamVjdGVkXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgWyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSBdXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFwicGVuZGluZ1wiLFxuICAgICAgICAgICAgICAgIHByb21pc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyBpIF0gKSAmJiBmbnNbIGkgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZFsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdIGZvciBmb3J3YXJkaW5nIGFjdGlvbnMgdG8gbmV3RGVmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQucHJvbWlzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyA9PT0gcHJvbWlzZSA/IG5ld0RlZmVyLnByb21pc2UoKSA6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSApLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSB7fTtcblxuICAgICAgICAgICAgLy8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuICAgICAgICAgICAgcHJvbWlzZS5waXBlID0gcHJvbWlzZS50aGVuO1xuXG4gICAgICAgICAgICAvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG4gICAgICAgICAgICBqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gPSBsaXN0LmFkZFxuICAgICAgICAgICAgICAgIHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHN0YXRlXG4gICAgICAgICAgICAgICAgaWYgKCBzdGF0ZVN0cmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5hZGQoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG4gICAgICAgICAgICAgICAgICAgIH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkWyByZXNvbHZlIHwgcmVqZWN0IHwgbm90aWZ5IF1cbiAgICAgICAgICAgICAgICBkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG4gICAgICAgICAgICBwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cbiAgICAgICAgICAgIC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcbiAgICAgICAgICAgIGlmICggZnVuYyApIHtcbiAgICAgICAgICAgICAgICBmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbGwgZG9uZSFcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZWZlcnJlZCBoZWxwZXJcbiAgICAgICAgd2hlbjogZnVuY3Rpb24oIHN1Ym9yZGluYXRlIC8qICwgLi4uLCBzdWJvcmRpbmF0ZU4gKi8gKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoLFxuXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IGxlbmd0aCAhPT0gMSB8fFxuICAgICAgICAgICAgICAgICggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuICAgICAgICAgICAgICAgIC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWQuXG4gICAgICAgICAgICAgICAgLy8gSWYgcmVzb2x2ZVZhbHVlcyBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgRGVmZXJyZWQsIGp1c3QgdXNlIHRoYXQuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xuICAgICAgICAgICAgICAgIHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRzWyBpIF0gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlcyA9PT0gcHJvZ3Jlc3NWYWx1ZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggISggLS1yZW1haW5pbmcgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBwcm9ncmVzc1ZhbHVlcywgcHJvZ3Jlc3NDb250ZXh0cywgcmVzb2x2ZUNvbnRleHRzO1xuXG4gICAgICAgICAgICAvLyBBZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG4gICAgICAgICAgICBpZiAoIGxlbmd0aCA+IDEgKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuICAgICAgICAgICAgICAgIHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuICAgICAgICAgICAgICAgIHJlc29sdmVDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRvbmUoIHVwZGF0ZUZ1bmMoIGksIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmFpbCggZGVmZXJyZWQucmVqZWN0ICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLXJlbWFpbmluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxuICAgICAgICAgICAgaWYgKCAhcmVtYWluaW5nICkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbiAgICB2YXIgcmVhZHlMaXN0O1xuXG4gICAgalF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG4gICAgICAgIC8vIEFkZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgalF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKCBmbiApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZXh0ZW5kKCB7XG5cbiAgICAgICAgLy8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cbiAgICAgICAgaXNSZWFkeTogZmFsc2UsXG5cbiAgICAgICAgLy8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuICAgICAgICAvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuICAgICAgICByZWFkeVdhaXQ6IDEsXG5cbiAgICAgICAgLy8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG4gICAgICAgIGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG4gICAgICAgICAgICBpZiAoIGhvbGQgKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlYWR5V2FpdCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVhZHkoIHRydWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG4gICAgICAgIHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuICAgICAgICAgICAgLy8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuICAgICAgICAgICAgaWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcbiAgICAgICAgICAgIGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcbiAgICAgICAgICAgIGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuICAgICAgICAgICAgcmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmZuLnRyaWdnZXJIYW5kbGVyICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeSggZG9jdW1lbnQgKS50cmlnZ2VySGFuZGxlciggXCJyZWFkeVwiICk7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCBkb2N1bWVudCApLm9mZiggXCJyZWFkeVwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuICAgICAgICBqUXVlcnkucmVhZHkoKTtcbiAgICB9XG5cbiAgICBqUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgIGlmICggIXJlYWR5TGlzdCApIHtcblxuICAgICAgICAgICAgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbiAgICAgICAgICAgIC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4gICAgICAgICAgICAvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOS0xMCBvbmx5XG4gICAgICAgICAgICAvLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbiAgICAgICAgICAgIGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG4gICAgICAgICAgICAgICAgKCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG4gICAgICAgICAgICAgICAgLy8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFkeUxpc3QucHJvbWlzZSggb2JqICk7XG4gICAgfTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG4gICAgalF1ZXJ5LnJlYWR5LnByb21pc2UoKTtcblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbiAgICB2YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBlbGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBidWxrID0ga2V5ID09IG51bGw7XG5cbiAgICAgICAgLy8gU2V0cyBtYW55IHZhbHVlc1xuICAgICAgICBpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgIGNoYWluYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKCBpIGluIGtleSApIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0cyBvbmUgdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGNoYWluYWJsZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgIHJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggYnVsayApIHtcblxuICAgICAgICAgICAgICAgIC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuICAgICAgICAgICAgICAgIGlmICggcmF3ICkge1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWxrID0gZm47XG4gICAgICAgICAgICAgICAgICAgIGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggZm4gKSB7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGFpbmFibGUgP1xuICAgICAgICAgICAgZWxlbXMgOlxuXG4gICAgICAgICAgICAvLyBHZXRzXG4gICAgICAgICAgICBidWxrID9cbiAgICAgICAgICAgICAgICBmbi5jYWxsKCBlbGVtcyApIDpcbiAgICAgICAgICAgICAgICBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbiAgICB9O1xuICAgIHZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG4gICAgICAgIC8vIEFjY2VwdHMgb25seTpcbiAgICAgICAgLy8gIC0gTm9kZVxuICAgICAgICAvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG4gICAgICAgIC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG4gICAgICAgIC8vICAtIE9iamVjdFxuICAgICAgICAvLyAgICAtIEFueVxuICAgICAgICAvKiBqc2hpbnQgLVcwMTggKi9cbiAgICAgICAgcmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xuICAgIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBEYXRhKCkge1xuICAgICAgICB0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG4gICAgfVxuXG4gICAgRGF0YS51aWQgPSAxO1xuXG4gICAgRGF0YS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKCBvd25lciwgaW5pdGlhbCApIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluaXRpYWwgfHwge307XG5cbiAgICAgICAgICAgIC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcbiAgICAgICAgICAgIC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG4gICAgICAgICAgICBpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuICAgICAgICAgICAgICAgIG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBjb25maWd1cmFiaWxpdHkgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZWQgd2l0aCB0aGUgZGVsZXRlIG9wZXJhdG9yXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuICAgICAgICB9LFxuICAgICAgICBjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG4gICAgICAgICAgICAvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2VycyxcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG4gICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgICAgICAgIGlmICggIWFjY2VwdERhdGEoIG93bmVyICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuICAgICAgICAgICAgLy8gSWYgbm90LCBjcmVhdGUgb25lXG4gICAgICAgICAgICBpZiAoICF2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgICAgICAgICAgICBpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCxcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3NcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVbIGRhdGEgXSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3NcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuICAgICAgICAgICAgICAgIGZvciAoIHByb3AgaW4gZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVbIHByb3AgXSA9IGRhdGFbIHByb3AgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUoIG93bmVyICkgOlxuICAgICAgICAgICAgICAgIG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGtleSBdO1xuICAgICAgICB9LFxuICAgICAgICBhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBzdG9yZWQ7XG5cbiAgICAgICAgICAgIC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcbiAgICAgICAgICAgIC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG4gICAgICAgICAgICAvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuICAgICAgICAgICAgICAgIHN0b3JlZCA9IHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmVkICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICBzdG9yZWQgOiB0aGlzLmdldCggb3duZXIsIGpRdWVyeS5jYW1lbENhc2UoIGtleSApICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG4gICAgICAgICAgICAvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcbiAgICAgICAgICAgIHZhciBpLCBuYW1lLCBjYW1lbCxcbiAgICAgICAgICAgICAgICBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuICAgICAgICAgICAgaWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKCBvd25lciApO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICAvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuICAgICAgICAgICAgICAgICAgICBuYW1lID0ga2V5LmNvbmNhdCgga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FtZWwgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGtleSBpbiBjYWNoZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBbIGtleSwgY2FtZWwgXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBjYW1lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lIGluIGNhY2hlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIG5hbWUgXSA6ICggbmFtZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkgPSBuYW1lLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVbIG5hbWVbIGkgXSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG4gICAgICAgICAgICBpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuICAgICAgICAgICAgICAgIC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgLy8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDdcbiAgICAgICAgICAgICAgICBpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuICAgICAgICAgICAgICAgICAgICBvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxuICAgIHZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbiAgICB2YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuICAgICAgICBybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbiAgICBmdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuICAgICAgICB2YXIgbmFtZTtcblxuICAgICAgICAvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG4gICAgICAgIC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuICAgICAgICBpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgbmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgK2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHt9XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcbiAgICAgICAgICAgICAgICBkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGpRdWVyeS5leHRlbmQoIHtcbiAgICAgICAgaGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcbiAgICAgICAgICAgIGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG4gICAgICAgIC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuICAgICAgICBfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIGksIG5hbWUsIGRhdGEsXG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbIDAgXSxcbiAgICAgICAgICAgICAgICBhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICAvLyBHZXRzIGFsbCB2YWx1ZXNcbiAgICAgICAgICAgIGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gYXR0cnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTExK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYXR0cnNbIGkgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSwgY2FtZWxLZXk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgICAgIC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIGtleSBhcy1pc1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKSB8fFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZmluZCBkYXNoZWQga2V5IGlmIGl0IGV4aXN0cyAoZ2gtMjc3OSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgZm9yIDIuMi54IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFVc2VyLmdldCggZWxlbSwga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGNhbWVsS2V5ICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuICAgICAgICAgICAgICAgICAgICAvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhQXR0ciggZWxlbSwgY2FtZWxLZXksIHVuZGVmaW5lZCApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBkYXRhLi4uXG4gICAgICAgICAgICAgICAgY2FtZWxLZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0LCBhdHRlbXB0IHRvIHN0b3JlIGEgY29weSBvciByZWZlcmVuY2Ugb2YgYW55XG4gICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgdGhhdCBtaWdodCd2ZSBiZWVuIHN0b3JlIHdpdGggYSBjYW1lbENhc2VkIGtleS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhVXNlci5nZXQoIHRoaXMsIGNhbWVsS2V5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGUgaW50ZXJvcCwgd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBwcm9wZXJ0eSBuYW1lcyB3aXRoIGRhc2hlcyBpbiBhIGNhbWVsQ2FzZSBmb3JtLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1pZ2h0IG5vdCBhcHBseSB0byBhbGwgcHJvcGVydGllcy4uLipcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVzZXIuc2V0KCB0aGlzLCBjYW1lbEtleSwgdmFsdWUgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyAqLi4uIEluIHRoZSBjYXNlIG9mIHByb3BlcnRpZXMgdGhhdCBtaWdodCBfYWN0dWFsbHlfXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgZGFzaGVzLCB3ZSBuZWVkIHRvIGFsc28gc3RvcmUgYSBjb3B5IG9mIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5jaGFuZ2VkIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoIGtleS5pbmRleE9mKCBcIi1cIiApID4gLTEgJiYgZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG4gICAgalF1ZXJ5LmV4dGVuZCgge1xuICAgICAgICBxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG4gICAgICAgICAgICB2YXIgcXVldWU7XG5cbiAgICAgICAgICAgIGlmICggZWxlbSApIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuICAgICAgICAgICAgICAgIHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFxdWV1ZSB8fCBqUXVlcnkuaXNBcnJheSggZGF0YSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaCggZGF0YSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZSB8fCBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG4gICAgICAgICAgICAgICAgc3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpLFxuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG4gICAgICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcbiAgICAgICAgICAgIGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuICAgICAgICAgICAgICAgIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBzdGFydExlbmd0aC0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGZuICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhvb2tzLnN0b3A7XG4gICAgICAgICAgICAgICAgZm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZW1wdHkuZmlyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG4gICAgICAgIF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuICAgICAgICAgICAgICAgIGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcbiAgICAgICAgICAgICAgICB9IClcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgcXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuICAgICAgICAgICAgdmFyIHNldHRlciA9IDI7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwiZnhcIjtcbiAgICAgICAgICAgICAgICBzZXR0ZXItLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB0aGlzIDpcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuICAgICAgICAvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcbiAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcbiAgICAgICAgICAgIHZhciB0bXAsXG4gICAgICAgICAgICAgICAgY291bnQgPSAxLFxuICAgICAgICAgICAgICAgIGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggISggLS1jb3VudCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gdHlwZTtcbiAgICAgICAgICAgICAgICB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG4gICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuICAgICAgICAgICAgICAgIGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgdG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcbiAgICAgICAgfVxuICAgIH0gKTtcbiAgICB2YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbiAgICB2YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxuICAgIHZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxuICAgIHZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuICAgICAgICAvLyBpc0hpZGRlbiBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcbiAgICAgICAgZWxlbSA9IGVsIHx8IGVsZW07XG4gICAgICAgIHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIiB8fFxuICAgICAgICAgICAgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG4gICAgfTtcblxuXG5cbiAgICBmdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuICAgICAgICB2YXIgYWRqdXN0ZWQsXG4gICAgICAgICAgICBzY2FsZSA9IDEsXG4gICAgICAgICAgICBtYXhJdGVyYXRpb25zID0gMjAsXG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiB0d2Vlbi5jdXIoKTsgfSA6XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7IH0sXG4gICAgICAgICAgICBpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG4gICAgICAgICAgICB1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cbiAgICAgICAgICAgIC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG4gICAgICAgICAgICBpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcbiAgICAgICAgICAgICAgICByY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG4gICAgICAgIGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cbiAgICAgICAgICAgIC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3NcbiAgICAgICAgICAgIHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuICAgICAgICAgICAgdmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cbiAgICAgICAgICAgIC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICBpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuICAgICAgICAgICAgZG8ge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG4gICAgICAgICAgICAgICAgLy8gVXNlIHN0cmluZyBmb3IgZG91Ymxpbmcgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcbiAgICAgICAgICAgICAgICBzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCBhbmQgYXBwbHlcbiAgICAgICAgICAgICAgICBpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG4gICAgICAgICAgICAgICAgLy8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cbiAgICAgICAgICAgIH0gd2hpbGUgKFxuICAgICAgICAgICAgICAgIHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdmFsdWVQYXJ0cyApIHtcbiAgICAgICAgICAgIGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG4gICAgICAgICAgICAvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cbiAgICAgICAgICAgICAgICBpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuICAgICAgICAgICAgICAgICt2YWx1ZVBhcnRzWyAyIF07XG4gICAgICAgICAgICBpZiAoIHR3ZWVuICkge1xuICAgICAgICAgICAgICAgIHR3ZWVuLnVuaXQgPSB1bml0O1xuICAgICAgICAgICAgICAgIHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcbiAgICAgICAgICAgICAgICB0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRqdXN0ZWQ7XG4gICAgfVxuICAgIHZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxuICAgIHZhciBydGFnTmFtZSA9ICggLzwoW1xcdzotXSspLyApO1xuXG4gICAgdmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxuICAgIHZhciB3cmFwTWFwID0ge1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFOVxuICAgICAgICBvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuICAgICAgICAvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuICAgICAgICAvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG4gICAgICAgIC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cbiAgICAgICAgdGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuICAgICAgICBjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuICAgICAgICB0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG4gICAgICAgIHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuICAgICAgICBfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbiAgICB9O1xuXG4vLyBTdXBwb3J0OiBJRTlcbiAgICB3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbiAgICB3cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xuICAgIHdyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbiAgICBmdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRTktMTErXG4gICAgICAgIC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcbiAgICAgICAgdmFyIHJldCA9IHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiID9cbiAgICAgICAgICAgIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcbiAgICAgICAgICAgIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgP1xuICAgICAgICAgICAgICAgIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICkgOlxuICAgICAgICAgICAgICAgIFtdO1xuXG4gICAgICAgIHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG4gICAgICAgICAgICBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKSA6XG4gICAgICAgICAgICByZXQ7XG4gICAgfVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuICAgIGZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbCA9IGVsZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICBkYXRhUHJpdi5zZXQoXG4gICAgICAgICAgICAgICAgZWxlbXNbIGkgXSxcbiAgICAgICAgICAgICAgICBcImdsb2JhbEV2YWxcIixcbiAgICAgICAgICAgICAgICAhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICB2YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbiAgICBmdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuICAgICAgICB2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuICAgICAgICAgICAgZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgIG5vZGVzID0gW10sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGwgPSBlbGVtcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW1zWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIG5vZGVzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICB0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICBqID0gd3JhcFsgMCBdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGotLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuICAgICAgICAgICAgICAgICAgICB0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcbiAgICAgICAgZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG4gICAgICAgICAgICAvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuICAgICAgICAgICAgaWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBpZ25vcmVkICkge1xuICAgICAgICAgICAgICAgICAgICBpZ25vcmVkLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuICAgICAgICAgICAgLy8gQXBwZW5kIHRvIGZyYWdtZW50XG4gICAgICAgICAgICB0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuICAgICAgICAgICAgLy8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuICAgICAgICAgICAgaWYgKCBjb250YWlucyApIHtcbiAgICAgICAgICAgICAgICBzZXRHbG9iYWxFdmFsKCB0bXAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuICAgICAgICAgICAgaWYgKCBzY3JpcHRzICkge1xuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRzLnB1c2goIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9XG5cblxuICAgICggZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgIGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcbiAgICAgICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAtNC4zLCBTYWZhcmk8PTUuMVxuICAgICAgICAvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuICAgICAgICAvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG4gICAgICAgIC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpPD01LjEsIEFuZHJvaWQ8NC4yXG4gICAgICAgIC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuICAgICAgICBzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUU8PTExK1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG4gICAgICAgIHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuICAgIH0gKSgpO1xuXG5cbiAgICB2YXJcbiAgICAgICAgcmtleUV2ZW50ID0gL15rZXkvLFxuICAgICAgICBybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcbiAgICAgICAgcnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG4gICAgZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgfSBjYXRjaCAoIGVyciApIHsgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG4gICAgICAgIHZhciBvcmlnRm4sIHR5cGU7XG5cbiAgICAgICAgLy8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG4gICAgICAgIGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG4gICAgICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuICAgICAgICAgICAgICAgIG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIC8vICggdHlwZXMsIGZuIClcbiAgICAgICAgICAgIGZuID0gc2VsZWN0b3I7XG4gICAgICAgICAgICBkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuICAgICAgICAgICAgICAgIC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG4gICAgICAgICAgICAgICAgZm4gPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcywgZGF0YSwgZm4gKVxuICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBmbiA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICBmbiA9IHJldHVybkZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCAhZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb25lID09PSAxICkge1xuICAgICAgICAgICAgb3JpZ0ZuID0gZm47XG4gICAgICAgICAgICBmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgICAgIC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuICAgICAgICAgICAgICAgIGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG4gICAgICAgICAgICBmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcbiAgICAgICAgfSApO1xuICAgIH1cblxuICAgIC8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG4gICAgalF1ZXJ5LmV2ZW50ID0ge1xuXG4gICAgICAgIGdsb2JhbDoge30sXG5cbiAgICAgICAgYWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG4gICAgICAgICAgICB2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG4gICAgICAgICAgICAgICAgZXZlbnRzLCB0LCBoYW5kbGVPYmosXG4gICAgICAgICAgICAgICAgc3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgIGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG4gICAgICAgICAgICBpZiAoICFlbGVtRGF0YSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuICAgICAgICAgICAgaWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuICAgICAgICAgICAgaWYgKCAhaGFuZGxlci5ndWlkICkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3RcbiAgICAgICAgICAgIGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2VcbiAgICAgICAgICAgIHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuICAgICAgICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggdC0tICkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgaWYgKCAhdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcbiAgICAgICAgICAgICAgICB0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1R5cGU6IG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBndWlkOiBoYW5kbGVyLmd1aWQsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcbiAgICAgICAgICAgICAgICB9LCBoYW5kbGVPYmpJbiApO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICBpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBzcGVjaWFsLmFkZCApIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuICAgICAgICAgICAgICAgIGlmICggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG4gICAgICAgICAgICB2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG4gICAgICAgICAgICAgICAgZXZlbnRzLCB0LCBoYW5kbGVPYmosXG4gICAgICAgICAgICAgICAgc3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgIGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG4gICAgICAgICAgICBpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcbiAgICAgICAgICAgIHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuICAgICAgICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggdC0tICkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKCAhdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdHlwZSBpbiBldmVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcbiAgICAgICAgICAgICAgICB0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcbiAgICAgICAgICAgICAgICB0bXAgPSB0bXBbIDIgXSAmJlxuICAgICAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcbiAgICAgICAgICAgICAgICBvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICggai0tICkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuICAgICAgICAgICAgICAgIC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuICAgICAgICAgICAgICAgIGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuICAgICAgICAgICAgICAgIGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICAvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3RcbiAgICAgICAgICAgIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuICAgICAgICAgICAgdmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLFxuICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IFtdLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcbiAgICAgICAgICAgICAgICBoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuICAgICAgICAgICAgYXJnc1sgMCBdID0gZXZlbnQ7XG4gICAgICAgICAgICBldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcbiAgICAgICAgICAgIGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGhhbmRsZXJzXG4gICAgICAgICAgICBoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cbiAgICAgICAgICAgIC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuICAgICAgICAgICAgICAgICFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2UocylcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuICAgICAgICAgICAgaWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcbiAgICAgICAgICAgICAgICBzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuICAgICAgICAgICAgdmFyIGksIG1hdGNoZXMsIHNlbCwgaGFuZGxlT2JqLFxuICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IFtdLFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuICAgICAgICAgICAgICAgIGN1ciA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydCAoYXQgbGVhc3QpOiBDaHJvbWUsIElFOVxuICAgICAgICAgICAgLy8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuICAgICAgICAgICAgLy8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKCMxMzE4MClcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94PD00MitcbiAgICAgICAgICAgIC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGluIEZGIGJ1dCBkb24ndCBibG9jayBJRSByYWRpbyBldmVudHMgKCMzODYxLCBnaC0yMzQzKVxuICAgICAgICAgICAgaWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJlxuICAgICAgICAgICAgICAgICggZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiIHx8IGlzTmFOKCBldmVudC5idXR0b24gKSB8fCBldmVudC5idXR0b24gPCAxICkgKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG4gICAgICAgICAgICAgICAgICAgIGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICggY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZXNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hlc1sgc2VsIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuICAgICAgICAgICAgaWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJRdWV1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxuICAgICAgICBwcm9wczogKCBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGRldGFpbCBldmVudFBoYXNlIFwiICtcbiAgICAgICAgICAgIFwibWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiICkuc3BsaXQoIFwiIFwiICksXG5cbiAgICAgICAgZml4SG9va3M6IHt9LFxuXG4gICAgICAgIGtleUhvb2tzOiB7XG4gICAgICAgICAgICBwcm9wczogXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXCIuc3BsaXQoIFwiIFwiICksXG4gICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcbiAgICAgICAgICAgICAgICBpZiAoIGV2ZW50LndoaWNoID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LndoaWNoID0gb3JpZ2luYWwuY2hhckNvZGUgIT0gbnVsbCA/IG9yaWdpbmFsLmNoYXJDb2RlIDogb3JpZ2luYWwua2V5Q29kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2VIb29rczoge1xuICAgICAgICAgICAgcHJvcHM6ICggXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIFwiICtcbiAgICAgICAgICAgICAgICBcInNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIiApLnNwbGl0KCBcIiBcIiApLFxuICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudERvYywgZG9jLCBib2R5LFxuICAgICAgICAgICAgICAgICAgICBidXR0b24gPSBvcmlnaW5hbC5idXR0b247XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBtaXNzaW5nIGFuZCBjbGllbnRYL1kgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgaWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gZXZlbnREb2MuYm9keTtcblxuICAgICAgICAgICAgICAgICAgICBldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggK1xuICAgICAgICAgICAgICAgICAgICAgICAgKCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCApIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICtcbiAgICAgICAgICAgICAgICAgICAgICAgICggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGRvYyAmJiBkb2MuY2xpZW50VG9wICB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wICB8fCAwICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XG4gICAgICAgICAgICAgICAgaWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LndoaWNoID0gKCBidXR0b24gJiAxID8gMSA6ICggYnV0dG9uICYgMiA/IDMgOiAoIGJ1dHRvbiAmIDQgPyAyIDogMCApICkgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICBpZiAoIGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgd3JpdGFibGUgY29weSBvZiB0aGUgZXZlbnQgb2JqZWN0IGFuZCBub3JtYWxpemUgc29tZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB2YXIgaSwgcHJvcCwgY29weSxcbiAgICAgICAgICAgICAgICB0eXBlID0gZXZlbnQudHlwZSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50ID0gZXZlbnQsXG4gICAgICAgICAgICAgICAgZml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuICAgICAgICAgICAgaWYgKCAhZml4SG9vayApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cbiAgICAgICAgICAgICAgICAgICAgcm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJrZXlFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLmtleUhvb2tzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoIGZpeEhvb2sucHJvcHMgKSA6IHRoaXMucHJvcHM7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG4gICAgICAgICAgICBpID0gY29weS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gY29weVsgaSBdO1xuICAgICAgICAgICAgICAgIGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENvcmRvdmEgMi41IChXZWJLaXQpICgjMTMyNTUpXG4gICAgICAgICAgICAvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3RcbiAgICAgICAgICAgIGlmICggIWV2ZW50LnRhcmdldCApIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDYuMCssIENocm9tZTwyOFxuICAgICAgICAgICAgLy8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0MylcbiAgICAgICAgICAgIGlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZml4SG9vay5maWx0ZXIgPyBmaXhIb29rLmZpbHRlciggZXZlbnQsIG9yaWdpbmFsRXZlbnQgKSA6IGV2ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNwZWNpYWw6IHtcbiAgICAgICAgICAgIGxvYWQ6IHtcblxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcbiAgICAgICAgICAgICAgICBub0J1YmJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzOiB7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3RcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibHVyOiB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGljazoge1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG4gICAgICAgICAgICAgICAgX2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJlZm9yZXVubG9hZDoge1xuICAgICAgICAgICAgICAgIHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBqUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG4gICAgICAgIC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuICAgICAgICBpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cbiAgICAgICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gICAgICAgIGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2ZW50IG9iamVjdFxuICAgICAgICBpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG4gICAgICAgICAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgICAgICAgICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG4gICAgICAgICAgICBzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG4gICAgICAgICAgICBzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICByZXR1cm5UcnVlIDpcbiAgICAgICAgICAgICAgICByZXR1cm5GYWxzZTtcblxuICAgICAgICAgICAgLy8gRXZlbnQgdHlwZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcbiAgICAgICAgaWYgKCBwcm9wcyApIHtcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuICAgICAgICB0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuICAgICAgICAvLyBNYXJrIGl0IGFzIGZpeGVkXG4gICAgICAgIHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xuICAgIH07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG4gICAgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcbiAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcbiAgICAgICAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuICAgICAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgICAgIGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICAgICAgICBpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgICAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICAgICAgICBpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAgICAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbiAgICBqUXVlcnkuZWFjaCgge1xuICAgICAgICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICAgICAgICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG4gICAgICAgIHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuICAgICAgICBwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG4gICAgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcbiAgICAgICAgICAgIGRlbGVnYXRlVHlwZTogZml4LFxuICAgICAgICAgICAgYmluZFR5cGU6IGZpeCxcblxuICAgICAgICAgICAgaGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuICAgICAgICAgICAgICAgIC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICAgICAgLy8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcbiAgICAgICAgICAgICAgICBpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IGZpeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcbiAgICAgICAgICAgIHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuICAgICAgICB9LFxuICAgICAgICBvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuICAgICAgICAgICAgcmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG4gICAgICAgIH0sXG4gICAgICAgIG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlT2JqLCB0eXBlO1xuICAgICAgICAgICAgaWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuICAgICAgICAgICAgICAgIGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5vcmlnVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuICAgICAgICAgICAgICAgIC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG4gICAgICAgICAgICAgICAgZm9yICggdHlwZSBpbiB0eXBlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzIFssIGZuXSApXG4gICAgICAgICAgICAgICAgZm4gPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggZm4gPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIGZuID0gcmV0dXJuRmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cblxuICAgIHZhclxuICAgICAgICByeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Oi1dKylbXj5dKilcXC8+L2dpLFxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDEwLTExLCBFZGdlIDEwMjQwK1xuICAgICAgICAvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuICAgICAgICBybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuICAgICAgICAvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcbiAgICAgICAgcmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuICAgICAgICByc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuICAgICAgICByY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIE1hbmlwdWxhdGluZyB0YWJsZXMgcmVxdWlyZXMgYSB0Ym9keVxuICAgIGZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcbiAgICAgICAgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApID9cblxuICAgICAgICAgICAgZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fFxuICAgICAgICAgICAgZWxlbS5hcHBlbmRDaGlsZCggZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGJvZHlcIiApICkgOlxuICAgICAgICAgICAgZWxlbTtcbiAgICB9XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbiAgICBmdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuICAgICAgICBlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG4gICAgICAgIGlmICggbWF0Y2ggKSB7XG4gICAgICAgICAgICBlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuICAgICAgICB2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuICAgICAgICBpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuICAgICAgICBpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuICAgICAgICAgICAgcGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuICAgICAgICAgICAgcGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG4gICAgICAgICAgICBldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cbiAgICAgICAgICAgIGlmICggZXZlbnRzICkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG4gICAgICAgICAgICAgICAgcGRhdGFDdXIuZXZlbnRzID0ge307XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBDb3B5IHVzZXIgZGF0YVxuICAgICAgICBpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuICAgICAgICAgICAgdWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuICAgICAgICAgICAgdWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuICAgICAgICAgICAgZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuICAgICAgICB9XG4gICAgfVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbiAgICBmdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuICAgICAgICB2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG4gICAgICAgIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuICAgICAgICAgICAgZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cbiAgICAgICAgICAgIC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG4gICAgICAgIH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcbiAgICAgICAgICAgIGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuICAgICAgICAvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG4gICAgICAgIGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cbiAgICAgICAgdmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgICBpTm9DbG9uZSA9IGwgLSAxLFxuICAgICAgICAgICAgdmFsdWUgPSBhcmdzWyAwIF0sXG4gICAgICAgICAgICBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cbiAgICAgICAgLy8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG4gICAgICAgIGlmICggaXNGdW5jdGlvbiB8fFxuICAgICAgICAgICAgKCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG4gICAgICAgICAgICAgICAgaWYgKCBpc0Z1bmN0aW9uICkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGwgKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuICAgICAgICAgICAgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG4gICAgICAgICAgICBpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gZmlyc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuICAgICAgICAgICAgICAgIHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcbiAgICAgICAgICAgICAgICBoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG4gICAgICAgICAgICAgICAgLy8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBmcmFnbWVudDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc1NjcmlwdHMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBoYXNTY3JpcHRzICkge1xuICAgICAgICAgICAgICAgICAgICBkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZW5hYmxlIHNjcmlwdHNcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gc2NyaXB0c1sgaSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGUuc3JjICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lmdsb2JhbEV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcbiAgICAgICAgdmFyIG5vZGUsXG4gICAgICAgICAgICBub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG4gICAgICAgICAgICBpID0gMDtcblxuICAgICAgICBmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgIGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZXh0ZW5kKCB7XG4gICAgICAgIGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcbiAgICAgICAgICAgIHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuICAgICAgICAgICAgICAgIGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcbiAgICAgICAgICAgICAgICBpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG4gICAgICAgICAgICAvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcbiAgICAgICAgICAgIGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcbiAgICAgICAgICAgICAgICAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHA6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuICAgICAgICAgICAgICAgIGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcbiAgICAgICAgICAgICAgICBzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuICAgICAgICAgICAgaWYgKCBkYXRhQW5kRXZlbnRzICkge1xuICAgICAgICAgICAgICAgIGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuICAgICAgICAgICAgaWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICBzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSwgZWxlbSwgdHlwZSxcbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG4gICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGF0YS5ldmVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PSAzNS00NStcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuXG4gICAgICAgIC8vIEtlZXAgZG9tTWFuaXAgZXhwb3NlZCB1bnRpbCAzLjAgKGdoLTIyMjUpXG4gICAgICAgIGRvbU1hbmlwOiBkb21NYW5pcCxcblxuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXBwZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlcGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmVmb3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG4gICAgICAgICAgICBkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuICAgICAgICAgICAgZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG4gICAgICAgICAgICAgICAgICAgICF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaWdub3JlZCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcbiAgICAgICAgICAgIHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwYXJlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG4gICAgICAgICAgICB9LCBpZ25vcmVkICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuZWFjaCgge1xuICAgICAgICBhcHBlbmRUbzogXCJhcHBlbmRcIixcbiAgICAgICAgcHJlcGVuZFRvOiBcInByZXBlbmRcIixcbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuICAgICAgICBpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuICAgICAgICByZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbiAgICB9LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG4gICAgICAgIGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgdmFyIGVsZW1zLFxuICAgICAgICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgICAgICAgIGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcbiAgICAgICAgICAgICAgICBsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG4gICAgICAgICAgICAgICAgZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcbiAgICAgICAgICAgICAgICBqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBRdFdlYktpdFxuICAgICAgICAgICAgICAgIC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3NcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG4gICAgICAgIH07XG4gICAgfSApO1xuXG5cbiAgICB2YXIgaWZyYW1lLFxuICAgICAgICBlbGVtZGlzcGxheSA9IHtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveFxuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBwcmUtZGVmaW5lIHRoZXNlIHZhbHVlcyBmb3IgRkYgKCMxMDIyNylcbiAgICAgICAgICAgIEhUTUw6IFwiYmxvY2tcIixcbiAgICAgICAgICAgIEJPRFk6IFwiYmxvY2tcIlxuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGFjdHVhbCBkaXNwbGF5IG9mIGEgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAgICAgKi9cblxuLy8gQ2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gZGVmYXVsdERpc3BsYXlcbiAgICBmdW5jdGlvbiBhY3R1YWxEaXNwbGF5KCBuYW1lLCBkb2MgKSB7XG4gICAgICAgIHZhciBlbGVtID0galF1ZXJ5KCBkb2MuY3JlYXRlRWxlbWVudCggbmFtZSApICkuYXBwZW5kVG8oIGRvYy5ib2R5ICksXG5cbiAgICAgICAgICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtWyAwIF0sIFwiZGlzcGxheVwiICk7XG5cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbnkgZGF0YSBzdG9yZWQgb24gdGhlIGVsZW1lbnQsXG4gICAgICAgIC8vIHNvIHVzZSBcImRldGFjaFwiIG1ldGhvZCBhcyBmYXN0IHdheSB0byBnZXQgcmlkIG9mIHRoZSBlbGVtZW50XG4gICAgICAgIGVsZW0uZGV0YWNoKCk7XG5cbiAgICAgICAgcmV0dXJuIGRpc3BsYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ5IHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBkaXNwbGF5IHZhbHVlIG9mIGFuIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0RGlzcGxheSggbm9kZU5hbWUgKSB7XG4gICAgICAgIHZhciBkb2MgPSBkb2N1bWVudCxcbiAgICAgICAgICAgIGRpc3BsYXkgPSBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcblxuICAgICAgICBpZiAoICFkaXNwbGF5ICkge1xuICAgICAgICAgICAgZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHNpbXBsZSB3YXkgZmFpbHMsIHJlYWQgZnJvbSBpbnNpZGUgYW4gaWZyYW1lXG4gICAgICAgICAgICBpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFkaXNwbGF5ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBhbHJlYWR5LWNyZWF0ZWQgaWZyYW1lIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgaWZyYW1lID0gKCBpZnJhbWUgfHwgalF1ZXJ5KCBcIjxpZnJhbWUgZnJhbWVib3JkZXI9JzAnIHdpZHRoPScwJyBoZWlnaHQ9JzAnLz5cIiApIClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKCBkb2MuZG9jdW1lbnRFbGVtZW50ICk7XG5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgd3JpdGUgYSBuZXcgSFRNTCBza2VsZXRvbiBzbyBXZWJraXQgYW5kIEZpcmVmb3ggZG9uJ3QgY2hva2Ugb24gcmV1c2VcbiAgICAgICAgICAgICAgICBkb2MgPSBpZnJhbWVbIDAgXS5jb250ZW50RG9jdW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRVxuICAgICAgICAgICAgICAgIGRvYy53cml0ZSgpO1xuICAgICAgICAgICAgICAgIGRvYy5jbG9zZSgpO1xuXG4gICAgICAgICAgICAgICAgZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcbiAgICAgICAgICAgICAgICBpZnJhbWUuZGV0YWNoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjb3JyZWN0IGRlZmF1bHQgZGlzcGxheVxuICAgICAgICAgICAgZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpc3BsYXk7XG4gICAgfVxuICAgIHZhciBybWFyZ2luID0gKCAvXm1hcmdpbi8gKTtcblxuICAgIHZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxuICAgIHZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRTw9MTErLCBGaXJlZm94PD0zMCsgKCMxNTA5OCwgIzE0MTUwKVxuICAgICAgICAvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcbiAgICAgICAgLy8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG4gICAgICAgIHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG4gICAgICAgIGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuICAgICAgICAgICAgdmlldyA9IHdpbmRvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcbiAgICB9O1xuXG4gICAgdmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG4gICAgICAgIHZhciByZXQsIG5hbWUsXG4gICAgICAgICAgICBvbGQgPSB7fTtcblxuICAgICAgICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgICAgICAgZm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgb2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG4gICAgICAgICAgICBlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG4gICAgICAgIC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuICAgICAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICBlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuXG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbiAgICAoIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHBpeGVsTWFyZ2luUmlnaHRWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuICAgICAgICAvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuICAgICAgICBpZiAoICFkaXYuc3R5bGUgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRTktMTErXG4gICAgICAgIC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuICAgICAgICBkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuICAgICAgICBzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O1wiICtcbiAgICAgICAgICAgIFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cbiAgICAgICAgLy8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG4gICAgICAgIC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuICAgICAgICAgICAgZGl2LnN0eWxlLmNzc1RleHQgPVxuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcbiAgICAgICAgICAgICAgICAvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcbiAgICAgICAgICAgICAgICBcIi13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG4gICAgICAgICAgICAgICAgXCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcbiAgICAgICAgICAgICAgICBcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuICAgICAgICAgICAgICAgIFwidG9wOjElO3dpZHRoOjUwJVwiO1xuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG4gICAgICAgICAgICB2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG4gICAgICAgICAgICBwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG4gICAgICAgICAgICByZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuICAgICAgICAgICAgYm94U2l6aW5nUmVsaWFibGVWYWwgPSBkaXZTdHlsZS53aWR0aCA9PT0gXCI0cHhcIjtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuICAgICAgICAgICAgLy8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG4gICAgICAgICAgICBkaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjUwJVwiO1xuICAgICAgICAgICAgcGl4ZWxNYXJnaW5SaWdodFZhbCA9IGRpdlN0eWxlLm1hcmdpblJpZ2h0ID09PSBcIjRweFwiO1xuXG4gICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuICAgICAgICB9XG5cbiAgICAgICAgalF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuICAgICAgICAgICAgcGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHRlc3QgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGJ1dCB3ZSBzdGlsbCBkbyBtZW1vaXppbmdcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBjYW4gdXNlIHRoZSBib3hTaXppbmdSZWxpYWJsZSBwcmUtY29tcHV0aW5nLlxuICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHRlc3Qgd2FzIGFscmVhZHkgcGVyZm9ybWVkLCB0aG91Z2guXG4gICAgICAgICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMC00LjNcbiAgICAgICAgICAgICAgICAvLyBXZSdyZSBjaGVja2luZyBmb3IgYm94U2l6aW5nUmVsaWFibGVWYWwgaGVyZSBpbnN0ZWFkIG9mIHBpeGVsTWFyZ2luUmlnaHRWYWxcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGF0IGNvbXByZXNzZXMgYmV0dGVyIGFuZCB0aGV5J3JlIGNvbXB1dGVkIHRvZ2V0aGVyIGFueXdheS5cbiAgICAgICAgICAgICAgICBpZiAoIGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTggb25seSwgQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSAzN1xuICAgICAgICAgICAgICAgIGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZGl2IHdpdGggZXhwbGljaXQgd2lkdGggYW5kIG5vIG1hcmdpbi1yaWdodCBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gKCMzMzMzKVxuICAgICAgICAgICAgICAgIC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc3VwcG9ydCBmdW5jdGlvbiBpcyBvbmx5IGV4ZWN1dGVkIG9uY2Ugc28gbm8gbWVtb2l6aW5nIGlzIG5lZWRlZC5cbiAgICAgICAgICAgICAgICB2YXIgcmV0LFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5EaXYgPSBkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgQ1NTOiBib3gtc2l6aW5nOyBkaXNwbGF5OyBtYXJnaW47IGJvcmRlcjsgcGFkZGluZ1xuICAgICAgICAgICAgICAgIG1hcmdpbkRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2LnN0eWxlLmNzc1RleHQgPVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG4gICAgICAgICAgICAgICAgICAgIC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuICAgICAgICAgICAgICAgICAgICBcIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcbiAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MFwiO1xuICAgICAgICAgICAgICAgIG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IFwiMXB4XCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuICAgICAgICAgICAgICAgIHJldCA9ICFwYXJzZUZsb2F0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2ICkubWFyZ2luUmlnaHQgKTtcblxuICAgICAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG4gICAgICAgICAgICAgICAgZGl2LnJlbW92ZUNoaWxkKCBtYXJnaW5EaXYgKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gKTtcbiAgICB9ICkoKTtcblxuXG4gICAgZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcbiAgICAgICAgdmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcbiAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcblxuICAgICAgICBjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuICAgICAgICByZXQgPSBjb21wdXRlZCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IE9wZXJhIDEyLjF4IG9ubHlcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHN0eWxlIGV2ZW4gd2l0aG91dCBjb21wdXRlZFxuICAgICAgICAvLyBjb21wdXRlZCBpcyB1bmRlZmluZWQgZm9yIGVsZW1zIG9uIGRvY3VtZW50IGZyYWdtZW50c1xuICAgICAgICBpZiAoICggcmV0ID09PSBcIlwiIHx8IHJldCA9PT0gdW5kZWZpbmVkICkgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG4gICAgICAgICAgICByZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFOVxuICAgICAgICAvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuXG4gICAgICAgICAgICAvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG4gICAgICAgICAgICAvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcbiAgICAgICAgICAgIC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG4gICAgICAgICAgICAvLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG4gICAgICAgICAgICBpZiAoICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuICAgICAgICAgICAgICAgIG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cbiAgICAgICAgICAgICAgICAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG4gICAgICAgICAgICAgICAgc3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICAgICAgICAgICAgICBzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU5LTExK1xuICAgICAgICAgICAgLy8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cbiAgICAgICAgICAgIHJldCArIFwiXCIgOlxuICAgICAgICAgICAgcmV0O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG4gICAgICAgIC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5nZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIHZhclxuXG4gICAgICAgIC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcbiAgICAgICAgLy8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG4gICAgICAgIC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuICAgICAgICByZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cbiAgICAgICAgY3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG4gICAgICAgIGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgIGxldHRlclNwYWNpbmc6IFwiMFwiLFxuICAgICAgICAgICAgZm9udFdlaWdodDogXCI0MDBcIlxuICAgICAgICB9LFxuXG4gICAgICAgIGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG4gICAgICAgIGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbiAgICBmdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuICAgICAgICBpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuICAgICAgICB2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuICAgICAgICAgICAgaSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgIG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcbiAgICAgICAgICAgIGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuICAgICAgICAvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG4gICAgICAgIC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuICAgICAgICB2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXMgP1xuXG4gICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuICAgICAgICAgICAgTWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG4gICAgICAgICAgICB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG4gICAgICAgIHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuICAgICAgICAgICAgNCA6XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcbiAgICAgICAgICAgIG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG4gICAgICAgICAgICB2YWwgPSAwO1xuXG4gICAgICAgIGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuICAgICAgICAgICAgLy8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuICAgICAgICAgICAgaWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcbiAgICAgICAgICAgICAgICB2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggaXNCb3JkZXJCb3ggKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcbiAgICAgICAgICAgICAgICBpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG4gICAgICAgICAgICAgICAgaWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG4gICAgICAgICAgICAgICAgdmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuICAgICAgICAgICAgICAgIGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG4gICAgICAgIHZhciB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcbiAgICAgICAgICAgIHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuICAgICAgICAgICAgaXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG4gICAgICAgIC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuICAgICAgICAvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcbiAgICAgICAgLy8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG4gICAgICAgIGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgdmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcbiAgICAgICAgICAgIGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG4gICAgICAgICAgICBpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuICAgICAgICAgICAgLy8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuICAgICAgICAgICAgdmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG4gICAgICAgICAgICAgICAgKCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG4gICAgICAgIHJldHVybiAoIHZhbCArXG4gICAgICAgICAgICBhdWdtZW50V2lkdGhPckhlaWdodChcbiAgICAgICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuICAgICAgICAgICAgICAgIHZhbHVlSXNCb3JkZXJCb3gsXG4gICAgICAgICAgICAgICAgc3R5bGVzXG4gICAgICAgICAgICApXG4gICAgICAgICkgKyBcInB4XCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuICAgICAgICB2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuICAgICAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcbiAgICAgICAgICAgIGlmICggIWVsZW0uc3R5bGUgKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcbiAgICAgICAgICAgIGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICBpZiAoIHNob3cgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgaW5saW5lIGRpc3BsYXkgb2YgdGhpcyBlbGVtZW50IHRvIGxlYXJuIGlmIGl0IGlzXG4gICAgICAgICAgICAgICAgLy8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuICAgICAgICAgICAgICAgIGlmICggIXZhbHVlc1sgaW5kZXggXSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXG4gICAgICAgICAgICAgICAgLy8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcbiAgICAgICAgICAgICAgICAvLyBmb3Igc3VjaCBhbiBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW4oIGVsZW0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuYWNjZXNzKFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwib2xkZGlzcGxheVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuID0gaXNIaWRkZW4oIGVsZW0gKTtcblxuICAgICAgICAgICAgICAgIGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgfHwgIWhpZGRlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwib2xkZGlzcGxheVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuID8gZGlzcGxheSA6IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuICAgICAgICAvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG4gICAgICAgIGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG4gICAgICAgICAgICBlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG4gICAgICAgICAgICBpZiAoICFlbGVtLnN0eWxlICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCAhc2hvdyB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiApIHtcbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gdmFsdWVzWyBpbmRleCBdIHx8IFwiXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG5cbiAgICBqUXVlcnkuZXh0ZW5kKCB7XG5cbiAgICAgICAgLy8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgIC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuICAgICAgICBjc3NIb29rczoge1xuICAgICAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuICAgICAgICBjc3NOdW1iZXI6IHtcbiAgICAgICAgICAgIFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZmxleEdyb3dcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZmxleFNocmlua1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJmb250V2VpZ2h0XCI6IHRydWUsXG4gICAgICAgICAgICBcImxpbmVIZWlnaHRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJvcmRlclwiOiB0cnVlLFxuICAgICAgICAgICAgXCJvcnBoYW5zXCI6IHRydWUsXG4gICAgICAgICAgICBcIndpZG93c1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJ6SW5kZXhcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiem9vbVwiOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuICAgICAgICAvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG4gICAgICAgIGNzc1Byb3BzOiB7XG4gICAgICAgICAgICBcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG4gICAgICAgIHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG4gICAgICAgICAgICAvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgIGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG4gICAgICAgICAgICB2YXIgcmV0LCB0eXBlLCBob29rcyxcbiAgICAgICAgICAgICAgICBvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcbiAgICAgICAgICAgICAgICBzdHlsZSA9IGVsZW0uc3R5bGU7XG5cbiAgICAgICAgICAgIG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcbiAgICAgICAgICAgICAgICAoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cbiAgICAgICAgICAgIC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG4gICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVzIGJ1ZyAjOTIzN1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJudW1iZXJcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU5LTExK1xuICAgICAgICAgICAgICAgIC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcbiAgICAgICAgICAgICAgICBpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlWyBuYW1lIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcbiAgICAgICAgICAgIHZhciB2YWwsIG51bSwgaG9va3MsXG4gICAgICAgICAgICAgICAgb3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuICAgICAgICAgICAgICAgICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuICAgICAgICAgICAgLy8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cbiAgICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG4gICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuICAgICAgICAgICAgaWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcbiAgICAgICAgICAgIGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuICAgICAgICAgICAgICAgIHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcbiAgICAgICAgICAgIGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG4gICAgICAgICAgICAgICAgbnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcbiAgICAgICAgalF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjb21wdXRlZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5vZmZzZXRXaWR0aCA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICksXG4gICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0ID0gZXh0cmEgJiYgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG4gICAgICAgICAgICAgICAgICAgICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZVsgbmFtZSBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG4gICAgICAgICAgICAgICAgICAgIHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gKVxuICAgICAgICAgICAgICAgICkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuICAgIGpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0LFxuICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzd2FwKCBlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xuICAgIGpRdWVyeS5lYWNoKCB7XG4gICAgICAgIG1hcmdpbjogXCJcIixcbiAgICAgICAgcGFkZGluZzogXCJcIixcbiAgICAgICAgYm9yZGVyOiBcIldpZHRoXCJcbiAgICB9LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG4gICAgICAgIGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG4gICAgICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkID0ge30sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcbiAgICAgICAgICAgIGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZXMsIGxlbixcbiAgICAgICAgICAgICAgICAgICAgbWFwID0ge30sXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gbmFtZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuICAgICAgICAgICAgfSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICggaXNIaWRkZW4oIHRoaXMgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggdGhpcyApLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cblxuICAgIGZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbiAgICB9XG4gICAgalF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cbiAgICBUd2Vlbi5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBUd2VlbixcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuICAgICAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgICAgIHRoaXMucHJvcCA9IHByb3A7XG4gICAgICAgICAgICB0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG4gICAgICAgIH0sXG4gICAgICAgIGN1cjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG4gICAgICAgICAgICByZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cbiAgICAgICAgICAgICAgICBob29rcy5nZXQoIHRoaXMgKSA6XG4gICAgICAgICAgICAgICAgVHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuICAgICAgICB9LFxuICAgICAgICBydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuICAgICAgICAgICAgdmFyIGVhc2VkLFxuICAgICAgICAgICAgICAgIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuICAgICAgICAgICAgaWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG4gICAgICAgICAgICAgICAgaG9va3Muc2V0KCB0aGlzICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuICAgIFR3ZWVuLnByb3BIb29rcyA9IHtcbiAgICAgICAgX2RlZmF1bHQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuICAgICAgICAgICAgICAgIC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG4gICAgICAgICAgICAgICAgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG4gICAgICAgICAgICAgICAgLy8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cbiAgICAgICAgICAgICAgICAvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cbiAgICAgICAgICAgICAgICByZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuICAgICAgICAgICAgICAgIC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cbiAgICAgICAgICAgICAgICAvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcbiAgICBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG4gICAgICAgIHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuICAgICAgICAgICAgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LmVhc2luZyA9IHtcbiAgICAgICAgbGluZWFyOiBmdW5jdGlvbiggcCApIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICBzd2luZzogZnVuY3Rpb24oIHAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuICAgICAgICB9LFxuICAgICAgICBfZGVmYXVsdDogXCJzd2luZ1wiXG4gICAgfTtcblxuICAgIGpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIENvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxuICAgIGpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbiAgICB2YXJcbiAgICAgICAgZnhOb3csIHRpbWVySWQsXG4gICAgICAgIHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuICAgICAgICBycnVuID0gL3F1ZXVlSG9va3MkLztcblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmeE5vdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSApO1xuICAgICAgICByZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xuICAgIH1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbiAgICBmdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuICAgICAgICB2YXIgd2hpY2gsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuICAgICAgICAvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG4gICAgICAgIC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG4gICAgICAgIGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuICAgICAgICBmb3IgKCA7IGkgPCA0IDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuICAgICAgICAgICAgd2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcbiAgICAgICAgICAgIGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBpbmNsdWRlV2lkdGggKSB7XG4gICAgICAgICAgICBhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuICAgICAgICB2YXIgdHdlZW4sXG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgICAgIGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHJldHVybiB0d2VlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuICAgICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gICAgICAgIHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCB0d2VlbiwgaG9va3MsIG9sZGZpcmUsIGRpc3BsYXksIGNoZWNrRGlzcGxheSxcbiAgICAgICAgICAgIGFuaW0gPSB0aGlzLFxuICAgICAgICAgICAgb3JpZyA9IHt9LFxuICAgICAgICAgICAgc3R5bGUgPSBlbGVtLnN0eWxlLFxuICAgICAgICAgICAgaGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbiggZWxlbSApLFxuICAgICAgICAgICAgZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuICAgICAgICAvLyBIYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG4gICAgICAgIGlmICggIW9wdHMucXVldWUgKSB7XG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG4gICAgICAgICAgICBpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQgPSAwO1xuICAgICAgICAgICAgICAgIG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuICAgICAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRmaXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQrKztcblxuICAgICAgICAgICAgYW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcbiAgICAgICAgICAgICAgICBhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVucXVldWVkLS07XG4gICAgICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3MuZW1wdHkuZmlyZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGVpZ2h0L3dpZHRoIG92ZXJmbG93IHBhc3NcbiAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCJoZWlnaHRcIiBpbiBwcm9wcyB8fCBcIndpZHRoXCIgaW4gcHJvcHMgKSApIHtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XG4gICAgICAgICAgICAvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFOS0xMCBkbyBub3RcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgb3ZlcmZsb3cgYXR0cmlidXRlIHdoZW4gb3ZlcmZsb3dYIGFuZFxuICAgICAgICAgICAgLy8gb3ZlcmZsb3dZIGFyZSBzZXQgdG8gdGhlIHNhbWUgdmFsdWVcbiAgICAgICAgICAgIG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG4gICAgICAgICAgICAvLyBTZXQgZGlzcGxheSBwcm9wZXJ0eSB0byBpbmxpbmUtYmxvY2sgZm9yIGhlaWdodC93aWR0aFxuICAgICAgICAgICAgLy8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZFxuICAgICAgICAgICAgZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cbiAgICAgICAgICAgIC8vIFRlc3QgZGVmYXVsdCBkaXNwbGF5IGlmIGRpc3BsYXkgaXMgY3VycmVudGx5IFwibm9uZVwiXG4gICAgICAgICAgICBjaGVja0Rpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/XG4gICAgICAgICAgICAgICAgZGF0YVByaXYuZ2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApIHx8IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5O1xuXG4gICAgICAgICAgICBpZiAoIGNoZWNrRGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG4gICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICBhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3cvaGlkZSBwYXNzXG4gICAgICAgIGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG4gICAgICAgICAgICBpZiAoIHJmeHR5cGVzLmV4ZWMoIHZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByb3BzWyBwcm9wIF07XG4gICAgICAgICAgICAgICAgdG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGRhdGFTaG93IGxlZnQgb3ZlciBmcm9tIGEgc3RvcHBlZCBoaWRlIG9yIHNob3dcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHdlIGFyZSBnb2luZyB0byBwcm9jZWVkIHdpdGggc2hvdywgd2Ugc2hvdWxkIHByZXRlbmQgdG8gYmUgaGlkZGVuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXG4gICAgICAgICAgICAgICAgLy8gQW55IG5vbi1meCB2YWx1ZSBzdG9wcyB1cyBmcm9tIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcbiAgICAgICAgICAgIGlmICggZGF0YVNob3cgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwge30gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcInJldmVyc2VcIlxuICAgICAgICAgICAgaWYgKCB0b2dnbGUgKSB7XG4gICAgICAgICAgICAgICAgZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggaGlkZGVuICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeSggZWxlbSApLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5pbS5kb25lKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCBlbGVtICkuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3A7XG5cbiAgICAgICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcbiAgICAgICAgICAgICAgICBmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgZm9yICggcHJvcCBpbiBvcmlnICkge1xuICAgICAgICAgICAgICAgIHR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNob3dbIHByb3AgXSA9IHR3ZWVuLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGhpZGRlbiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbm9vcCBsaWtlIC5oaWRlKCkuaGlkZSgpLCByZXN0b3JlIGFuIG92ZXJ3cml0dGVuIGRpc3BsYXkgdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmICggKCBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5ICkgPT09IFwiaW5saW5lXCIgKSB7XG4gICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuICAgICAgICB2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG4gICAgICAgIC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuICAgICAgICBmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcbiAgICAgICAgICAgIG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuICAgICAgICAgICAgZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuICAgICAgICAgICAgdmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgZWFzaW5nID0gdmFsdWVbIDEgXTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gbmFtZSApIHtcbiAgICAgICAgICAgICAgICBwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICAgICAgLy8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuICAgICAgICAgICAgICAgIC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcbiAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIHN0b3BwZWQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG4gICAgICAgICAgICBkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBkZWxldGUgdGljay5lbGVtO1xuICAgICAgICAgICAgfSApLFxuICAgICAgICAgICAgdGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICggc3RvcHBlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAxIC0gdGVtcCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG4gICAgICAgICAgICAgICAgZWxlbTogZWxlbSxcbiAgICAgICAgICAgICAgICBwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcbiAgICAgICAgICAgICAgICBvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmc6IHt9LFxuICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zICksXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHdlZW5zOiBbXSxcbiAgICAgICAgICAgICAgICBjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0d2VlbjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzdG9wcGVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgIGlmICggZ290b0VuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApLFxuICAgICAgICAgICAgcHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cbiAgICAgICAgcHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuICAgICAgICBmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG4gICAgICAgICAgICBpZiAoIHJlc3VsdCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG4gICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG4gICAgICAgICAgICBhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGpRdWVyeS5meC50aW1lcihcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcbiAgICAgICAgICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICAgICAgICAgIGFuaW06IGFuaW1hdGlvbixcbiAgICAgICAgICAgICAgICBxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcbiAgICAgICAgICAgIH0gKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG4gICAgICAgIHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcbiAgICAgICAgICAgIC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG4gICAgICAgICAgICAuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG4gICAgICAgICAgICAuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbiAgICB9XG5cbiAgICBqUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG4gICAgICAgIHR3ZWVuZXJzOiB7XG4gICAgICAgICAgICBcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICBhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW47XG4gICAgICAgICAgICB9IF1cbiAgICAgICAgfSxcblxuICAgICAgICB0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHByb3BzO1xuICAgICAgICAgICAgICAgIHByb3BzID0gWyBcIipcIiBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90d2hpdGUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb3AsXG4gICAgICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IHByb3BzWyBpbmRleCBdO1xuICAgICAgICAgICAgICAgIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuICAgICAgICBwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcbiAgICAgICAgICAgIGlmICggcHJlcGVuZCApIHtcbiAgICAgICAgICAgICAgICBBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuICAgICAgICB2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG4gICAgICAgICAgICBjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuICAgICAgICAgICAgalF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG4gICAgICAgICAgICBkdXJhdGlvbjogc3BlZWQsXG4gICAgICAgICAgICBlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcbiAgICAgICAgfTtcblxuICAgICAgICBvcHQuZHVyYXRpb24gPSBqUXVlcnkuZngub2ZmID8gMCA6IHR5cGVvZiBvcHQuZHVyYXRpb24gPT09IFwibnVtYmVyXCIgP1xuICAgICAgICAgICAgb3B0LmR1cmF0aW9uIDogb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgP1xuICAgICAgICAgICAgICAgIGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcbiAgICAgICAgaWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG4gICAgICAgICAgICBvcHQucXVldWUgPSBcImZ4XCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBRdWV1ZWluZ1xuICAgICAgICBvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG4gICAgICAgIG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuICAgICAgICAgICAgICAgIG9wdC5vbGQuY2FsbCggdGhpcyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG9wdC5xdWV1ZSApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG9wdDtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgICAgICBmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgICAgIC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbiApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuICAgICAgICAgICAgLy8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgLmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcbiAgICAgICAgfSxcbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgdmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcbiAgICAgICAgICAgICAgICBvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG4gICAgICAgICAgICAgICAgZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltLnN0b3AoIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuICAgICAgICAgICAgICAgIHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcbiAgICAgICAgICAgIHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBob29rcy5zdG9wO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBob29rcy5zdG9wO1xuICAgICAgICAgICAgICAgIHN0b3AoIGdvdG9FbmQgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgZ290b0VuZCA9IGNsZWFyUXVldWU7XG4gICAgICAgICAgICAgICAgY2xlYXJRdWV1ZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlcXVldWUgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuICAgICAgICAgICAgICAgIGlmICggaW5kZXggKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXF1ZXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cbiAgICAgICAgICAgICAgICAvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuICAgICAgICAgICAgICAgIGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuICAgICAgICAgICAgICAgICAgICBxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgaG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycyxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG4gICAgICAgICAgICAgICAgLy8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuICAgICAgICAgICAgICAgIGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuICAgICAgICAgICAgICAgIGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuICAgICAgICAgICAgICAgIGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgaG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cbiAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuICAgICAgICAgICAgICAgIGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGEuZmluaXNoO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuICAgICAgICB2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcbiAgICAgICAgalF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cbiAgICAgICAgICAgICAgICBjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcbiAgICAgICAgfTtcbiAgICB9ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbiAgICBqUXVlcnkuZWFjaCgge1xuICAgICAgICBzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuICAgICAgICBzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcbiAgICAgICAgc2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG4gICAgICAgIGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuICAgICAgICBmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG4gICAgICAgIGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG4gICAgfSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuICAgICAgICBqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuICAgICAgICB9O1xuICAgIH0gKTtcblxuICAgIGpRdWVyeS50aW1lcnMgPSBbXTtcbiAgICBqUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGltZXIsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cbiAgICAgICAgZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cbiAgICAgICAgZm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdGltZXIgPSB0aW1lcnNbIGkgXTtcblxuICAgICAgICAgICAgLy8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICBpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcbiAgICAgICAgICAgICAgICB0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggIXRpbWVycy5sZW5ndGggKSB7XG4gICAgICAgICAgICBqUXVlcnkuZnguc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGZ4Tm93ID0gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG4gICAgICAgIGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcbiAgICAgICAgaWYgKCB0aW1lcigpICkge1xuICAgICAgICAgICAgalF1ZXJ5LmZ4LnN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqUXVlcnkudGltZXJzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xuICAgIGpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoICF0aW1lcklkICkge1xuICAgICAgICAgICAgdGltZXJJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cbiAgICAgICAgdGltZXJJZCA9IG51bGw7XG4gICAgfTtcblxuICAgIGpRdWVyeS5meC5zcGVlZHMgPSB7XG4gICAgICAgIHNsb3c6IDYwMCxcbiAgICAgICAgZmFzdDogMjAwLFxuXG4gICAgICAgIC8vIERlZmF1bHQgc3BlZWRcbiAgICAgICAgX2RlZmF1bHQ6IDQwMFxuICAgIH07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cDovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xuICAgIGpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuICAgICAgICB0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcbiAgICAgICAgICAgIGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9ICk7XG4gICAgfTtcblxuXG4gICAgKCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG4gICAgICAgICAgICBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG4gICAgICAgICAgICBvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG4gICAgICAgIGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogaU9TPD01LjEsIEFuZHJvaWQ8PTQuMitcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG4gICAgICAgIHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFPD0xMStcbiAgICAgICAgLy8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3RcbiAgICAgICAgc3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkPD0yLjNcbiAgICAgICAgLy8gT3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmUgaW5jb3JyZWN0bHkgbWFya2VkIGFzIGRpc2FibGVkXG4gICAgICAgIHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFPD0xMStcbiAgICAgICAgLy8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cbiAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSBcInRcIjtcbiAgICAgICAgaW5wdXQudHlwZSA9IFwicmFkaW9cIjtcbiAgICAgICAgc3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xuICAgIH0gKSgpO1xuXG5cbiAgICB2YXIgYm9vbEhvb2ssXG4gICAgICAgIGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgICAgICBhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCgge1xuICAgICAgICBhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgcmV0LCBob29rcyxcbiAgICAgICAgICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcbiAgICAgICAgICAgIGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXG4gICAgICAgICAgICAvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG4gICAgICAgICAgICBpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdIHx8XG4gICAgICAgICAgICAgICAgICAgICggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuICAgICAgICAgICAgICAgICAgICAoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cbiAgICAgICAgICAgIC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0ckhvb2tzOiB7XG4gICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGVsZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBuYW1lLCBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cbiAgICAgICAgICAgIGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG4gICAgYm9vbEhvb2sgPSB7XG4gICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBqUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuICAgICAgICBhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG4gICAgICAgICAgICB2YXIgcmV0LCBoYW5kbGU7XG4gICAgICAgICAgICBpZiAoICFpc1hNTCApIHtcblxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBhdHRySGFuZGxlWyBuYW1lIF07XG4gICAgICAgICAgICAgICAgYXR0ckhhbmRsZVsgbmFtZSBdID0gcmV0O1xuICAgICAgICAgICAgICAgIHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpIDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICBhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH0gKTtcblxuXG5cblxuICAgIHZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcbiAgICAgICAgcmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgcHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCgge1xuICAgICAgICBwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgcmV0LCBob29rcyxcbiAgICAgICAgICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcbiAgICAgICAgICAgIGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAgIC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3NcbiAgICAgICAgICAgICAgICBuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgICggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtWyBuYW1lIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJvcEhvb2tzOiB7XG4gICAgICAgICAgICB0YWJJbmRleDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFiaW5kZXggP1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICByY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiBlbGVtLmhyZWYgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwcm9wRml4OiB7XG4gICAgICAgICAgICBcImZvclwiOiBcImh0bWxGb3JcIixcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuICAgICAgICB9XG4gICAgfSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbiAgICBpZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuICAgICAgICBqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCBwYXJlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGpRdWVyeS5lYWNoKCBbXG4gICAgICAgIFwidGFiSW5kZXhcIixcbiAgICAgICAgXCJyZWFkT25seVwiLFxuICAgICAgICBcIm1heExlbmd0aFwiLFxuICAgICAgICBcImNlbGxTcGFjaW5nXCIsXG4gICAgICAgIFwiY2VsbFBhZGRpbmdcIixcbiAgICAgICAgXCJyb3dTcGFuXCIsXG4gICAgICAgIFwiY29sU3BhblwiLFxuICAgICAgICBcInVzZU1hcFwiLFxuICAgICAgICBcImZyYW1lQm9yZGVyXCIsXG4gICAgICAgIFwiY29udGVudEVkaXRhYmxlXCJcbiAgICBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgalF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbiAgICB9ICk7XG5cblxuXG5cbiAgICB2YXIgcmNsYXNzID0gL1tcXHRcXHJcXG5cXGZdL2c7XG5cbiAgICBmdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xuICAgIH1cblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcbiAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIFwiIFwiICsgY3VyVmFsdWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGN1ciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciArPSBjbGF6eiArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcbiAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggY3VyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVWYWxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjbGFzc05hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lLCBlbGVtLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG4gICAgICAgICAgICB3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICggXCIgXCIgKyBnZXRDbGFzcyggZWxlbSApICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSApO1xuXG5cblxuXG4gICAgdmFyIHJyZXR1cm4gPSAvXFxyL2csXG4gICAgICAgIHJzcGFjZXMgPSAvW1xceDIwXFx0XFxyXFxuXFxmXSsvZztcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgdmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1sgMCBdO1xuXG4gICAgICAgICAgICBpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIGlmICggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2V0XCIgaW4gaG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gZWxlbS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICkgOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbDtcblxuICAgICAgICAgICAgICAgIGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKCB2YWwgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gXCJcIjtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCArPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcbiAgICAgICAgICAgICAgICBpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCgge1xuICAgICAgICB2YWxIb29rczoge1xuICAgICAgICAgICAgb3B0aW9uOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTEwLTExK1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkudHJpbSggalF1ZXJ5LnRleHQoIGVsZW0gKSApLnJlcGxhY2UoIHJzcGFjZXMsIFwiIFwiICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSwgb3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIiB8fCBpbmRleCA8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpbmRleCA8IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lID8gaW5kZXggOiAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBzdXBwb3J0Lm9wdERpc2FibGVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09PSBudWxsICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb25lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCggdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBvcHRpb25zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb3B0aW9uLnNlbGVjdGVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG4gICAgICAgICAgICAgICAgICAgIGlmICggIW9wdGlvblNldCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxuICAgIGpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuICAgICAgICBqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG4gICAgICAgICAgICBqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG4gICAgdmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cbiAgICAgICAgICAgIHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG4gICAgICAgICAgICAgICAgZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG4gICAgICAgICAgICAgICAgdHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuICAgICAgICAgICAgY3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuICAgICAgICAgICAgaWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuICAgICAgICAgICAgICAgIC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcbiAgICAgICAgICAgICAgICB0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMuc29ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG4gICAgICAgICAgICAvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuICAgICAgICAgICAgICAgIGV2ZW50IDpcbiAgICAgICAgICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuICAgICAgICAgICAgLy8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuICAgICAgICAgICAgZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG4gICAgICAgICAgICBldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG4gICAgICAgICAgICBldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cbiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcblxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG4gICAgICAgICAgICBldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoICFldmVudC50YXJnZXQgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZWxlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuICAgICAgICAgICAgZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgWyBldmVudCBdIDpcbiAgICAgICAgICAgICAgICBqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuICAgICAgICAgICAgLy8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG4gICAgICAgICAgICBpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuICAgICAgICAgICAgLy8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcbiAgICAgICAgICAgIGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cbiAgICAgICAgICAgICAgICBidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFBhdGgucHVzaCggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IGN1cjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcbiAgICAgICAgICAgICAgICBpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG4gICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IGkgPiAxID9cbiAgICAgICAgICAgICAgICAgICAgYnViYmxlVHlwZSA6XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgaGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuICAgICAgICAgICAgICAgIGlmICggaGFuZGxlICkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE5hdGl2ZSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgaGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG4gICAgICAgICAgICAgICAgaWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQudHlwZSA9IHR5cGU7XG5cbiAgICAgICAgICAgIC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcbiAgICAgICAgICAgIGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gZWxlbVsgb250eXBlIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdG1wICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIG9udHlwZSBdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgdHlwZSBdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRtcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtWyBvbnR5cGUgXSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcbiAgICAgICAgLy8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcbiAgICAgICAgc2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcbiAgICAgICAgICAgIHZhciBlID0galF1ZXJ5LmV4dGVuZChcbiAgICAgICAgICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCksXG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBpc1NpbXVsYXRlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG4gICAgICAgIH1cblxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcblxuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1sgMCBdO1xuICAgICAgICAgICAgaWYgKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSApO1xuXG5cbiAgICBqUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIFwiICtcbiAgICAgICAgXCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG4gICAgICAgIFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG4gICAgICAgIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuICAgICAgICAgICAgalF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlciggbmFtZSApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSApO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgICAgICBob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG5cblxuICAgIHN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3hcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lLCBTYWZhcmlcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbiAgICBpZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG4gICAgICAgIGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG4gICAgICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICFhdHRhY2hlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICFhdHRhY2hlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9ICk7XG4gICAgfVxuICAgIHZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxuICAgIHZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxuICAgIHZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuLy8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcbiAgICBqUXVlcnkucGFyc2VKU09OID0gZnVuY3Rpb24oIGRhdGEgKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKCBkYXRhICsgXCJcIiApO1xuICAgIH07XG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xuICAgIGpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuICAgICAgICB2YXIgeG1sO1xuICAgICAgICBpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRTlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG4gICAgICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgICAgICAgeG1sID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuICAgICAgICAgICAgalF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geG1sO1xuICAgIH07XG5cblxuICAgIHZhclxuICAgICAgICByaGFzaCA9IC8jLiokLyxcbiAgICAgICAgcnRzID0gLyhbPyZdKV89W14mXSovLFxuICAgICAgICByaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cbiAgICAgICAgLy8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG4gICAgICAgIHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG4gICAgICAgIHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuICAgICAgICBycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cbiAgICAgICAgLyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuICAgICAgICBwcmVmaWx0ZXJzID0ge30sXG5cbiAgICAgICAgLyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuICAgICAgICB0cmFuc3BvcnRzID0ge30sXG5cbiAgICAgICAgLy8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG4gICAgICAgIGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuICAgICAgICAvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cbiAgICAgICAgb3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcbiAgICBvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbiAgICBmdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuICAgICAgICAvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGFUeXBlLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhcHBlbmRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG4gICAgZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuICAgICAgICB2YXIgaW5zcGVjdGVkID0ge30sXG4gICAgICAgICAgICBzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuICAgICAgICBmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZDtcbiAgICAgICAgICAgIGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG4gICAgICAgICAgICBqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICAhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuICAgICAgICAgICAgICAgICAgICBpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG4gICAgfVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuICAgIGZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuICAgICAgICB2YXIga2V5LCBkZWVwLFxuICAgICAgICAgICAgZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGZvciAoIGtleSBpbiBzcmMgKSB7XG4gICAgICAgICAgICBpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICggZGVlcCApIHtcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbiAgICBmdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG4gICAgICAgIHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcbiAgICAgICAgICAgIGNvbnRlbnRzID0gcy5jb250ZW50cyxcbiAgICAgICAgICAgIGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG4gICAgICAgIHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuICAgICAgICAgICAgZGF0YVR5cGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgY3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcbiAgICAgICAgaWYgKCBjdCApIHtcbiAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG4gICAgICAgIGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuICAgICAgICAgICAgZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG4gICAgICAgICAgICBmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcbiAgICAgICAgICAgICAgICBpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCAhZmlyc3REYXRhVHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REYXRhVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcbiAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG4gICAgICAgIC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG4gICAgICAgIC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAgICAgICAgaWYgKCBmaW5hbERhdGFUeXBlICkge1xuICAgICAgICAgICAgaWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbiAgICBmdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG4gICAgICAgIHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuICAgICAgICAgICAgY29udmVydGVycyA9IHt9LFxuXG4gICAgICAgICAgICAvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG4gICAgICAgICAgICBkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuICAgICAgICBpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuICAgICAgICAgICAgZm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG4gICAgICAgICAgICAgICAgY29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuICAgICAgICB3aGlsZSAoIGN1cnJlbnQgKSB7XG5cbiAgICAgICAgICAgIGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuICAgICAgICAgICAgICAgIGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2ID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuICAgICAgICAgICAgaWYgKCBjdXJyZW50ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuICAgICAgICAgICAgICAgIGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHByZXY7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcbiAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhY29udiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb252ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbnYgPT09IHRydWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0bXBbIDAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwicGFyc2VyZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZXh0ZW5kKCB7XG5cbiAgICAgICAgLy8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG4gICAgICAgIGFjdGl2ZTogMCxcblxuICAgICAgICAvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG4gICAgICAgIGxhc3RNb2RpZmllZDoge30sXG4gICAgICAgIGV0YWc6IHt9LFxuXG4gICAgICAgIGFqYXhTZXR0aW5nczoge1xuICAgICAgICAgICAgdXJsOiBsb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgIGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG4gICAgICAgICAgICBnbG9iYWw6IHRydWUsXG4gICAgICAgICAgICBwcm9jZXNzRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG4gICAgICAgICAgICAvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG4gICAgICAgICAgICBhY2NlcHRzOiB7XG4gICAgICAgICAgICAgICAgXCIqXCI6IGFsbFR5cGVzLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwidGV4dC9wbGFpblwiLFxuICAgICAgICAgICAgICAgIGh0bWw6IFwidGV4dC9odG1sXCIsXG4gICAgICAgICAgICAgICAgeG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcbiAgICAgICAgICAgICAgICBqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb250ZW50czoge1xuICAgICAgICAgICAgICAgIHhtbDogL1xcYnhtbFxcYi8sXG4gICAgICAgICAgICAgICAgaHRtbDogL1xcYmh0bWwvLFxuICAgICAgICAgICAgICAgIGpzb246IC9cXGJqc29uXFxiL1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVzcG9uc2VGaWVsZHM6IHtcbiAgICAgICAgICAgICAgICB4bWw6IFwicmVzcG9uc2VYTUxcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuICAgICAgICAgICAgICAgIGpzb246IFwicmVzcG9uc2VKU09OXCJcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIERhdGEgY29udmVydGVyc1xuICAgICAgICAgICAgLy8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgICAgY29udmVydGVyczoge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG4gICAgICAgICAgICAgICAgXCIqIHRleHRcIjogU3RyaW5nLFxuXG4gICAgICAgICAgICAgICAgLy8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGV4dCBhcyB4bWxcbiAgICAgICAgICAgICAgICBcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcbiAgICAgICAgICAgIC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcbiAgICAgICAgICAgIC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG4gICAgICAgICAgICAvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcbiAgICAgICAgICAgIGZsYXRPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdXJsOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuICAgICAgICAvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG4gICAgICAgIC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG4gICAgICAgIGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MgP1xuXG4gICAgICAgICAgICAgICAgLy8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICAgICAgICBhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG4gICAgICAgICAgICAgICAgYWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG4gICAgICAgIGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG4gICAgICAgIC8vIE1haW4gbWV0aG9kXG4gICAgICAgIGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHVybDtcbiAgICAgICAgICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydCxcblxuICAgICAgICAgICAgICAgIC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cbiAgICAgICAgICAgICAgICBjYWNoZVVSTCxcblxuICAgICAgICAgICAgICAgIC8vIFJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuXG4gICAgICAgICAgICAgICAgLy8gdGltZW91dCBoYW5kbGVcbiAgICAgICAgICAgICAgICB0aW1lb3V0VGltZXIsXG5cbiAgICAgICAgICAgICAgICAvLyBVcmwgY2xlYW51cCB2YXJcbiAgICAgICAgICAgICAgICB1cmxBbmNob3IsXG5cbiAgICAgICAgICAgICAgICAvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcbiAgICAgICAgICAgICAgICBmaXJlR2xvYmFscyxcblxuICAgICAgICAgICAgICAgIC8vIExvb3AgdmFyaWFibGVcbiAgICAgICAgICAgICAgICBpLFxuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgICAgIHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG4gICAgICAgICAgICAgICAgLy8gQ2FsbGJhY2tzIGNvbnRleHRcbiAgICAgICAgICAgICAgICBjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuICAgICAgICAgICAgICAgIC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LFxuXG4gICAgICAgICAgICAgICAgLy8gRGVmZXJyZWRzXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cbiAgICAgICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cbiAgICAgICAgICAgICAgICAvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzID0ge30sXG4gICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGpxWEhSIHN0YXRlXG4gICAgICAgICAgICAgICAgc3RhdGUgPSAwLFxuXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgc3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cbiAgICAgICAgICAgICAgICAvLyBGYWtlIHhoclxuICAgICAgICAgICAgICAgIGpxWEhSID0ge1xuICAgICAgICAgICAgICAgICAgICByZWFkeVN0YXRlOiAwLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlID09PSAyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJhdyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGVzIHRoZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3RhdGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdIHx8IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFzdGF0ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm1pbWVUeXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWFwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUgPCAyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBjb2RlIGluIG1hcCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYW5jZWwgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRyYW5zcG9ydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSggMCwgZmluYWxUZXh0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBkZWZlcnJlZHNcbiAgICAgICAgICAgIGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcbiAgICAgICAgICAgIGpxWEhSLnN1Y2Nlc3MgPSBqcVhIUi5kb25lO1xuICAgICAgICAgICAganFYSFIuZXJyb3IgPSBqcVhIUi5mYWlsO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcbiAgICAgICAgICAgIC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuICAgICAgICAgICAgLy8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcbiAgICAgICAgICAgIC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgcy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKS5yZXBsYWNlKCByaGFzaCwgXCJcIiApXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuICAgICAgICAgICAgLy8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG4gICAgICAgICAgICBzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG4gICAgICAgICAgICBzLmRhdGFUeXBlcyA9IGpRdWVyeS50cmltKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cbiAgICAgICAgICAgIC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuICAgICAgICAgICAgaWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgdXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOC0xMStcbiAgICAgICAgICAgICAgICAvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIGlmIHVybCBpcyBtYWxmb3JtZWQsIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOC0xMStcbiAgICAgICAgICAgICAgICAgICAgLy8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgdXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcbiAgICAgICAgICAgICAgICAgICAgcy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcbiAgICAgICAgICAgICAgICAgICAgcy5jcm9zc0RvbWFpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcbiAgICAgICAgICAgIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICBzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSBwcmVmaWx0ZXJzXG4gICAgICAgICAgICBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuICAgICAgICAgICAgLy8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcbiAgICAgICAgICAgIGlmICggc3RhdGUgPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuICAgICAgICAgICAgLy8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcbiAgICAgICAgICAgIGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG4gICAgICAgICAgICAvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG4gICAgICAgICAgICBpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcHBlcmNhc2UgdGhlIHR5cGVcbiAgICAgICAgICAgIHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuICAgICAgICAgICAgcy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuICAgICAgICAgICAgLy8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG4gICAgICAgICAgICBjYWNoZVVSTCA9IHMudXJsO1xuXG4gICAgICAgICAgICAvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuICAgICAgICAgICAgaWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuICAgICAgICAgICAgICAgIGlmICggcy5kYXRhICkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVVSTCA9ICggcy51cmwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHMuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcy51cmwgPSBydHMudGVzdCggY2FjaGVVUkwgKSA/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVVSTC5yZXBsYWNlKCBydHMsIFwiJDFfPVwiICsgbm9uY2UrKyApIDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBvbmUgdG8gdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG4gICAgICAgICAgICBpZiAoIHMuaWZNb2RpZmllZCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuICAgICAgICAgICAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuICAgICAgICAgICAgaWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG4gICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG4gICAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuICAgICAgICAgICAgICAgIFwiQWNjZXB0XCIsXG4gICAgICAgICAgICAgICAgcy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG4gICAgICAgICAgICAgICAgICAgIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcbiAgICAgICAgICAgICAgICAgICAgKCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcbiAgICAgICAgICAgICAgICAgICAgcy5hY2NlcHRzWyBcIipcIiBdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cbiAgICAgICAgICAgIGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcbiAgICAgICAgICAgIGlmICggcy5iZWZvcmVTZW5kICYmXG4gICAgICAgICAgICAgICAgKCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSLmFib3J0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuICAgICAgICAgICAgc3RyQWJvcnQgPSBcImFib3J0XCI7XG5cbiAgICAgICAgICAgIC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuICAgICAgICAgICAgZm9yICggaSBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9ICkge1xuICAgICAgICAgICAgICAgIGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgdHJhbnNwb3J0XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuICAgICAgICAgICAgLy8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG4gICAgICAgICAgICBpZiAoICF0cmFuc3BvcnQgKSB7XG4gICAgICAgICAgICAgICAgZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAganFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cbiAgICAgICAgICAgICAgICAvLyBTZW5kIGdsb2JhbCBldmVudFxuICAgICAgICAgICAgICAgIGlmICggZmlyZUdsb2JhbHMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG4gICAgICAgICAgICAgICAgaWYgKCBzdGF0ZSA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRpbWVvdXRcbiAgICAgICAgICAgICAgICBpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAganFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHMudGltZW91dCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlIDwgMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoIC0xLCBlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG4gICAgICAgICAgICBmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuICAgICAgICAgICAgICAgIC8vIENhbGxlZCBvbmNlXG4gICAgICAgICAgICAgICAgaWYgKCBzdGF0ZSA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMjtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKCB0aW1lb3V0VGltZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlYWR5U3RhdGVcbiAgICAgICAgICAgICAgICBqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICBpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuICAgICAgICAgICAgICAgIC8vIEdldCByZXNwb25zZSBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKCByZXNwb25zZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcbiAgICAgICAgICAgICAgICBpZiAoIGlzU3VjY2VzcyApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIHMuaWZNb2RpZmllZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1vZGlmaWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1vZGlmaWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgbW9kaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3VjY2VzcyA9ICFlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHN0YXR1c1RleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3RcbiAgICAgICAgICAgICAgICBqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAganFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy9FcnJvclxuICAgICAgICAgICAgICAgIGlmICggaXNTdWNjZXNzICkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBmaXJlR2xvYmFscyApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlXG4gICAgICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuICAgICAgICAgICAgICAgIGlmICggZmlyZUdsb2JhbHMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG4gICAgICAgIGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuICAgICAgICAgICAgLy8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICB0eXBlOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBjYWxsYmFja1xuICAgICAgICAgICAgfSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG4gICAgICAgIH07XG4gICAgfSApO1xuXG5cbiAgICBqUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuICAgICAgICByZXR1cm4galF1ZXJ5LmFqYXgoIHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuXG4gICAgICAgICAgICAvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJzY3JpcHRcIixcbiAgICAgICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgIGdsb2JhbDogZmFsc2UsXG4gICAgICAgICAgICBcInRocm93c1wiOiB0cnVlXG4gICAgICAgIH0gKTtcbiAgICB9O1xuXG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuICAgICAgICAgICAgdmFyIHdyYXA7XG5cbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdGhpc1sgMCBdICkge1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcbiAgICAgICAgICAgICAgICB3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuICAgICAgICAgICAgICAgIGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICAgICAgICAgIH0gKS5hcHBlbmQoIHRoaXMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBlbmQoIGh0bWwgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bndyYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImJvZHlcIiApICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSApO1xuXG5cbiAgICBqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICByZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSggZWxlbSApO1xuICAgIH07XG4gICAgalF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogT3BlcmEgPD0gMTIuMTJcbiAgICAgICAgLy8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xuICAgICAgICAvLyBVc2UgT1IgaW5zdGVhZCBvZiBBTkQgYXMgdGhlIGVsZW1lbnQgaXMgbm90IHZpc2libGUgaWYgZWl0aGVyIGlzIHRydWVcbiAgICAgICAgLy8gU2VlIHRpY2tldHMgIzEwNDA2IGFuZCAjMTMxMzJcbiAgICAgICAgcmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPiAwIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0ID4gMCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID4gMDtcbiAgICB9O1xuXG5cblxuXG4gICAgdmFyIHIyMCA9IC8lMjAvZyxcbiAgICAgICAgcmJyYWNrZXQgPSAvXFxbXFxdJC8sXG4gICAgICAgIHJDUkxGID0gL1xccj9cXG4vZyxcbiAgICAgICAgcnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuICAgICAgICByc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbiAgICBmdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG4gICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgIGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuICAgICAgICAgICAgICAgIGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuICAgICAgICAgICAgICAgICAgICBhZGQoIHByZWZpeCwgdiApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWRpdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cbiAgICAgICAgICAgIGZvciAoIG5hbWUgaW4gb2JqICkge1xuICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG4gICAgICAgICAgICBhZGQoIHByZWZpeCwgb2JqICk7XG4gICAgICAgIH1cbiAgICB9XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbiAgICBqUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG4gICAgICAgIHZhciBwcmVmaXgsXG4gICAgICAgICAgICBzID0gW10sXG4gICAgICAgICAgICBhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblxuICAgICAgICAgICAgICAgIC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG4gICAgICAgICAgICAgICAgc1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cbiAgICAgICAgaWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgdHJhZGl0aW9uYWwgPSBqUXVlcnkuYWpheFNldHRpbmdzICYmIGpRdWVyeS5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuICAgICAgICBpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG4gICAgICAgICAgICAvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cbiAgICAgICAgICAgIGZvciAoIHByZWZpeCBpbiBhICkge1xuICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG4gICAgICAgIHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG4gICAgICAgICAgICB9IClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcbiAgICAgICAgICAgICAgICB9IClcbiAgICAgICAgICAgICAgICAubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pc0FycmF5KCB2YWwgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuICAgICAgICAgICAgICAgIH0gKS5nZXQoKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG4gICAgalF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIH0gY2F0Y2ggKCBlICkge31cbiAgICB9O1xuXG4gICAgdmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cbiAgICAgICAgICAgIC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG4gICAgICAgICAgICAwOiAyMDAsXG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOVxuICAgICAgICAgICAgLy8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG4gICAgICAgICAgICAxMjIzOiAyMDRcbiAgICAgICAgfSxcbiAgICAgICAgeGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuICAgIHN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbiAgICBzdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxuICAgIGpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG4gICAgICAgIC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgaWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyID0gb3B0aW9ucy54aHIoKTtcblxuICAgICAgICAgICAgICAgICAgICB4aHIub3BlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5hc3luYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhc3N3b3JkXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZShcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gdG8gZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU5XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9ICk7XG5cblxuXG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG4gICAgalF1ZXJ5LmFqYXhTZXR1cCgge1xuICAgICAgICBhY2NlcHRzOiB7XG4gICAgICAgICAgICBzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG4gICAgICAgICAgICBcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRzOiB7XG4gICAgICAgICAgICBzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0ZXJzOiB7XG4gICAgICAgICAgICBcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbiAgICBqUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG4gICAgICAgIGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgcy5jYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICggcy5jcm9zc0RvbWFpbiApIHtcbiAgICAgICAgICAgIHMudHlwZSA9IFwiR0VUXCI7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxuICAgIGpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuICAgICAgICAvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG4gICAgICAgIGlmICggcy5jcm9zc0RvbWFpbiApIHtcbiAgICAgICAgICAgIHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBzLnVybFxuICAgICAgICAgICAgICAgICAgICB9ICkub24oXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxvYWQgZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZXZ0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG5cblxuICAgIHZhciBvbGRDYWxsYmFja3MgPSBbXSxcbiAgICAgICAgcmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xuICAgIGpRdWVyeS5hamF4U2V0dXAoIHtcbiAgICAgICAganNvbnA6IFwiY2FsbGJhY2tcIixcbiAgICAgICAganNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcbiAgICAgICAgICAgIHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbiAgICBqUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuICAgICAgICB2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG4gICAgICAgICAgICBqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuICAgICAgICAgICAgICAgICAgICBcInVybFwiIDpcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICAoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG4gICAgICAgIGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG4gICAgICAgICAgICAvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG4gICAgICAgICAgICBjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuICAgICAgICAgICAgICAgIHMuanNvbnBDYWxsYmFjaygpIDpcbiAgICAgICAgICAgICAgICBzLmpzb25wQ2FsbGJhY2s7XG5cbiAgICAgICAgICAgIC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcbiAgICAgICAgICAgIGlmICgganNvblByb3AgKSB7XG4gICAgICAgICAgICAgICAgc1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cbiAgICAgICAgICAgIHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gRm9yY2UganNvbiBkYXRhVHlwZVxuICAgICAgICAgICAgcy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG4gICAgICAgICAgICAvLyBJbnN0YWxsIGNhbGxiYWNrXG4gICAgICAgICAgICBvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG4gICAgICAgICAgICB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcbiAgICAgICAgICAgIGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICBpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBiYWNrIGFzIGZyZWVcbiAgICAgICAgICAgICAgICBpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuICAgICAgICAgICAgICAgICAgICBzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuICAgICAgICAgICAgICAgICAgICBvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgaWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcbiAgICAgICAgICAgIHJldHVybiBcInNjcmlwdFwiO1xuICAgICAgICB9XG4gICAgfSApO1xuXG5cblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG4gICAgalF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcbiAgICAgICAgaWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuICAgICAgICAgICAga2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuICAgICAgICAgICAgY29udGV4dCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG4gICAgICAgIHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcbiAgICAgICAgICAgIHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cbiAgICAgICAgLy8gU2luZ2xlIHRhZ1xuICAgICAgICBpZiAoIHBhcnNlZCApIHtcbiAgICAgICAgICAgIHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuICAgICAgICBpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG4gICAgICAgICAgICBqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xuICAgIH07XG5cblxuLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxuICAgIHZhciBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICAgICAqL1xuICAgIGpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcbiAgICAgICAgaWYgKCB0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiICYmIF9sb2FkICkge1xuICAgICAgICAgICAgcmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG4gICAgICAgIGlmICggb2ZmID4gLTEgKSB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IGpRdWVyeS50cmltKCB1cmwuc2xpY2UoIG9mZiApICk7XG4gICAgICAgICAgICB1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQncyBhIGZ1bmN0aW9uXG4gICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG4gICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcbiAgICAgICAgfSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJQT1NUXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuICAgICAgICBpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgIGpRdWVyeS5hamF4KCB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG5cbiAgICAgICAgICAgICAgICAvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgICAgICAgIC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuICAgICAgICAgICAgICAgIC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zXG4gICAgICAgICAgICB9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuICAgICAgICAgICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5odG1sKCBzZWxlY3RvciA/XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRleHQgKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG4gICAgICAgICAgICB9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG4gICAgalF1ZXJ5LmVhY2goIFtcbiAgICAgICAgXCJhamF4U3RhcnRcIixcbiAgICAgICAgXCJhamF4U3RvcFwiLFxuICAgICAgICBcImFqYXhDb21wbGV0ZVwiLFxuICAgICAgICBcImFqYXhFcnJvclwiLFxuICAgICAgICBcImFqYXhTdWNjZXNzXCIsXG4gICAgICAgIFwiYWpheFNlbmRcIlxuICAgIF0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuICAgICAgICBqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuICAgICAgICB9O1xuICAgIH0gKTtcblxuXG5cblxuICAgIGpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcbiAgICAgICAgfSApLmxlbmd0aDtcbiAgICB9O1xuXG5cblxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/IGVsZW0gOiBlbGVtLm5vZGVUeXBlID09PSA5ICYmIGVsZW0uZGVmYXVsdFZpZXc7XG4gICAgfVxuXG4gICAgalF1ZXJ5Lm9mZnNldCA9IHtcbiAgICAgICAgc2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcbiAgICAgICAgICAgIHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcbiAgICAgICAgICAgICAgICBjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG4gICAgICAgICAgICAgICAgcHJvcHMgPSB7fTtcblxuICAgICAgICAgICAgLy8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuICAgICAgICAgICAgaWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuICAgICAgICAgICAgY3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuICAgICAgICAgICAgY3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG4gICAgICAgICAgICBjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcbiAgICAgICAgICAgICAgICAoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG4gICAgICAgICAgICAvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcbiAgICAgICAgICAgIGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG4gICAgICAgICAgICAgICAgY3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgY3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuICAgICAgICAgICAgICAgIGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG4gICAgICAgICAgICAgICAgY3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgIHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgIHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJFbGVtLmNzcyggcHJvcHMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZG9jRWxlbSwgd2luLFxuICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWyAwIF0sXG4gICAgICAgICAgICAgICAgYm94ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcbiAgICAgICAgICAgICAgICBkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDtcblxuICAgICAgICAgICAgaWYgKCAhZG9jICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJveDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogYm94LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGJveC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICggIXRoaXNbIDAgXSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1sgMCBdLFxuICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cbiAgICAgICAgICAgIC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG4gICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG4gICAgICAgIC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuICAgICAgICAvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG4gICAgICAgIC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcbiAgICAgICAgLy9cbiAgICAgICAgLy8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG4gICAgICAgIC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuICAgICAgICBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbiAgICBqUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG4gICAgICAgIHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cbiAgICAgICAgalF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCB3aW4gKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5zY3JvbGxUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG4gICAgICAgIH07XG4gICAgfSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmk8Ny04KywgQ2hyb21lPDM3LTQ0K1xuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MjgwXG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbiAgICBqUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcbiAgICAgICAgalF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcbiAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG4gICAgalF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuICAgICAgICBqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuICAgICAgICAgICAgICAgIC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuICAgICAgICAgICAgICAgIGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2M7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzbid0IGEgd2hvbGUgbG90IHdlIGNhbiBkby4gU2VlIHB1bGwgcmVxdWVzdCBhdCB0aGlzIFVSTCBmb3IgZGlzY3Vzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzc2NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUsIG51bGwgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSApO1xuICAgIH0gKTtcblxuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cbiAgICAgICAgICAgIC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICAgICB0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbiAgICBpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuICAgICAgICBkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnk7XG4gICAgICAgIH0gKTtcbiAgICB9XG5cblxuXG4gICAgdmFyXG5cbiAgICAgICAgLy8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgICAgIF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG4gICAgICAgIC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgICAgIF8kID0gd2luZG93LiQ7XG5cbiAgICBqUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuICAgICAgICBpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG4gICAgICAgICAgICB3aW5kb3cuJCA9IF8kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcbiAgICAgICAgICAgIHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeTtcbiAgICB9O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuICAgIGlmICggIW5vR2xvYmFsICkge1xuICAgICAgICB3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpRdWVyeTtcbn0pKTsiLCIvKiEgalF1ZXJ5IFVJIC0gdjEuMTIuMSAtIDIwMTgtMDQtMjZcbiogaHR0cDovL2pxdWVyeXVpLmNvbVxuKiBJbmNsdWRlczogd2lkZ2V0LmpzLCBwb3NpdGlvbi5qcywgZGF0YS5qcywgZGlzYWJsZS1zZWxlY3Rpb24uanMsIGZvY3VzYWJsZS5qcywgZm9ybS1yZXNldC1taXhpbi5qcywganF1ZXJ5LTEtNy5qcywga2V5Y29kZS5qcywgbGFiZWxzLmpzLCBzY3JvbGwtcGFyZW50LmpzLCB0YWJiYWJsZS5qcywgdW5pcXVlLWlkLmpzXG4qIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzOyBMaWNlbnNlZCBNSVQgKi9cblxuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbIFwianF1ZXJ5XCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQgKSB7XG5cbiQudWkgPSAkLnVpIHx8IHt9O1xuXG52YXIgdmVyc2lvbiA9ICQudWkudmVyc2lvbiA9IFwiMS4xMi4xXCI7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgV2lkZ2V0IDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBXaWRnZXRcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBQcm92aWRlcyBhIGZhY3RvcnkgZm9yIGNyZWF0aW5nIHN0YXRlZnVsIHdpZGdldHMgd2l0aCBhIGNvbW1vbiBBUEkuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LndpZGdldC9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS93aWRnZXQvXG5cblxuXG52YXIgd2lkZ2V0VXVpZCA9IDA7XG52YXIgd2lkZ2V0U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiQuY2xlYW5EYXRhID0gKCBmdW5jdGlvbiggb3JpZyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZXZlbnRzLCBlbGVtLCBpO1xuXHRcdGZvciAoIGkgPSAwOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHQvLyBPbmx5IHRyaWdnZXIgcmVtb3ZlIHdoZW4gbmVjZXNzYXJ5IHRvIHNhdmUgdGltZVxuXHRcdFx0XHRldmVudHMgPSAkLl9kYXRhKCBlbGVtLCBcImV2ZW50c1wiICk7XG5cdFx0XHRcdGlmICggZXZlbnRzICYmIGV2ZW50cy5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0JCggZWxlbSApLnRyaWdnZXJIYW5kbGVyKCBcInJlbW92ZVwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODIzNVxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdH1cblx0XHRvcmlnKCBlbGVtcyApO1xuXHR9O1xufSApKCAkLmNsZWFuRGF0YSApO1xuXG4kLndpZGdldCA9IGZ1bmN0aW9uKCBuYW1lLCBiYXNlLCBwcm90b3R5cGUgKSB7XG5cdHZhciBleGlzdGluZ0NvbnN0cnVjdG9yLCBjb25zdHJ1Y3RvciwgYmFzZVByb3RvdHlwZTtcblxuXHQvLyBQcm94aWVkUHJvdG90eXBlIGFsbG93cyB0aGUgcHJvdmlkZWQgcHJvdG90eXBlIHRvIHJlbWFpbiB1bm1vZGlmaWVkXG5cdC8vIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgYSBtaXhpbiBmb3IgbXVsdGlwbGUgd2lkZ2V0cyAoIzg4NzYpXG5cdHZhciBwcm94aWVkUHJvdG90eXBlID0ge307XG5cblx0dmFyIG5hbWVzcGFjZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDAgXTtcblx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDEgXTtcblx0dmFyIGZ1bGxOYW1lID0gbmFtZXNwYWNlICsgXCItXCIgKyBuYW1lO1xuXG5cdGlmICggIXByb3RvdHlwZSApIHtcblx0XHRwcm90b3R5cGUgPSBiYXNlO1xuXHRcdGJhc2UgPSAkLldpZGdldDtcblx0fVxuXG5cdGlmICggJC5pc0FycmF5KCBwcm90b3R5cGUgKSApIHtcblx0XHRwcm90b3R5cGUgPSAkLmV4dGVuZC5hcHBseSggbnVsbCwgWyB7fSBdLmNvbmNhdCggcHJvdG90eXBlICkgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBzZWxlY3RvciBmb3IgcGx1Z2luXG5cdCQuZXhwclsgXCI6XCIgXVsgZnVsbE5hbWUudG9Mb3dlckNhc2UoKSBdID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBmdWxsTmFtZSApO1xuXHR9O1xuXG5cdCRbIG5hbWVzcGFjZSBdID0gJFsgbmFtZXNwYWNlIF0gfHwge307XG5cdGV4aXN0aW5nQ29uc3RydWN0b3IgPSAkWyBuYW1lc3BhY2UgXVsgbmFtZSBdO1xuXHRjb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF0gPSBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblxuXHRcdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBcIm5ld1wiIGtleXdvcmRcblx0XHRpZiAoICF0aGlzLl9jcmVhdGVXaWRnZXQgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGNvbnN0cnVjdG9yKCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IGluaXRpYWxpemluZyBmb3Igc2ltcGxlIGluaGVyaXRhbmNlXG5cdFx0Ly8gbXVzdCB1c2UgXCJuZXdcIiBrZXl3b3JkICh0aGUgY29kZSBhYm92ZSBhbHdheXMgcGFzc2VzIGFyZ3MpXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fY3JlYXRlV2lkZ2V0KCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEV4dGVuZCB3aXRoIHRoZSBleGlzdGluZyBjb25zdHJ1Y3RvciB0byBjYXJyeSBvdmVyIGFueSBzdGF0aWMgcHJvcGVydGllc1xuXHQkLmV4dGVuZCggY29uc3RydWN0b3IsIGV4aXN0aW5nQ29uc3RydWN0b3IsIHtcblx0XHR2ZXJzaW9uOiBwcm90b3R5cGUudmVyc2lvbixcblxuXHRcdC8vIENvcHkgdGhlIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGUgcHJvdG90eXBlIGluIGNhc2Ugd2UgbmVlZCB0b1xuXHRcdC8vIHJlZGVmaW5lIHRoZSB3aWRnZXQgbGF0ZXJcblx0XHRfcHJvdG86ICQuZXh0ZW5kKCB7fSwgcHJvdG90eXBlICksXG5cblx0XHQvLyBUcmFjayB3aWRnZXRzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgd2lkZ2V0IGluIGNhc2UgdGhpcyB3aWRnZXQgaXNcblx0XHQvLyByZWRlZmluZWQgYWZ0ZXIgYSB3aWRnZXQgaW5oZXJpdHMgZnJvbSBpdFxuXHRcdF9jaGlsZENvbnN0cnVjdG9yczogW11cblx0fSApO1xuXG5cdGJhc2VQcm90b3R5cGUgPSBuZXcgYmFzZSgpO1xuXG5cdC8vIFdlIG5lZWQgdG8gbWFrZSB0aGUgb3B0aW9ucyBoYXNoIGEgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5ldyBpbnN0YW5jZVxuXHQvLyBvdGhlcndpc2Ugd2UnbGwgbW9kaWZ5IHRoZSBvcHRpb25zIGhhc2ggb24gdGhlIHByb3RvdHlwZSB0aGF0IHdlJ3JlXG5cdC8vIGluaGVyaXRpbmcgZnJvbVxuXHRiYXNlUHJvdG90eXBlLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LCBiYXNlUHJvdG90eXBlLm9wdGlvbnMgKTtcblx0JC5lYWNoKCBwcm90b3R5cGUsIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRpZiAoICEkLmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gKCBmdW5jdGlvbigpIHtcblx0XHRcdGZ1bmN0aW9uIF9zdXBlcigpIHtcblx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBfc3VwZXJBcHBseSggYXJncyApIHtcblx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX19zdXBlciA9IHRoaXMuX3N1cGVyO1xuXHRcdFx0XHR2YXIgX19zdXBlckFwcGx5ID0gdGhpcy5fc3VwZXJBcHBseTtcblx0XHRcdFx0dmFyIHJldHVyblZhbHVlO1xuXG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB2YWx1ZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX19zdXBlckFwcGx5O1xuXG5cdFx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHRcdH07XG5cdFx0fSApKCk7XG5cdH0gKTtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gJC53aWRnZXQuZXh0ZW5kKCBiYXNlUHJvdG90eXBlLCB7XG5cblx0XHQvLyBUT0RPOiByZW1vdmUgc3VwcG9ydCBmb3Igd2lkZ2V0RXZlbnRQcmVmaXhcblx0XHQvLyBhbHdheXMgdXNlIHRoZSBuYW1lICsgYSBjb2xvbiBhcyB0aGUgcHJlZml4LCBlLmcuLCBkcmFnZ2FibGU6c3RhcnRcblx0XHQvLyBkb24ndCBwcmVmaXggZm9yIHdpZGdldHMgdGhhdCBhcmVuJ3QgRE9NLWJhc2VkXG5cdFx0d2lkZ2V0RXZlbnRQcmVmaXg6IGV4aXN0aW5nQ29uc3RydWN0b3IgPyAoIGJhc2VQcm90b3R5cGUud2lkZ2V0RXZlbnRQcmVmaXggfHwgbmFtZSApIDogbmFtZVxuXHR9LCBwcm94aWVkUHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuXHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuXHRcdHdpZGdldE5hbWU6IG5hbWUsXG5cdFx0d2lkZ2V0RnVsbE5hbWU6IGZ1bGxOYW1lXG5cdH0gKTtcblxuXHQvLyBJZiB0aGlzIHdpZGdldCBpcyBiZWluZyByZWRlZmluZWQgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgYWxsIHdpZGdldHMgdGhhdFxuXHQvLyBhcmUgaW5oZXJpdGluZyBmcm9tIGl0IGFuZCByZWRlZmluZSBhbGwgb2YgdGhlbSBzbyB0aGF0IHRoZXkgaW5oZXJpdCBmcm9tXG5cdC8vIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGlzIHdpZGdldC4gV2UncmUgZXNzZW50aWFsbHkgdHJ5aW5nIHRvIHJlcGxhY2Ugb25lXG5cdC8vIGxldmVsIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5cdGlmICggZXhpc3RpbmdDb25zdHJ1Y3RvciApIHtcblx0XHQkLmVhY2goIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzLCBmdW5jdGlvbiggaSwgY2hpbGQgKSB7XG5cdFx0XHR2YXIgY2hpbGRQcm90b3R5cGUgPSBjaGlsZC5wcm90b3R5cGU7XG5cblx0XHRcdC8vIFJlZGVmaW5lIHRoZSBjaGlsZCB3aWRnZXQgdXNpbmcgdGhlIHNhbWUgcHJvdG90eXBlIHRoYXQgd2FzXG5cdFx0XHQvLyBvcmlnaW5hbGx5IHVzZWQsIGJ1dCBpbmhlcml0IGZyb20gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBiYXNlXG5cdFx0XHQkLndpZGdldCggY2hpbGRQcm90b3R5cGUubmFtZXNwYWNlICsgXCIuXCIgKyBjaGlsZFByb3RvdHlwZS53aWRnZXROYW1lLCBjb25zdHJ1Y3Rvcixcblx0XHRcdFx0Y2hpbGQuX3Byb3RvICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBsaXN0IG9mIGV4aXN0aW5nIGNoaWxkIGNvbnN0cnVjdG9ycyBmcm9tIHRoZSBvbGQgY29uc3RydWN0b3Jcblx0XHQvLyBzbyB0aGUgb2xkIGNoaWxkIGNvbnN0cnVjdG9ycyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcblx0XHRkZWxldGUgZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnM7XG5cdH0gZWxzZSB7XG5cdFx0YmFzZS5fY2hpbGRDb25zdHJ1Y3RvcnMucHVzaCggY29uc3RydWN0b3IgKTtcblx0fVxuXG5cdCQud2lkZ2V0LmJyaWRnZSggbmFtZSwgY29uc3RydWN0b3IgKTtcblxuXHRyZXR1cm4gY29uc3RydWN0b3I7XG59O1xuXG4kLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHR2YXIgaW5wdXQgPSB3aWRnZXRTbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0dmFyIGlucHV0SW5kZXggPSAwO1xuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdHZhciBrZXk7XG5cdHZhciB2YWx1ZTtcblxuXHRmb3IgKCA7IGlucHV0SW5kZXggPCBpbnB1dExlbmd0aDsgaW5wdXRJbmRleCsrICkge1xuXHRcdGZvciAoIGtleSBpbiBpbnB1dFsgaW5wdXRJbmRleCBdICkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dFsgaW5wdXRJbmRleCBdWyBrZXkgXTtcblx0XHRcdGlmICggaW5wdXRbIGlucHV0SW5kZXggXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBDbG9uZSBvYmplY3RzXG5cdFx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSAkLmlzUGxhaW5PYmplY3QoIHRhcmdldFsga2V5IF0gKSA/XG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB0YXJnZXRbIGtleSBdLCB2YWx1ZSApIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgZXh0ZW5kIHN0cmluZ3MsIGFycmF5cywgZXRjLiB3aXRoIG9iamVjdHNcblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHZhbHVlICk7XG5cblx0XHRcdFx0Ly8gQ29weSBldmVyeXRoaW5nIGVsc2UgYnkgcmVmZXJlbmNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4kLndpZGdldC5icmlkZ2UgPSBmdW5jdGlvbiggbmFtZSwgb2JqZWN0ICkge1xuXHR2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XG5cdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBpc01ldGhvZENhbGwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIjtcblx0XHR2YXIgYXJncyA9IHdpZGdldFNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdHZhciByZXR1cm5WYWx1ZSA9IHRoaXM7XG5cblx0XHRpZiAoIGlzTWV0aG9kQ2FsbCApIHtcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBlbXB0eSBjb2xsZWN0aW9uLCB3ZSBuZWVkIHRvIGhhdmUgdGhlIGluc3RhbmNlIG1ldGhvZFxuXHRcdFx0Ly8gcmV0dXJuIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHRoZSBqUXVlcnkgaW5zdGFuY2Vcblx0XHRcdGlmICggIXRoaXMubGVuZ3RoICYmIG9wdGlvbnMgPT09IFwiaW5zdGFuY2VcIiApIHtcblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMgPT09IFwiaW5zdGFuY2VcIiApIHtcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlID0gaW5zdGFuY2U7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJjYW5ub3QgY2FsbCBtZXRob2RzIG9uIFwiICsgbmFtZSArXG5cdFx0XHRcdFx0XHRcdFwiIHByaW9yIHRvIGluaXRpYWxpemF0aW9uOyBcIiArXG5cdFx0XHRcdFx0XHRcdFwiYXR0ZW1wdGVkIHRvIGNhbGwgbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIidcIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggISQuaXNGdW5jdGlvbiggaW5zdGFuY2VbIG9wdGlvbnMgXSApIHx8IG9wdGlvbnMuY2hhckF0KCAwICkgPT09IFwiX1wiICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwibm8gc3VjaCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJyBmb3IgXCIgKyBuYW1lICtcblx0XHRcdFx0XHRcdFx0XCIgd2lkZ2V0IGluc3RhbmNlXCIgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtZXRob2RWYWx1ZSA9IGluc3RhbmNlWyBvcHRpb25zIF0uYXBwbHkoIGluc3RhbmNlLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1ldGhvZFZhbHVlICE9PSBpbnN0YW5jZSAmJiBtZXRob2RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBtZXRob2RWYWx1ZSAmJiBtZXRob2RWYWx1ZS5qcXVlcnkgP1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZS5wdXNoU3RhY2soIG1ldGhvZFZhbHVlLmdldCgpICkgOlxuXHRcdFx0XHRcdFx0XHRtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBbGxvdyBtdWx0aXBsZSBoYXNoZXMgdG8gYmUgcGFzc2VkIG9uIGluaXRcblx0XHRcdGlmICggYXJncy5sZW5ndGggKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQuYXBwbHkoIG51bGwsIFsgb3B0aW9ucyBdLmNvbmNhdCggYXJncyApICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRpbnN0YW5jZS5vcHRpb24oIG9wdGlvbnMgfHwge30gKTtcblx0XHRcdFx0XHRpZiAoIGluc3RhbmNlLl9pbml0ICkge1xuXHRcdFx0XHRcdFx0aW5zdGFuY2UuX2luaXQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRhKCB0aGlzLCBmdWxsTmFtZSwgbmV3IG9iamVjdCggb3B0aW9ucywgdGhpcyApICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG59O1xuXG4kLldpZGdldCA9IGZ1bmN0aW9uKCAvKiBvcHRpb25zLCBlbGVtZW50ICovICkge307XG4kLldpZGdldC5fY2hpbGRDb25zdHJ1Y3RvcnMgPSBbXTtcblxuJC5XaWRnZXQucHJvdG90eXBlID0ge1xuXHR3aWRnZXROYW1lOiBcIndpZGdldFwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGRpdj5cIixcblxuXHRvcHRpb25zOiB7XG5cdFx0Y2xhc3Nlczoge30sXG5cdFx0ZGlzYWJsZWQ6IGZhbHNlLFxuXG5cdFx0Ly8gQ2FsbGJhY2tzXG5cdFx0Y3JlYXRlOiBudWxsXG5cdH0sXG5cblx0X2NyZWF0ZVdpZGdldDogZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0ZWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgdGhpcy5kZWZhdWx0RWxlbWVudCB8fCB0aGlzIClbIDAgXTtcblx0XHR0aGlzLmVsZW1lbnQgPSAkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy51dWlkID0gd2lkZ2V0VXVpZCsrO1xuXHRcdHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZDtcblxuXHRcdHRoaXMuYmluZGluZ3MgPSAkKCk7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCk7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSAkKCk7XG5cdFx0dGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cCA9IHt9O1xuXG5cdFx0aWYgKCBlbGVtZW50ICE9PSB0aGlzICkge1xuXHRcdFx0JC5kYXRhKCBlbGVtZW50LCB0aGlzLndpZGdldEZ1bGxOYW1lLCB0aGlzICk7XG5cdFx0XHR0aGlzLl9vbiggdHJ1ZSwgdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLmRvY3VtZW50ID0gJCggZWxlbWVudC5zdHlsZSA/XG5cblx0XHRcdFx0Ly8gRWxlbWVudCB3aXRoaW4gdGhlIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQub3duZXJEb2N1bWVudCA6XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyB3aW5kb3cgb3IgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5kb2N1bWVudCB8fCBlbGVtZW50ICk7XG5cdFx0XHR0aGlzLndpbmRvdyA9ICQoIHRoaXMuZG9jdW1lbnRbIDAgXS5kZWZhdWx0VmlldyB8fCB0aGlzLmRvY3VtZW50WyAwIF0ucGFyZW50V2luZG93ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vcHRpb25zID0gJC53aWRnZXQuZXh0ZW5kKCB7fSxcblx0XHRcdHRoaXMub3B0aW9ucyxcblx0XHRcdHRoaXMuX2dldENyZWF0ZU9wdGlvbnMoKSxcblx0XHRcdG9wdGlvbnMgKTtcblxuXHRcdHRoaXMuX2NyZWF0ZSgpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25EaXNhYmxlZCggdGhpcy5vcHRpb25zLmRpc2FibGVkICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJjcmVhdGVcIiwgbnVsbCwgdGhpcy5fZ2V0Q3JlYXRlRXZlbnREYXRhKCkgKTtcblx0XHR0aGlzLl9pbml0KCk7XG5cdH0sXG5cblx0X2dldENyZWF0ZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7fTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiAkLm5vb3AsXG5cblx0X2NyZWF0ZTogJC5ub29wLFxuXG5cdF9pbml0OiAkLm5vb3AsXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5fZGVzdHJveSgpO1xuXHRcdCQuZWFjaCggdGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cCwgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHR0aGF0Ll9yZW1vdmVDbGFzcyggdmFsdWUsIGtleSApO1xuXHRcdH0gKTtcblxuXHRcdC8vIFdlIGNhbiBwcm9iYWJseSByZW1vdmUgdGhlIHVuYmluZCBjYWxscyBpbiAyLjBcblx0XHQvLyBhbGwgZXZlbnQgYmluZGluZ3Mgc2hvdWxkIGdvIHRocm91Z2ggdGhpcy5fb24oKVxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0Lm9mZiggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXRGdWxsTmFtZSApO1xuXHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdC5vZmYoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiICk7XG5cblx0XHQvLyBDbGVhbiB1cCBldmVudHMgYW5kIHN0YXRlc1xuXHRcdHRoaXMuYmluZGluZ3Mub2ZmKCB0aGlzLmV2ZW50TmFtZXNwYWNlICk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6ICQubm9vcCxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XG5cdH0sXG5cblx0b3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgb3B0aW9ucyA9IGtleTtcblx0XHR2YXIgcGFydHM7XG5cdFx0dmFyIGN1ck9wdGlvbjtcblx0XHR2YXIgaTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBoYXNoXG5cdFx0XHRyZXR1cm4gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyBIYW5kbGUgbmVzdGVkIGtleXMsIGUuZy4sIFwiZm9vLmJhclwiID0+IHsgZm9vOiB7IGJhcjogX19fIH0gfVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0cGFydHMgPSBrZXkuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHRrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0aWYgKCBwYXJ0cy5sZW5ndGggKSB7XG5cdFx0XHRcdGN1ck9wdGlvbiA9IG9wdGlvbnNbIGtleSBdID0gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zWyBrZXkgXSApO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKyApIHtcblx0XHRcdFx0XHRjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdIHx8IHt9O1xuXHRcdFx0XHRcdGN1ck9wdGlvbiA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleSA9IHBhcnRzLnBvcCgpO1xuXHRcdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGN1ck9wdGlvblsga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdXJPcHRpb25bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN1ck9wdGlvblsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHRoaXMub3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zZXRPcHRpb25zKCBvcHRpb25zICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdGZvciAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uKCBrZXksIG9wdGlvbnNbIGtleSBdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiY2xhc3Nlc1wiICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uQ2xhc3NlcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uRGlzYWJsZWQoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NldE9wdGlvbkNsYXNzZXM6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NLZXksIGVsZW1lbnRzLCBjdXJyZW50RWxlbWVudHM7XG5cblx0XHRmb3IgKCBjbGFzc0tleSBpbiB2YWx1ZSApIHtcblx0XHRcdGN1cnJlbnRFbGVtZW50cyA9IHRoaXMuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzS2V5IF07XG5cdFx0XHRpZiAoIHZhbHVlWyBjbGFzc0tleSBdID09PSB0aGlzLm9wdGlvbnMuY2xhc3Nlc1sgY2xhc3NLZXkgXSB8fFxuXHRcdFx0XHRcdCFjdXJyZW50RWxlbWVudHMgfHxcblx0XHRcdFx0XHQhY3VycmVudEVsZW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlIGFyZSBkb2luZyB0aGlzIHRvIGNyZWF0ZSBhIG5ldyBqUXVlcnkgb2JqZWN0IGJlY2F1c2UgdGhlIF9yZW1vdmVDbGFzcygpIGNhbGxcblx0XHRcdC8vIG9uIHRoZSBuZXh0IGxpbmUgaXMgZ29pbmcgdG8gZGVzdHJveSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGVsZW1lbnRzIGJlaW5nXG5cdFx0XHQvLyB0cmFja2VkLiBXZSBuZWVkIHRvIHNhdmUgYSBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbiBzbyB0aGF0IHdlIGNhbiBhZGQgdGhlIG5ldyBjbGFzc2VzXG5cdFx0XHQvLyBiZWxvdy5cblx0XHRcdGVsZW1lbnRzID0gJCggY3VycmVudEVsZW1lbnRzLmdldCgpICk7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggY3VycmVudEVsZW1lbnRzLCBjbGFzc0tleSApO1xuXG5cdFx0XHQvLyBXZSBkb24ndCB1c2UgX2FkZENsYXNzKCkgaGVyZSwgYmVjYXVzZSB0aGF0IHVzZXMgdGhpcy5vcHRpb25zLmNsYXNzZXNcblx0XHRcdC8vIGZvciBnZW5lcmF0aW5nIHRoZSBzdHJpbmcgb2YgY2xhc3Nlcy4gV2Ugd2FudCB0byB1c2UgdGhlIHZhbHVlIHBhc3NlZCBpbiBmcm9tXG5cdFx0XHQvLyBfc2V0T3B0aW9uKCksIHRoaXMgaXMgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgY2xhc3NlcyBvcHRpb24gd2hpY2ggd2FzIHBhc3NlZCB0b1xuXHRcdFx0Ly8gX3NldE9wdGlvbigpLiBXZSBwYXNzIHRoaXMgdmFsdWUgZGlyZWN0bHkgdG8gX2NsYXNzZXMoKS5cblx0XHRcdGVsZW1lbnRzLmFkZENsYXNzKCB0aGlzLl9jbGFzc2VzKCB7XG5cdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnRzLFxuXHRcdFx0XHRrZXlzOiBjbGFzc0tleSxcblx0XHRcdFx0Y2xhc3NlczogdmFsdWUsXG5cdFx0XHRcdGFkZDogdHJ1ZVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb25EaXNhYmxlZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHRoaXMuX3RvZ2dsZUNsYXNzKCB0aGlzLndpZGdldCgpLCB0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWRcIiwgbnVsbCwgISF2YWx1ZSApO1xuXG5cdFx0Ly8gSWYgdGhlIHdpZGdldCBpcyBiZWNvbWluZyBkaXNhYmxlZCwgdGhlbiBub3RoaW5nIGlzIGludGVyYWN0aXZlXG5cdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmhvdmVyYWJsZSwgbnVsbCwgXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5mb2N1c2FibGUsIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb25zKCB7IGRpc2FibGVkOiBmYWxzZSB9ICk7XG5cdH0sXG5cblx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoIHsgZGlzYWJsZWQ6IHRydWUgfSApO1xuXHR9LFxuXG5cdF9jbGFzc2VzOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIgZnVsbCA9IFtdO1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCgge1xuXHRcdFx0ZWxlbWVudDogdGhpcy5lbGVtZW50LFxuXHRcdFx0Y2xhc3NlczogdGhpcy5vcHRpb25zLmNsYXNzZXMgfHwge31cblx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzQ2xhc3NTdHJpbmcoIGNsYXNzZXMsIGNoZWNrT3B0aW9uICkge1xuXHRcdFx0dmFyIGN1cnJlbnQsIGk7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSB0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBjbGFzc2VzWyBpIF0gXSB8fCAkKCk7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5hZGQgKSB7XG5cdFx0XHRcdFx0Y3VycmVudCA9ICQoICQudW5pcXVlKCBjdXJyZW50LmdldCgpLmNvbmNhdCggb3B0aW9ucy5lbGVtZW50LmdldCgpICkgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1cnJlbnQgPSAkKCBjdXJyZW50Lm5vdCggb3B0aW9ucy5lbGVtZW50ICkuZ2V0KCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBjbGFzc2VzWyBpIF0gXSA9IGN1cnJlbnQ7XG5cdFx0XHRcdGZ1bGwucHVzaCggY2xhc3Nlc1sgaSBdICk7XG5cdFx0XHRcdGlmICggY2hlY2tPcHRpb24gJiYgb3B0aW9ucy5jbGFzc2VzWyBjbGFzc2VzWyBpIF0gXSApIHtcblx0XHRcdFx0XHRmdWxsLnB1c2goIG9wdGlvbnMuY2xhc3Nlc1sgY2xhc3Nlc1sgaSBdIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX29uKCBvcHRpb25zLmVsZW1lbnQsIHtcblx0XHRcdFwicmVtb3ZlXCI6IFwiX3VudHJhY2tDbGFzc2VzRWxlbWVudFwiXG5cdFx0fSApO1xuXG5cdFx0aWYgKCBvcHRpb25zLmtleXMgKSB7XG5cdFx0XHRwcm9jZXNzQ2xhc3NTdHJpbmcoIG9wdGlvbnMua2V5cy5tYXRjaCggL1xcUysvZyApIHx8IFtdLCB0cnVlICk7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5leHRyYSApIHtcblx0XHRcdHByb2Nlc3NDbGFzc1N0cmluZyggb3B0aW9ucy5leHRyYS5tYXRjaCggL1xcUysvZyApIHx8IFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bGwuam9pbiggXCIgXCIgKTtcblx0fSxcblxuXHRfdW50cmFja0NsYXNzZXNFbGVtZW50OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdCQuZWFjaCggdGhhdC5jbGFzc2VzRWxlbWVudExvb2t1cCwgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoICQuaW5BcnJheSggZXZlbnQudGFyZ2V0LCB2YWx1ZSApICE9PSAtMSApIHtcblx0XHRcdFx0dGhhdC5jbGFzc2VzRWxlbWVudExvb2t1cFsga2V5IF0gPSAkKCB2YWx1ZS5ub3QoIGV2ZW50LnRhcmdldCApLmdldCgpICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9yZW1vdmVDbGFzczogZnVuY3Rpb24oIGVsZW1lbnQsIGtleXMsIGV4dHJhICkge1xuXHRcdHJldHVybiB0aGlzLl90b2dnbGVDbGFzcyggZWxlbWVudCwga2V5cywgZXh0cmEsIGZhbHNlICk7XG5cdH0sXG5cblx0X2FkZENsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RvZ2dsZUNsYXNzKCBlbGVtZW50LCBrZXlzLCBleHRyYSwgdHJ1ZSApO1xuXHR9LFxuXG5cdF90b2dnbGVDbGFzczogZnVuY3Rpb24oIGVsZW1lbnQsIGtleXMsIGV4dHJhLCBhZGQgKSB7XG5cdFx0YWRkID0gKCB0eXBlb2YgYWRkID09PSBcImJvb2xlYW5cIiApID8gYWRkIDogZXh0cmE7XG5cdFx0dmFyIHNoaWZ0ID0gKCB0eXBlb2YgZWxlbWVudCA9PT0gXCJzdHJpbmdcIiB8fCBlbGVtZW50ID09PSBudWxsICksXG5cdFx0XHRvcHRpb25zID0ge1xuXHRcdFx0XHRleHRyYTogc2hpZnQgPyBrZXlzIDogZXh0cmEsXG5cdFx0XHRcdGtleXM6IHNoaWZ0ID8gZWxlbWVudCA6IGtleXMsXG5cdFx0XHRcdGVsZW1lbnQ6IHNoaWZ0ID8gdGhpcy5lbGVtZW50IDogZWxlbWVudCxcblx0XHRcdFx0YWRkOiBhZGRcblx0XHRcdH07XG5cdFx0b3B0aW9ucy5lbGVtZW50LnRvZ2dsZUNsYXNzKCB0aGlzLl9jbGFzc2VzKCBvcHRpb25zICksIGFkZCApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9vbjogZnVuY3Rpb24oIHN1cHByZXNzRGlzYWJsZWRDaGVjaywgZWxlbWVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGRlbGVnYXRlRWxlbWVudDtcblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0Ly8gTm8gc3VwcHJlc3NEaXNhYmxlZENoZWNrIGZsYWcsIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0aWYgKCB0eXBlb2Ygc3VwcHJlc3NEaXNhYmxlZENoZWNrICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSBzdXBwcmVzc0Rpc2FibGVkQ2hlY2s7XG5cdFx0XHRzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBObyBlbGVtZW50IGFyZ3VtZW50LCBzaHVmZmxlIGFuZCB1c2UgdGhpcy5lbGVtZW50XG5cdFx0aWYgKCAhaGFuZGxlcnMgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0ZGVsZWdhdGVFbGVtZW50ID0gdGhpcy53aWRnZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudCA9IGRlbGVnYXRlRWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHRcdHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmFkZCggZWxlbWVudCApO1xuXHRcdH1cblxuXHRcdCQuZWFjaCggaGFuZGxlcnMsIGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlciApIHtcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblxuXHRcdFx0XHQvLyBBbGxvdyB3aWRnZXRzIHRvIGN1c3RvbWl6ZSB0aGUgZGlzYWJsZWQgaGFuZGxpbmdcblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBjbGFzcyBhcyBtZXRob2QgZm9yIGRpc2FibGluZyBpbmRpdmlkdWFsIHBhcnRzXG5cdFx0XHRcdGlmICggIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJlxuXHRcdFx0XHRcdFx0KCBpbnN0YW5jZS5vcHRpb25zLmRpc2FibGVkID09PSB0cnVlIHx8XG5cdFx0XHRcdFx0XHQkKCB0aGlzICkuaGFzQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb3B5IHRoZSBndWlkIHNvIGRpcmVjdCB1bmJpbmRpbmcgd29ya3Ncblx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGhhbmRsZXJQcm94eS5ndWlkID0gaGFuZGxlci5ndWlkID1cblx0XHRcdFx0XHRoYW5kbGVyLmd1aWQgfHwgaGFuZGxlclByb3h5Lmd1aWQgfHwgJC5ndWlkKys7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXRjaCA9IGV2ZW50Lm1hdGNoKCAvXihbXFx3Oi1dKilcXHMqKC4qKSQvICk7XG5cdFx0XHR2YXIgZXZlbnROYW1lID0gbWF0Y2hbIDEgXSArIGluc3RhbmNlLmV2ZW50TmFtZXNwYWNlO1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gbWF0Y2hbIDIgXTtcblxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0ZGVsZWdhdGVFbGVtZW50Lm9uKCBldmVudE5hbWUsIHNlbGVjdG9yLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQub24oIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9vZmY6IGZ1bmN0aW9uKCBlbGVtZW50LCBldmVudE5hbWUgKSB7XG5cdFx0ZXZlbnROYW1lID0gKCBldmVudE5hbWUgfHwgXCJcIiApLnNwbGl0KCBcIiBcIiApLmpvaW4oIHRoaXMuZXZlbnROYW1lc3BhY2UgKyBcIiBcIiApICtcblx0XHRcdHRoaXMuZXZlbnROYW1lc3BhY2U7XG5cdFx0ZWxlbWVudC5vZmYoIGV2ZW50TmFtZSApLm9mZiggZXZlbnROYW1lICk7XG5cblx0XHQvLyBDbGVhciB0aGUgc3RhY2sgdG8gYXZvaWQgbWVtb3J5IGxlYWtzICgjMTAwNTYpXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoIHRoaXMuYmluZGluZ3Mubm90KCBlbGVtZW50ICkuZ2V0KCkgKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoIHRoaXMuZm9jdXNhYmxlLm5vdCggZWxlbWVudCApLmdldCgpICk7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCB0aGlzLmhvdmVyYWJsZS5ub3QoIGVsZW1lbnQgKS5nZXQoKSApO1xuXHR9LFxuXG5cdF9kZWxheTogZnVuY3Rpb24oIGhhbmRsZXIsIGRlbGF5ICkge1xuXHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHQuYXBwbHkoIGluc3RhbmNlLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdFx0dmFyIGluc3RhbmNlID0gdGhpcztcblx0XHRyZXR1cm4gc2V0VGltZW91dCggaGFuZGxlclByb3h5LCBkZWxheSB8fCAwICk7XG5cdH0sXG5cblx0X2hvdmVyYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSB0aGlzLmhvdmVyYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0bW91c2VlbnRlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggJCggZXZlbnQuY3VycmVudFRhcmdldCApLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfZm9jdXNhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmZvY3VzYWJsZSA9IHRoaXMuZm9jdXNhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRmb2N1c2luOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3Vzb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBkYXRhICkge1xuXHRcdHZhciBwcm9wLCBvcmlnO1xuXHRcdHZhciBjYWxsYmFjayA9IHRoaXMub3B0aW9uc1sgdHlwZSBdO1xuXG5cdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0ZXZlbnQgPSAkLkV2ZW50KCBldmVudCApO1xuXHRcdGV2ZW50LnR5cGUgPSAoIHR5cGUgPT09IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggP1xuXHRcdFx0dHlwZSA6XG5cdFx0XHR0aGlzLndpZGdldEV2ZW50UHJlZml4ICsgdHlwZSApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHQvLyBUaGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WyAwIF07XG5cblx0XHQvLyBDb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdFx0b3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCBvcmlnICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRpZiAoICEoIHByb3AgaW4gZXZlbnQgKSApIHtcblx0XHRcdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhICk7XG5cdFx0cmV0dXJuICEoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSAmJlxuXHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMuZWxlbWVudFsgMCBdLCBbIGV2ZW50IF0uY29uY2F0KCBkYXRhICkgKSA9PT0gZmFsc2UgfHxcblx0XHRcdGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICk7XG5cdH1cbn07XG5cbiQuZWFjaCggeyBzaG93OiBcImZhZGVJblwiLCBoaWRlOiBcImZhZGVPdXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBkZWZhdWx0RWZmZWN0ICkge1xuXHQkLldpZGdldC5wcm90b3R5cGVbIFwiX1wiICsgbWV0aG9kIF0gPSBmdW5jdGlvbiggZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGVmZmVjdDogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdHZhciBoYXNPcHRpb25zO1xuXHRcdHZhciBlZmZlY3ROYW1lID0gIW9wdGlvbnMgP1xuXHRcdFx0bWV0aG9kIDpcblx0XHRcdG9wdGlvbnMgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0XHRkZWZhdWx0RWZmZWN0IDpcblx0XHRcdFx0b3B0aW9ucy5lZmZlY3QgfHwgZGVmYXVsdEVmZmVjdDtcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdGhhc09wdGlvbnMgPSAhJC5pc0VtcHR5T2JqZWN0KCBvcHRpb25zICk7XG5cdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNhbGxiYWNrO1xuXG5cdFx0aWYgKCBvcHRpb25zLmRlbGF5ICkge1xuXHRcdFx0ZWxlbWVudC5kZWxheSggb3B0aW9ucy5kZWxheSApO1xuXHRcdH1cblxuXHRcdGlmICggaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgbWV0aG9kIF0oIG9wdGlvbnMgKTtcblx0XHR9IGVsc2UgaWYgKCBlZmZlY3ROYW1lICE9PSBtZXRob2QgJiYgZWxlbWVudFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgZWZmZWN0TmFtZSBdKCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC5xdWV1ZSggZnVuY3Rpb24oIG5leHQgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKVsgbWV0aG9kIF0oKTtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCBlbGVtZW50WyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXh0KCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG52YXIgd2lkZ2V0ID0gJC53aWRnZXQ7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgUG9zaXRpb24gMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9wb3NpdGlvbi9cbiAqL1xuXG4vLz4+bGFiZWw6IFBvc2l0aW9uXG4vLz4+Z3JvdXA6IENvcmVcbi8vPj5kZXNjcmlwdGlvbjogUG9zaXRpb25zIGVsZW1lbnRzIHJlbGF0aXZlIHRvIG90aGVyIGVsZW1lbnRzLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3Bvc2l0aW9uL1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3Bvc2l0aW9uL1xuXG5cbiggZnVuY3Rpb24oKSB7XG52YXIgY2FjaGVkU2Nyb2xsYmFyV2lkdGgsXG5cdG1heCA9IE1hdGgubWF4LFxuXHRhYnMgPSBNYXRoLmFicyxcblx0cmhvcml6b250YWwgPSAvbGVmdHxjZW50ZXJ8cmlnaHQvLFxuXHRydmVydGljYWwgPSAvdG9wfGNlbnRlcnxib3R0b20vLFxuXHRyb2Zmc2V0ID0gL1tcXCtcXC1dXFxkKyhcXC5bXFxkXSspPyU/Lyxcblx0cnBvc2l0aW9uID0gL15cXHcrLyxcblx0cnBlcmNlbnQgPSAvJSQvLFxuXHRfcG9zaXRpb24gPSAkLmZuLnBvc2l0aW9uO1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRzKCBvZmZzZXRzLCB3aWR0aCwgaGVpZ2h0ICkge1xuXHRyZXR1cm4gW1xuXHRcdHBhcnNlRmxvYXQoIG9mZnNldHNbIDAgXSApICogKCBycGVyY2VudC50ZXN0KCBvZmZzZXRzWyAwIF0gKSA/IHdpZHRoIC8gMTAwIDogMSApLFxuXHRcdHBhcnNlRmxvYXQoIG9mZnNldHNbIDEgXSApICogKCBycGVyY2VudC50ZXN0KCBvZmZzZXRzWyAxIF0gKSA/IGhlaWdodCAvIDEwMCA6IDEgKVxuXHRdO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNzcyggZWxlbWVudCwgcHJvcGVydHkgKSB7XG5cdHJldHVybiBwYXJzZUludCggJC5jc3MoIGVsZW1lbnQsIHByb3BlcnR5ICksIDEwICkgfHwgMDtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyggZWxlbSApIHtcblx0dmFyIHJhdyA9IGVsZW1bIDAgXTtcblx0aWYgKCByYXcubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBlbGVtLndpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiAwLCBsZWZ0OiAwIH1cblx0XHR9O1xuXHR9XG5cdGlmICggJC5pc1dpbmRvdyggcmF3ICkgKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBlbGVtLndpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiBlbGVtLnNjcm9sbFRvcCgpLCBsZWZ0OiBlbGVtLnNjcm9sbExlZnQoKSB9XG5cdFx0fTtcblx0fVxuXHRpZiAoIHJhdy5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDAsXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiByYXcucGFnZVksIGxlZnQ6IHJhdy5wYWdlWCB9XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHdpZHRoOiBlbGVtLm91dGVyV2lkdGgoKSxcblx0XHRoZWlnaHQ6IGVsZW0ub3V0ZXJIZWlnaHQoKSxcblx0XHRvZmZzZXQ6IGVsZW0ub2Zmc2V0KClcblx0fTtcbn1cblxuJC5wb3NpdGlvbiA9IHtcblx0c2Nyb2xsYmFyV2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggY2FjaGVkU2Nyb2xsYmFyV2lkdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBjYWNoZWRTY3JvbGxiYXJXaWR0aDtcblx0XHR9XG5cdFx0dmFyIHcxLCB3Mixcblx0XHRcdGRpdiA9ICQoIFwiPGRpdiBcIiArXG5cdFx0XHRcdFwic3R5bGU9J2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6NTBweDtoZWlnaHQ6NTBweDtvdmVyZmxvdzpoaWRkZW47Jz5cIiArXG5cdFx0XHRcdFwiPGRpdiBzdHlsZT0naGVpZ2h0OjEwMHB4O3dpZHRoOmF1dG87Jz48L2Rpdj48L2Rpdj5cIiApLFxuXHRcdFx0aW5uZXJEaXYgPSBkaXYuY2hpbGRyZW4oKVsgMCBdO1xuXG5cdFx0JCggXCJib2R5XCIgKS5hcHBlbmQoIGRpdiApO1xuXHRcdHcxID0gaW5uZXJEaXYub2Zmc2V0V2lkdGg7XG5cdFx0ZGl2LmNzcyggXCJvdmVyZmxvd1wiLCBcInNjcm9sbFwiICk7XG5cblx0XHR3MiA9IGlubmVyRGl2Lm9mZnNldFdpZHRoO1xuXG5cdFx0aWYgKCB3MSA9PT0gdzIgKSB7XG5cdFx0XHR3MiA9IGRpdlsgMCBdLmNsaWVudFdpZHRoO1xuXHRcdH1cblxuXHRcdGRpdi5yZW1vdmUoKTtcblxuXHRcdHJldHVybiAoIGNhY2hlZFNjcm9sbGJhcldpZHRoID0gdzEgLSB3MiApO1xuXHR9LFxuXHRnZXRTY3JvbGxJbmZvOiBmdW5jdGlvbiggd2l0aGluICkge1xuXHRcdHZhciBvdmVyZmxvd1ggPSB3aXRoaW4uaXNXaW5kb3cgfHwgd2l0aGluLmlzRG9jdW1lbnQgPyBcIlwiIDpcblx0XHRcdFx0d2l0aGluLmVsZW1lbnQuY3NzKCBcIm92ZXJmbG93LXhcIiApLFxuXHRcdFx0b3ZlcmZsb3dZID0gd2l0aGluLmlzV2luZG93IHx8IHdpdGhpbi5pc0RvY3VtZW50ID8gXCJcIiA6XG5cdFx0XHRcdHdpdGhpbi5lbGVtZW50LmNzcyggXCJvdmVyZmxvdy15XCIgKSxcblx0XHRcdGhhc092ZXJmbG93WCA9IG92ZXJmbG93WCA9PT0gXCJzY3JvbGxcIiB8fFxuXHRcdFx0XHQoIG92ZXJmbG93WCA9PT0gXCJhdXRvXCIgJiYgd2l0aGluLndpZHRoIDwgd2l0aGluLmVsZW1lbnRbIDAgXS5zY3JvbGxXaWR0aCApLFxuXHRcdFx0aGFzT3ZlcmZsb3dZID0gb3ZlcmZsb3dZID09PSBcInNjcm9sbFwiIHx8XG5cdFx0XHRcdCggb3ZlcmZsb3dZID09PSBcImF1dG9cIiAmJiB3aXRoaW4uaGVpZ2h0IDwgd2l0aGluLmVsZW1lbnRbIDAgXS5zY3JvbGxIZWlnaHQgKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGhhc092ZXJmbG93WSA/ICQucG9zaXRpb24uc2Nyb2xsYmFyV2lkdGgoKSA6IDAsXG5cdFx0XHRoZWlnaHQ6IGhhc092ZXJmbG93WCA/ICQucG9zaXRpb24uc2Nyb2xsYmFyV2lkdGgoKSA6IDBcblx0XHR9O1xuXHR9LFxuXHRnZXRXaXRoaW5JbmZvOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgd2l0aGluRWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgd2luZG93ICksXG5cdFx0XHRpc1dpbmRvdyA9ICQuaXNXaW5kb3coIHdpdGhpbkVsZW1lbnRbIDAgXSApLFxuXHRcdFx0aXNEb2N1bWVudCA9ICEhd2l0aGluRWxlbWVudFsgMCBdICYmIHdpdGhpbkVsZW1lbnRbIDAgXS5ub2RlVHlwZSA9PT0gOSxcblx0XHRcdGhhc09mZnNldCA9ICFpc1dpbmRvdyAmJiAhaXNEb2N1bWVudDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudDogd2l0aGluRWxlbWVudCxcblx0XHRcdGlzV2luZG93OiBpc1dpbmRvdyxcblx0XHRcdGlzRG9jdW1lbnQ6IGlzRG9jdW1lbnQsXG5cdFx0XHRvZmZzZXQ6IGhhc09mZnNldCA/ICQoIGVsZW1lbnQgKS5vZmZzZXQoKSA6IHsgbGVmdDogMCwgdG9wOiAwIH0sXG5cdFx0XHRzY3JvbGxMZWZ0OiB3aXRoaW5FbGVtZW50LnNjcm9sbExlZnQoKSxcblx0XHRcdHNjcm9sbFRvcDogd2l0aGluRWxlbWVudC5zY3JvbGxUb3AoKSxcblx0XHRcdHdpZHRoOiB3aXRoaW5FbGVtZW50Lm91dGVyV2lkdGgoKSxcblx0XHRcdGhlaWdodDogd2l0aGluRWxlbWVudC5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0fVxufTtcblxuJC5mbi5wb3NpdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRpZiAoICFvcHRpb25zIHx8ICFvcHRpb25zLm9mICkge1xuXHRcdHJldHVybiBfcG9zaXRpb24uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0Ly8gTWFrZSBhIGNvcHksIHdlIGRvbid0IHdhbnQgdG8gbW9kaWZ5IGFyZ3VtZW50c1xuXHRvcHRpb25zID0gJC5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIGF0T2Zmc2V0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB0YXJnZXRPZmZzZXQsIGJhc2VQb3NpdGlvbiwgZGltZW5zaW9ucyxcblx0XHR0YXJnZXQgPSAkKCBvcHRpb25zLm9mICksXG5cdFx0d2l0aGluID0gJC5wb3NpdGlvbi5nZXRXaXRoaW5JbmZvKCBvcHRpb25zLndpdGhpbiApLFxuXHRcdHNjcm9sbEluZm8gPSAkLnBvc2l0aW9uLmdldFNjcm9sbEluZm8oIHdpdGhpbiApLFxuXHRcdGNvbGxpc2lvbiA9ICggb3B0aW9ucy5jb2xsaXNpb24gfHwgXCJmbGlwXCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRvZmZzZXRzID0ge307XG5cblx0ZGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnMoIHRhcmdldCApO1xuXHRpZiAoIHRhcmdldFsgMCBdLnByZXZlbnREZWZhdWx0ICkge1xuXG5cdFx0Ly8gRm9yY2UgbGVmdCB0b3AgdG8gYWxsb3cgZmxpcHBpbmdcblx0XHRvcHRpb25zLmF0ID0gXCJsZWZ0IHRvcFwiO1xuXHR9XG5cdHRhcmdldFdpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcblx0dGFyZ2V0SGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG5cdHRhcmdldE9mZnNldCA9IGRpbWVuc2lvbnMub2Zmc2V0O1xuXG5cdC8vIENsb25lIHRvIHJldXNlIG9yaWdpbmFsIHRhcmdldE9mZnNldCBsYXRlclxuXHRiYXNlUG9zaXRpb24gPSAkLmV4dGVuZCgge30sIHRhcmdldE9mZnNldCApO1xuXG5cdC8vIEZvcmNlIG15IGFuZCBhdCB0byBoYXZlIHZhbGlkIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHBvc2l0aW9uc1xuXHQvLyBpZiBhIHZhbHVlIGlzIG1pc3Npbmcgb3IgaW52YWxpZCwgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2VudGVyXG5cdCQuZWFjaCggWyBcIm15XCIsIFwiYXRcIiBdLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9zID0gKCBvcHRpb25zWyB0aGlzIF0gfHwgXCJcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdFx0aG9yaXpvbnRhbE9mZnNldCxcblx0XHRcdHZlcnRpY2FsT2Zmc2V0O1xuXG5cdFx0aWYgKCBwb3MubGVuZ3RoID09PSAxICkge1xuXHRcdFx0cG9zID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdHBvcy5jb25jYXQoIFsgXCJjZW50ZXJcIiBdICkgOlxuXHRcdFx0XHRydmVydGljYWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiIF0uY29uY2F0KCBwb3MgKSA6XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiLCBcImNlbnRlclwiIF07XG5cdFx0fVxuXHRcdHBvc1sgMCBdID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/IHBvc1sgMCBdIDogXCJjZW50ZXJcIjtcblx0XHRwb3NbIDEgXSA9IHJ2ZXJ0aWNhbC50ZXN0KCBwb3NbIDEgXSApID8gcG9zWyAxIF0gOiBcImNlbnRlclwiO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIG9mZnNldHNcblx0XHRob3Jpem9udGFsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDAgXSApO1xuXHRcdHZlcnRpY2FsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDEgXSApO1xuXHRcdG9mZnNldHNbIHRoaXMgXSA9IFtcblx0XHRcdGhvcml6b250YWxPZmZzZXQgPyBob3Jpem9udGFsT2Zmc2V0WyAwIF0gOiAwLFxuXHRcdFx0dmVydGljYWxPZmZzZXQgPyB2ZXJ0aWNhbE9mZnNldFsgMCBdIDogMFxuXHRcdF07XG5cblx0XHQvLyBSZWR1Y2UgdG8ganVzdCB0aGUgcG9zaXRpb25zIHdpdGhvdXQgdGhlIG9mZnNldHNcblx0XHRvcHRpb25zWyB0aGlzIF0gPSBbXG5cdFx0XHRycG9zaXRpb24uZXhlYyggcG9zWyAwIF0gKVsgMCBdLFxuXHRcdFx0cnBvc2l0aW9uLmV4ZWMoIHBvc1sgMSBdIClbIDAgXVxuXHRcdF07XG5cdH0gKTtcblxuXHQvLyBOb3JtYWxpemUgY29sbGlzaW9uIG9wdGlvblxuXHRpZiAoIGNvbGxpc2lvbi5sZW5ndGggPT09IDEgKSB7XG5cdFx0Y29sbGlzaW9uWyAxIF0gPSBjb2xsaXNpb25bIDAgXTtcblx0fVxuXG5cdGlmICggb3B0aW9ucy5hdFsgMCBdID09PSBcInJpZ2h0XCIgKSB7XG5cdFx0YmFzZVBvc2l0aW9uLmxlZnQgKz0gdGFyZ2V0V2lkdGg7XG5cdH0gZWxzZSBpZiAoIG9wdGlvbnMuYXRbIDAgXSA9PT0gXCJjZW50ZXJcIiApIHtcblx0XHRiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aCAvIDI7XG5cdH1cblxuXHRpZiAoIG9wdGlvbnMuYXRbIDEgXSA9PT0gXCJib3R0b21cIiApIHtcblx0XHRiYXNlUG9zaXRpb24udG9wICs9IHRhcmdldEhlaWdodDtcblx0fSBlbHNlIGlmICggb3B0aW9ucy5hdFsgMSBdID09PSBcImNlbnRlclwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi50b3AgKz0gdGFyZ2V0SGVpZ2h0IC8gMjtcblx0fVxuXG5cdGF0T2Zmc2V0ID0gZ2V0T2Zmc2V0cyggb2Zmc2V0cy5hdCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCApO1xuXHRiYXNlUG9zaXRpb24ubGVmdCArPSBhdE9mZnNldFsgMCBdO1xuXHRiYXNlUG9zaXRpb24udG9wICs9IGF0T2Zmc2V0WyAxIF07XG5cblx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbGxpc2lvblBvc2l0aW9uLCB1c2luZyxcblx0XHRcdGVsZW0gPSAkKCB0aGlzICksXG5cdFx0XHRlbGVtV2lkdGggPSBlbGVtLm91dGVyV2lkdGgoKSxcblx0XHRcdGVsZW1IZWlnaHQgPSBlbGVtLm91dGVySGVpZ2h0KCksXG5cdFx0XHRtYXJnaW5MZWZ0ID0gcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luTGVmdFwiICksXG5cdFx0XHRtYXJnaW5Ub3AgPSBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5Ub3BcIiApLFxuXHRcdFx0Y29sbGlzaW9uV2lkdGggPSBlbGVtV2lkdGggKyBtYXJnaW5MZWZ0ICsgcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luUmlnaHRcIiApICtcblx0XHRcdFx0c2Nyb2xsSW5mby53aWR0aCxcblx0XHRcdGNvbGxpc2lvbkhlaWdodCA9IGVsZW1IZWlnaHQgKyBtYXJnaW5Ub3AgKyBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5Cb3R0b21cIiApICtcblx0XHRcdFx0c2Nyb2xsSW5mby5oZWlnaHQsXG5cdFx0XHRwb3NpdGlvbiA9ICQuZXh0ZW5kKCB7fSwgYmFzZVBvc2l0aW9uICksXG5cdFx0XHRteU9mZnNldCA9IGdldE9mZnNldHMoIG9mZnNldHMubXksIGVsZW0ub3V0ZXJXaWR0aCgpLCBlbGVtLm91dGVySGVpZ2h0KCkgKTtcblxuXHRcdGlmICggb3B0aW9ucy5teVsgMCBdID09PSBcInJpZ2h0XCIgKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0IC09IGVsZW1XaWR0aDtcblx0XHR9IGVsc2UgaWYgKCBvcHRpb25zLm15WyAwIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0IC09IGVsZW1XaWR0aCAvIDI7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLm15WyAxIF0gPT09IFwiYm90dG9tXCIgKSB7XG5cdFx0XHRwb3NpdGlvbi50b3AgLT0gZWxlbUhlaWdodDtcblx0XHR9IGVsc2UgaWYgKCBvcHRpb25zLm15WyAxIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0XHRwb3NpdGlvbi50b3AgLT0gZWxlbUhlaWdodCAvIDI7XG5cdFx0fVxuXG5cdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldFsgMCBdO1xuXHRcdHBvc2l0aW9uLnRvcCArPSBteU9mZnNldFsgMSBdO1xuXG5cdFx0Y29sbGlzaW9uUG9zaXRpb24gPSB7XG5cdFx0XHRtYXJnaW5MZWZ0OiBtYXJnaW5MZWZ0LFxuXHRcdFx0bWFyZ2luVG9wOiBtYXJnaW5Ub3Bcblx0XHR9O1xuXG5cdFx0JC5lYWNoKCBbIFwibGVmdFwiLCBcInRvcFwiIF0sIGZ1bmN0aW9uKCBpLCBkaXIgKSB7XG5cdFx0XHRpZiAoICQudWkucG9zaXRpb25bIGNvbGxpc2lvblsgaSBdIF0gKSB7XG5cdFx0XHRcdCQudWkucG9zaXRpb25bIGNvbGxpc2lvblsgaSBdIF1bIGRpciBdKCBwb3NpdGlvbiwge1xuXHRcdFx0XHRcdHRhcmdldFdpZHRoOiB0YXJnZXRXaWR0aCxcblx0XHRcdFx0XHR0YXJnZXRIZWlnaHQ6IHRhcmdldEhlaWdodCxcblx0XHRcdFx0XHRlbGVtV2lkdGg6IGVsZW1XaWR0aCxcblx0XHRcdFx0XHRlbGVtSGVpZ2h0OiBlbGVtSGVpZ2h0LFxuXHRcdFx0XHRcdGNvbGxpc2lvblBvc2l0aW9uOiBjb2xsaXNpb25Qb3NpdGlvbixcblx0XHRcdFx0XHRjb2xsaXNpb25XaWR0aDogY29sbGlzaW9uV2lkdGgsXG5cdFx0XHRcdFx0Y29sbGlzaW9uSGVpZ2h0OiBjb2xsaXNpb25IZWlnaHQsXG5cdFx0XHRcdFx0b2Zmc2V0OiBbIGF0T2Zmc2V0WyAwIF0gKyBteU9mZnNldFsgMCBdLCBhdE9mZnNldCBbIDEgXSArIG15T2Zmc2V0WyAxIF0gXSxcblx0XHRcdFx0XHRteTogb3B0aW9ucy5teSxcblx0XHRcdFx0XHRhdDogb3B0aW9ucy5hdCxcblx0XHRcdFx0XHR3aXRoaW46IHdpdGhpbixcblx0XHRcdFx0XHRlbGVtOiBlbGVtXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRpZiAoIG9wdGlvbnMudXNpbmcgKSB7XG5cblx0XHRcdC8vIEFkZHMgZmVlZGJhY2sgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIHVzaW5nIGNhbGxiYWNrLCBpZiBwcmVzZW50XG5cdFx0XHR1c2luZyA9IGZ1bmN0aW9uKCBwcm9wcyApIHtcblx0XHRcdFx0dmFyIGxlZnQgPSB0YXJnZXRPZmZzZXQubGVmdCAtIHBvc2l0aW9uLmxlZnQsXG5cdFx0XHRcdFx0cmlnaHQgPSBsZWZ0ICsgdGFyZ2V0V2lkdGggLSBlbGVtV2lkdGgsXG5cdFx0XHRcdFx0dG9wID0gdGFyZ2V0T2Zmc2V0LnRvcCAtIHBvc2l0aW9uLnRvcCxcblx0XHRcdFx0XHRib3R0b20gPSB0b3AgKyB0YXJnZXRIZWlnaHQgLSBlbGVtSGVpZ2h0LFxuXHRcdFx0XHRcdGZlZWRiYWNrID0ge1xuXHRcdFx0XHRcdFx0dGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQ6IHRhcmdldCxcblx0XHRcdFx0XHRcdFx0bGVmdDogdGFyZ2V0T2Zmc2V0LmxlZnQsXG5cdFx0XHRcdFx0XHRcdHRvcDogdGFyZ2V0T2Zmc2V0LnRvcCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHRhcmdldFdpZHRoLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IHRhcmdldEhlaWdodFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGVsZW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbSxcblx0XHRcdFx0XHRcdFx0bGVmdDogcG9zaXRpb24ubGVmdCxcblx0XHRcdFx0XHRcdFx0dG9wOiBwb3NpdGlvbi50b3AsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBlbGVtV2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogZWxlbUhlaWdodFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGhvcml6b250YWw6IHJpZ2h0IDwgMCA/IFwibGVmdFwiIDogbGVmdCA+IDAgPyBcInJpZ2h0XCIgOiBcImNlbnRlclwiLFxuXHRcdFx0XHRcdFx0dmVydGljYWw6IGJvdHRvbSA8IDAgPyBcInRvcFwiIDogdG9wID4gMCA/IFwiYm90dG9tXCIgOiBcIm1pZGRsZVwiXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCB0YXJnZXRXaWR0aCA8IGVsZW1XaWR0aCAmJiBhYnMoIGxlZnQgKyByaWdodCApIDwgdGFyZ2V0V2lkdGggKSB7XG5cdFx0XHRcdFx0ZmVlZGJhY2suaG9yaXpvbnRhbCA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0YXJnZXRIZWlnaHQgPCBlbGVtSGVpZ2h0ICYmIGFicyggdG9wICsgYm90dG9tICkgPCB0YXJnZXRIZWlnaHQgKSB7XG5cdFx0XHRcdFx0ZmVlZGJhY2sudmVydGljYWwgPSBcIm1pZGRsZVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWF4KCBhYnMoIGxlZnQgKSwgYWJzKCByaWdodCApICkgPiBtYXgoIGFicyggdG9wICksIGFicyggYm90dG9tICkgKSApIHtcblx0XHRcdFx0XHRmZWVkYmFjay5pbXBvcnRhbnQgPSBcImhvcml6b250YWxcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmZWVkYmFjay5pbXBvcnRhbnQgPSBcInZlcnRpY2FsXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCB0aGlzLCBwcm9wcywgZmVlZGJhY2sgKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZWxlbS5vZmZzZXQoICQuZXh0ZW5kKCBwb3NpdGlvbiwgeyB1c2luZzogdXNpbmcgfSApICk7XG5cdH0gKTtcbn07XG5cbiQudWkucG9zaXRpb24gPSB7XG5cdGZpdDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbExlZnQgOiB3aXRoaW4ub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdG91dGVyV2lkdGggPSB3aXRoaW4ud2lkdGgsXG5cdFx0XHRcdGNvbGxpc2lvblBvc0xlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5MZWZ0LFxuXHRcdFx0XHRvdmVyTGVmdCA9IHdpdGhpbk9mZnNldCAtIGNvbGxpc2lvblBvc0xlZnQsXG5cdFx0XHRcdG92ZXJSaWdodCA9IGNvbGxpc2lvblBvc0xlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldCxcblx0XHRcdFx0bmV3T3ZlclJpZ2h0O1xuXG5cdFx0XHQvLyBFbGVtZW50IGlzIHdpZGVyIHRoYW4gd2l0aGluXG5cdFx0XHRpZiAoIGRhdGEuY29sbGlzaW9uV2lkdGggPiBvdXRlcldpZHRoICkge1xuXG5cdFx0XHRcdC8vIEVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgdGhlIGxlZnQgc2lkZSBvZiB3aXRoaW5cblx0XHRcdFx0aWYgKCBvdmVyTGVmdCA+IDAgJiYgb3ZlclJpZ2h0IDw9IDAgKSB7XG5cdFx0XHRcdFx0bmV3T3ZlclJpZ2h0ID0gcG9zaXRpb24ubGVmdCArIG92ZXJMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLVxuXHRcdFx0XHRcdFx0d2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gb3ZlckxlZnQgLSBuZXdPdmVyUmlnaHQ7XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciByaWdodCBzaWRlIG9mIHdpdGhpblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICYmIG92ZXJMZWZ0IDw9IDAgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldDtcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdGggbGVmdCBhbmQgcmlnaHQgc2lkZXMgb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBvdmVyTGVmdCA+IG92ZXJSaWdodCApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQgKyBvdXRlcldpZHRoIC0gZGF0YS5jb2xsaXNpb25XaWR0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9vIGZhciBsZWZ0IC0+IGFsaWduIHdpdGggbGVmdCBlZGdlXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyTGVmdCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gb3ZlckxlZnQ7XG5cblx0XHRcdC8vIFRvbyBmYXIgcmlnaHQgLT4gYWxpZ24gd2l0aCByaWdodCBlZGdlXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi5sZWZ0IC09IG92ZXJSaWdodDtcblxuXHRcdFx0Ly8gQWRqdXN0IGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBtYXJnaW5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSBtYXgoIHBvc2l0aW9uLmxlZnQgLSBjb2xsaXNpb25Qb3NMZWZ0LCBwb3NpdGlvbi5sZWZ0ICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbFRvcCA6IHdpdGhpbi5vZmZzZXQudG9wLFxuXHRcdFx0XHRvdXRlckhlaWdodCA9IGRhdGEud2l0aGluLmhlaWdodCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AsXG5cdFx0XHRcdG92ZXJUb3AgPSB3aXRoaW5PZmZzZXQgLSBjb2xsaXNpb25Qb3NUb3AsXG5cdFx0XHRcdG92ZXJCb3R0b20gPSBjb2xsaXNpb25Qb3NUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0LFxuXHRcdFx0XHRuZXdPdmVyQm90dG9tO1xuXG5cdFx0XHQvLyBFbGVtZW50IGlzIHRhbGxlciB0aGFuIHdpdGhpblxuXHRcdFx0aWYgKCBkYXRhLmNvbGxpc2lvbkhlaWdodCA+IG91dGVySGVpZ2h0ICkge1xuXG5cdFx0XHRcdC8vIEVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgdGhlIHRvcCBvZiB3aXRoaW5cblx0XHRcdFx0aWYgKCBvdmVyVG9wID4gMCAmJiBvdmVyQm90dG9tIDw9IDAgKSB7XG5cdFx0XHRcdFx0bmV3T3ZlckJvdHRvbSA9IHBvc2l0aW9uLnRvcCArIG92ZXJUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC1cblx0XHRcdFx0XHRcdHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gb3ZlclRvcCAtIG5ld092ZXJCb3R0b207XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciBib3R0b20gb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICYmIG92ZXJUb3AgPD0gMCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQ7XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciBib3RoIHRvcCBhbmQgYm90dG9tIG9mIHdpdGhpblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggb3ZlclRvcCA+IG92ZXJCb3R0b20gKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQgKyBvdXRlckhlaWdodCAtIGRhdGEuY29sbGlzaW9uSGVpZ2h0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvbyBmYXIgdXAgLT4gYWxpZ24gd2l0aCB0b3Bcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJUb3AgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gb3ZlclRvcDtcblxuXHRcdFx0Ly8gVG9vIGZhciBkb3duIC0+IGFsaWduIHdpdGggYm90dG9tIGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgLT0gb3ZlckJvdHRvbTtcblxuXHRcdFx0Ly8gQWRqdXN0IGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBtYXJnaW5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc2l0aW9uLnRvcCA9IG1heCggcG9zaXRpb24udG9wIC0gY29sbGlzaW9uUG9zVG9wLCBwb3NpdGlvbi50b3AgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGZsaXA6IHtcblx0XHRsZWZ0OiBmdW5jdGlvbiggcG9zaXRpb24sIGRhdGEgKSB7XG5cdFx0XHR2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXG5cdFx0XHRcdHdpdGhpbk9mZnNldCA9IHdpdGhpbi5vZmZzZXQubGVmdCArIHdpdGhpbi5zY3JvbGxMZWZ0LFxuXHRcdFx0XHRvdXRlcldpZHRoID0gd2l0aGluLndpZHRoLFxuXHRcdFx0XHRvZmZzZXRMZWZ0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbExlZnQgOiB3aXRoaW4ub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdGNvbGxpc2lvblBvc0xlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5MZWZ0LFxuXHRcdFx0XHRvdmVyTGVmdCA9IGNvbGxpc2lvblBvc0xlZnQgLSBvZmZzZXRMZWZ0LFxuXHRcdFx0XHRvdmVyUmlnaHQgPSBjb2xsaXNpb25Qb3NMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSBvZmZzZXRMZWZ0LFxuXHRcdFx0XHRteU9mZnNldCA9IGRhdGEubXlbIDAgXSA9PT0gXCJsZWZ0XCIgP1xuXHRcdFx0XHRcdC1kYXRhLmVsZW1XaWR0aCA6XG5cdFx0XHRcdFx0ZGF0YS5teVsgMCBdID09PSBcInJpZ2h0XCIgP1xuXHRcdFx0XHRcdFx0ZGF0YS5lbGVtV2lkdGggOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0YXRPZmZzZXQgPSBkYXRhLmF0WyAwIF0gPT09IFwibGVmdFwiID9cblx0XHRcdFx0XHRkYXRhLnRhcmdldFdpZHRoIDpcblx0XHRcdFx0XHRkYXRhLmF0WyAwIF0gPT09IFwicmlnaHRcIiA/XG5cdFx0XHRcdFx0XHQtZGF0YS50YXJnZXRXaWR0aCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRvZmZzZXQgPSAtMiAqIGRhdGEub2Zmc2V0WyAwIF0sXG5cdFx0XHRcdG5ld092ZXJSaWdodCxcblx0XHRcdFx0bmV3T3ZlckxlZnQ7XG5cblx0XHRcdGlmICggb3ZlckxlZnQgPCAwICkge1xuXHRcdFx0XHRuZXdPdmVyUmlnaHQgPSBwb3NpdGlvbi5sZWZ0ICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCArIGRhdGEuY29sbGlzaW9uV2lkdGggLVxuXHRcdFx0XHRcdG91dGVyV2lkdGggLSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdGlmICggbmV3T3ZlclJpZ2h0IDwgMCB8fCBuZXdPdmVyUmlnaHQgPCBhYnMoIG92ZXJMZWZ0ICkgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICkge1xuXHRcdFx0XHRuZXdPdmVyTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQgKyBteU9mZnNldCArXG5cdFx0XHRcdFx0YXRPZmZzZXQgKyBvZmZzZXQgLSBvZmZzZXRMZWZ0O1xuXHRcdFx0XHRpZiAoIG5ld092ZXJMZWZ0ID4gMCB8fCBhYnMoIG5ld092ZXJMZWZ0ICkgPCBvdmVyUmlnaHQgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLm9mZnNldC50b3AgKyB3aXRoaW4uc2Nyb2xsVG9wLFxuXHRcdFx0XHRvdXRlckhlaWdodCA9IHdpdGhpbi5oZWlnaHQsXG5cdFx0XHRcdG9mZnNldFRvcCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxUb3AgOiB3aXRoaW4ub2Zmc2V0LnRvcCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AsXG5cdFx0XHRcdG92ZXJUb3AgPSBjb2xsaXNpb25Qb3NUb3AgLSBvZmZzZXRUb3AsXG5cdFx0XHRcdG92ZXJCb3R0b20gPSBjb2xsaXNpb25Qb3NUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gb2Zmc2V0VG9wLFxuXHRcdFx0XHR0b3AgPSBkYXRhLm15WyAxIF0gPT09IFwidG9wXCIsXG5cdFx0XHRcdG15T2Zmc2V0ID0gdG9wID9cblx0XHRcdFx0XHQtZGF0YS5lbGVtSGVpZ2h0IDpcblx0XHRcdFx0XHRkYXRhLm15WyAxIF0gPT09IFwiYm90dG9tXCIgP1xuXHRcdFx0XHRcdFx0ZGF0YS5lbGVtSGVpZ2h0IDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdGF0T2Zmc2V0ID0gZGF0YS5hdFsgMSBdID09PSBcInRvcFwiID9cblx0XHRcdFx0XHRkYXRhLnRhcmdldEhlaWdodCA6XG5cdFx0XHRcdFx0ZGF0YS5hdFsgMSBdID09PSBcImJvdHRvbVwiID9cblx0XHRcdFx0XHRcdC1kYXRhLnRhcmdldEhlaWdodCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRvZmZzZXQgPSAtMiAqIGRhdGEub2Zmc2V0WyAxIF0sXG5cdFx0XHRcdG5ld092ZXJUb3AsXG5cdFx0XHRcdG5ld092ZXJCb3R0b207XG5cdFx0XHRpZiAoIG92ZXJUb3AgPCAwICkge1xuXHRcdFx0XHRuZXdPdmVyQm90dG9tID0gcG9zaXRpb24udG9wICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC1cblx0XHRcdFx0XHRvdXRlckhlaWdodCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0aWYgKCBuZXdPdmVyQm90dG9tIDwgMCB8fCBuZXdPdmVyQm90dG9tIDwgYWJzKCBvdmVyVG9wICkgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24udG9wICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICkge1xuXHRcdFx0XHRuZXdPdmVyVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICtcblx0XHRcdFx0XHRvZmZzZXQgLSBvZmZzZXRUb3A7XG5cdFx0XHRcdGlmICggbmV3T3ZlclRvcCA+IDAgfHwgYWJzKCBuZXdPdmVyVG9wICkgPCBvdmVyQm90dG9tICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRmbGlwZml0OiB7XG5cdFx0bGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZsaXAubGVmdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZpdC5sZWZ0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZsaXAudG9wLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdCQudWkucG9zaXRpb24uZml0LnRvcC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9XG59O1xuXG59ICkoKTtcblxudmFyIHBvc2l0aW9uID0gJC51aS5wb3NpdGlvbjtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSA6ZGF0YSAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogOmRhdGEgU2VsZWN0b3Jcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBTZWxlY3RzIGVsZW1lbnRzIHdoaWNoIGhhdmUgZGF0YSBzdG9yZWQgdW5kZXIgdGhlIHNwZWNpZmllZCBrZXkuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZGF0YS1zZWxlY3Rvci9cblxuXG52YXIgZGF0YSA9ICQuZXh0ZW5kKCAkLmV4cHJbIFwiOlwiIF0sIHtcblx0ZGF0YTogJC5leHByLmNyZWF0ZVBzZXVkbyA/XG5cdFx0JC5leHByLmNyZWF0ZVBzZXVkbyggZnVuY3Rpb24oIGRhdGFOYW1lICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGRhdGFOYW1lICk7XG5cdFx0XHR9O1xuXHRcdH0gKSA6XG5cblx0XHQvLyBTdXBwb3J0OiBqUXVlcnkgPDEuOFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgbWF0Y2hbIDMgXSApO1xuXHRcdH1cbn0gKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgRGlzYWJsZSBTZWxlY3Rpb24gMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IGRpc2FibGVTZWxlY3Rpb25cbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBEaXNhYmxlIHNlbGVjdGlvbiBvZiB0ZXh0IGNvbnRlbnQgd2l0aGluIHRoZSBzZXQgb2YgbWF0Y2hlZCBlbGVtZW50cy5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9kaXNhYmxlU2VsZWN0aW9uL1xuXG4vLyBUaGlzIGZpbGUgaXMgZGVwcmVjYXRlZFxuXG5cbnZhciBkaXNhYmxlU2VsZWN0aW9uID0gJC5mbi5leHRlbmQoIHtcblx0ZGlzYWJsZVNlbGVjdGlvbjogKCBmdW5jdGlvbigpIHtcblx0XHR2YXIgZXZlbnRUeXBlID0gXCJvbnNlbGVjdHN0YXJ0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApID9cblx0XHRcdFwic2VsZWN0c3RhcnRcIiA6XG5cdFx0XHRcIm1vdXNlZG93blwiO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMub24oIGV2ZW50VHlwZSArIFwiLnVpLWRpc2FibGVTZWxlY3Rpb25cIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSApO1xuXHRcdH07XG5cdH0gKSgpLFxuXG5cdGVuYWJsZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCBcIi51aS1kaXNhYmxlU2VsZWN0aW9uXCIgKTtcblx0fVxufSApO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIEZvY3VzYWJsZSAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogOmZvY3VzYWJsZSBTZWxlY3RvclxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IFNlbGVjdHMgZWxlbWVudHMgd2hpY2ggY2FuIGJlIGZvY3VzZWQuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZm9jdXNhYmxlLXNlbGVjdG9yL1xuXG5cblxuLy8gU2VsZWN0b3JzXG4kLnVpLmZvY3VzYWJsZSA9IGZ1bmN0aW9uKCBlbGVtZW50LCBoYXNUYWJpbmRleCApIHtcblx0dmFyIG1hcCwgbWFwTmFtZSwgaW1nLCBmb2N1c2FibGVJZlZpc2libGUsIGZpZWxkc2V0LFxuXHRcdG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdGlmICggXCJhcmVhXCIgPT09IG5vZGVOYW1lICkge1xuXHRcdG1hcCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRtYXBOYW1lID0gbWFwLm5hbWU7XG5cdFx0aWYgKCAhZWxlbWVudC5ocmVmIHx8ICFtYXBOYW1lIHx8IG1hcC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm1hcFwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpbWcgPSAkKCBcImltZ1t1c2VtYXA9JyNcIiArIG1hcE5hbWUgKyBcIiddXCIgKTtcblx0XHRyZXR1cm4gaW1nLmxlbmd0aCA+IDAgJiYgaW1nLmlzKCBcIjp2aXNpYmxlXCIgKTtcblx0fVxuXG5cdGlmICggL14oaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC8udGVzdCggbm9kZU5hbWUgKSApIHtcblx0XHRmb2N1c2FibGVJZlZpc2libGUgPSAhZWxlbWVudC5kaXNhYmxlZDtcblxuXHRcdGlmICggZm9jdXNhYmxlSWZWaXNpYmxlICkge1xuXG5cdFx0XHQvLyBGb3JtIGNvbnRyb2xzIHdpdGhpbiBhIGRpc2FibGVkIGZpZWxkc2V0IGFyZSBkaXNhYmxlZC5cblx0XHRcdC8vIEhvd2V2ZXIsIGNvbnRyb2xzIHdpdGhpbiB0aGUgZmllbGRzZXQncyBsZWdlbmQgZG8gbm90IGdldCBkaXNhYmxlZC5cblx0XHRcdC8vIFNpbmNlIGNvbnRyb2xzIGdlbmVyYWxseSBhcmVuJ3QgcGxhY2VkIGluc2lkZSBsZWdlbmRzLCB3ZSBza2lwXG5cdFx0XHQvLyB0aGlzIHBvcnRpb24gb2YgdGhlIGNoZWNrLlxuXHRcdFx0ZmllbGRzZXQgPSAkKCBlbGVtZW50ICkuY2xvc2VzdCggXCJmaWVsZHNldFwiIClbIDAgXTtcblx0XHRcdGlmICggZmllbGRzZXQgKSB7XG5cdFx0XHRcdGZvY3VzYWJsZUlmVmlzaWJsZSA9ICFmaWVsZHNldC5kaXNhYmxlZDtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIFwiYVwiID09PSBub2RlTmFtZSApIHtcblx0XHRmb2N1c2FibGVJZlZpc2libGUgPSBlbGVtZW50LmhyZWYgfHwgaGFzVGFiaW5kZXg7XG5cdH0gZWxzZSB7XG5cdFx0Zm9jdXNhYmxlSWZWaXNpYmxlID0gaGFzVGFiaW5kZXg7XG5cdH1cblxuXHRyZXR1cm4gZm9jdXNhYmxlSWZWaXNpYmxlICYmICQoIGVsZW1lbnQgKS5pcyggXCI6dmlzaWJsZVwiICkgJiYgdmlzaWJsZSggJCggZWxlbWVudCApICk7XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA4IG9ubHlcbi8vIElFIDggZG9lc24ndCByZXNvbHZlIGluaGVyaXQgdG8gdmlzaWJsZS9oaWRkZW4gZm9yIGNvbXB1dGVkIHZhbHVlc1xuZnVuY3Rpb24gdmlzaWJsZSggZWxlbWVudCApIHtcblx0dmFyIHZpc2liaWxpdHkgPSBlbGVtZW50LmNzcyggXCJ2aXNpYmlsaXR5XCIgKTtcblx0d2hpbGUgKCB2aXNpYmlsaXR5ID09PSBcImluaGVyaXRcIiApIHtcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQoKTtcblx0XHR2aXNpYmlsaXR5ID0gZWxlbWVudC5jc3MoIFwidmlzaWJpbGl0eVwiICk7XG5cdH1cblx0cmV0dXJuIHZpc2liaWxpdHkgIT09IFwiaGlkZGVuXCI7XG59XG5cbiQuZXh0ZW5kKCAkLmV4cHJbIFwiOlwiIF0sIHtcblx0Zm9jdXNhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRyZXR1cm4gJC51aS5mb2N1c2FibGUoIGVsZW1lbnQsICQuYXR0ciggZWxlbWVudCwgXCJ0YWJpbmRleFwiICkgIT0gbnVsbCApO1xuXHR9XG59ICk7XG5cbnZhciBmb2N1c2FibGUgPSAkLnVpLmZvY3VzYWJsZTtcblxuXG5cblxuLy8gU3VwcG9ydDogSUU4IE9ubHlcbi8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBmb3JtIGF0dHJpYnV0ZSBhbmQgd2hlbiBpdCBpcyBzdXBwbGllZC4gSXQgb3ZlcndyaXRlcyB0aGUgZm9ybSBwcm9wXG4vLyB3aXRoIGEgc3RyaW5nLCBzbyB3ZSBuZWVkIHRvIGZpbmQgdGhlIHByb3BlciBmb3JtLlxudmFyIGZvcm0gPSAkLmZuLmZvcm0gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHR5cGVvZiB0aGlzWyAwIF0uZm9ybSA9PT0gXCJzdHJpbmdcIiA/IHRoaXMuY2xvc2VzdCggXCJmb3JtXCIgKSA6ICQoIHRoaXNbIDAgXS5mb3JtICk7XG59O1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIEZvcm0gUmVzZXQgTWl4aW4gMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IEZvcm0gUmVzZXQgTWl4aW5cbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBSZWZyZXNoIGlucHV0IHdpZGdldHMgd2hlbiB0aGVpciBmb3JtIGlzIHJlc2V0XG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZm9ybS1yZXNldC1taXhpbi9cblxuXG5cbnZhciBmb3JtUmVzZXRNaXhpbiA9ICQudWkuZm9ybVJlc2V0TWl4aW4gPSB7XG5cdF9mb3JtUmVzZXRIYW5kbGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZm9ybSA9ICQoIHRoaXMgKTtcblxuXHRcdC8vIFdhaXQgZm9yIHRoZSBmb3JtIHJlc2V0IHRvIGFjdHVhbGx5IGhhcHBlbiBiZWZvcmUgcmVmcmVzaGluZ1xuXHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluc3RhbmNlcyA9IGZvcm0uZGF0YSggXCJ1aS1mb3JtLXJlc2V0LWluc3RhbmNlc1wiICk7XG5cdFx0XHQkLmVhY2goIGluc3RhbmNlcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRfYmluZEZvcm1SZXNldEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZm9ybSA9IHRoaXMuZWxlbWVudC5mb3JtKCk7XG5cdFx0aWYgKCAhdGhpcy5mb3JtLmxlbmd0aCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaW5zdGFuY2VzID0gdGhpcy5mb3JtLmRhdGEoIFwidWktZm9ybS1yZXNldC1pbnN0YW5jZXNcIiApIHx8IFtdO1xuXHRcdGlmICggIWluc3RhbmNlcy5sZW5ndGggKSB7XG5cblx0XHRcdC8vIFdlIGRvbid0IHVzZSBfb24oKSBoZXJlIGJlY2F1c2Ugd2UgdXNlIGEgc2luZ2xlIGV2ZW50IGhhbmRsZXIgcGVyIGZvcm1cblx0XHRcdHRoaXMuZm9ybS5vbiggXCJyZXNldC51aS1mb3JtLXJlc2V0XCIsIHRoaXMuX2Zvcm1SZXNldEhhbmRsZXIgKTtcblx0XHR9XG5cdFx0aW5zdGFuY2VzLnB1c2goIHRoaXMgKTtcblx0XHR0aGlzLmZvcm0uZGF0YSggXCJ1aS1mb3JtLXJlc2V0LWluc3RhbmNlc1wiLCBpbnN0YW5jZXMgKTtcblx0fSxcblxuXHRfdW5iaW5kRm9ybVJlc2V0SGFuZGxlcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpcy5mb3JtLmxlbmd0aCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaW5zdGFuY2VzID0gdGhpcy5mb3JtLmRhdGEoIFwidWktZm9ybS1yZXNldC1pbnN0YW5jZXNcIiApO1xuXHRcdGluc3RhbmNlcy5zcGxpY2UoICQuaW5BcnJheSggdGhpcywgaW5zdGFuY2VzICksIDEgKTtcblx0XHRpZiAoIGluc3RhbmNlcy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmZvcm0uZGF0YSggXCJ1aS1mb3JtLXJlc2V0LWluc3RhbmNlc1wiLCBpbnN0YW5jZXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5mb3JtXG5cdFx0XHRcdC5yZW1vdmVEYXRhKCBcInVpLWZvcm0tcmVzZXQtaW5zdGFuY2VzXCIgKVxuXHRcdFx0XHQub2ZmKCBcInJlc2V0LnVpLWZvcm0tcmVzZXRcIiApO1xuXHRcdH1cblx0fVxufTtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBTdXBwb3J0IGZvciBqUXVlcnkgY29yZSAxLjcueCAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqL1xuXG4vLz4+bGFiZWw6IGpRdWVyeSAxLjcgU3VwcG9ydFxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IFN1cHBvcnQgdmVyc2lvbiAxLjcueCBvZiBqUXVlcnkgY29yZVxuXG5cblxuLy8gU3VwcG9ydDogalF1ZXJ5IDEuNyBvbmx5XG4vLyBOb3QgYSBncmVhdCB3YXkgdG8gY2hlY2sgdmVyc2lvbnMsIGJ1dCBzaW5jZSB3ZSBvbmx5IHN1cHBvcnQgMS43KyBhbmQgb25seVxuLy8gbmVlZCB0byBkZXRlY3QgPDEuOCwgdGhpcyBpcyBhIHNpbXBsZSBjaGVjayB0aGF0IHNob3VsZCBzdWZmaWNlLiBDaGVja2luZ1xuLy8gZm9yIFwiMS43LlwiIHdvdWxkIGJlIGEgYml0IHNhZmVyLCBidXQgdGhlIHZlcnNpb24gc3RyaW5nIGlzIDEuNywgbm90IDEuNy4wXG4vLyBhbmQgd2UnbGwgbmV2ZXIgcmVhY2ggMS43MC4wIChpZiB3ZSBkbywgd2UgY2VydGFpbmx5IHdvbid0IGJlIHN1cHBvcnRpbmdcbi8vIDEuNyBhbnltb3JlKS4gU2VlICMxMTE5NyBmb3Igd2h5IHdlJ3JlIG5vdCB1c2luZyBmZWF0dXJlIGRldGVjdGlvbi5cbmlmICggJC5mbi5qcXVlcnkuc3Vic3RyaW5nKCAwLCAzICkgPT09IFwiMS43XCIgKSB7XG5cblx0Ly8gU2V0dGVycyBmb3IgLmlubmVyV2lkdGgoKSwgLmlubmVySGVpZ2h0KCksIC5vdXRlcldpZHRoKCksIC5vdXRlckhlaWdodCgpXG5cdC8vIFVubGlrZSBqUXVlcnkgQ29yZSAxLjgrLCB0aGVzZSBvbmx5IHN1cHBvcnQgbnVtZXJpYyB2YWx1ZXMgdG8gc2V0IHRoZVxuXHQvLyBkaW1lbnNpb25zIGluIHBpeGVsc1xuXHQkLmVhY2goIFsgXCJXaWR0aFwiLCBcIkhlaWdodFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRcdHZhciBzaWRlID0gbmFtZSA9PT0gXCJXaWR0aFwiID8gWyBcIkxlZnRcIiwgXCJSaWdodFwiIF0gOiBbIFwiVG9wXCIsIFwiQm90dG9tXCIgXSxcblx0XHRcdHR5cGUgPSBuYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRvcmlnID0ge1xuXHRcdFx0XHRpbm5lcldpZHRoOiAkLmZuLmlubmVyV2lkdGgsXG5cdFx0XHRcdGlubmVySGVpZ2h0OiAkLmZuLmlubmVySGVpZ2h0LFxuXHRcdFx0XHRvdXRlcldpZHRoOiAkLmZuLm91dGVyV2lkdGgsXG5cdFx0XHRcdG91dGVySGVpZ2h0OiAkLmZuLm91dGVySGVpZ2h0XG5cdFx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVkdWNlKCBlbGVtLCBzaXplLCBib3JkZXIsIG1hcmdpbiApIHtcblx0XHRcdCQuZWFjaCggc2lkZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNpemUgLT0gcGFyc2VGbG9hdCggJC5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgdGhpcyApICkgfHwgMDtcblx0XHRcdFx0aWYgKCBib3JkZXIgKSB7XG5cdFx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJib3JkZXJcIiArIHRoaXMgKyBcIldpZHRoXCIgKSApIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXJnaW4gKSB7XG5cdFx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJtYXJnaW5cIiArIHRoaXMgKSApIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBzaXplO1xuXHRcdH1cblxuXHRcdCQuZm5bIFwiaW5uZXJcIiArIG5hbWUgXSA9IGZ1bmN0aW9uKCBzaXplICkge1xuXHRcdFx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBvcmlnWyBcImlubmVyXCIgKyBuYW1lIF0uY2FsbCggdGhpcyApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmNzcyggdHlwZSwgcmVkdWNlKCB0aGlzLCBzaXplICkgKyBcInB4XCIgKTtcblx0XHRcdH0gKTtcblx0XHR9O1xuXG5cdFx0JC5mblsgXCJvdXRlclwiICsgbmFtZSBdID0gZnVuY3Rpb24oIHNpemUsIG1hcmdpbiApIHtcblx0XHRcdGlmICggdHlwZW9mIHNpemUgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHJldHVybiBvcmlnWyBcIm91dGVyXCIgKyBuYW1lIF0uY2FsbCggdGhpcywgc2l6ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmNzcyggdHlwZSwgcmVkdWNlKCB0aGlzLCBzaXplLCB0cnVlLCBtYXJnaW4gKSArIFwicHhcIiApO1xuXHRcdFx0fSApO1xuXHRcdH07XG5cdH0gKTtcblxuXHQkLmZuLmFkZEJhY2sgPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9O1xufVxuXG47XG4vKiFcbiAqIGpRdWVyeSBVSSBLZXljb2RlIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBLZXljb2RlXG4vLz4+Z3JvdXA6IENvcmVcbi8vPj5kZXNjcmlwdGlvbjogUHJvdmlkZSBrZXljb2RlcyBhcyBrZXluYW1lc1xuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2pRdWVyeS51aS5rZXlDb2RlL1xuXG5cbnZhciBrZXljb2RlID0gJC51aS5rZXlDb2RlID0ge1xuXHRCQUNLU1BBQ0U6IDgsXG5cdENPTU1BOiAxODgsXG5cdERFTEVURTogNDYsXG5cdERPV046IDQwLFxuXHRFTkQ6IDM1LFxuXHRFTlRFUjogMTMsXG5cdEVTQ0FQRTogMjcsXG5cdEhPTUU6IDM2LFxuXHRMRUZUOiAzNyxcblx0UEFHRV9ET1dOOiAzNCxcblx0UEFHRV9VUDogMzMsXG5cdFBFUklPRDogMTkwLFxuXHRSSUdIVDogMzksXG5cdFNQQUNFOiAzMixcblx0VEFCOiA5LFxuXHRVUDogMzhcbn07XG5cblxuXG5cbi8vIEludGVybmFsIHVzZSBvbmx5XG52YXIgZXNjYXBlU2VsZWN0b3IgPSAkLnVpLmVzY2FwZVNlbGVjdG9yID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIHNlbGVjdG9yRXNjYXBlID0gLyhbIVwiIyQlJicoKSorLC4vOjs8PT4/QFtcXF1eYHt8fX5dKS9nO1xuXHRyZXR1cm4gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKCBzZWxlY3RvckVzY2FwZSwgXCJcXFxcJDFcIiApO1xuXHR9O1xufSApKCk7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgTGFiZWxzIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBsYWJlbHNcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBGaW5kIGFsbCB0aGUgbGFiZWxzIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGlucHV0XG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vbGFiZWxzL1xuXG5cblxudmFyIGxhYmVscyA9ICQuZm4ubGFiZWxzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBhbmNlc3Rvciwgc2VsZWN0b3IsIGlkLCBsYWJlbHMsIGFuY2VzdG9ycztcblxuXHQvLyBDaGVjayBjb250cm9sLmxhYmVscyBmaXJzdFxuXHRpZiAoIHRoaXNbIDAgXS5sYWJlbHMgJiYgdGhpc1sgMCBdLmxhYmVscy5sZW5ndGggKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB0aGlzWyAwIF0ubGFiZWxzICk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PSAxMSwgRkYgPD0gMzcsIEFuZHJvaWQgPD0gMi4zIG9ubHlcblx0Ly8gQWJvdmUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgY29udHJvbC5sYWJlbHMuIEV2ZXJ5dGhpbmcgYmVsb3cgaXMgdG8gc3VwcG9ydCB0aGVtXG5cdC8vIGFzIHdlbGwgYXMgZG9jdW1lbnQgZnJhZ21lbnRzLiBjb250cm9sLmxhYmVscyBkb2VzIG5vdCB3b3JrIG9uIGRvY3VtZW50IGZyYWdtZW50c1xuXHRsYWJlbHMgPSB0aGlzLmVxKCAwICkucGFyZW50cyggXCJsYWJlbFwiICk7XG5cblx0Ly8gTG9vayBmb3IgdGhlIGxhYmVsIGJhc2VkIG9uIHRoZSBpZFxuXHRpZCA9IHRoaXMuYXR0ciggXCJpZFwiICk7XG5cdGlmICggaWQgKSB7XG5cblx0XHQvLyBXZSBkb24ndCBzZWFyY2ggYWdhaW5zdCB0aGUgZG9jdW1lbnQgaW4gY2FzZSB0aGUgZWxlbWVudFxuXHRcdC8vIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBET01cblx0XHRhbmNlc3RvciA9IHRoaXMuZXEoIDAgKS5wYXJlbnRzKCkubGFzdCgpO1xuXG5cdFx0Ly8gR2V0IGEgZnVsbCBzZXQgb2YgdG9wIGxldmVsIGFuY2VzdG9yc1xuXHRcdGFuY2VzdG9ycyA9IGFuY2VzdG9yLmFkZCggYW5jZXN0b3IubGVuZ3RoID8gYW5jZXN0b3Iuc2libGluZ3MoKSA6IHRoaXMuc2libGluZ3MoKSApO1xuXG5cdFx0Ly8gQ3JlYXRlIGEgc2VsZWN0b3IgZm9yIHRoZSBsYWJlbCBiYXNlZCBvbiB0aGUgaWRcblx0XHRzZWxlY3RvciA9IFwibGFiZWxbZm9yPSdcIiArICQudWkuZXNjYXBlU2VsZWN0b3IoIGlkICkgKyBcIiddXCI7XG5cblx0XHRsYWJlbHMgPSBsYWJlbHMuYWRkKCBhbmNlc3RvcnMuZmluZCggc2VsZWN0b3IgKS5hZGRCYWNrKCBzZWxlY3RvciApICk7XG5cblx0fVxuXG5cdC8vIFJldHVybiB3aGF0ZXZlciB3ZSBoYXZlIGZvdW5kIGZvciBsYWJlbHNcblx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBsYWJlbHMgKTtcbn07XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgU2Nyb2xsIFBhcmVudCAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogc2Nyb2xsUGFyZW50XG4vLz4+Z3JvdXA6IENvcmVcbi8vPj5kZXNjcmlwdGlvbjogR2V0IHRoZSBjbG9zZXN0IGFuY2VzdG9yIGVsZW1lbnQgdGhhdCBpcyBzY3JvbGxhYmxlLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3Njcm9sbFBhcmVudC9cblxuXG5cbnZhciBzY3JvbGxQYXJlbnQgPSAkLmZuLnNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uKCBpbmNsdWRlSGlkZGVuICkge1xuXHR2YXIgcG9zaXRpb24gPSB0aGlzLmNzcyggXCJwb3NpdGlvblwiICksXG5cdFx0ZXhjbHVkZVN0YXRpY1BhcmVudCA9IHBvc2l0aW9uID09PSBcImFic29sdXRlXCIsXG5cdFx0b3ZlcmZsb3dSZWdleCA9IGluY2x1ZGVIaWRkZW4gPyAvKGF1dG98c2Nyb2xsfGhpZGRlbikvIDogLyhhdXRvfHNjcm9sbCkvLFxuXHRcdHNjcm9sbFBhcmVudCA9IHRoaXMucGFyZW50cygpLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gJCggdGhpcyApO1xuXHRcdFx0aWYgKCBleGNsdWRlU3RhdGljUGFyZW50ICYmIHBhcmVudC5jc3MoIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3ZlcmZsb3dSZWdleC50ZXN0KCBwYXJlbnQuY3NzKCBcIm92ZXJmbG93XCIgKSArIHBhcmVudC5jc3MoIFwib3ZlcmZsb3cteVwiICkgK1xuXHRcdFx0XHRwYXJlbnQuY3NzKCBcIm92ZXJmbG93LXhcIiApICk7XG5cdFx0fSApLmVxKCAwICk7XG5cblx0cmV0dXJuIHBvc2l0aW9uID09PSBcImZpeGVkXCIgfHwgIXNjcm9sbFBhcmVudC5sZW5ndGggP1xuXHRcdCQoIHRoaXNbIDAgXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgOlxuXHRcdHNjcm9sbFBhcmVudDtcbn07XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgVGFiYmFibGUgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IDp0YWJiYWJsZSBTZWxlY3RvclxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IFNlbGVjdHMgZWxlbWVudHMgd2hpY2ggY2FuIGJlIHRhYmJlZCB0by5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS90YWJiYWJsZS1zZWxlY3Rvci9cblxuXG5cbnZhciB0YWJiYWJsZSA9ICQuZXh0ZW5kKCAkLmV4cHJbIFwiOlwiIF0sIHtcblx0dGFiYmFibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciB0YWJJbmRleCA9ICQuYXR0ciggZWxlbWVudCwgXCJ0YWJpbmRleFwiICksXG5cdFx0XHRoYXNUYWJpbmRleCA9IHRhYkluZGV4ICE9IG51bGw7XG5cdFx0cmV0dXJuICggIWhhc1RhYmluZGV4IHx8IHRhYkluZGV4ID49IDAgKSAmJiAkLnVpLmZvY3VzYWJsZSggZWxlbWVudCwgaGFzVGFiaW5kZXggKTtcblx0fVxufSApO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIFVuaXF1ZSBJRCAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogdW5pcXVlSWRcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBGdW5jdGlvbnMgdG8gZ2VuZXJhdGUgYW5kIHJlbW92ZSB1bmlxdWVJZCdzXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vdW5pcXVlSWQvXG5cblxuXG52YXIgdW5pcXVlSWQgPSAkLmZuLmV4dGVuZCgge1xuXHR1bmlxdWVJZDogKCBmdW5jdGlvbigpIHtcblx0XHR2YXIgdXVpZCA9IDA7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5pZCApIHtcblx0XHRcdFx0XHR0aGlzLmlkID0gXCJ1aS1pZC1cIiArICggKyt1dWlkICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHR9ICkoKSxcblxuXHRyZW1vdmVVbmlxdWVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIC9edWktaWQtXFxkKyQvLnRlc3QoIHRoaXMuaWQgKSApIHtcblx0XHRcdFx0JCggdGhpcyApLnJlbW92ZUF0dHIoIFwiaWRcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cblxuXG59KSk7IiwiLyohXG4gKiBCb290c3RyYXAgdjMuMy43IChodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbSlcbiAqIENvcHlyaWdodCAyMDExLTIwMTggVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqL1xuXG4vKiFcbiAqIEdlbmVyYXRlZCB1c2luZyB0aGUgQm9vdHN0cmFwIEN1c3RvbWl6ZXIgKDxub25lPilcbiAqIENvbmZpZyBzYXZlZCB0byBjb25maWcuanNvbiBhbmQgPG5vbmU+XG4gKi9cbmlmICh0eXBlb2YgalF1ZXJ5ID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnknKVxufVxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIHZlcnNpb24gPSAkLmZuLmpxdWVyeS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJylcbiAgaWYgKCh2ZXJzaW9uWzBdIDwgMiAmJiB2ZXJzaW9uWzFdIDwgOSkgfHwgKHZlcnNpb25bMF0gPT0gMSAmJiB2ZXJzaW9uWzFdID09IDkgJiYgdmVyc2lvblsyXSA8IDEpIHx8ICh2ZXJzaW9uWzBdID4gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnkgdmVyc2lvbiAxLjkuMSBvciBoaWdoZXIsIGJ1dCBsb3dlciB0aGFuIHZlcnNpb24gNCcpXG4gIH1cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGFsZXJ0LmpzIHYzLjMuN1xuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jYWxlcnRzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTYgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQUxFUlQgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGRpc21pc3MgPSAnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJ1xuICB2YXIgQWxlcnQgICA9IGZ1bmN0aW9uIChlbCkge1xuICAgICQoZWwpLm9uKCdjbGljaycsIGRpc21pc3MsIHRoaXMuY2xvc2UpXG4gIH1cblxuICBBbGVydC5WRVJTSU9OID0gJzMuMy43J1xuXG4gIEFsZXJ0LlRSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBBbGVydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgICA9ICQodGhpcylcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIHZhciAkcGFyZW50ID0gJChzZWxlY3RvciA9PT0gJyMnID8gW10gOiBzZWxlY3RvcilcblxuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIGlmICghJHBhcmVudC5sZW5ndGgpIHtcbiAgICAgICRwYXJlbnQgPSAkdGhpcy5jbG9zZXN0KCcuYWxlcnQnKVxuICAgIH1cblxuICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnY2xvc2UuYnMuYWxlcnQnKSlcblxuICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoKSB7XG4gICAgICAvLyBkZXRhY2ggZnJvbSBwYXJlbnQsIGZpcmUgZXZlbnQgdGhlbiBjbGVhbiB1cCBkYXRhXG4gICAgICAkcGFyZW50LmRldGFjaCgpLnRyaWdnZXIoJ2Nsb3NlZC5icy5hbGVydCcpLnJlbW92ZSgpXG4gICAgfVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgJHBhcmVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICRwYXJlbnRcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgcmVtb3ZlRWxlbWVudClcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKEFsZXJ0LlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIHJlbW92ZUVsZW1lbnQoKVxuICB9XG5cblxuICAvLyBBTEVSVCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JzLmFsZXJ0JylcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5hbGVydCcsIChkYXRhID0gbmV3IEFsZXJ0KHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0uY2FsbCgkdGhpcylcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uYWxlcnRcblxuICAkLmZuLmFsZXJ0ICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uYWxlcnQuQ29uc3RydWN0b3IgPSBBbGVydFxuXG5cbiAgLy8gQUxFUlQgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmFsZXJ0Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5hbGVydCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEFMRVJUIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLmFsZXJ0LmRhdGEtYXBpJywgZGlzbWlzcywgQWxlcnQucHJvdG90eXBlLmNsb3NlKVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBkcm9wZG93bi5qcyB2My4zLjdcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Ryb3Bkb3duc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE2IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERST1BET1dOIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBiYWNrZHJvcCA9ICcuZHJvcGRvd24tYmFja2Ryb3AnXG4gIHZhciB0b2dnbGUgICA9ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSdcbiAgdmFyIERyb3Bkb3duID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAkKGVsZW1lbnQpLm9uKCdjbGljay5icy5kcm9wZG93bicsIHRoaXMudG9nZ2xlKVxuICB9XG5cbiAgRHJvcGRvd24uVkVSU0lPTiA9ICczLjMuNydcblxuICBmdW5jdGlvbiBnZXRQYXJlbnQoJHRoaXMpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiAvI1tBLVphLXpdLy50ZXN0KHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIHZhciAkcGFyZW50ID0gc2VsZWN0b3IgJiYgJChzZWxlY3RvcilcblxuICAgIHJldHVybiAkcGFyZW50ICYmICRwYXJlbnQubGVuZ3RoID8gJHBhcmVudCA6ICR0aGlzLnBhcmVudCgpXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhck1lbnVzKGUpIHtcbiAgICBpZiAoZSAmJiBlLndoaWNoID09PSAzKSByZXR1cm5cbiAgICAkKGJhY2tkcm9wKS5yZW1vdmUoKVxuICAgICQodG9nZ2xlKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgICAgICAgID0gJCh0aGlzKVxuICAgICAgdmFyICRwYXJlbnQgICAgICAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHsgcmVsYXRlZFRhcmdldDogdGhpcyB9XG5cbiAgICAgIGlmICghJHBhcmVudC5oYXNDbGFzcygnb3BlbicpKSByZXR1cm5cblxuICAgICAgaWYgKGUgJiYgZS50eXBlID09ICdjbGljaycgJiYgL2lucHV0fHRleHRhcmVhL2kudGVzdChlLnRhcmdldC50YWdOYW1lKSAmJiAkLmNvbnRhaW5zKCRwYXJlbnRbMF0sIGUudGFyZ2V0KSkgcmV0dXJuXG5cbiAgICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnaGlkZS5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICR0aGlzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKVxuICAgICAgJHBhcmVudC5yZW1vdmVDbGFzcygnb3BlbicpLnRyaWdnZXIoJC5FdmVudCgnaGlkZGVuLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG4gICAgfSlcbiAgfVxuXG4gIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyA9ICQodGhpcylcblxuICAgIGlmICgkdGhpcy5pcygnLmRpc2FibGVkLCA6ZGlzYWJsZWQnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHBhcmVudCAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgdmFyIGlzQWN0aXZlID0gJHBhcmVudC5oYXNDbGFzcygnb3BlbicpXG5cbiAgICBjbGVhck1lbnVzKClcblxuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgISRwYXJlbnQuY2xvc2VzdCgnLm5hdmJhci1uYXYnKS5sZW5ndGgpIHtcbiAgICAgICAgLy8gaWYgbW9iaWxlIHdlIHVzZSBhIGJhY2tkcm9wIGJlY2F1c2UgY2xpY2sgZXZlbnRzIGRvbid0IGRlbGVnYXRlXG4gICAgICAgICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgICAgLmFkZENsYXNzKCdkcm9wZG93bi1iYWNrZHJvcCcpXG4gICAgICAgICAgLmluc2VydEFmdGVyKCQodGhpcykpXG4gICAgICAgICAgLm9uKCdjbGljaycsIGNsZWFyTWVudXMpXG4gICAgICB9XG5cbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0geyByZWxhdGVkVGFyZ2V0OiB0aGlzIH1cbiAgICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnc2hvdy5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICR0aGlzXG4gICAgICAgIC50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKVxuXG4gICAgICAkcGFyZW50XG4gICAgICAgIC50b2dnbGVDbGFzcygnb3BlbicpXG4gICAgICAgIC50cmlnZ2VyKCQuRXZlbnQoJ3Nob3duLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCEvKDM4fDQwfDI3fDMyKS8udGVzdChlLndoaWNoKSB8fCAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpKSByZXR1cm5cblxuICAgIHZhciAkdGhpcyA9ICQodGhpcylcblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGlmICgkdGhpcy5pcygnLmRpc2FibGVkLCA6ZGlzYWJsZWQnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHBhcmVudCAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgdmFyIGlzQWN0aXZlID0gJHBhcmVudC5oYXNDbGFzcygnb3BlbicpXG5cbiAgICBpZiAoIWlzQWN0aXZlICYmIGUud2hpY2ggIT0gMjcgfHwgaXNBY3RpdmUgJiYgZS53aGljaCA9PSAyNykge1xuICAgICAgaWYgKGUud2hpY2ggPT0gMjcpICRwYXJlbnQuZmluZCh0b2dnbGUpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIHJldHVybiAkdGhpcy50cmlnZ2VyKCdjbGljaycpXG4gICAgfVxuXG4gICAgdmFyIGRlc2MgPSAnIGxpOm5vdCguZGlzYWJsZWQpOnZpc2libGUgYSdcbiAgICB2YXIgJGl0ZW1zID0gJHBhcmVudC5maW5kKCcuZHJvcGRvd24tbWVudScgKyBkZXNjKVxuXG4gICAgaWYgKCEkaXRlbXMubGVuZ3RoKSByZXR1cm5cblxuICAgIHZhciBpbmRleCA9ICRpdGVtcy5pbmRleChlLnRhcmdldClcblxuICAgIGlmIChlLndoaWNoID09IDM4ICYmIGluZGV4ID4gMCkgICAgICAgICAgICAgICAgIGluZGV4LS0gICAgICAgICAvLyB1cFxuICAgIGlmIChlLndoaWNoID09IDQwICYmIGluZGV4IDwgJGl0ZW1zLmxlbmd0aCAtIDEpIGluZGV4KysgICAgICAgICAvLyBkb3duXG4gICAgaWYgKCF+aW5kZXgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwXG5cbiAgICAkaXRlbXMuZXEoaW5kZXgpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgfVxuXG5cbiAgLy8gRFJPUERPV04gUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgPSAkdGhpcy5kYXRhKCdicy5kcm9wZG93bicpXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuZHJvcGRvd24nLCAoZGF0YSA9IG5ldyBEcm9wZG93bih0aGlzKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dLmNhbGwoJHRoaXMpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmRyb3Bkb3duXG5cbiAgJC5mbi5kcm9wZG93biAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yID0gRHJvcGRvd25cblxuXG4gIC8vIERST1BET1dOIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5kcm9wZG93bi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uZHJvcGRvd24gPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBBUFBMWSBUTyBTVEFOREFSRCBEUk9QRE9XTiBFTEVNRU5UU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIGNsZWFyTWVudXMpXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsICcuZHJvcGRvd24gZm9ybScsIGZ1bmN0aW9uIChlKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCkgfSlcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgdG9nZ2xlLCBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsIHRvZ2dsZSwgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJy5kcm9wZG93bi1tZW51JywgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IG1vZGFsLmpzIHYzLjMuN1xuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jbW9kYWxzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTYgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gTU9EQUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIE1vZGFsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgICAgICAgPSBvcHRpb25zXG4gICAgdGhpcy4kYm9keSAgICAgICAgICAgICAgID0gJChkb2N1bWVudC5ib2R5KVxuICAgIHRoaXMuJGVsZW1lbnQgICAgICAgICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLiRkaWFsb2cgICAgICAgICAgICAgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5tb2RhbC1kaWFsb2cnKVxuICAgIHRoaXMuJGJhY2tkcm9wICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLmlzU2hvd24gICAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5vcmlnaW5hbEJvZHlQYWQgICAgID0gbnVsbFxuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggICAgICA9IDBcbiAgICB0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdGUpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLmZpbmQoJy5tb2RhbC1jb250ZW50JylcbiAgICAgICAgLmxvYWQodGhpcy5vcHRpb25zLnJlbW90ZSwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdsb2FkZWQuYnMubW9kYWwnKVxuICAgICAgICB9LCB0aGlzKSlcbiAgICB9XG4gIH1cblxuICBNb2RhbC5WRVJTSU9OICA9ICczLjMuNydcblxuICBNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzAwXG4gIE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBNb2RhbC5ERUZBVUxUUyA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBzaG93OiB0cnVlXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KF9yZWxhdGVkVGFyZ2V0KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB2YXIgZSAgICA9ICQuRXZlbnQoJ3Nob3cuYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmICh0aGlzLmlzU2hvd24gfHwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLmlzU2hvd24gPSB0cnVlXG5cbiAgICB0aGlzLmNoZWNrU2Nyb2xsYmFyKClcbiAgICB0aGlzLnNldFNjcm9sbGJhcigpXG4gICAgdGhpcy4kYm9keS5hZGRDbGFzcygnbW9kYWwtb3BlbicpXG5cbiAgICB0aGlzLmVzY2FwZSgpXG4gICAgdGhpcy5yZXNpemUoKVxuXG4gICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcsICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLCAkLnByb3h5KHRoaXMuaGlkZSwgdGhpcykpXG5cbiAgICB0aGlzLiRkaWFsb2cub24oJ21vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC4kZWxlbWVudC5vbmUoJ21vdXNldXAuZGlzbWlzcy5icy5tb2RhbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyh0aGF0LiRlbGVtZW50KSkgdGhhdC5pZ25vcmVCYWNrZHJvcENsaWNrID0gdHJ1ZVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5iYWNrZHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9ICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoYXQuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKVxuXG4gICAgICBpZiAoIXRoYXQuJGVsZW1lbnQucGFyZW50KCkubGVuZ3RoKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnQuYXBwZW5kVG8odGhhdC4kYm9keSkgLy8gZG9uJ3QgbW92ZSBtb2RhbHMgZG9tIHBvc2l0aW9uXG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLnNob3coKVxuICAgICAgICAuc2Nyb2xsVG9wKDApXG5cbiAgICAgIHRoYXQuYWRqdXN0RGlhbG9nKClcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhhdC4kZWxlbWVudFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcbiAgICAgIH1cblxuICAgICAgdGhhdC4kZWxlbWVudC5hZGRDbGFzcygnaW4nKVxuXG4gICAgICB0aGF0LmVuZm9yY2VGb2N1cygpXG5cbiAgICAgIHZhciBlID0gJC5FdmVudCgnc2hvd24uYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICAgIHRyYW5zaXRpb24gP1xuICAgICAgICB0aGF0LiRkaWFsb2cgLy8gd2FpdCBmb3IgbW9kYWwgdG8gc2xpZGUgaW5cbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcihlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpLnRyaWdnZXIoZSlcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIGUgPSAkLkV2ZW50KCdoaWRlLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKCF0aGlzLmlzU2hvd24gfHwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLmlzU2hvd24gPSBmYWxzZVxuXG4gICAgdGhpcy5lc2NhcGUoKVxuICAgIHRoaXMucmVzaXplKClcblxuICAgICQoZG9jdW1lbnQpLm9mZignZm9jdXNpbi5icy5tb2RhbCcpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAucmVtb3ZlQ2xhc3MoJ2luJylcbiAgICAgIC5vZmYoJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnKVxuICAgICAgLm9mZignbW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGRpYWxvZy5vZmYoJ21vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsJylcblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsICQucHJveHkodGhpcy5oaWRlTW9kYWwsIHRoaXMpKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgdGhpcy5oaWRlTW9kYWwoKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmVuZm9yY2VGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAkKGRvY3VtZW50KVxuICAgICAgLm9mZignZm9jdXNpbi5icy5tb2RhbCcpIC8vIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxuICAgICAgLm9uKCdmb2N1c2luLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZG9jdW1lbnQgIT09IGUudGFyZ2V0ICYmXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50WzBdICE9PSBlLnRhcmdldCAmJlxuICAgICAgICAgICAgIXRoaXMuJGVsZW1lbnQuaGFzKGUudGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcykpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuZXNjYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzU2hvd24gJiYgdGhpcy5vcHRpb25zLmtleWJvYXJkKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdrZXlkb3duLmRpc21pc3MuYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUud2hpY2ggPT0gMjcgJiYgdGhpcy5oaWRlKClcbiAgICAgIH0sIHRoaXMpKVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTaG93bikge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ2tleWRvd24uZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1Nob3duKSB7XG4gICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS5icy5tb2RhbCcsICQucHJveHkodGhpcy5oYW5kbGVVcGRhdGUsIHRoaXMpKVxuICAgIH0gZWxzZSB7XG4gICAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUuYnMubW9kYWwnKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5oaWRlTW9kYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdGhpcy4kZWxlbWVudC5oaWRlKClcbiAgICB0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGJvZHkucmVtb3ZlQ2xhc3MoJ21vZGFsLW9wZW4nKVxuICAgICAgdGhhdC5yZXNldEFkanVzdG1lbnRzKClcbiAgICAgIHRoYXQucmVzZXRTY3JvbGxiYXIoKVxuICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdoaWRkZW4uYnMubW9kYWwnKVxuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVtb3ZlQmFja2Ryb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kYmFja2Ryb3AgJiYgdGhpcy4kYmFja2Ryb3AucmVtb3ZlKClcbiAgICB0aGlzLiRiYWNrZHJvcCA9IG51bGxcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5iYWNrZHJvcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciBhbmltYXRlID0gdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID8gJ2ZhZGUnIDogJydcblxuICAgIGlmICh0aGlzLmlzU2hvd24gJiYgdGhpcy5vcHRpb25zLmJhY2tkcm9wKSB7XG4gICAgICB2YXIgZG9BbmltYXRlID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgYW5pbWF0ZVxuXG4gICAgICB0aGlzLiRiYWNrZHJvcCA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgIC5hZGRDbGFzcygnbW9kYWwtYmFja2Ryb3AgJyArIGFuaW1hdGUpXG4gICAgICAgIC5hcHBlbmRUbyh0aGlzLiRib2R5KVxuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay5kaXNtaXNzLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2VcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCkgcmV0dXJuXG4gICAgICAgIHRoaXMub3B0aW9ucy5iYWNrZHJvcCA9PSAnc3RhdGljJ1xuICAgICAgICAgID8gdGhpcy4kZWxlbWVudFswXS5mb2N1cygpXG4gICAgICAgICAgOiB0aGlzLmhpZGUoKVxuICAgICAgfSwgdGhpcykpXG5cbiAgICAgIGlmIChkb0FuaW1hdGUpIHRoaXMuJGJhY2tkcm9wWzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuXG4gICAgICB0aGlzLiRiYWNrZHJvcC5hZGRDbGFzcygnaW4nKVxuXG4gICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm5cblxuICAgICAgZG9BbmltYXRlID9cbiAgICAgICAgdGhpcy4kYmFja2Ryb3BcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjYWxsYmFjaylcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjYWxsYmFjaygpXG5cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24gJiYgdGhpcy4kYmFja2Ryb3ApIHtcbiAgICAgIHRoaXMuJGJhY2tkcm9wLnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5yZW1vdmVCYWNrZHJvcCgpXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2tSZW1vdmUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2tSZW1vdmUoKVxuXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIC8vIHRoZXNlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcblxuICBNb2RhbC5wcm90b3R5cGUuaGFuZGxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRqdXN0RGlhbG9nKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5hZGp1c3REaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGFsSXNPdmVyZmxvd2luZyA9IHRoaXMuJGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuXG4gICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgcGFkZGluZ0xlZnQ6ICAhdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiBtb2RhbElzT3ZlcmZsb3dpbmcgPyB0aGlzLnNjcm9sbGJhcldpZHRoIDogJycsXG4gICAgICBwYWRkaW5nUmlnaHQ6IHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgJiYgIW1vZGFsSXNPdmVyZmxvd2luZyA/IHRoaXMuc2Nyb2xsYmFyV2lkdGggOiAnJ1xuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzZXRBZGp1c3RtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICBwYWRkaW5nTGVmdDogJycsXG4gICAgICBwYWRkaW5nUmlnaHQ6ICcnXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5jaGVja1Njcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnVsbFdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGhcbiAgICBpZiAoIWZ1bGxXaW5kb3dXaWR0aCkgeyAvLyB3b3JrYXJvdW5kIGZvciBtaXNzaW5nIHdpbmRvdy5pbm5lcldpZHRoIGluIElFOFxuICAgICAgdmFyIGRvY3VtZW50RWxlbWVudFJlY3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGZ1bGxXaW5kb3dXaWR0aCA9IGRvY3VtZW50RWxlbWVudFJlY3QucmlnaHQgLSBNYXRoLmFicyhkb2N1bWVudEVsZW1lbnRSZWN0LmxlZnQpXG4gICAgfVxuICAgIHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIDwgZnVsbFdpbmRvd1dpZHRoXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCA9IHRoaXMubWVhc3VyZVNjcm9sbGJhcigpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBib2R5UGFkID0gcGFyc2VJbnQoKHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JykgfHwgMCksIDEwKVxuICAgIHRoaXMub3JpZ2luYWxCb2R5UGFkID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgfHwgJydcbiAgICBpZiAodGhpcy5ib2R5SXNPdmVyZmxvd2luZykgdGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBib2R5UGFkICsgdGhpcy5zY3JvbGxiYXJXaWR0aClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZXNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcsIHRoaXMub3JpZ2luYWxCb2R5UGFkKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLm1lYXN1cmVTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7IC8vIHRoeCB3YWxzaFxuICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHNjcm9sbERpdi5jbGFzc05hbWUgPSAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnXG4gICAgdGhpcy4kYm9keS5hcHBlbmQoc2Nyb2xsRGl2KVxuICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aFxuICAgIHRoaXMuJGJvZHlbMF0ucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KVxuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aFxuICB9XG5cblxuICAvLyBNT0RBTCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24sIF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMubW9kYWwnKVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTW9kYWwuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMubW9kYWwnLCAoZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKF9yZWxhdGVkVGFyZ2V0KVxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5zaG93KSBkYXRhLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLm1vZGFsXG5cbiAgJC5mbi5tb2RhbCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLm1vZGFsLkNvbnN0cnVjdG9yID0gTW9kYWxcblxuXG4gIC8vIE1PREFMIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5tb2RhbC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4ubW9kYWwgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBNT0RBTCBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay5icy5tb2RhbC5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgdmFyIGhyZWYgICAgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICB2YXIgJHRhcmdldCA9ICQoJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSB8fCAoaHJlZiAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSkpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB2YXIgb3B0aW9uICA9ICR0YXJnZXQuZGF0YSgnYnMubW9kYWwnKSA/ICd0b2dnbGUnIDogJC5leHRlbmQoeyByZW1vdGU6ICEvIy8udGVzdChocmVmKSAmJiBocmVmIH0sICR0YXJnZXQuZGF0YSgpLCAkdGhpcy5kYXRhKCkpXG5cbiAgICBpZiAoJHRoaXMuaXMoJ2EnKSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAkdGFyZ2V0Lm9uZSgnc2hvdy5icy5tb2RhbCcsIGZ1bmN0aW9uIChzaG93RXZlbnQpIHtcbiAgICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVybiAvLyBvbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXG4gICAgICAkdGFyZ2V0Lm9uZSgnaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAkdGhpcy5pcygnOnZpc2libGUnKSAmJiAkdGhpcy50cmlnZ2VyKCdmb2N1cycpXG4gICAgICB9KVxuICAgIH0pXG4gICAgUGx1Z2luLmNhbGwoJHRhcmdldCwgb3B0aW9uLCB0aGlzKVxuICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0cmFuc2l0aW9uLmpzIHYzLjMuN1xuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdHJhbnNpdGlvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDU1MgVFJBTlNJVElPTiBTVVBQT1JUIChTaG91dG91dDogaHR0cDovL3d3dy5tb2Rlcm5penIuY29tLylcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib290c3RyYXAnKVxuXG4gICAgdmFyIHRyYW5zRW5kRXZlbnROYW1lcyA9IHtcbiAgICAgIFdlYmtpdFRyYW5zaXRpb24gOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICBNb3pUcmFuc2l0aW9uICAgIDogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgT1RyYW5zaXRpb24gICAgICA6ICdvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCcsXG4gICAgICB0cmFuc2l0aW9uICAgICAgIDogJ3RyYW5zaXRpb25lbmQnXG4gICAgfVxuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB0cmFuc0VuZEV2ZW50TmFtZXMpIHtcbiAgICAgIGlmIChlbC5zdHlsZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7IGVuZDogdHJhbnNFbmRFdmVudE5hbWVzW25hbWVdIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgLy8gZXhwbGljaXQgZm9yIGllOCAoICAuXy4pXG4gIH1cblxuICAvLyBodHRwOi8vYmxvZy5hbGV4bWFjY2F3LmNvbS9jc3MtdHJhbnNpdGlvbnNcbiAgJC5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZVxuICAgIHZhciAkZWwgPSB0aGlzXG4gICAgJCh0aGlzKS5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZSB9KVxuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgaWYgKCFjYWxsZWQpICQoJGVsKS50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCkgfVxuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIGR1cmF0aW9uKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAkKGZ1bmN0aW9uICgpIHtcbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25FbmQoKVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuXG5cbiAgICAkLmV2ZW50LnNwZWNpYWwuYnNUcmFuc2l0aW9uRW5kID0ge1xuICAgICAgYmluZFR5cGU6ICQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxcbiAgICAgIGRlbGVnYXRlVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXModGhpcykpIHJldHVybiBlLmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qIVxuICogU2VsZWN0MiA0LjAuM1xuICogaHR0cHM6Ly9zZWxlY3QyLmdpdGh1Yi5pb1xuICpcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3NlbGVjdDIvc2VsZWN0Mi9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4gKi9cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBOb2RlL0NvbW1vbkpTXG4gICAgZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZmFjdG9yeShqUXVlcnkpO1xuICB9XG59KGZ1bmN0aW9uIChqUXVlcnkpIHtcbiAgLy8gVGhpcyBpcyBuZWVkZWQgc28gd2UgY2FuIGNhdGNoIHRoZSBBTUQgbG9hZGVyIGNvbmZpZ3VyYXRpb24gYW5kIHVzZSBpdFxuICAvLyBUaGUgaW5uZXIgZmlsZSBzaG91bGQgYmUgd3JhcHBlZCAoYnkgYGJhbm5lci5zdGFydC5qc2ApIGluIGEgZnVuY3Rpb24gdGhhdFxuICAvLyByZXR1cm5zIHRoZSBBTUQgbG9hZGVyIHJlZmVyZW5jZXMuXG4gIHZhciBTMiA9XG4oZnVuY3Rpb24gKCkge1xuICAvLyBSZXN0b3JlIHRoZSBTZWxlY3QyIEFNRCBsb2FkZXIgc28gaXQgY2FuIGJlIHVzZWRcbiAgLy8gTmVlZGVkIG1vc3RseSBpbiB0aGUgbGFuZ3VhZ2UgZmlsZXMsIHdoZXJlIHRoZSBsb2FkZXIgaXMgbm90IGluc2VydGVkXG4gIGlmIChqUXVlcnkgJiYgalF1ZXJ5LmZuICYmIGpRdWVyeS5mbi5zZWxlY3QyICYmIGpRdWVyeS5mbi5zZWxlY3QyLmFtZCkge1xuICAgIHZhciBTMiA9IGpRdWVyeS5mbi5zZWxlY3QyLmFtZDtcbiAgfVxudmFyIFMyOyhmdW5jdGlvbiAoKSB7IGlmICghUzIgfHwgIVMyLnJlcXVpcmVqcykge1xuaWYgKCFTMikgeyBTMiA9IHt9OyB9IGVsc2UgeyByZXF1aXJlID0gUzI7IH1cbi8qKlxuICogQGxpY2Vuc2UgYWxtb25kIDAuMy4xIENvcHlyaWdodCAoYykgMjAxMS0yMDE0LCBUaGUgRG9qbyBGb3VuZGF0aW9uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBBdmFpbGFibGUgdmlhIHRoZSBNSVQgb3IgbmV3IEJTRCBsaWNlbnNlLlxuICogc2VlOiBodHRwOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL2FsbW9uZCBmb3IgZGV0YWlsc1xuICovXG4vL0dvaW5nIHNsb3BweSB0byBhdm9pZCAndXNlIHN0cmljdCcgc3RyaW5nIGNvc3QsIGJ1dCBzdHJpY3QgcHJhY3RpY2VzIHNob3VsZFxuLy9iZSBmb2xsb3dlZC5cbi8qanNsaW50IHNsb3BweTogdHJ1ZSAqL1xuLypnbG9iYWwgc2V0VGltZW91dDogZmFsc2UgKi9cblxudmFyIHJlcXVpcmVqcywgcmVxdWlyZSwgZGVmaW5lO1xuKGZ1bmN0aW9uICh1bmRlZikge1xuICAgIHZhciBtYWluLCByZXEsIG1ha2VNYXAsIGhhbmRsZXJzLFxuICAgICAgICBkZWZpbmVkID0ge30sXG4gICAgICAgIHdhaXRpbmcgPSB7fSxcbiAgICAgICAgY29uZmlnID0ge30sXG4gICAgICAgIGRlZmluaW5nID0ge30sXG4gICAgICAgIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGFwcyA9IFtdLnNsaWNlLFxuICAgICAgICBqc1N1ZmZpeFJlZ0V4cCA9IC9cXC5qcyQvO1xuXG4gICAgZnVuY3Rpb24gaGFzUHJvcChvYmosIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGhhc093bi5jYWxsKG9iaiwgcHJvcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSByZWxhdGl2ZSBtb2R1bGUgbmFtZSwgbGlrZSAuL3NvbWV0aGluZywgbm9ybWFsaXplIGl0IHRvXG4gICAgICogYSByZWFsIG5hbWUgdGhhdCBjYW4gYmUgbWFwcGVkIHRvIGEgcGF0aC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgcmVsYXRpdmUgbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlTmFtZSBhIHJlYWwgbmFtZSB0aGF0IHRoZSBuYW1lIGFyZyBpcyByZWxhdGl2ZVxuICAgICAqIHRvLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IG5vcm1hbGl6ZWQgbmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBiYXNlTmFtZSkge1xuICAgICAgICB2YXIgbmFtZVBhcnRzLCBuYW1lU2VnbWVudCwgbWFwVmFsdWUsIGZvdW5kTWFwLCBsYXN0SW5kZXgsXG4gICAgICAgICAgICBmb3VuZEksIGZvdW5kU3Rhck1hcCwgc3RhckksIGksIGosIHBhcnQsXG4gICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlTmFtZSAmJiBiYXNlTmFtZS5zcGxpdChcIi9cIiksXG4gICAgICAgICAgICBtYXAgPSBjb25maWcubWFwLFxuICAgICAgICAgICAgc3Rhck1hcCA9IChtYXAgJiYgbWFwWycqJ10pIHx8IHt9O1xuXG4gICAgICAgIC8vQWRqdXN0IGFueSByZWxhdGl2ZSBwYXRocy5cbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5jaGFyQXQoMCkgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAvL0lmIGhhdmUgYSBiYXNlIG5hbWUsIHRyeSB0byBub3JtYWxpemUgYWdhaW5zdCBpdCxcbiAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCBhc3N1bWUgaXQgaXMgYSB0b3AtbGV2ZWwgcmVxdWlyZSB0aGF0IHdpbGxcbiAgICAgICAgICAgIC8vYmUgcmVsYXRpdmUgdG8gYmFzZVVybCBpbiB0aGUgZW5kLlxuICAgICAgICAgICAgaWYgKGJhc2VOYW1lKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBuYW1lLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgICAgICAvLyBOb2RlIC5qcyBhbGxvd2FuY2U6XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5ub2RlSWRDb21wYXQgJiYganNTdWZmaXhSZWdFeHAudGVzdChuYW1lW2xhc3RJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVbbGFzdEluZGV4XSA9IG5hbWVbbGFzdEluZGV4XS5yZXBsYWNlKGpzU3VmZml4UmVnRXhwLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9Mb3Agb2ZmIHRoZSBsYXN0IHBhcnQgb2YgYmFzZVBhcnRzLCBzbyB0aGF0IC4gbWF0Y2hlcyB0aGVcbiAgICAgICAgICAgICAgICAvL1wiZGlyZWN0b3J5XCIgYW5kIG5vdCBuYW1lIG9mIHRoZSBiYXNlTmFtZSdzIG1vZHVsZS4gRm9yIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIC8vYmFzZU5hbWUgb2YgXCJvbmUvdHdvL3RocmVlXCIsIG1hcHMgdG8gXCJvbmUvdHdvL3RocmVlLmpzXCIsIGJ1dCB3ZVxuICAgICAgICAgICAgICAgIC8vd2FudCB0aGUgZGlyZWN0b3J5LCBcIm9uZS90d29cIiBmb3IgdGhpcyBub3JtYWxpemF0aW9uLlxuICAgICAgICAgICAgICAgIG5hbWUgPSBiYXNlUGFydHMuc2xpY2UoMCwgYmFzZVBhcnRzLmxlbmd0aCAtIDEpLmNvbmNhdChuYW1lKTtcblxuICAgICAgICAgICAgICAgIC8vc3RhcnQgdHJpbURvdHNcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gbmFtZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIChuYW1lWzJdID09PSAnLi4nIHx8IG5hbWVbMF0gPT09ICcuLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9FbmQgb2YgdGhlIGxpbmUuIEtlZXAgYXQgbGVhc3Qgb25lIG5vbi1kb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3BhdGggc2VnbWVudCBhdCB0aGUgZnJvbnQgc28gaXQgY2FuIGJlIG1hcHBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29ycmVjdGx5IHRvIGRpc2suIE90aGVyd2lzZSwgdGhlcmUgaXMgbGlrZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ubyBwYXRoIG1hcHBpbmcgZm9yIGEgcGF0aCBzdGFydGluZyB3aXRoICcuLicuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNhbiBzdGlsbCBmYWlsLCBidXQgY2F0Y2hlcyB0aGUgbW9zdCByZWFzb25hYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy91c2VzIG9mIC4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZS5zcGxpY2UoaSAtIDEsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2VuZCB0cmltRG90c1xuXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuam9pbihcIi9cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZignLi8nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIGJhc2VOYW1lLCBzbyB0aGlzIGlzIElEIGlzIHJlc29sdmVkIHJlbGF0aXZlXG4gICAgICAgICAgICAgICAgLy8gdG8gYmFzZVVybCwgcHVsbCBvZmYgdGhlIGxlYWRpbmcgZG90LlxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vQXBwbHkgbWFwIGNvbmZpZyBpZiBhdmFpbGFibGUuXG4gICAgICAgIGlmICgoYmFzZVBhcnRzIHx8IHN0YXJNYXApICYmIG1hcCkge1xuICAgICAgICAgICAgbmFtZVBhcnRzID0gbmFtZS5zcGxpdCgnLycpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSBuYW1lUGFydHMubGVuZ3RoOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgbmFtZVNlZ21lbnQgPSBuYW1lUGFydHMuc2xpY2UoMCwgaSkuam9pbihcIi9cIik7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZVBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vRmluZCB0aGUgbG9uZ2VzdCBiYXNlTmFtZSBzZWdtZW50IG1hdGNoIGluIHRoZSBjb25maWcuXG4gICAgICAgICAgICAgICAgICAgIC8vU28sIGRvIGpvaW5zIG9uIHRoZSBiaWdnZXN0IHRvIHNtYWxsZXN0IGxlbmd0aHMgb2YgYmFzZVBhcnRzLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBiYXNlUGFydHMubGVuZ3RoOyBqID4gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZSA9IG1hcFtiYXNlUGFydHMuc2xpY2UoMCwgaikuam9pbignLycpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9iYXNlTmFtZSBzZWdtZW50IGhhcyAgY29uZmlnLCBmaW5kIGlmIGl0IGhhcyBvbmUgZm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcFZhbHVlID0gbWFwVmFsdWVbbmFtZVNlZ21lbnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL01hdGNoLCB1cGRhdGUgbmFtZSB0byB0aGUgbmV3IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZE1hcCA9IG1hcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEkgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZm91bmRNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9DaGVjayBmb3IgYSBzdGFyIG1hcCBtYXRjaCwgYnV0IGp1c3QgaG9sZCBvbiB0byBpdCxcbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGlzIGEgc2hvcnRlciBzZWdtZW50IG1hdGNoIGxhdGVyIGluIGEgbWF0Y2hpbmdcbiAgICAgICAgICAgICAgICAvL2NvbmZpZywgdGhlbiBmYXZvciBvdmVyIHRoaXMgc3RhciBtYXAuXG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZFN0YXJNYXAgJiYgc3Rhck1hcCAmJiBzdGFyTWFwW25hbWVTZWdtZW50XSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFN0YXJNYXAgPSBzdGFyTWFwW25hbWVTZWdtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgc3RhckkgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmb3VuZE1hcCAmJiBmb3VuZFN0YXJNYXApIHtcbiAgICAgICAgICAgICAgICBmb3VuZE1hcCA9IGZvdW5kU3Rhck1hcDtcbiAgICAgICAgICAgICAgICBmb3VuZEkgPSBzdGFySTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvdW5kTWFwKSB7XG4gICAgICAgICAgICAgICAgbmFtZVBhcnRzLnNwbGljZSgwLCBmb3VuZEksIGZvdW5kTWFwKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZVBhcnRzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VSZXF1aXJlKHJlbE5hbWUsIGZvcmNlU3luYykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy9BIHZlcnNpb24gb2YgYSByZXF1aXJlIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIGEgbW9kdWxlTmFtZVxuICAgICAgICAgICAgLy92YWx1ZSBmb3IgaXRlbXMgdGhhdCBtYXkgbmVlZCB0b1xuICAgICAgICAgICAgLy9sb29rIHVwIHBhdGhzIHJlbGF0aXZlIHRvIHRoZSBtb2R1bGVOYW1lXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFwcy5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgICAgIC8vSWYgZmlyc3QgYXJnIGlzIG5vdCByZXF1aXJlKCdzdHJpbmcnKSwgYW5kIHRoZXJlIGlzIG9ubHlcbiAgICAgICAgICAgIC8vb25lIGFyZywgaXQgaXMgdGhlIGFycmF5IGZvcm0gd2l0aG91dCBhIGNhbGxiYWNrLiBJbnNlcnRcbiAgICAgICAgICAgIC8vYSBudWxsIHNvIHRoYXQgdGhlIGZvbGxvd2luZyBjb25jYXQgaXMgY29ycmVjdC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycgJiYgYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVxLmFwcGx5KHVuZGVmLCBhcmdzLmNvbmNhdChbcmVsTmFtZSwgZm9yY2VTeW5jXSkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VOb3JtYWxpemUocmVsTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUobmFtZSwgcmVsTmFtZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUxvYWQoZGVwTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBkZWZpbmVkW2RlcE5hbWVdID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsbERlcChuYW1lKSB7XG4gICAgICAgIGlmIChoYXNQcm9wKHdhaXRpbmcsIG5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHdhaXRpbmdbbmFtZV07XG4gICAgICAgICAgICBkZWxldGUgd2FpdGluZ1tuYW1lXTtcbiAgICAgICAgICAgIGRlZmluaW5nW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIG1haW4uYXBwbHkodW5kZWYsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNQcm9wKGRlZmluZWQsIG5hbWUpICYmICFoYXNQcm9wKGRlZmluaW5nLCBuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyAnICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluZWRbbmFtZV07XG4gICAgfVxuXG4gICAgLy9UdXJucyBhIHBsdWdpbiFyZXNvdXJjZSB0byBbcGx1Z2luLCByZXNvdXJjZV1cbiAgICAvL3dpdGggdGhlIHBsdWdpbiBiZWluZyB1bmRlZmluZWQgaWYgdGhlIG5hbWVcbiAgICAvL2RpZCBub3QgaGF2ZSBhIHBsdWdpbiBwcmVmaXguXG4gICAgZnVuY3Rpb24gc3BsaXRQcmVmaXgobmFtZSkge1xuICAgICAgICB2YXIgcHJlZml4LFxuICAgICAgICAgICAgaW5kZXggPSBuYW1lID8gbmFtZS5pbmRleE9mKCchJykgOiAtMTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IG5hbWUuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhpbmRleCArIDEsIG5hbWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYSBuYW1lIG1hcCwgbm9ybWFsaXppbmcgdGhlIG5hbWUsIGFuZCB1c2luZyBhIHBsdWdpblxuICAgICAqIGZvciBub3JtYWxpemF0aW9uIGlmIG5lY2Vzc2FyeS4gR3JhYnMgYSByZWYgdG8gcGx1Z2luXG4gICAgICogdG9vLCBhcyBhbiBvcHRpbWl6YXRpb24uXG4gICAgICovXG4gICAgbWFrZU1hcCA9IGZ1bmN0aW9uIChuYW1lLCByZWxOYW1lKSB7XG4gICAgICAgIHZhciBwbHVnaW4sXG4gICAgICAgICAgICBwYXJ0cyA9IHNwbGl0UHJlZml4KG5hbWUpLFxuICAgICAgICAgICAgcHJlZml4ID0gcGFydHNbMF07XG5cbiAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xuXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IG5vcm1hbGl6ZShwcmVmaXgsIHJlbE5hbWUpO1xuICAgICAgICAgICAgcGx1Z2luID0gY2FsbERlcChwcmVmaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9Ob3JtYWxpemUgYWNjb3JkaW5nXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4gJiYgcGx1Z2luLm5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBwbHVnaW4ubm9ybWFsaXplKG5hbWUsIG1ha2VOb3JtYWxpemUocmVsTmFtZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZShuYW1lLCByZWxOYW1lKTtcbiAgICAgICAgICAgIHBhcnRzID0gc3BsaXRQcmVmaXgobmFtZSk7XG4gICAgICAgICAgICBwcmVmaXggPSBwYXJ0c1swXTtcbiAgICAgICAgICAgIG5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4gPSBjYWxsRGVwKHByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL1VzaW5nIHJpZGljdWxvdXMgcHJvcGVydHkgbmFtZXMgZm9yIHNwYWNlIHJlYXNvbnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGY6IHByZWZpeCA/IHByZWZpeCArICchJyArIG5hbWUgOiBuYW1lLCAvL2Z1bGxOYW1lXG4gICAgICAgICAgICBuOiBuYW1lLFxuICAgICAgICAgICAgcHI6IHByZWZpeCxcbiAgICAgICAgICAgIHA6IHBsdWdpblxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlQ29uZmlnKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoY29uZmlnICYmIGNvbmZpZy5jb25maWcgJiYgY29uZmlnLmNvbmZpZ1tuYW1lXSkgfHwge307XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaGFuZGxlcnMgPSB7XG4gICAgICAgIHJlcXVpcmU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZVJlcXVpcmUobmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGV4cG9ydHM6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGRlZmluZWRbbmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZGVmaW5lZFtuYW1lXSA9IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW9kdWxlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogbmFtZSxcbiAgICAgICAgICAgICAgICB1cmk6ICcnLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IGRlZmluZWRbbmFtZV0sXG4gICAgICAgICAgICAgICAgY29uZmlnOiBtYWtlQ29uZmlnKG5hbWUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1haW4gPSBmdW5jdGlvbiAobmFtZSwgZGVwcywgY2FsbGJhY2ssIHJlbE5hbWUpIHtcbiAgICAgICAgdmFyIGNqc01vZHVsZSwgZGVwTmFtZSwgcmV0LCBtYXAsIGksXG4gICAgICAgICAgICBhcmdzID0gW10sXG4gICAgICAgICAgICBjYWxsYmFja1R5cGUgPSB0eXBlb2YgY2FsbGJhY2ssXG4gICAgICAgICAgICB1c2luZ0V4cG9ydHM7XG5cbiAgICAgICAgLy9Vc2UgbmFtZSBpZiBubyByZWxOYW1lXG4gICAgICAgIHJlbE5hbWUgPSByZWxOYW1lIHx8IG5hbWU7XG5cbiAgICAgICAgLy9DYWxsIHRoZSBjYWxsYmFjayB0byBkZWZpbmUgdGhlIG1vZHVsZSwgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAoY2FsbGJhY2tUeXBlID09PSAndW5kZWZpbmVkJyB8fCBjYWxsYmFja1R5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vUHVsbCBvdXQgdGhlIGRlZmluZWQgZGVwZW5kZW5jaWVzIGFuZCBwYXNzIHRoZSBvcmRlcmVkXG4gICAgICAgICAgICAvL3ZhbHVlcyB0byB0aGUgY2FsbGJhY2suXG4gICAgICAgICAgICAvL0RlZmF1bHQgdG8gW3JlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZV0gaWYgbm8gZGVwc1xuICAgICAgICAgICAgZGVwcyA9ICFkZXBzLmxlbmd0aCAmJiBjYWxsYmFjay5sZW5ndGggPyBbJ3JlcXVpcmUnLCAnZXhwb3J0cycsICdtb2R1bGUnXSA6IGRlcHM7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIG1hcCA9IG1ha2VNYXAoZGVwc1tpXSwgcmVsTmFtZSk7XG4gICAgICAgICAgICAgICAgZGVwTmFtZSA9IG1hcC5mO1xuXG4gICAgICAgICAgICAgICAgLy9GYXN0IHBhdGggQ29tbW9uSlMgc3RhbmRhcmQgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgICAgIGlmIChkZXBOYW1lID09PSBcInJlcXVpcmVcIikge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gaGFuZGxlcnMucmVxdWlyZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlcE5hbWUgPT09IFwiZXhwb3J0c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vQ29tbW9uSlMgbW9kdWxlIHNwZWMgMS4xXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBoYW5kbGVycy5leHBvcnRzKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB1c2luZ0V4cG9ydHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwTmFtZSA9PT0gXCJtb2R1bGVcIikge1xuICAgICAgICAgICAgICAgICAgICAvL0NvbW1vbkpTIG1vZHVsZSBzcGVjIDEuMVxuICAgICAgICAgICAgICAgICAgICBjanNNb2R1bGUgPSBhcmdzW2ldID0gaGFuZGxlcnMubW9kdWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzUHJvcChkZWZpbmVkLCBkZXBOYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUHJvcCh3YWl0aW5nLCBkZXBOYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUHJvcChkZWZpbmluZywgZGVwTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGNhbGxEZXAoZGVwTmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXAucCkge1xuICAgICAgICAgICAgICAgICAgICBtYXAucC5sb2FkKG1hcC5uLCBtYWtlUmVxdWlyZShyZWxOYW1lLCB0cnVlKSwgbWFrZUxvYWQoZGVwTmFtZSksIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGRlZmluZWRbZGVwTmFtZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyAnIG1pc3NpbmcgJyArIGRlcE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0ID0gY2FsbGJhY2sgPyBjYWxsYmFjay5hcHBseShkZWZpbmVkW25hbWVdLCBhcmdzKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvL0lmIHNldHRpbmcgZXhwb3J0cyB2aWEgXCJtb2R1bGVcIiBpcyBpbiBwbGF5LFxuICAgICAgICAgICAgICAgIC8vZmF2b3IgdGhhdCBvdmVyIHJldHVybiB2YWx1ZSBhbmQgZXhwb3J0cy4gQWZ0ZXIgdGhhdCxcbiAgICAgICAgICAgICAgICAvL2Zhdm9yIGEgbm9uLXVuZGVmaW5lZCByZXR1cm4gdmFsdWUgb3ZlciBleHBvcnRzIHVzZS5cbiAgICAgICAgICAgICAgICBpZiAoY2pzTW9kdWxlICYmIGNqc01vZHVsZS5leHBvcnRzICE9PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2pzTW9kdWxlLmV4cG9ydHMgIT09IGRlZmluZWRbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IGNqc01vZHVsZS5leHBvcnRzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0ICE9PSB1bmRlZiB8fCAhdXNpbmdFeHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vVXNlIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZWRbbmFtZV0gPSByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIC8vTWF5IGp1c3QgYmUgYW4gb2JqZWN0IGRlZmluaXRpb24gZm9yIHRoZSBtb2R1bGUuIE9ubHlcbiAgICAgICAgICAgIC8vd29ycnkgYWJvdXQgZGVmaW5pbmcgaWYgaGF2ZSBhIG1vZHVsZSBuYW1lLlxuICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJlcXVpcmVqcyA9IHJlcXVpcmUgPSByZXEgPSBmdW5jdGlvbiAoZGVwcywgY2FsbGJhY2ssIHJlbE5hbWUsIGZvcmNlU3luYywgYWx0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJzW2RlcHNdKSB7XG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBpbiB0aGlzIGNhc2UgaXMgcmVhbGx5IHJlbE5hbWVcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcnNbZGVwc10oY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9KdXN0IHJldHVybiB0aGUgbW9kdWxlIHdhbnRlZC4gSW4gdGhpcyBzY2VuYXJpbywgdGhlXG4gICAgICAgICAgICAvL2RlcHMgYXJnIGlzIHRoZSBtb2R1bGUgbmFtZSwgYW5kIHNlY29uZCBhcmcgKGlmIHBhc3NlZClcbiAgICAgICAgICAgIC8vaXMganVzdCB0aGUgcmVsTmFtZS5cbiAgICAgICAgICAgIC8vTm9ybWFsaXplIG1vZHVsZSBuYW1lLCBpZiBpdCBjb250YWlucyAuIG9yIC4uXG4gICAgICAgICAgICByZXR1cm4gY2FsbERlcChtYWtlTWFwKGRlcHMsIGNhbGxiYWNrKS5mKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVwcy5zcGxpY2UpIHtcbiAgICAgICAgICAgIC8vZGVwcyBpcyBhIGNvbmZpZyBvYmplY3QsIG5vdCBhbiBhcnJheS5cbiAgICAgICAgICAgIGNvbmZpZyA9IGRlcHM7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmRlcHMpIHtcbiAgICAgICAgICAgICAgICByZXEoY29uZmlnLmRlcHMsIGNvbmZpZy5jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suc3BsaWNlKSB7XG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBpcyBhbiBhcnJheSwgd2hpY2ggbWVhbnMgaXQgaXMgYSBkZXBlbmRlbmN5IGxpc3QuXG4gICAgICAgICAgICAgICAgLy9BZGp1c3QgYXJncyBpZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgZGVwcyA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcmVsTmFtZTtcbiAgICAgICAgICAgICAgICByZWxOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwcyA9IHVuZGVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9TdXBwb3J0IHJlcXVpcmUoWydhJ10pXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgLy9JZiByZWxOYW1lIGlzIGEgZnVuY3Rpb24sIGl0IGlzIGFuIGVycmJhY2sgaGFuZGxlcixcbiAgICAgICAgLy9zbyByZW1vdmUgaXQuXG4gICAgICAgIGlmICh0eXBlb2YgcmVsTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVsTmFtZSA9IGZvcmNlU3luYztcbiAgICAgICAgICAgIGZvcmNlU3luYyA9IGFsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vU2ltdWxhdGUgYXN5bmMgY2FsbGJhY2s7XG4gICAgICAgIGlmIChmb3JjZVN5bmMpIHtcbiAgICAgICAgICAgIG1haW4odW5kZWYsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vVXNpbmcgYSBub24temVybyB2YWx1ZSBiZWNhdXNlIG9mIGNvbmNlcm4gZm9yIHdoYXQgb2xkIGJyb3dzZXJzXG4gICAgICAgICAgICAvL2RvLCBhbmQgbGF0ZXN0IGJyb3dzZXJzIFwidXBncmFkZVwiIHRvIDQgaWYgbG93ZXIgdmFsdWUgaXMgdXNlZDpcbiAgICAgICAgICAgIC8vaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGltZXJzLmh0bWwjZG9tLXdpbmRvd3RpbWVycy1zZXR0aW1lb3V0OlxuICAgICAgICAgICAgLy9JZiB3YW50IGEgdmFsdWUgaW1tZWRpYXRlbHksIHVzZSByZXF1aXJlKCdpZCcpIGluc3RlYWQgLS0gc29tZXRoaW5nXG4gICAgICAgICAgICAvL3RoYXQgd29ya3MgaW4gYWxtb25kIG9uIHRoZSBnbG9iYWwgbGV2ZWwsIGJ1dCBub3QgZ3VhcmFudGVlZCBhbmRcbiAgICAgICAgICAgIC8vdW5saWtlbHkgdG8gd29yayBpbiBvdGhlciBBTUQgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbWFpbih1bmRlZiwgZGVwcywgY2FsbGJhY2ssIHJlbE5hbWUpO1xuICAgICAgICAgICAgfSwgNCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVxO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBKdXN0IGRyb3BzIHRoZSBjb25maWcgb24gdGhlIGZsb29yLCBidXQgcmV0dXJucyByZXEgaW4gY2FzZVxuICAgICAqIHRoZSBjb25maWcgcmV0dXJuIHZhbHVlIGlzIHVzZWQuXG4gICAgICovXG4gICAgcmVxLmNvbmZpZyA9IGZ1bmN0aW9uIChjZmcpIHtcbiAgICAgICAgcmV0dXJuIHJlcShjZmcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2UgbW9kdWxlIHJlZ2lzdHJ5IGZvciBkZWJ1Z2dpbmcgYW5kIHRvb2xpbmdcbiAgICAgKi9cbiAgICByZXF1aXJlanMuX2RlZmluZWQgPSBkZWZpbmVkO1xuXG4gICAgZGVmaW5lID0gZnVuY3Rpb24gKG5hbWUsIGRlcHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VlIGFsbW9uZCBSRUFETUU6IGluY29ycmVjdCBtb2R1bGUgYnVpbGQsIG5vIG1vZHVsZSBuYW1lJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1RoaXMgbW9kdWxlIG1heSBub3QgaGF2ZSBkZXBlbmRlbmNpZXNcbiAgICAgICAgaWYgKCFkZXBzLnNwbGljZSkge1xuICAgICAgICAgICAgLy9kZXBzIGlzIG5vdCBhbiBhcnJheSwgc28gcHJvYmFibHkgbWVhbnNcbiAgICAgICAgICAgIC8vYW4gb2JqZWN0IGxpdGVyYWwgb3IgZmFjdG9yeSBmdW5jdGlvbiBmb3JcbiAgICAgICAgICAgIC8vdGhlIHZhbHVlLiBBZGp1c3QgYXJncy5cbiAgICAgICAgICAgIGNhbGxiYWNrID0gZGVwcztcbiAgICAgICAgICAgIGRlcHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzUHJvcChkZWZpbmVkLCBuYW1lKSAmJiAhaGFzUHJvcCh3YWl0aW5nLCBuYW1lKSkge1xuICAgICAgICAgICAgd2FpdGluZ1tuYW1lXSA9IFtuYW1lLCBkZXBzLCBjYWxsYmFja107XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVmaW5lLmFtZCA9IHtcbiAgICAgICAgalF1ZXJ5OiB0cnVlXG4gICAgfTtcbn0oKSk7XG5cblMyLnJlcXVpcmVqcyA9IHJlcXVpcmVqcztTMi5yZXF1aXJlID0gcmVxdWlyZTtTMi5kZWZpbmUgPSBkZWZpbmU7XG59XG59KCkpO1xuUzIuZGVmaW5lKFwiYWxtb25kXCIsIGZ1bmN0aW9uKCl7fSk7XG5cbi8qIGdsb2JhbCBqUXVlcnk6ZmFsc2UsICQ6ZmFsc2UgKi9cblMyLmRlZmluZSgnanF1ZXJ5JyxbXSxmdW5jdGlvbiAoKSB7XG4gIHZhciBfJCA9IGpRdWVyeSB8fCAkO1xuXG4gIGlmIChfJCA9PSBudWxsICYmIGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAnU2VsZWN0MjogQW4gaW5zdGFuY2Ugb2YgalF1ZXJ5IG9yIGEgalF1ZXJ5LWNvbXBhdGlibGUgbGlicmFyeSB3YXMgbm90ICcgK1xuICAgICAgJ2ZvdW5kLiBNYWtlIHN1cmUgdGhhdCB5b3UgYXJlIGluY2x1ZGluZyBqUXVlcnkgYmVmb3JlIFNlbGVjdDIgb24geW91ciAnICtcbiAgICAgICd3ZWIgcGFnZS4nXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBfJDtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvdXRpbHMnLFtcbiAgJ2pxdWVyeSdcbl0sIGZ1bmN0aW9uICgkKSB7XG4gIHZhciBVdGlscyA9IHt9O1xuXG4gIFV0aWxzLkV4dGVuZCA9IGZ1bmN0aW9uIChDaGlsZENsYXNzLCBTdXBlckNsYXNzKSB7XG4gICAgdmFyIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gICAgZnVuY3Rpb24gQmFzZUNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBDaGlsZENsYXNzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBTdXBlckNsYXNzKSB7XG4gICAgICBpZiAoX19oYXNQcm9wLmNhbGwoU3VwZXJDbGFzcywga2V5KSkge1xuICAgICAgICBDaGlsZENsYXNzW2tleV0gPSBTdXBlckNsYXNzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IFN1cGVyQ2xhc3MucHJvdG90eXBlO1xuICAgIENoaWxkQ2xhc3MucHJvdG90eXBlID0gbmV3IEJhc2VDb25zdHJ1Y3RvcigpO1xuICAgIENoaWxkQ2xhc3MuX19zdXBlcl9fID0gU3VwZXJDbGFzcy5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gQ2hpbGRDbGFzcztcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRNZXRob2RzICh0aGVDbGFzcykge1xuICAgIHZhciBwcm90byA9IHRoZUNsYXNzLnByb3RvdHlwZTtcblxuICAgIHZhciBtZXRob2RzID0gW107XG5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIHByb3RvKSB7XG4gICAgICB2YXIgbSA9IHByb3RvW21ldGhvZE5hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mIG0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRob2ROYW1lID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBtZXRob2RzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZHM7XG4gIH1cblxuICBVdGlscy5EZWNvcmF0ZSA9IGZ1bmN0aW9uIChTdXBlckNsYXNzLCBEZWNvcmF0b3JDbGFzcykge1xuICAgIHZhciBkZWNvcmF0ZWRNZXRob2RzID0gZ2V0TWV0aG9kcyhEZWNvcmF0b3JDbGFzcyk7XG4gICAgdmFyIHN1cGVyTWV0aG9kcyA9IGdldE1ldGhvZHMoU3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBEZWNvcmF0ZWRDbGFzcyAoKSB7XG4gICAgICB2YXIgdW5zaGlmdCA9IEFycmF5LnByb3RvdHlwZS51bnNoaWZ0O1xuXG4gICAgICB2YXIgYXJnQ291bnQgPSBEZWNvcmF0b3JDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IubGVuZ3RoO1xuXG4gICAgICB2YXIgY2FsbGVkQ29uc3RydWN0b3IgPSBTdXBlckNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuICAgICAgaWYgKGFyZ0NvdW50ID4gMCkge1xuICAgICAgICB1bnNoaWZ0LmNhbGwoYXJndW1lbnRzLCBTdXBlckNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcik7XG5cbiAgICAgICAgY2FsbGVkQ29uc3RydWN0b3IgPSBEZWNvcmF0b3JDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3I7XG4gICAgICB9XG5cbiAgICAgIGNhbGxlZENvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgRGVjb3JhdG9yQ2xhc3MuZGlzcGxheU5hbWUgPSBTdXBlckNsYXNzLmRpc3BsYXlOYW1lO1xuXG4gICAgZnVuY3Rpb24gY3RyICgpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBEZWNvcmF0ZWRDbGFzcztcbiAgICB9XG5cbiAgICBEZWNvcmF0ZWRDbGFzcy5wcm90b3R5cGUgPSBuZXcgY3RyKCk7XG5cbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IHN1cGVyTWV0aG9kcy5sZW5ndGg7IG0rKykge1xuICAgICAgICB2YXIgc3VwZXJNZXRob2QgPSBzdXBlck1ldGhvZHNbbV07XG5cbiAgICAgICAgRGVjb3JhdGVkQ2xhc3MucHJvdG90eXBlW3N1cGVyTWV0aG9kXSA9XG4gICAgICAgICAgU3VwZXJDbGFzcy5wcm90b3R5cGVbc3VwZXJNZXRob2RdO1xuICAgIH1cblxuICAgIHZhciBjYWxsZWRNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgLy8gU3R1YiBvdXQgdGhlIG9yaWdpbmFsIG1ldGhvZCBpZiBpdCdzIG5vdCBkZWNvcmF0aW5nIGFuIGFjdHVhbCBtZXRob2RcbiAgICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICBpZiAobWV0aG9kTmFtZSBpbiBEZWNvcmF0ZWRDbGFzcy5wcm90b3R5cGUpIHtcbiAgICAgICAgb3JpZ2luYWxNZXRob2QgPSBEZWNvcmF0ZWRDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV07XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWNvcmF0ZWRNZXRob2QgPSBEZWNvcmF0b3JDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1bnNoaWZ0ID0gQXJyYXkucHJvdG90eXBlLnVuc2hpZnQ7XG5cbiAgICAgICAgdW5zaGlmdC5jYWxsKGFyZ3VtZW50cywgb3JpZ2luYWxNZXRob2QpO1xuXG4gICAgICAgIHJldHVybiBkZWNvcmF0ZWRNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGVjb3JhdGVkTWV0aG9kcy5sZW5ndGg7IGQrKykge1xuICAgICAgdmFyIGRlY29yYXRlZE1ldGhvZCA9IGRlY29yYXRlZE1ldGhvZHNbZF07XG5cbiAgICAgIERlY29yYXRlZENsYXNzLnByb3RvdHlwZVtkZWNvcmF0ZWRNZXRob2RdID0gY2FsbGVkTWV0aG9kKGRlY29yYXRlZE1ldGhvZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIERlY29yYXRlZENsYXNzO1xuICB9O1xuXG4gIHZhciBPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyB8fCB7fTtcblxuICAgIGlmIChldmVudCBpbiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRdLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc1tldmVudF0gPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIHZhciBwYXJhbXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB0aGlzLmxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzIHx8IHt9O1xuXG4gICAgLy8gUGFyYW1zIHNob3VsZCBhbHdheXMgY29tZSBpbiBhcyBhbiBhcnJheVxuICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgcGFyYW1zID0gW107XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGFyZ3VtZW50cyB0byB0aGUgZXZlbnQsIHVzZSBhIHRlbXBvcmFyeSBvYmplY3RcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcGFyYW1zLnB1c2goe30pO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgYF90eXBlYCBvZiB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBldmVudFxuICAgIHBhcmFtc1swXS5fdHlwZSA9IGV2ZW50O1xuXG4gICAgaWYgKGV2ZW50IGluIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLmludm9rZSh0aGlzLmxpc3RlbmVyc1tldmVudF0sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgaWYgKCcqJyBpbiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgdGhpcy5pbnZva2UodGhpcy5saXN0ZW5lcnNbJyonXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKGxpc3RlbmVycywgcGFyYW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIHBhcmFtcyk7XG4gICAgfVxuICB9O1xuXG4gIFV0aWxzLk9ic2VydmFibGUgPSBPYnNlcnZhYmxlO1xuXG4gIFV0aWxzLmdlbmVyYXRlQ2hhcnMgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgdmFyIGNoYXJzID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZG9tQ2hhciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDM2KTtcbiAgICAgIGNoYXJzICs9IHJhbmRvbUNoYXIudG9TdHJpbmcoMzYpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFycztcbiAgfTtcblxuICBVdGlscy5iaW5kID0gZnVuY3Rpb24gKGZ1bmMsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgVXRpbHMuX2NvbnZlcnREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBmb3IgKHZhciBvcmlnaW5hbEtleSBpbiBkYXRhKSB7XG4gICAgICB2YXIga2V5cyA9IG9yaWdpbmFsS2V5LnNwbGl0KCctJyk7XG5cbiAgICAgIHZhciBkYXRhTGV2ZWwgPSBkYXRhO1xuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwga2V5cy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1trXTtcblxuICAgICAgICAvLyBMb3dlcmNhc2UgdGhlIGZpcnN0IGxldHRlclxuICAgICAgICAvLyBCeSBkZWZhdWx0LCBkYXNoLXNlcGFyYXRlZCBiZWNvbWVzIGNhbWVsQ2FzZVxuICAgICAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xuXG4gICAgICAgIGlmICghKGtleSBpbiBkYXRhTGV2ZWwpKSB7XG4gICAgICAgICAgZGF0YUxldmVsW2tleV0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrID09IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGRhdGFMZXZlbFtrZXldID0gZGF0YVtvcmlnaW5hbEtleV07XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhTGV2ZWwgPSBkYXRhTGV2ZWxba2V5XTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGRhdGFbb3JpZ2luYWxLZXldO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIFV0aWxzLmhhc1Njcm9sbCA9IGZ1bmN0aW9uIChpbmRleCwgZWwpIHtcbiAgICAvLyBBZGFwdGVkIGZyb20gdGhlIGZ1bmN0aW9uIGNyZWF0ZWQgYnkgQFNoYWRvd1NjcmlwdGVyXG4gICAgLy8gYW5kIGFkYXB0ZWQgYnkgQEJpbGxCYXJyeSBvbiB0aGUgU3RhY2sgRXhjaGFuZ2UgQ29kZSBSZXZpZXcgd2Vic2l0ZS5cbiAgICAvLyBUaGUgb3JpZ2luYWwgY29kZSBjYW4gYmUgZm91bmQgYXRcbiAgICAvLyBodHRwOi8vY29kZXJldmlldy5zdGFja2V4Y2hhbmdlLmNvbS9xLzEzMzM4XG4gICAgLy8gYW5kIHdhcyBkZXNpZ25lZCB0byBiZSB1c2VkIHdpdGggdGhlIFNpenpsZSBzZWxlY3RvciBlbmdpbmUuXG5cbiAgICB2YXIgJGVsID0gJChlbCk7XG4gICAgdmFyIG92ZXJmbG93WCA9IGVsLnN0eWxlLm92ZXJmbG93WDtcbiAgICB2YXIgb3ZlcmZsb3dZID0gZWwuc3R5bGUub3ZlcmZsb3dZO1xuXG4gICAgLy9DaGVjayBib3RoIHggYW5kIHkgZGVjbGFyYXRpb25zXG4gICAgaWYgKG92ZXJmbG93WCA9PT0gb3ZlcmZsb3dZICYmXG4gICAgICAgIChvdmVyZmxvd1kgPT09ICdoaWRkZW4nIHx8IG92ZXJmbG93WSA9PT0gJ3Zpc2libGUnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvdmVyZmxvd1ggPT09ICdzY3JvbGwnIHx8IG92ZXJmbG93WSA9PT0gJ3Njcm9sbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiAoJGVsLmlubmVySGVpZ2h0KCkgPCBlbC5zY3JvbGxIZWlnaHQgfHxcbiAgICAgICRlbC5pbm5lcldpZHRoKCkgPCBlbC5zY3JvbGxXaWR0aCk7XG4gIH07XG5cbiAgVXRpbHMuZXNjYXBlTWFya3VwID0gZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciByZXBsYWNlTWFwID0ge1xuICAgICAgJ1xcXFwnOiAnJiM5MjsnLFxuICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgJ1xcJyc6ICcmIzM5OycsXG4gICAgICAnLyc6ICcmIzQ3OydcbiAgICB9O1xuXG4gICAgLy8gRG8gbm90IHRyeSB0byBlc2NhcGUgdGhlIG1hcmt1cCBpZiBpdCdzIG5vdCBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2YgbWFya3VwICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nKG1hcmt1cCkucmVwbGFjZSgvWyY8PlwiJ1xcL1xcXFxdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgcmV0dXJuIHJlcGxhY2VNYXBbbWF0Y2hdO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEFwcGVuZCBhbiBhcnJheSBvZiBqUXVlcnkgbm9kZXMgdG8gYSBnaXZlbiBlbGVtZW50LlxuICBVdGlscy5hcHBlbmRNYW55ID0gZnVuY3Rpb24gKCRlbGVtZW50LCAkbm9kZXMpIHtcbiAgICAvLyBqUXVlcnkgMS43LnggZG9lcyBub3Qgc3VwcG9ydCAkLmZuLmFwcGVuZCgpIHdpdGggYW4gYXJyYXlcbiAgICAvLyBGYWxsIGJhY2sgdG8gYSBqUXVlcnkgb2JqZWN0IGNvbGxlY3Rpb24gdXNpbmcgJC5mbi5hZGQoKVxuICAgIGlmICgkLmZuLmpxdWVyeS5zdWJzdHIoMCwgMykgPT09ICcxLjcnKSB7XG4gICAgICB2YXIgJGpxTm9kZXMgPSAkKCk7XG5cbiAgICAgICQubWFwKCRub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgJGpxTm9kZXMgPSAkanFOb2Rlcy5hZGQobm9kZSk7XG4gICAgICB9KTtcblxuICAgICAgJG5vZGVzID0gJGpxTm9kZXM7XG4gICAgfVxuXG4gICAgJGVsZW1lbnQuYXBwZW5kKCRub2Rlcyk7XG4gIH07XG5cbiAgcmV0dXJuIFV0aWxzO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9yZXN1bHRzJyxbXG4gICdqcXVlcnknLFxuICAnLi91dGlscydcbl0sIGZ1bmN0aW9uICgkLCBVdGlscykge1xuICBmdW5jdGlvbiBSZXN1bHRzICgkZWxlbWVudCwgb3B0aW9ucywgZGF0YUFkYXB0ZXIpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XG4gICAgdGhpcy5kYXRhID0gZGF0YUFkYXB0ZXI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIFJlc3VsdHMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gIH1cblxuICBVdGlscy5FeHRlbmQoUmVzdWx0cywgVXRpbHMuT2JzZXJ2YWJsZSk7XG5cbiAgUmVzdWx0cy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkcmVzdWx0cyA9ICQoXG4gICAgICAnPHVsIGNsYXNzPVwic2VsZWN0Mi1yZXN1bHRzX19vcHRpb25zXCIgcm9sZT1cInRyZWVcIj48L3VsPidcbiAgICApO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5nZXQoJ211bHRpcGxlJykpIHtcbiAgICAgICRyZXN1bHRzLmF0dHIoJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJywgJ3RydWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLiRyZXN1bHRzID0gJHJlc3VsdHM7XG5cbiAgICByZXR1cm4gJHJlc3VsdHM7XG4gIH07XG5cbiAgUmVzdWx0cy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kcmVzdWx0cy5lbXB0eSgpO1xuICB9O1xuXG4gIFJlc3VsdHMucHJvdG90eXBlLmRpc3BsYXlNZXNzYWdlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBlc2NhcGVNYXJrdXAgPSB0aGlzLm9wdGlvbnMuZ2V0KCdlc2NhcGVNYXJrdXAnKTtcblxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLmhpZGVMb2FkaW5nKCk7XG5cbiAgICB2YXIgJG1lc3NhZ2UgPSAkKFxuICAgICAgJzxsaSByb2xlPVwidHJlZWl0ZW1cIiBhcmlhLWxpdmU9XCJhc3NlcnRpdmVcIicgK1xuICAgICAgJyBjbGFzcz1cInNlbGVjdDItcmVzdWx0c19fb3B0aW9uXCI+PC9saT4nXG4gICAgKTtcblxuICAgIHZhciBtZXNzYWdlID0gdGhpcy5vcHRpb25zLmdldCgndHJhbnNsYXRpb25zJykuZ2V0KHBhcmFtcy5tZXNzYWdlKTtcblxuICAgICRtZXNzYWdlLmFwcGVuZChcbiAgICAgIGVzY2FwZU1hcmt1cChcbiAgICAgICAgbWVzc2FnZShwYXJhbXMuYXJncylcbiAgICAgIClcbiAgICApO1xuXG4gICAgJG1lc3NhZ2VbMF0uY2xhc3NOYW1lICs9ICcgc2VsZWN0Mi1yZXN1bHRzX19tZXNzYWdlJztcblxuICAgIHRoaXMuJHJlc3VsdHMuYXBwZW5kKCRtZXNzYWdlKTtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5oaWRlTWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kcmVzdWx0cy5maW5kKCcuc2VsZWN0Mi1yZXN1bHRzX19tZXNzYWdlJykucmVtb3ZlKCk7XG4gIH07XG5cbiAgUmVzdWx0cy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLmhpZGVMb2FkaW5nKCk7XG5cbiAgICB2YXIgJG9wdGlvbnMgPSBbXTtcblxuICAgIGlmIChkYXRhLnJlc3VsdHMgPT0gbnVsbCB8fCBkYXRhLnJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy4kcmVzdWx0cy5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Jlc3VsdHM6bWVzc2FnZScsIHtcbiAgICAgICAgICBtZXNzYWdlOiAnbm9SZXN1bHRzJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRhdGEucmVzdWx0cyA9IHRoaXMuc29ydChkYXRhLnJlc3VsdHMpO1xuXG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkYXRhLnJlc3VsdHMubGVuZ3RoOyBkKyspIHtcbiAgICAgIHZhciBpdGVtID0gZGF0YS5yZXN1bHRzW2RdO1xuXG4gICAgICB2YXIgJG9wdGlvbiA9IHRoaXMub3B0aW9uKGl0ZW0pO1xuXG4gICAgICAkb3B0aW9ucy5wdXNoKCRvcHRpb24pO1xuICAgIH1cblxuICAgIHRoaXMuJHJlc3VsdHMuYXBwZW5kKCRvcHRpb25zKTtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgkcmVzdWx0cywgJGRyb3Bkb3duKSB7XG4gICAgdmFyICRyZXN1bHRzQ29udGFpbmVyID0gJGRyb3Bkb3duLmZpbmQoJy5zZWxlY3QyLXJlc3VsdHMnKTtcbiAgICAkcmVzdWx0c0NvbnRhaW5lci5hcHBlbmQoJHJlc3VsdHMpO1xuICB9O1xuXG4gIFJlc3VsdHMucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3J0ZXIgPSB0aGlzLm9wdGlvbnMuZ2V0KCdzb3J0ZXInKTtcblxuICAgIHJldHVybiBzb3J0ZXIoZGF0YSk7XG4gIH07XG5cbiAgUmVzdWx0cy5wcm90b3R5cGUuaGlnaGxpZ2h0Rmlyc3RJdGVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkb3B0aW9ucyA9IHRoaXMuJHJlc3VsdHNcbiAgICAgIC5maW5kKCcuc2VsZWN0Mi1yZXN1bHRzX19vcHRpb25bYXJpYS1zZWxlY3RlZF0nKTtcblxuICAgIHZhciAkc2VsZWN0ZWQgPSAkb3B0aW9ucy5maWx0ZXIoJ1thcmlhLXNlbGVjdGVkPXRydWVdJyk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IHNlbGVjdGVkIG9wdGlvbnNcbiAgICBpZiAoJHNlbGVjdGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBzZWxlY3RlZCBvcHRpb25zLCBoaWdobGlnaHQgdGhlIGZpcnN0XG4gICAgICAkc2VsZWN0ZWQuZmlyc3QoKS50cmlnZ2VyKCdtb3VzZWVudGVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBzZWxlY3RlZCBvcHRpb25zLCBoaWdobGlnaHQgdGhlIGZpcnN0IG9wdGlvblxuICAgICAgLy8gaW4gdGhlIGRyb3Bkb3duXG4gICAgICAkb3B0aW9ucy5maXJzdCgpLnRyaWdnZXIoJ21vdXNlZW50ZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLmVuc3VyZUhpZ2hsaWdodFZpc2libGUoKTtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuZGF0YS5jdXJyZW50KGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgdmFyIHNlbGVjdGVkSWRzID0gJC5tYXAoc2VsZWN0ZWQsIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLmlkLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyICRvcHRpb25zID0gc2VsZi4kcmVzdWx0c1xuICAgICAgICAuZmluZCgnLnNlbGVjdDItcmVzdWx0c19fb3B0aW9uW2FyaWEtc2VsZWN0ZWRdJyk7XG5cbiAgICAgICRvcHRpb25zLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJG9wdGlvbiA9ICQodGhpcyk7XG5cbiAgICAgICAgdmFyIGl0ZW0gPSAkLmRhdGEodGhpcywgJ2RhdGEnKTtcblxuICAgICAgICAvLyBpZCBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgd2hlbiBjb21wYXJpbmdcbiAgICAgICAgdmFyIGlkID0gJycgKyBpdGVtLmlkO1xuXG4gICAgICAgIGlmICgoaXRlbS5lbGVtZW50ICE9IG51bGwgJiYgaXRlbS5lbGVtZW50LnNlbGVjdGVkKSB8fFxuICAgICAgICAgICAgKGl0ZW0uZWxlbWVudCA9PSBudWxsICYmICQuaW5BcnJheShpZCwgc2VsZWN0ZWRJZHMpID4gLTEpKSB7XG4gICAgICAgICAgJG9wdGlvbi5hdHRyKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkb3B0aW9uLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB9KTtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5zaG93TG9hZGluZyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB0aGlzLmhpZGVMb2FkaW5nKCk7XG5cbiAgICB2YXIgbG9hZGluZ01vcmUgPSB0aGlzLm9wdGlvbnMuZ2V0KCd0cmFuc2xhdGlvbnMnKS5nZXQoJ3NlYXJjaGluZycpO1xuXG4gICAgdmFyIGxvYWRpbmcgPSB7XG4gICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICB0ZXh0OiBsb2FkaW5nTW9yZShwYXJhbXMpXG4gICAgfTtcbiAgICB2YXIgJGxvYWRpbmcgPSB0aGlzLm9wdGlvbihsb2FkaW5nKTtcbiAgICAkbG9hZGluZy5jbGFzc05hbWUgKz0gJyBsb2FkaW5nLXJlc3VsdHMnO1xuXG4gICAgdGhpcy4kcmVzdWx0cy5wcmVwZW5kKCRsb2FkaW5nKTtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5oaWRlTG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRyZXN1bHRzLmZpbmQoJy5sb2FkaW5nLXJlc3VsdHMnKS5yZW1vdmUoKTtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIG9wdGlvbi5jbGFzc05hbWUgPSAnc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24nO1xuXG4gICAgdmFyIGF0dHJzID0ge1xuICAgICAgJ3JvbGUnOiAndHJlZWl0ZW0nLFxuICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiAnZmFsc2UnXG4gICAgfTtcblxuICAgIGlmIChkYXRhLmRpc2FibGVkKSB7XG4gICAgICBkZWxldGUgYXR0cnNbJ2FyaWEtc2VsZWN0ZWQnXTtcbiAgICAgIGF0dHJzWydhcmlhLWRpc2FibGVkJ10gPSAndHJ1ZSc7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuaWQgPT0gbnVsbCkge1xuICAgICAgZGVsZXRlIGF0dHJzWydhcmlhLXNlbGVjdGVkJ107XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuX3Jlc3VsdElkICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbi5pZCA9IGRhdGEuX3Jlc3VsdElkO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnRpdGxlKSB7XG4gICAgICBvcHRpb24udGl0bGUgPSBkYXRhLnRpdGxlO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmNoaWxkcmVuKSB7XG4gICAgICBhdHRycy5yb2xlID0gJ2dyb3VwJztcbiAgICAgIGF0dHJzWydhcmlhLWxhYmVsJ10gPSBkYXRhLnRleHQ7XG4gICAgICBkZWxldGUgYXR0cnNbJ2FyaWEtc2VsZWN0ZWQnXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICB2YXIgdmFsID0gYXR0cnNbYXR0cl07XG5cbiAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5jaGlsZHJlbikge1xuICAgICAgdmFyICRvcHRpb24gPSAkKG9wdGlvbik7XG5cbiAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0cm9uZycpO1xuICAgICAgbGFiZWwuY2xhc3NOYW1lID0gJ3NlbGVjdDItcmVzdWx0c19fZ3JvdXAnO1xuXG4gICAgICB2YXIgJGxhYmVsID0gJChsYWJlbCk7XG4gICAgICB0aGlzLnRlbXBsYXRlKGRhdGEsIGxhYmVsKTtcblxuICAgICAgdmFyICRjaGlsZHJlbiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGRhdGEuY2hpbGRyZW4ubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gZGF0YS5jaGlsZHJlbltjXTtcblxuICAgICAgICB2YXIgJGNoaWxkID0gdGhpcy5vcHRpb24oY2hpbGQpO1xuXG4gICAgICAgICRjaGlsZHJlbi5wdXNoKCRjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciAkY2hpbGRyZW5Db250YWluZXIgPSAkKCc8dWw+PC91bD4nLCB7XG4gICAgICAgICdjbGFzcyc6ICdzZWxlY3QyLXJlc3VsdHNfX29wdGlvbnMgc2VsZWN0Mi1yZXN1bHRzX19vcHRpb25zLS1uZXN0ZWQnXG4gICAgICB9KTtcblxuICAgICAgJGNoaWxkcmVuQ29udGFpbmVyLmFwcGVuZCgkY2hpbGRyZW4pO1xuXG4gICAgICAkb3B0aW9uLmFwcGVuZChsYWJlbCk7XG4gICAgICAkb3B0aW9uLmFwcGVuZCgkY2hpbGRyZW5Db250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRlbXBsYXRlKGRhdGEsIG9wdGlvbik7XG4gICAgfVxuXG4gICAgJC5kYXRhKG9wdGlvbiwgJ2RhdGEnLCBkYXRhKTtcblxuICAgIHJldHVybiBvcHRpb247XG4gIH07XG5cbiAgUmVzdWx0cy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChjb250YWluZXIsICRjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgaWQgPSBjb250YWluZXIuaWQgKyAnLXJlc3VsdHMnO1xuXG4gICAgdGhpcy4kcmVzdWx0cy5hdHRyKCdpZCcsIGlkKTtcblxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czphbGwnLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBzZWxmLmNsZWFyKCk7XG4gICAgICBzZWxmLmFwcGVuZChwYXJhbXMuZGF0YSk7XG5cbiAgICAgIGlmIChjb250YWluZXIuaXNPcGVuKCkpIHtcbiAgICAgICAgc2VsZi5zZXRDbGFzc2VzKCk7XG4gICAgICAgIHNlbGYuaGlnaGxpZ2h0Rmlyc3RJdGVtKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6YXBwZW5kJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgc2VsZi5hcHBlbmQocGFyYW1zLmRhdGEpO1xuXG4gICAgICBpZiAoY29udGFpbmVyLmlzT3BlbigpKSB7XG4gICAgICAgIHNlbGYuc2V0Q2xhc3NlcygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdxdWVyeScsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIHNlbGYuaGlkZU1lc3NhZ2VzKCk7XG4gICAgICBzZWxmLnNob3dMb2FkaW5nKHBhcmFtcyk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ3NlbGVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY29udGFpbmVyLmlzT3BlbigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5zZXRDbGFzc2VzKCk7XG4gICAgICBzZWxmLmhpZ2hsaWdodEZpcnN0SXRlbSgpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCd1bnNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY29udGFpbmVyLmlzT3BlbigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5zZXRDbGFzc2VzKCk7XG4gICAgICBzZWxmLmhpZ2hsaWdodEZpcnN0SXRlbSgpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gV2hlbiB0aGUgZHJvcGRvd24gaXMgb3BlbiwgYXJpYS1leHBlbmRlZD1cInRydWVcIlxuICAgICAgc2VsZi4kcmVzdWx0cy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICAgIHNlbGYuJHJlc3VsdHMuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgc2VsZi5zZXRDbGFzc2VzKCk7XG4gICAgICBzZWxmLmVuc3VyZUhpZ2hsaWdodFZpc2libGUoKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBXaGVuIHRoZSBkcm9wZG93biBpcyBjbG9zZWQsIGFyaWEtZXhwZW5kZWQ9XCJmYWxzZVwiXG4gICAgICBzZWxmLiRyZXN1bHRzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgIHNlbGYuJHJlc3VsdHMuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgc2VsZi4kcmVzdWx0cy5yZW1vdmVBdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czp0b2dnbGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJGhpZ2hsaWdodGVkID0gc2VsZi5nZXRIaWdobGlnaHRlZFJlc3VsdHMoKTtcblxuICAgICAgaWYgKCRoaWdobGlnaHRlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAkaGlnaGxpZ2h0ZWQudHJpZ2dlcignbW91c2V1cCcpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOnNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkaGlnaGxpZ2h0ZWQgPSBzZWxmLmdldEhpZ2hsaWdodGVkUmVzdWx0cygpO1xuXG4gICAgICBpZiAoJGhpZ2hsaWdodGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gJGhpZ2hsaWdodGVkLmRhdGEoJ2RhdGEnKTtcblxuICAgICAgaWYgKCRoaWdobGlnaHRlZC5hdHRyKCdhcmlhLXNlbGVjdGVkJykgPT0gJ3RydWUnKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcignY2xvc2UnLCB7fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdCcsIHtcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOnByZXZpb3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRoaWdobGlnaHRlZCA9IHNlbGYuZ2V0SGlnaGxpZ2h0ZWRSZXN1bHRzKCk7XG5cbiAgICAgIHZhciAkb3B0aW9ucyA9IHNlbGYuJHJlc3VsdHMuZmluZCgnW2FyaWEtc2VsZWN0ZWRdJyk7XG5cbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSAkb3B0aW9ucy5pbmRleCgkaGlnaGxpZ2h0ZWQpO1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBhdCB0ZSB0b3AsIGRvbid0IG1vdmUgZnVydGhlclxuICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXh0SW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuXG4gICAgICAvLyBJZiBub25lIGFyZSBoaWdobGlnaHRlZCwgaGlnaGxpZ2h0IHRoZSBmaXJzdFxuICAgICAgaWYgKCRoaWdobGlnaHRlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbmV4dEluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyICRuZXh0ID0gJG9wdGlvbnMuZXEobmV4dEluZGV4KTtcblxuICAgICAgJG5leHQudHJpZ2dlcignbW91c2VlbnRlcicpO1xuXG4gICAgICB2YXIgY3VycmVudE9mZnNldCA9IHNlbGYuJHJlc3VsdHMub2Zmc2V0KCkudG9wO1xuICAgICAgdmFyIG5leHRUb3AgPSAkbmV4dC5vZmZzZXQoKS50b3A7XG4gICAgICB2YXIgbmV4dE9mZnNldCA9IHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKCkgKyAobmV4dFRvcCAtIGN1cnJlbnRPZmZzZXQpO1xuXG4gICAgICBpZiAobmV4dEluZGV4ID09PSAwKSB7XG4gICAgICAgIHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKDApO1xuICAgICAgfSBlbHNlIGlmIChuZXh0VG9wIC0gY3VycmVudE9mZnNldCA8IDApIHtcbiAgICAgICAgc2VsZi4kcmVzdWx0cy5zY3JvbGxUb3AobmV4dE9mZnNldCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6bmV4dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkaGlnaGxpZ2h0ZWQgPSBzZWxmLmdldEhpZ2hsaWdodGVkUmVzdWx0cygpO1xuXG4gICAgICB2YXIgJG9wdGlvbnMgPSBzZWxmLiRyZXN1bHRzLmZpbmQoJ1thcmlhLXNlbGVjdGVkXScpO1xuXG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gJG9wdGlvbnMuaW5kZXgoJGhpZ2hsaWdodGVkKTtcblxuICAgICAgdmFyIG5leHRJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG5cbiAgICAgIC8vIElmIHdlIGFyZSBhdCB0aGUgbGFzdCBvcHRpb24sIHN0YXkgdGhlcmVcbiAgICAgIGlmIChuZXh0SW5kZXggPj0gJG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyICRuZXh0ID0gJG9wdGlvbnMuZXEobmV4dEluZGV4KTtcblxuICAgICAgJG5leHQudHJpZ2dlcignbW91c2VlbnRlcicpO1xuXG4gICAgICB2YXIgY3VycmVudE9mZnNldCA9IHNlbGYuJHJlc3VsdHMub2Zmc2V0KCkudG9wICtcbiAgICAgICAgc2VsZi4kcmVzdWx0cy5vdXRlckhlaWdodChmYWxzZSk7XG4gICAgICB2YXIgbmV4dEJvdHRvbSA9ICRuZXh0Lm9mZnNldCgpLnRvcCArICRuZXh0Lm91dGVySGVpZ2h0KGZhbHNlKTtcbiAgICAgIHZhciBuZXh0T2Zmc2V0ID0gc2VsZi4kcmVzdWx0cy5zY3JvbGxUb3AoKSArIG5leHRCb3R0b20gLSBjdXJyZW50T2Zmc2V0O1xuXG4gICAgICBpZiAobmV4dEluZGV4ID09PSAwKSB7XG4gICAgICAgIHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKDApO1xuICAgICAgfSBlbHNlIGlmIChuZXh0Qm90dG9tID4gY3VycmVudE9mZnNldCkge1xuICAgICAgICBzZWxmLiRyZXN1bHRzLnNjcm9sbFRvcChuZXh0T2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czpmb2N1cycsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIHBhcmFtcy5lbGVtZW50LmFkZENsYXNzKCdzZWxlY3QyLXJlc3VsdHNfX29wdGlvbi0taGlnaGxpZ2h0ZWQnKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czptZXNzYWdlJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgc2VsZi5kaXNwbGF5TWVzc2FnZShwYXJhbXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKCQuZm4ubW91c2V3aGVlbCkge1xuICAgICAgdGhpcy4kcmVzdWx0cy5vbignbW91c2V3aGVlbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0b3AgPSBzZWxmLiRyZXN1bHRzLnNjcm9sbFRvcCgpO1xuXG4gICAgICAgIHZhciBib3R0b20gPSBzZWxmLiRyZXN1bHRzLmdldCgwKS5zY3JvbGxIZWlnaHQgLSB0b3AgKyBlLmRlbHRhWTtcblxuICAgICAgICB2YXIgaXNBdFRvcCA9IGUuZGVsdGFZID4gMCAmJiB0b3AgLSBlLmRlbHRhWSA8PSAwO1xuICAgICAgICB2YXIgaXNBdEJvdHRvbSA9IGUuZGVsdGFZIDwgMCAmJiBib3R0b20gPD0gc2VsZi4kcmVzdWx0cy5oZWlnaHQoKTtcblxuICAgICAgICBpZiAoaXNBdFRvcCkge1xuICAgICAgICAgIHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKDApO1xuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBdEJvdHRvbSkge1xuICAgICAgICAgIHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKFxuICAgICAgICAgICAgc2VsZi4kcmVzdWx0cy5nZXQoMCkuc2Nyb2xsSGVpZ2h0IC0gc2VsZi4kcmVzdWx0cy5oZWlnaHQoKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy4kcmVzdWx0cy5vbignbW91c2V1cCcsICcuc2VsZWN0Mi1yZXN1bHRzX19vcHRpb25bYXJpYS1zZWxlY3RlZF0nLFxuICAgICAgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcblxuICAgICAgdmFyIGRhdGEgPSAkdGhpcy5kYXRhKCdkYXRhJyk7XG5cbiAgICAgIGlmICgkdGhpcy5hdHRyKCdhcmlhLXNlbGVjdGVkJykgPT09ICd0cnVlJykge1xuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmdldCgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgIHNlbGYudHJpZ2dlcigndW5zZWxlY3QnLCB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnQsXG4gICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCdjbG9zZScsIHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3QnLCB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRyZXN1bHRzLm9uKCdtb3VzZWVudGVyJywgJy5zZWxlY3QyLXJlc3VsdHNfX29wdGlvblthcmlhLXNlbGVjdGVkXScsXG4gICAgICBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICB2YXIgZGF0YSA9ICQodGhpcykuZGF0YSgnZGF0YScpO1xuXG4gICAgICBzZWxmLmdldEhpZ2hsaWdodGVkUmVzdWx0cygpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKCdzZWxlY3QyLXJlc3VsdHNfX29wdGlvbi0taGlnaGxpZ2h0ZWQnKTtcblxuICAgICAgc2VsZi50cmlnZ2VyKCdyZXN1bHRzOmZvY3VzJywge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBlbGVtZW50OiAkKHRoaXMpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5nZXRIaWdobGlnaHRlZFJlc3VsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRoaWdobGlnaHRlZCA9IHRoaXMuJHJlc3VsdHNcbiAgICAuZmluZCgnLnNlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1oaWdobGlnaHRlZCcpO1xuXG4gICAgcmV0dXJuICRoaWdobGlnaHRlZDtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJHJlc3VsdHMucmVtb3ZlKCk7XG4gIH07XG5cbiAgUmVzdWx0cy5wcm90b3R5cGUuZW5zdXJlSGlnaGxpZ2h0VmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGhpZ2hsaWdodGVkID0gdGhpcy5nZXRIaWdobGlnaHRlZFJlc3VsdHMoKTtcblxuICAgIGlmICgkaGlnaGxpZ2h0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyICRvcHRpb25zID0gdGhpcy4kcmVzdWx0cy5maW5kKCdbYXJpYS1zZWxlY3RlZF0nKTtcblxuICAgIHZhciBjdXJyZW50SW5kZXggPSAkb3B0aW9ucy5pbmRleCgkaGlnaGxpZ2h0ZWQpO1xuXG4gICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB0aGlzLiRyZXN1bHRzLm9mZnNldCgpLnRvcDtcbiAgICB2YXIgbmV4dFRvcCA9ICRoaWdobGlnaHRlZC5vZmZzZXQoKS50b3A7XG4gICAgdmFyIG5leHRPZmZzZXQgPSB0aGlzLiRyZXN1bHRzLnNjcm9sbFRvcCgpICsgKG5leHRUb3AgLSBjdXJyZW50T2Zmc2V0KTtcblxuICAgIHZhciBvZmZzZXREZWx0YSA9IG5leHRUb3AgLSBjdXJyZW50T2Zmc2V0O1xuICAgIG5leHRPZmZzZXQgLT0gJGhpZ2hsaWdodGVkLm91dGVySGVpZ2h0KGZhbHNlKSAqIDI7XG5cbiAgICBpZiAoY3VycmVudEluZGV4IDw9IDIpIHtcbiAgICAgIHRoaXMuJHJlc3VsdHMuc2Nyb2xsVG9wKDApO1xuICAgIH0gZWxzZSBpZiAob2Zmc2V0RGVsdGEgPiB0aGlzLiRyZXN1bHRzLm91dGVySGVpZ2h0KCkgfHwgb2Zmc2V0RGVsdGEgPCAwKSB7XG4gICAgICB0aGlzLiRyZXN1bHRzLnNjcm9sbFRvcChuZXh0T2Zmc2V0KTtcbiAgICB9XG4gIH07XG5cbiAgUmVzdWx0cy5wcm90b3R5cGUudGVtcGxhdGUgPSBmdW5jdGlvbiAocmVzdWx0LCBjb250YWluZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMuZ2V0KCd0ZW1wbGF0ZVJlc3VsdCcpO1xuICAgIHZhciBlc2NhcGVNYXJrdXAgPSB0aGlzLm9wdGlvbnMuZ2V0KCdlc2NhcGVNYXJrdXAnKTtcblxuICAgIHZhciBjb250ZW50ID0gdGVtcGxhdGUocmVzdWx0LCBjb250YWluZXIpO1xuXG4gICAgaWYgKGNvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBlc2NhcGVNYXJrdXAoY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQoY29udGFpbmVyKS5hcHBlbmQoY29udGVudCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSZXN1bHRzO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9rZXlzJyxbXG5cbl0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIEtFWVMgPSB7XG4gICAgQkFDS1NQQUNFOiA4LFxuICAgIFRBQjogOSxcbiAgICBFTlRFUjogMTMsXG4gICAgU0hJRlQ6IDE2LFxuICAgIENUUkw6IDE3LFxuICAgIEFMVDogMTgsXG4gICAgRVNDOiAyNyxcbiAgICBTUEFDRTogMzIsXG4gICAgUEFHRV9VUDogMzMsXG4gICAgUEFHRV9ET1dOOiAzNCxcbiAgICBFTkQ6IDM1LFxuICAgIEhPTUU6IDM2LFxuICAgIExFRlQ6IDM3LFxuICAgIFVQOiAzOCxcbiAgICBSSUdIVDogMzksXG4gICAgRE9XTjogNDAsXG4gICAgREVMRVRFOiA0NlxuICB9O1xuXG4gIHJldHVybiBLRVlTO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vYmFzZScsW1xuICAnanF1ZXJ5JyxcbiAgJy4uL3V0aWxzJyxcbiAgJy4uL2tleXMnXG5dLCBmdW5jdGlvbiAoJCwgVXRpbHMsIEtFWVMpIHtcbiAgZnVuY3Rpb24gQmFzZVNlbGVjdGlvbiAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIEJhc2VTZWxlY3Rpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gIH1cblxuICBVdGlscy5FeHRlbmQoQmFzZVNlbGVjdGlvbiwgVXRpbHMuT2JzZXJ2YWJsZSk7XG5cbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkc2VsZWN0aW9uID0gJChcbiAgICAgICc8c3BhbiBjbGFzcz1cInNlbGVjdDItc2VsZWN0aW9uXCIgcm9sZT1cImNvbWJvYm94XCIgJyArXG4gICAgICAnIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+JyArXG4gICAgICAnPC9zcGFuPidcbiAgICApO1xuXG4gICAgdGhpcy5fdGFiaW5kZXggPSAwO1xuXG4gICAgaWYgKHRoaXMuJGVsZW1lbnQuZGF0YSgnb2xkLXRhYmluZGV4JykgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fdGFiaW5kZXggPSB0aGlzLiRlbGVtZW50LmRhdGEoJ29sZC10YWJpbmRleCcpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3RhYmluZGV4ID0gdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpO1xuICAgIH1cblxuICAgICRzZWxlY3Rpb24uYXR0cigndGl0bGUnLCB0aGlzLiRlbGVtZW50LmF0dHIoJ3RpdGxlJykpO1xuICAgICRzZWxlY3Rpb24uYXR0cigndGFiaW5kZXgnLCB0aGlzLl90YWJpbmRleCk7XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24gPSAkc2VsZWN0aW9uO1xuXG4gICAgcmV0dXJuICRzZWxlY3Rpb247XG4gIH07XG5cbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChjb250YWluZXIsICRjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgaWQgPSBjb250YWluZXIuaWQgKyAnLWNvbnRhaW5lcic7XG4gICAgdmFyIHJlc3VsdHNJZCA9IGNvbnRhaW5lci5pZCArICctcmVzdWx0cyc7XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbignZm9jdXMnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBzZWxmLnRyaWdnZXIoJ2ZvY3VzJywgZXZ0KTtcbiAgICB9KTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbignYmx1cicsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIHNlbGYuX2hhbmRsZUJsdXIoZXZ0KTtcbiAgICB9KTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIHNlbGYudHJpZ2dlcigna2V5cHJlc3MnLCBldnQpO1xuXG4gICAgICBpZiAoZXZ0LndoaWNoID09PSBLRVlTLlNQQUNFKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOmZvY3VzJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIHBhcmFtcy5kYXRhLl9yZXN1bHRJZCk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ3NlbGVjdGlvbjp1cGRhdGUnLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBzZWxmLnVwZGF0ZShwYXJhbXMuZGF0YSk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBXaGVuIHRoZSBkcm9wZG93biBpcyBvcGVuLCBhcmlhLWV4cGFuZGVkPVwidHJ1ZVwiXG4gICAgICBzZWxmLiRzZWxlY3Rpb24uYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgICBzZWxmLiRzZWxlY3Rpb24uYXR0cignYXJpYS1vd25zJywgcmVzdWx0c0lkKTtcblxuICAgICAgc2VsZi5fYXR0YWNoQ2xvc2VIYW5kbGVyKGNvbnRhaW5lcik7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gV2hlbiB0aGUgZHJvcGRvd24gaXMgY2xvc2VkLCBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIlxuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi5yZW1vdmVBdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi5yZW1vdmVBdHRyKCdhcmlhLW93bnMnKTtcblxuICAgICAgc2VsZi4kc2VsZWN0aW9uLmZvY3VzKCk7XG5cbiAgICAgIHNlbGYuX2RldGFjaENsb3NlSGFuZGxlcihjb250YWluZXIpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdlbmFibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLiRzZWxlY3Rpb24uYXR0cigndGFiaW5kZXgnLCBzZWxmLl90YWJpbmRleCk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ2Rpc2FibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLiRzZWxlY3Rpb24uYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcbiAgICB9KTtcbiAgfTtcblxuICBCYXNlU2VsZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlQmx1ciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYXMgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIHRoZSBib2R5IHdoZW4gdGhlIHRhYlxuICAgIC8vIGtleSBpcyBwcmVzc2VkLCBwb3NzaWJseSBhbG9uZyB3aXRoIG90aGVycy5cbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBEb24ndCB0cmlnZ2VyIGBibHVyYCBpZiB0aGUgZm9jdXMgaXMgc3RpbGwgaW4gdGhlIHNlbGVjdGlvblxuICAgICAgaWYgKFxuICAgICAgICAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSBzZWxmLiRzZWxlY3Rpb25bMF0pIHx8XG4gICAgICAgICgkLmNvbnRhaW5zKHNlbGYuJHNlbGVjdGlvblswXSwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnRyaWdnZXIoJ2JsdXInLCBldnQpO1xuICAgIH0sIDEpO1xuICB9O1xuXG4gIEJhc2VTZWxlY3Rpb24ucHJvdG90eXBlLl9hdHRhY2hDbG9zZUhhbmRsZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgJChkb2N1bWVudC5ib2R5KS5vbignbW91c2Vkb3duLnNlbGVjdDIuJyArIGNvbnRhaW5lci5pZCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciAkdGFyZ2V0ID0gJChlLnRhcmdldCk7XG5cbiAgICAgIHZhciAkc2VsZWN0ID0gJHRhcmdldC5jbG9zZXN0KCcuc2VsZWN0MicpO1xuXG4gICAgICB2YXIgJGFsbCA9ICQoJy5zZWxlY3QyLnNlbGVjdDItY29udGFpbmVyLS1vcGVuJyk7XG5cbiAgICAgICRhbGwuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMgPT0gJHNlbGVjdFswXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkZWxlbWVudCA9ICR0aGlzLmRhdGEoJ2VsZW1lbnQnKTtcblxuICAgICAgICAkZWxlbWVudC5zZWxlY3QyKCdjbG9zZScpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUuX2RldGFjaENsb3NlSGFuZGxlciA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAkKGRvY3VtZW50LmJvZHkpLm9mZignbW91c2Vkb3duLnNlbGVjdDIuJyArIGNvbnRhaW5lci5pZCk7XG4gIH07XG5cbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoJHNlbGVjdGlvbiwgJGNvbnRhaW5lcikge1xuICAgIHZhciAkc2VsZWN0aW9uQ29udGFpbmVyID0gJGNvbnRhaW5lci5maW5kKCcuc2VsZWN0aW9uJyk7XG4gICAgJHNlbGVjdGlvbkNvbnRhaW5lci5hcHBlbmQoJHNlbGVjdGlvbik7XG4gIH07XG5cbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kZXRhY2hDbG9zZUhhbmRsZXIodGhpcy5jb250YWluZXIpO1xuICB9O1xuXG4gIEJhc2VTZWxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHVwZGF0ZWAgbWV0aG9kIG11c3QgYmUgZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzLicpO1xuICB9O1xuXG4gIHJldHVybiBCYXNlU2VsZWN0aW9uO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vc2luZ2xlJyxbXG4gICdqcXVlcnknLFxuICAnLi9iYXNlJyxcbiAgJy4uL3V0aWxzJyxcbiAgJy4uL2tleXMnXG5dLCBmdW5jdGlvbiAoJCwgQmFzZVNlbGVjdGlvbiwgVXRpbHMsIEtFWVMpIHtcbiAgZnVuY3Rpb24gU2luZ2xlU2VsZWN0aW9uICgpIHtcbiAgICBTaW5nbGVTZWxlY3Rpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBVdGlscy5FeHRlbmQoU2luZ2xlU2VsZWN0aW9uLCBCYXNlU2VsZWN0aW9uKTtcblxuICBTaW5nbGVTZWxlY3Rpb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHNlbGVjdGlvbiA9IFNpbmdsZVNlbGVjdGlvbi5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XG5cbiAgICAkc2VsZWN0aW9uLmFkZENsYXNzKCdzZWxlY3QyLXNlbGVjdGlvbi0tc2luZ2xlJyk7XG5cbiAgICAkc2VsZWN0aW9uLmh0bWwoXG4gICAgICAnPHNwYW4gY2xhc3M9XCJzZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWRcIj48L3NwYW4+JyArXG4gICAgICAnPHNwYW4gY2xhc3M9XCJzZWxlY3QyLXNlbGVjdGlvbl9fYXJyb3dcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+JyArXG4gICAgICAgICc8YiByb2xlPVwicHJlc2VudGF0aW9uXCI+PC9iPicgK1xuICAgICAgJzwvc3Bhbj4nXG4gICAgKTtcblxuICAgIHJldHVybiAkc2VsZWN0aW9uO1xuICB9O1xuXG4gIFNpbmdsZVNlbGVjdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChjb250YWluZXIsICRjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBTaW5nbGVTZWxlY3Rpb24uX19zdXBlcl9fLmJpbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBpZCA9IGNvbnRhaW5lci5pZCArICctY29udGFpbmVyJztcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJykuYXR0cignaWQnLCBpZCk7XG4gICAgdGhpcy4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtbGFiZWxsZWRieScsIGlkKTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbignbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgLy8gT25seSByZXNwb25kIHRvIGxlZnQgY2xpY2tzXG4gICAgICBpZiAoZXZ0LndoaWNoICE9PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi50cmlnZ2VyKCd0b2dnbGUnLCB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2ZvY3VzJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgLy8gVXNlciBmb2N1c2VzIG9uIHRoZSBjb250YWluZXJcbiAgICB9KTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbignYmx1cicsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIC8vIFVzZXIgZXhpdHMgdGhlIGNvbnRhaW5lclxuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdmb2N1cycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmICghY29udGFpbmVyLmlzT3BlbigpKSB7XG4gICAgICAgIHNlbGYuJHNlbGVjdGlvbi5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdzZWxlY3Rpb246dXBkYXRlJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgc2VsZi51cGRhdGUocGFyYW1zLmRhdGEpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNpbmdsZVNlbGVjdGlvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKS5lbXB0eSgpO1xuICB9O1xuXG4gIFNpbmdsZVNlbGVjdGlvbi5wcm90b3R5cGUuZGlzcGxheSA9IGZ1bmN0aW9uIChkYXRhLCBjb250YWluZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMuZ2V0KCd0ZW1wbGF0ZVNlbGVjdGlvbicpO1xuICAgIHZhciBlc2NhcGVNYXJrdXAgPSB0aGlzLm9wdGlvbnMuZ2V0KCdlc2NhcGVNYXJrdXAnKTtcblxuICAgIHJldHVybiBlc2NhcGVNYXJrdXAodGVtcGxhdGUoZGF0YSwgY29udGFpbmVyKSk7XG4gIH07XG5cbiAgU2luZ2xlU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3Rpb25Db250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICQoJzxzcGFuPjwvc3Bhbj4nKTtcbiAgfTtcblxuICBTaW5nbGVTZWxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGlvbiA9IGRhdGFbMF07XG5cbiAgICB2YXIgJHJlbmRlcmVkID0gdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKTtcbiAgICB2YXIgZm9ybWF0dGVkID0gdGhpcy5kaXNwbGF5KHNlbGVjdGlvbiwgJHJlbmRlcmVkKTtcblxuICAgICRyZW5kZXJlZC5lbXB0eSgpLmFwcGVuZChmb3JtYXR0ZWQpO1xuICAgICRyZW5kZXJlZC5wcm9wKCd0aXRsZScsIHNlbGVjdGlvbi50aXRsZSB8fCBzZWxlY3Rpb24udGV4dCk7XG4gIH07XG5cbiAgcmV0dXJuIFNpbmdsZVNlbGVjdGlvbjtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvc2VsZWN0aW9uL211bHRpcGxlJyxbXG4gICdqcXVlcnknLFxuICAnLi9iYXNlJyxcbiAgJy4uL3V0aWxzJ1xuXSwgZnVuY3Rpb24gKCQsIEJhc2VTZWxlY3Rpb24sIFV0aWxzKSB7XG4gIGZ1bmN0aW9uIE11bHRpcGxlU2VsZWN0aW9uICgkZWxlbWVudCwgb3B0aW9ucykge1xuICAgIE11bHRpcGxlU2VsZWN0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgVXRpbHMuRXh0ZW5kKE11bHRpcGxlU2VsZWN0aW9uLCBCYXNlU2VsZWN0aW9uKTtcblxuICBNdWx0aXBsZVNlbGVjdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkc2VsZWN0aW9uID0gTXVsdGlwbGVTZWxlY3Rpb24uX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xuXG4gICAgJHNlbGVjdGlvbi5hZGRDbGFzcygnc2VsZWN0Mi1zZWxlY3Rpb24tLW11bHRpcGxlJyk7XG5cbiAgICAkc2VsZWN0aW9uLmh0bWwoXG4gICAgICAnPHVsIGNsYXNzPVwic2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkXCI+PC91bD4nXG4gICAgKTtcblxuICAgIHJldHVybiAkc2VsZWN0aW9uO1xuICB9O1xuXG4gIE11bHRpcGxlU2VsZWN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIE11bHRpcGxlU2VsZWN0aW9uLl9fc3VwZXJfXy5iaW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi50cmlnZ2VyKCd0b2dnbGUnLCB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oXG4gICAgICAnY2xpY2snLFxuICAgICAgJy5zZWxlY3QyLXNlbGVjdGlvbl9fY2hvaWNlX19yZW1vdmUnLFxuICAgICAgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGl0IGlzIGRpc2FibGVkXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZ2V0KCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICRyZW1vdmUgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgJHNlbGVjdGlvbiA9ICRyZW1vdmUucGFyZW50KCk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSAkc2VsZWN0aW9uLmRhdGEoJ2RhdGEnKTtcblxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dCxcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgTXVsdGlwbGVTZWxlY3Rpb24ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJykuZW1wdHkoKTtcbiAgfTtcblxuICBNdWx0aXBsZVNlbGVjdGlvbi5wcm90b3R5cGUuZGlzcGxheSA9IGZ1bmN0aW9uIChkYXRhLCBjb250YWluZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMuZ2V0KCd0ZW1wbGF0ZVNlbGVjdGlvbicpO1xuICAgIHZhciBlc2NhcGVNYXJrdXAgPSB0aGlzLm9wdGlvbnMuZ2V0KCdlc2NhcGVNYXJrdXAnKTtcblxuICAgIHJldHVybiBlc2NhcGVNYXJrdXAodGVtcGxhdGUoZGF0YSwgY29udGFpbmVyKSk7XG4gIH07XG5cbiAgTXVsdGlwbGVTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdGlvbkNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGNvbnRhaW5lciA9ICQoXG4gICAgICAnPGxpIGNsYXNzPVwic2VsZWN0Mi1zZWxlY3Rpb25fX2Nob2ljZVwiPicgK1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWxlY3QyLXNlbGVjdGlvbl9fY2hvaWNlX19yZW1vdmVcIiByb2xlPVwicHJlc2VudGF0aW9uXCI+JyArXG4gICAgICAgICAgJyZ0aW1lczsnICtcbiAgICAgICAgJzwvc3Bhbj4nICtcbiAgICAgICc8L2xpPidcbiAgICApO1xuXG4gICAgcmV0dXJuICRjb250YWluZXI7XG4gIH07XG5cbiAgTXVsdGlwbGVTZWxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyICRzZWxlY3Rpb25zID0gW107XG5cbiAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBkYXRhW2RdO1xuXG4gICAgICB2YXIgJHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uQ29udGFpbmVyKCk7XG4gICAgICB2YXIgZm9ybWF0dGVkID0gdGhpcy5kaXNwbGF5KHNlbGVjdGlvbiwgJHNlbGVjdGlvbik7XG5cbiAgICAgICRzZWxlY3Rpb24uYXBwZW5kKGZvcm1hdHRlZCk7XG4gICAgICAkc2VsZWN0aW9uLnByb3AoJ3RpdGxlJywgc2VsZWN0aW9uLnRpdGxlIHx8IHNlbGVjdGlvbi50ZXh0KTtcblxuICAgICAgJHNlbGVjdGlvbi5kYXRhKCdkYXRhJywgc2VsZWN0aW9uKTtcblxuICAgICAgJHNlbGVjdGlvbnMucHVzaCgkc2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICB2YXIgJHJlbmRlcmVkID0gdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKTtcblxuICAgIFV0aWxzLmFwcGVuZE1hbnkoJHJlbmRlcmVkLCAkc2VsZWN0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIE11bHRpcGxlU2VsZWN0aW9uO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vcGxhY2Vob2xkZXInLFtcbiAgJy4uL3V0aWxzJ1xuXSwgZnVuY3Rpb24gKFV0aWxzKSB7XG4gIGZ1bmN0aW9uIFBsYWNlaG9sZGVyIChkZWNvcmF0ZWQsICRlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5wbGFjZWhvbGRlciA9IHRoaXMubm9ybWFsaXplUGxhY2Vob2xkZXIob3B0aW9ucy5nZXQoJ3BsYWNlaG9sZGVyJykpO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgUGxhY2Vob2xkZXIucHJvdG90eXBlLm5vcm1hbGl6ZVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKF8sIHBsYWNlaG9sZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBwbGFjZWhvbGRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBsYWNlaG9sZGVyID0ge1xuICAgICAgICBpZDogJycsXG4gICAgICAgIHRleHQ6IHBsYWNlaG9sZGVyXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgfTtcblxuICBQbGFjZWhvbGRlci5wcm90b3R5cGUuY3JlYXRlUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBwbGFjZWhvbGRlcikge1xuICAgIHZhciAkcGxhY2Vob2xkZXIgPSB0aGlzLnNlbGVjdGlvbkNvbnRhaW5lcigpO1xuXG4gICAgJHBsYWNlaG9sZGVyLmh0bWwodGhpcy5kaXNwbGF5KHBsYWNlaG9sZGVyKSk7XG4gICAgJHBsYWNlaG9sZGVyLmFkZENsYXNzKCdzZWxlY3QyLXNlbGVjdGlvbl9fcGxhY2Vob2xkZXInKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2VsZWN0Mi1zZWxlY3Rpb25fX2Nob2ljZScpO1xuXG4gICAgcmV0dXJuICRwbGFjZWhvbGRlcjtcbiAgfTtcblxuICBQbGFjZWhvbGRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgZGF0YSkge1xuICAgIHZhciBzaW5nbGVQbGFjZWhvbGRlciA9IChcbiAgICAgIGRhdGEubGVuZ3RoID09IDEgJiYgZGF0YVswXS5pZCAhPSB0aGlzLnBsYWNlaG9sZGVyLmlkXG4gICAgKTtcbiAgICB2YXIgbXVsdGlwbGVTZWxlY3Rpb25zID0gZGF0YS5sZW5ndGggPiAxO1xuXG4gICAgaWYgKG11bHRpcGxlU2VsZWN0aW9ucyB8fCBzaW5nbGVQbGFjZWhvbGRlcikge1xuICAgICAgcmV0dXJuIGRlY29yYXRlZC5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHZhciAkcGxhY2Vob2xkZXIgPSB0aGlzLmNyZWF0ZVBsYWNlaG9sZGVyKHRoaXMucGxhY2Vob2xkZXIpO1xuXG4gICAgdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKS5hcHBlbmQoJHBsYWNlaG9sZGVyKTtcbiAgfTtcblxuICByZXR1cm4gUGxhY2Vob2xkZXI7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL3NlbGVjdGlvbi9hbGxvd0NsZWFyJyxbXG4gICdqcXVlcnknLFxuICAnLi4va2V5cydcbl0sIGZ1bmN0aW9uICgkLCBLRVlTKSB7XG4gIGZ1bmN0aW9uIEFsbG93Q2xlYXIgKCkgeyB9XG5cbiAgQWxsb3dDbGVhci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XG5cbiAgICBpZiAodGhpcy5wbGFjZWhvbGRlciA9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmdldCgnZGVidWcnKSAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ1NlbGVjdDI6IFRoZSBgYWxsb3dDbGVhcmAgb3B0aW9uIHNob3VsZCBiZSB1c2VkIGluIGNvbWJpbmF0aW9uICcgK1xuICAgICAgICAgICd3aXRoIHRoZSBgcGxhY2Vob2xkZXJgIG9wdGlvbi4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdtb3VzZWRvd24nLCAnLnNlbGVjdDItc2VsZWN0aW9uX19jbGVhcicsXG4gICAgICBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHNlbGYuX2hhbmRsZUNsZWFyKGV2dCk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ2tleXByZXNzJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi5faGFuZGxlS2V5Ym9hcmRDbGVhcihldnQsIGNvbnRhaW5lcik7XG4gICAgfSk7XG4gIH07XG5cbiAgQWxsb3dDbGVhci5wcm90b3R5cGUuX2hhbmRsZUNsZWFyID0gZnVuY3Rpb24gKF8sIGV2dCkge1xuICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgaXQgaXMgZGlzYWJsZWRcbiAgICBpZiAodGhpcy5vcHRpb25zLmdldCgnZGlzYWJsZWQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciAkY2xlYXIgPSB0aGlzLiRzZWxlY3Rpb24uZmluZCgnLnNlbGVjdDItc2VsZWN0aW9uX19jbGVhcicpO1xuXG4gICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiBub3RoaW5nIGhhcyBiZWVuIHNlbGVjdGVkXG4gICAgaWYgKCRjbGVhci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICB2YXIgZGF0YSA9ICRjbGVhci5kYXRhKCdkYXRhJyk7XG5cbiAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcbiAgICAgIHZhciB1bnNlbGVjdERhdGEgPSB7XG4gICAgICAgIGRhdGE6IGRhdGFbZF1cbiAgICAgIH07XG5cbiAgICAgIC8vIFRyaWdnZXIgdGhlIGB1bnNlbGVjdGAgZXZlbnQsIHNvIHBlb3BsZSBjYW4gcHJldmVudCBpdCBmcm9tIGJlaW5nXG4gICAgICAvLyBjbGVhcmVkLlxuICAgICAgdGhpcy50cmlnZ2VyKCd1bnNlbGVjdCcsIHVuc2VsZWN0RGF0YSk7XG5cbiAgICAgIC8vIElmIHRoZSBldmVudCB3YXMgcHJldmVudGVkLCBkb24ndCBjbGVhciBpdCBvdXQuXG4gICAgICBpZiAodW5zZWxlY3REYXRhLnByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC52YWwodGhpcy5wbGFjZWhvbGRlci5pZCkudHJpZ2dlcignY2hhbmdlJyk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3RvZ2dsZScsIHt9KTtcbiAgfTtcblxuICBBbGxvd0NsZWFyLnByb3RvdHlwZS5faGFuZGxlS2V5Ym9hcmRDbGVhciA9IGZ1bmN0aW9uIChfLCBldnQsIGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIuaXNPcGVuKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZ0LndoaWNoID09IEtFWVMuREVMRVRFIHx8IGV2dC53aGljaCA9PSBLRVlTLkJBQ0tTUEFDRSkge1xuICAgICAgdGhpcy5faGFuZGxlQ2xlYXIoZXZ0KTtcbiAgICB9XG4gIH07XG5cbiAgQWxsb3dDbGVhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgZGF0YSkge1xuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGRhdGEpO1xuXG4gICAgaWYgKHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3BsYWNlaG9sZGVyJykubGVuZ3RoID4gMCB8fFxuICAgICAgICBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciAkcmVtb3ZlID0gJChcbiAgICAgICc8c3BhbiBjbGFzcz1cInNlbGVjdDItc2VsZWN0aW9uX19jbGVhclwiPicgK1xuICAgICAgICAnJnRpbWVzOycgK1xuICAgICAgJzwvc3Bhbj4nXG4gICAgKTtcbiAgICAkcmVtb3ZlLmRhdGEoJ2RhdGEnLCBkYXRhKTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJykucHJlcGVuZCgkcmVtb3ZlKTtcbiAgfTtcblxuICByZXR1cm4gQWxsb3dDbGVhcjtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvc2VsZWN0aW9uL3NlYXJjaCcsW1xuICAnanF1ZXJ5JyxcbiAgJy4uL3V0aWxzJyxcbiAgJy4uL2tleXMnXG5dLCBmdW5jdGlvbiAoJCwgVXRpbHMsIEtFWVMpIHtcbiAgZnVuY3Rpb24gU2VhcmNoIChkZWNvcmF0ZWQsICRlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgU2VhcmNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XG4gICAgdmFyICRzZWFyY2ggPSAkKFxuICAgICAgJzxsaSBjbGFzcz1cInNlbGVjdDItc2VhcmNoIHNlbGVjdDItc2VhcmNoLS1pbmxpbmVcIj4nICtcbiAgICAgICAgJzxpbnB1dCBjbGFzcz1cInNlbGVjdDItc2VhcmNoX19maWVsZFwiIHR5cGU9XCJzZWFyY2hcIiB0YWJpbmRleD1cIi0xXCInICtcbiAgICAgICAgJyBhdXRvY29tcGxldGU9XCJvZmZcIiBhdXRvY29ycmVjdD1cIm9mZlwiIGF1dG9jYXBpdGFsaXplPVwib2ZmXCInICtcbiAgICAgICAgJyBzcGVsbGNoZWNrPVwiZmFsc2VcIiByb2xlPVwidGV4dGJveFwiIGFyaWEtYXV0b2NvbXBsZXRlPVwibGlzdFwiIC8+JyArXG4gICAgICAnPC9saT4nXG4gICAgKTtcblxuICAgIHRoaXMuJHNlYXJjaENvbnRhaW5lciA9ICRzZWFyY2g7XG4gICAgdGhpcy4kc2VhcmNoID0gJHNlYXJjaC5maW5kKCdpbnB1dCcpO1xuXG4gICAgdmFyICRyZW5kZXJlZCA9IGRlY29yYXRlZC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fdHJhbnNmZXJUYWJJbmRleCgpO1xuXG4gICAgcmV0dXJuICRyZW5kZXJlZDtcbiAgfTtcblxuICBTZWFyY2gucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIsICRjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xuXG4gICAgY29udGFpbmVyLm9uKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi4kc2VhcmNoLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi4kc2VhcmNoLnZhbCgnJyk7XG4gICAgICBzZWxmLiRzZWFyY2gucmVtb3ZlQXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyk7XG4gICAgICBzZWxmLiRzZWFyY2gudHJpZ2dlcignZm9jdXMnKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbignZW5hYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi4kc2VhcmNoLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuXG4gICAgICBzZWxmLl90cmFuc2ZlclRhYkluZGV4KCk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ2Rpc2FibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLiRzZWFyY2gucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbignZm9jdXMnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBzZWxmLiRzZWFyY2gudHJpZ2dlcignZm9jdXMnKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czpmb2N1cycsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIHNlbGYuJHNlYXJjaC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBwYXJhbXMuaWQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdmb2N1c2luJywgJy5zZWxlY3QyLXNlYXJjaC0taW5saW5lJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi50cmlnZ2VyKCdmb2N1cycsIGV2dCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2ZvY3Vzb3V0JywgJy5zZWxlY3QyLXNlYXJjaC0taW5saW5lJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi5faGFuZGxlQmx1cihldnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdrZXlkb3duJywgJy5zZWxlY3QyLXNlYXJjaC0taW5saW5lJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBzZWxmLnRyaWdnZXIoJ2tleXByZXNzJywgZXZ0KTtcblxuICAgICAgc2VsZi5fa2V5VXBQcmV2ZW50ZWQgPSBldnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG5cbiAgICAgIHZhciBrZXkgPSBldnQud2hpY2g7XG5cbiAgICAgIGlmIChrZXkgPT09IEtFWVMuQkFDS1NQQUNFICYmIHNlbGYuJHNlYXJjaC52YWwoKSA9PT0gJycpIHtcbiAgICAgICAgdmFyICRwcmV2aW91c0Nob2ljZSA9IHNlbGYuJHNlYXJjaENvbnRhaW5lclxuICAgICAgICAgIC5wcmV2KCcuc2VsZWN0Mi1zZWxlY3Rpb25fX2Nob2ljZScpO1xuXG4gICAgICAgIGlmICgkcHJldmlvdXNDaG9pY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBpdGVtID0gJHByZXZpb3VzQ2hvaWNlLmRhdGEoJ2RhdGEnKTtcblxuICAgICAgICAgIHNlbGYuc2VhcmNoUmVtb3ZlQ2hvaWNlKGl0ZW0pO1xuXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRyeSB0byBkZXRlY3QgdGhlIElFIHZlcnNpb24gc2hvdWxkIHRoZSBgZG9jdW1lbnRNb2RlYCBwcm9wZXJ0eSB0aGF0XG4gICAgLy8gaXMgc3RvcmVkIG9uIHRoZSBkb2N1bWVudC4gVGhpcyBpcyBvbmx5IGltcGxlbWVudGVkIGluIElFIGFuZCBpc1xuICAgIC8vIHNsaWdodGx5IGNsZWFuZXIgdGhhbiBkb2luZyBhIHByb2ZpbGUgYWdlbnQgY2hlY2suXG4gICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlIGluIEVkZ2UsIGJ1dCBFZGdlIGFsc28gZG9lc24ndCBoYXZlXG4gICAgLy8gdGhpcyBidWcuXG4gICAgdmFyIG1zaWUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG4gICAgdmFyIGRpc2FibGVJbnB1dEV2ZW50cyA9IG1zaWUgJiYgbXNpZSA8PSAxMTtcblxuICAgIC8vIFdvcmthcm91bmQgZm9yIGJyb3dzZXJzIHdoaWNoIGRvIG5vdCBzdXBwb3J0IHRoZSBgaW5wdXRgIGV2ZW50XG4gICAgLy8gVGhpcyB3aWxsIHByZXZlbnQgZG91YmxlLXRyaWdnZXJpbmcgb2YgZXZlbnRzIGZvciBicm93c2VycyB3aGljaCBzdXBwb3J0XG4gICAgLy8gYm90aCB0aGUgYGtleXVwYCBhbmQgYGlucHV0YCBldmVudHMuXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKFxuICAgICAgJ2lucHV0LnNlYXJjaGNoZWNrJyxcbiAgICAgICcuc2VsZWN0Mi1zZWFyY2gtLWlubGluZScsXG4gICAgICBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIC8vIElFIHdpbGwgdHJpZ2dlciB0aGUgYGlucHV0YCBldmVudCB3aGVuIGEgcGxhY2Vob2xkZXIgaXMgdXNlZCBvbiBhXG4gICAgICAgIC8vIHNlYXJjaCBib3guIFRvIGdldCBhcm91bmQgdGhpcyBpc3N1ZSwgd2UgYXJlIGZvcmNlZCB0byBpZ25vcmUgYWxsXG4gICAgICAgIC8vIGBpbnB1dGAgZXZlbnRzIGluIElFIGFuZCBrZWVwIHVzaW5nIGBrZXl1cGAuXG4gICAgICAgIGlmIChkaXNhYmxlSW5wdXRFdmVudHMpIHtcbiAgICAgICAgICBzZWxmLiRzZWxlY3Rpb24ub2ZmKCdpbnB1dC5zZWFyY2ggaW5wdXQuc2VhcmNoY2hlY2snKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbmJpbmQgdGhlIGR1cGxpY2F0ZWQgYGtleXVwYCBldmVudFxuICAgICAgICBzZWxmLiRzZWxlY3Rpb24ub2ZmKCdrZXl1cC5zZWFyY2gnKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKFxuICAgICAgJ2tleXVwLnNlYXJjaCBpbnB1dC5zZWFyY2gnLFxuICAgICAgJy5zZWxlY3QyLXNlYXJjaC0taW5saW5lJyxcbiAgICAgIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgLy8gSUUgd2lsbCB0cmlnZ2VyIHRoZSBgaW5wdXRgIGV2ZW50IHdoZW4gYSBwbGFjZWhvbGRlciBpcyB1c2VkIG9uIGFcbiAgICAgICAgLy8gc2VhcmNoIGJveC4gVG8gZ2V0IGFyb3VuZCB0aGlzIGlzc3VlLCB3ZSBhcmUgZm9yY2VkIHRvIGlnbm9yZSBhbGxcbiAgICAgICAgLy8gYGlucHV0YCBldmVudHMgaW4gSUUgYW5kIGtlZXAgdXNpbmcgYGtleXVwYC5cbiAgICAgICAgaWYgKGRpc2FibGVJbnB1dEV2ZW50cyAmJiBldnQudHlwZSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgIHNlbGYuJHNlbGVjdGlvbi5vZmYoJ2lucHV0LnNlYXJjaCBpbnB1dC5zZWFyY2hjaGVjaycpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXkgPSBldnQud2hpY2g7XG5cbiAgICAgICAgLy8gV2UgY2FuIGZyZWVseSBpZ25vcmUgZXZlbnRzIGZyb20gbW9kaWZpZXIga2V5c1xuICAgICAgICBpZiAoa2V5ID09IEtFWVMuU0hJRlQgfHwga2V5ID09IEtFWVMuQ1RSTCB8fCBrZXkgPT0gS0VZUy5BTFQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYWJiaW5nIHdpbGwgYmUgaGFuZGxlZCBkdXJpbmcgdGhlIGBrZXlkb3duYCBwaGFzZVxuICAgICAgICBpZiAoa2V5ID09IEtFWVMuVEFCKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5oYW5kbGVTZWFyY2goZXZ0KTtcbiAgICAgIH1cbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHRyYW5zZmVyIHRoZSB0YWJpbmRleCBhdHRyaWJ1dGUgZnJvbSB0aGUgcmVuZGVyZWRcbiAgICogc2VsZWN0aW9uIHRvIHRoZSBzZWFyY2ggYm94LiBUaGlzIGFsbG93cyBmb3IgdGhlIHNlYXJjaCBib3ggdG8gYmUgdXNlZCBhc1xuICAgKiB0aGUgcHJpbWFyeSBmb2N1cyBpbnN0ZWFkIG9mIHRoZSBzZWxlY3Rpb24gY29udGFpbmVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU2VhcmNoLnByb3RvdHlwZS5fdHJhbnNmZXJUYWJJbmRleCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQpIHtcbiAgICB0aGlzLiRzZWFyY2guYXR0cigndGFiaW5kZXgnLCB0aGlzLiRzZWxlY3Rpb24uYXR0cigndGFiaW5kZXgnKSk7XG4gICAgdGhpcy4kc2VsZWN0aW9uLmF0dHIoJ3RhYmluZGV4JywgJy0xJyk7XG4gIH07XG5cbiAgU2VhcmNoLnByb3RvdHlwZS5jcmVhdGVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBsYWNlaG9sZGVyKSB7XG4gICAgdGhpcy4kc2VhcmNoLmF0dHIoJ3BsYWNlaG9sZGVyJywgcGxhY2Vob2xkZXIudGV4dCk7XG4gIH07XG5cbiAgU2VhcmNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBkYXRhKSB7XG4gICAgdmFyIHNlYXJjaEhhZEZvY3VzID0gdGhpcy4kc2VhcmNoWzBdID09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICB0aGlzLiRzZWFyY2guYXR0cigncGxhY2Vob2xkZXInLCAnJyk7XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBkYXRhKTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJylcbiAgICAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMuJHNlYXJjaENvbnRhaW5lcik7XG5cbiAgICB0aGlzLnJlc2l6ZVNlYXJjaCgpO1xuICAgIGlmIChzZWFyY2hIYWRGb2N1cykge1xuICAgICAgdGhpcy4kc2VhcmNoLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIFNlYXJjaC5wcm90b3R5cGUuaGFuZGxlU2VhcmNoID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzaXplU2VhcmNoKCk7XG5cbiAgICBpZiAoIXRoaXMuX2tleVVwUHJldmVudGVkKSB7XG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLiRzZWFyY2gudmFsKCk7XG5cbiAgICAgIHRoaXMudHJpZ2dlcigncXVlcnknLCB7XG4gICAgICAgIHRlcm06IGlucHV0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9rZXlVcFByZXZlbnRlZCA9IGZhbHNlO1xuICB9O1xuXG4gIFNlYXJjaC5wcm90b3R5cGUuc2VhcmNoUmVtb3ZlQ2hvaWNlID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgaXRlbSkge1xuICAgIHRoaXMudHJpZ2dlcigndW5zZWxlY3QnLCB7XG4gICAgICBkYXRhOiBpdGVtXG4gICAgfSk7XG5cbiAgICB0aGlzLiRzZWFyY2gudmFsKGl0ZW0udGV4dCk7XG4gICAgdGhpcy5oYW5kbGVTZWFyY2goKTtcbiAgfTtcblxuICBTZWFyY2gucHJvdG90eXBlLnJlc2l6ZVNlYXJjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRzZWFyY2guY3NzKCd3aWR0aCcsICcyNXB4Jyk7XG5cbiAgICB2YXIgd2lkdGggPSAnJztcblxuICAgIGlmICh0aGlzLiRzZWFyY2guYXR0cigncGxhY2Vob2xkZXInKSAhPT0gJycpIHtcbiAgICAgIHdpZHRoID0gdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKS5pbm5lcldpZHRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtaW5pbXVtV2lkdGggPSB0aGlzLiRzZWFyY2gudmFsKCkubGVuZ3RoICsgMTtcblxuICAgICAgd2lkdGggPSAobWluaW11bVdpZHRoICogMC43NSkgKyAnZW0nO1xuICAgIH1cblxuICAgIHRoaXMuJHNlYXJjaC5jc3MoJ3dpZHRoJywgd2lkdGgpO1xuICB9O1xuXG4gIHJldHVybiBTZWFyY2g7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL3NlbGVjdGlvbi9ldmVudFJlbGF5JyxbXG4gICdqcXVlcnknXG5dLCBmdW5jdGlvbiAoJCkge1xuICBmdW5jdGlvbiBFdmVudFJlbGF5ICgpIHsgfVxuXG4gIEV2ZW50UmVsYXkucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIsICRjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlbGF5RXZlbnRzID0gW1xuICAgICAgJ29wZW4nLCAnb3BlbmluZycsXG4gICAgICAnY2xvc2UnLCAnY2xvc2luZycsXG4gICAgICAnc2VsZWN0JywgJ3NlbGVjdGluZycsXG4gICAgICAndW5zZWxlY3QnLCAndW5zZWxlY3RpbmcnXG4gICAgXTtcblxuICAgIHZhciBwcmV2ZW50YWJsZUV2ZW50cyA9IFsnb3BlbmluZycsICdjbG9zaW5nJywgJ3NlbGVjdGluZycsICd1bnNlbGVjdGluZyddO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcblxuICAgIGNvbnRhaW5lci5vbignKicsIGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcbiAgICAgIC8vIElnbm9yZSBldmVudHMgdGhhdCBzaG91bGQgbm90IGJlIHJlbGF5ZWRcbiAgICAgIGlmICgkLmluQXJyYXkobmFtZSwgcmVsYXlFdmVudHMpID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBwYXJhbWV0ZXJzIHNob3VsZCBhbHdheXMgYmUgYW4gb2JqZWN0XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICAgIC8vIEdlbmVyYXRlIHRoZSBqUXVlcnkgZXZlbnQgZm9yIHRoZSBTZWxlY3QyIGV2ZW50XG4gICAgICB2YXIgZXZ0ID0gJC5FdmVudCgnc2VsZWN0MjonICsgbmFtZSwge1xuICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuJGVsZW1lbnQudHJpZ2dlcihldnQpO1xuXG4gICAgICAvLyBPbmx5IGhhbmRsZSBwcmV2ZW50YWJsZSBldmVudHMgaWYgaXQgd2FzIG9uZVxuICAgICAgaWYgKCQuaW5BcnJheShuYW1lLCBwcmV2ZW50YWJsZUV2ZW50cykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGFyYW1zLnByZXZlbnRlZCA9IGV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRXZlbnRSZWxheTtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvdHJhbnNsYXRpb24nLFtcbiAgJ2pxdWVyeScsXG4gICdyZXF1aXJlJ1xuXSwgZnVuY3Rpb24gKCQsIHJlcXVpcmUpIHtcbiAgZnVuY3Rpb24gVHJhbnNsYXRpb24gKGRpY3QpIHtcbiAgICB0aGlzLmRpY3QgPSBkaWN0IHx8IHt9O1xuICB9XG5cbiAgVHJhbnNsYXRpb24ucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kaWN0O1xuICB9O1xuXG4gIFRyYW5zbGF0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGljdFtrZXldO1xuICB9O1xuXG4gIFRyYW5zbGF0aW9uLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAodHJhbnNsYXRpb24pIHtcbiAgICB0aGlzLmRpY3QgPSAkLmV4dGVuZCh7fSwgdHJhbnNsYXRpb24uYWxsKCksIHRoaXMuZGljdCk7XG4gIH07XG5cbiAgLy8gU3RhdGljIGZ1bmN0aW9uc1xuXG4gIFRyYW5zbGF0aW9uLl9jYWNoZSA9IHt9O1xuXG4gIFRyYW5zbGF0aW9uLmxvYWRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAoIShwYXRoIGluIFRyYW5zbGF0aW9uLl9jYWNoZSkpIHtcbiAgICAgIHZhciB0cmFuc2xhdGlvbnMgPSByZXF1aXJlKHBhdGgpO1xuXG4gICAgICBUcmFuc2xhdGlvbi5fY2FjaGVbcGF0aF0gPSB0cmFuc2xhdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2xhdGlvbihUcmFuc2xhdGlvbi5fY2FjaGVbcGF0aF0pO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc2xhdGlvbjtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZGlhY3JpdGljcycsW1xuXG5dLCBmdW5jdGlvbiAoKSB7XG4gIHZhciBkaWFjcml0aWNzID0ge1xuICAgICdcXHUyNEI2JzogJ0EnLFxuICAgICdcXHVGRjIxJzogJ0EnLFxuICAgICdcXHUwMEMwJzogJ0EnLFxuICAgICdcXHUwMEMxJzogJ0EnLFxuICAgICdcXHUwMEMyJzogJ0EnLFxuICAgICdcXHUxRUE2JzogJ0EnLFxuICAgICdcXHUxRUE0JzogJ0EnLFxuICAgICdcXHUxRUFBJzogJ0EnLFxuICAgICdcXHUxRUE4JzogJ0EnLFxuICAgICdcXHUwMEMzJzogJ0EnLFxuICAgICdcXHUwMTAwJzogJ0EnLFxuICAgICdcXHUwMTAyJzogJ0EnLFxuICAgICdcXHUxRUIwJzogJ0EnLFxuICAgICdcXHUxRUFFJzogJ0EnLFxuICAgICdcXHUxRUI0JzogJ0EnLFxuICAgICdcXHUxRUIyJzogJ0EnLFxuICAgICdcXHUwMjI2JzogJ0EnLFxuICAgICdcXHUwMUUwJzogJ0EnLFxuICAgICdcXHUwMEM0JzogJ0EnLFxuICAgICdcXHUwMURFJzogJ0EnLFxuICAgICdcXHUxRUEyJzogJ0EnLFxuICAgICdcXHUwMEM1JzogJ0EnLFxuICAgICdcXHUwMUZBJzogJ0EnLFxuICAgICdcXHUwMUNEJzogJ0EnLFxuICAgICdcXHUwMjAwJzogJ0EnLFxuICAgICdcXHUwMjAyJzogJ0EnLFxuICAgICdcXHUxRUEwJzogJ0EnLFxuICAgICdcXHUxRUFDJzogJ0EnLFxuICAgICdcXHUxRUI2JzogJ0EnLFxuICAgICdcXHUxRTAwJzogJ0EnLFxuICAgICdcXHUwMTA0JzogJ0EnLFxuICAgICdcXHUwMjNBJzogJ0EnLFxuICAgICdcXHUyQzZGJzogJ0EnLFxuICAgICdcXHVBNzMyJzogJ0FBJyxcbiAgICAnXFx1MDBDNic6ICdBRScsXG4gICAgJ1xcdTAxRkMnOiAnQUUnLFxuICAgICdcXHUwMUUyJzogJ0FFJyxcbiAgICAnXFx1QTczNCc6ICdBTycsXG4gICAgJ1xcdUE3MzYnOiAnQVUnLFxuICAgICdcXHVBNzM4JzogJ0FWJyxcbiAgICAnXFx1QTczQSc6ICdBVicsXG4gICAgJ1xcdUE3M0MnOiAnQVknLFxuICAgICdcXHUyNEI3JzogJ0InLFxuICAgICdcXHVGRjIyJzogJ0InLFxuICAgICdcXHUxRTAyJzogJ0InLFxuICAgICdcXHUxRTA0JzogJ0InLFxuICAgICdcXHUxRTA2JzogJ0InLFxuICAgICdcXHUwMjQzJzogJ0InLFxuICAgICdcXHUwMTgyJzogJ0InLFxuICAgICdcXHUwMTgxJzogJ0InLFxuICAgICdcXHUyNEI4JzogJ0MnLFxuICAgICdcXHVGRjIzJzogJ0MnLFxuICAgICdcXHUwMTA2JzogJ0MnLFxuICAgICdcXHUwMTA4JzogJ0MnLFxuICAgICdcXHUwMTBBJzogJ0MnLFxuICAgICdcXHUwMTBDJzogJ0MnLFxuICAgICdcXHUwMEM3JzogJ0MnLFxuICAgICdcXHUxRTA4JzogJ0MnLFxuICAgICdcXHUwMTg3JzogJ0MnLFxuICAgICdcXHUwMjNCJzogJ0MnLFxuICAgICdcXHVBNzNFJzogJ0MnLFxuICAgICdcXHUyNEI5JzogJ0QnLFxuICAgICdcXHVGRjI0JzogJ0QnLFxuICAgICdcXHUxRTBBJzogJ0QnLFxuICAgICdcXHUwMTBFJzogJ0QnLFxuICAgICdcXHUxRTBDJzogJ0QnLFxuICAgICdcXHUxRTEwJzogJ0QnLFxuICAgICdcXHUxRTEyJzogJ0QnLFxuICAgICdcXHUxRTBFJzogJ0QnLFxuICAgICdcXHUwMTEwJzogJ0QnLFxuICAgICdcXHUwMThCJzogJ0QnLFxuICAgICdcXHUwMThBJzogJ0QnLFxuICAgICdcXHUwMTg5JzogJ0QnLFxuICAgICdcXHVBNzc5JzogJ0QnLFxuICAgICdcXHUwMUYxJzogJ0RaJyxcbiAgICAnXFx1MDFDNCc6ICdEWicsXG4gICAgJ1xcdTAxRjInOiAnRHonLFxuICAgICdcXHUwMUM1JzogJ0R6JyxcbiAgICAnXFx1MjRCQSc6ICdFJyxcbiAgICAnXFx1RkYyNSc6ICdFJyxcbiAgICAnXFx1MDBDOCc6ICdFJyxcbiAgICAnXFx1MDBDOSc6ICdFJyxcbiAgICAnXFx1MDBDQSc6ICdFJyxcbiAgICAnXFx1MUVDMCc6ICdFJyxcbiAgICAnXFx1MUVCRSc6ICdFJyxcbiAgICAnXFx1MUVDNCc6ICdFJyxcbiAgICAnXFx1MUVDMic6ICdFJyxcbiAgICAnXFx1MUVCQyc6ICdFJyxcbiAgICAnXFx1MDExMic6ICdFJyxcbiAgICAnXFx1MUUxNCc6ICdFJyxcbiAgICAnXFx1MUUxNic6ICdFJyxcbiAgICAnXFx1MDExNCc6ICdFJyxcbiAgICAnXFx1MDExNic6ICdFJyxcbiAgICAnXFx1MDBDQic6ICdFJyxcbiAgICAnXFx1MUVCQSc6ICdFJyxcbiAgICAnXFx1MDExQSc6ICdFJyxcbiAgICAnXFx1MDIwNCc6ICdFJyxcbiAgICAnXFx1MDIwNic6ICdFJyxcbiAgICAnXFx1MUVCOCc6ICdFJyxcbiAgICAnXFx1MUVDNic6ICdFJyxcbiAgICAnXFx1MDIyOCc6ICdFJyxcbiAgICAnXFx1MUUxQyc6ICdFJyxcbiAgICAnXFx1MDExOCc6ICdFJyxcbiAgICAnXFx1MUUxOCc6ICdFJyxcbiAgICAnXFx1MUUxQSc6ICdFJyxcbiAgICAnXFx1MDE5MCc6ICdFJyxcbiAgICAnXFx1MDE4RSc6ICdFJyxcbiAgICAnXFx1MjRCQic6ICdGJyxcbiAgICAnXFx1RkYyNic6ICdGJyxcbiAgICAnXFx1MUUxRSc6ICdGJyxcbiAgICAnXFx1MDE5MSc6ICdGJyxcbiAgICAnXFx1QTc3Qic6ICdGJyxcbiAgICAnXFx1MjRCQyc6ICdHJyxcbiAgICAnXFx1RkYyNyc6ICdHJyxcbiAgICAnXFx1MDFGNCc6ICdHJyxcbiAgICAnXFx1MDExQyc6ICdHJyxcbiAgICAnXFx1MUUyMCc6ICdHJyxcbiAgICAnXFx1MDExRSc6ICdHJyxcbiAgICAnXFx1MDEyMCc6ICdHJyxcbiAgICAnXFx1MDFFNic6ICdHJyxcbiAgICAnXFx1MDEyMic6ICdHJyxcbiAgICAnXFx1MDFFNCc6ICdHJyxcbiAgICAnXFx1MDE5Myc6ICdHJyxcbiAgICAnXFx1QTdBMCc6ICdHJyxcbiAgICAnXFx1QTc3RCc6ICdHJyxcbiAgICAnXFx1QTc3RSc6ICdHJyxcbiAgICAnXFx1MjRCRCc6ICdIJyxcbiAgICAnXFx1RkYyOCc6ICdIJyxcbiAgICAnXFx1MDEyNCc6ICdIJyxcbiAgICAnXFx1MUUyMic6ICdIJyxcbiAgICAnXFx1MUUyNic6ICdIJyxcbiAgICAnXFx1MDIxRSc6ICdIJyxcbiAgICAnXFx1MUUyNCc6ICdIJyxcbiAgICAnXFx1MUUyOCc6ICdIJyxcbiAgICAnXFx1MUUyQSc6ICdIJyxcbiAgICAnXFx1MDEyNic6ICdIJyxcbiAgICAnXFx1MkM2Nyc6ICdIJyxcbiAgICAnXFx1MkM3NSc6ICdIJyxcbiAgICAnXFx1QTc4RCc6ICdIJyxcbiAgICAnXFx1MjRCRSc6ICdJJyxcbiAgICAnXFx1RkYyOSc6ICdJJyxcbiAgICAnXFx1MDBDQyc6ICdJJyxcbiAgICAnXFx1MDBDRCc6ICdJJyxcbiAgICAnXFx1MDBDRSc6ICdJJyxcbiAgICAnXFx1MDEyOCc6ICdJJyxcbiAgICAnXFx1MDEyQSc6ICdJJyxcbiAgICAnXFx1MDEyQyc6ICdJJyxcbiAgICAnXFx1MDEzMCc6ICdJJyxcbiAgICAnXFx1MDBDRic6ICdJJyxcbiAgICAnXFx1MUUyRSc6ICdJJyxcbiAgICAnXFx1MUVDOCc6ICdJJyxcbiAgICAnXFx1MDFDRic6ICdJJyxcbiAgICAnXFx1MDIwOCc6ICdJJyxcbiAgICAnXFx1MDIwQSc6ICdJJyxcbiAgICAnXFx1MUVDQSc6ICdJJyxcbiAgICAnXFx1MDEyRSc6ICdJJyxcbiAgICAnXFx1MUUyQyc6ICdJJyxcbiAgICAnXFx1MDE5Nyc6ICdJJyxcbiAgICAnXFx1MjRCRic6ICdKJyxcbiAgICAnXFx1RkYyQSc6ICdKJyxcbiAgICAnXFx1MDEzNCc6ICdKJyxcbiAgICAnXFx1MDI0OCc6ICdKJyxcbiAgICAnXFx1MjRDMCc6ICdLJyxcbiAgICAnXFx1RkYyQic6ICdLJyxcbiAgICAnXFx1MUUzMCc6ICdLJyxcbiAgICAnXFx1MDFFOCc6ICdLJyxcbiAgICAnXFx1MUUzMic6ICdLJyxcbiAgICAnXFx1MDEzNic6ICdLJyxcbiAgICAnXFx1MUUzNCc6ICdLJyxcbiAgICAnXFx1MDE5OCc6ICdLJyxcbiAgICAnXFx1MkM2OSc6ICdLJyxcbiAgICAnXFx1QTc0MCc6ICdLJyxcbiAgICAnXFx1QTc0Mic6ICdLJyxcbiAgICAnXFx1QTc0NCc6ICdLJyxcbiAgICAnXFx1QTdBMic6ICdLJyxcbiAgICAnXFx1MjRDMSc6ICdMJyxcbiAgICAnXFx1RkYyQyc6ICdMJyxcbiAgICAnXFx1MDEzRic6ICdMJyxcbiAgICAnXFx1MDEzOSc6ICdMJyxcbiAgICAnXFx1MDEzRCc6ICdMJyxcbiAgICAnXFx1MUUzNic6ICdMJyxcbiAgICAnXFx1MUUzOCc6ICdMJyxcbiAgICAnXFx1MDEzQic6ICdMJyxcbiAgICAnXFx1MUUzQyc6ICdMJyxcbiAgICAnXFx1MUUzQSc6ICdMJyxcbiAgICAnXFx1MDE0MSc6ICdMJyxcbiAgICAnXFx1MDIzRCc6ICdMJyxcbiAgICAnXFx1MkM2Mic6ICdMJyxcbiAgICAnXFx1MkM2MCc6ICdMJyxcbiAgICAnXFx1QTc0OCc6ICdMJyxcbiAgICAnXFx1QTc0Nic6ICdMJyxcbiAgICAnXFx1QTc4MCc6ICdMJyxcbiAgICAnXFx1MDFDNyc6ICdMSicsXG4gICAgJ1xcdTAxQzgnOiAnTGonLFxuICAgICdcXHUyNEMyJzogJ00nLFxuICAgICdcXHVGRjJEJzogJ00nLFxuICAgICdcXHUxRTNFJzogJ00nLFxuICAgICdcXHUxRTQwJzogJ00nLFxuICAgICdcXHUxRTQyJzogJ00nLFxuICAgICdcXHUyQzZFJzogJ00nLFxuICAgICdcXHUwMTlDJzogJ00nLFxuICAgICdcXHUyNEMzJzogJ04nLFxuICAgICdcXHVGRjJFJzogJ04nLFxuICAgICdcXHUwMUY4JzogJ04nLFxuICAgICdcXHUwMTQzJzogJ04nLFxuICAgICdcXHUwMEQxJzogJ04nLFxuICAgICdcXHUxRTQ0JzogJ04nLFxuICAgICdcXHUwMTQ3JzogJ04nLFxuICAgICdcXHUxRTQ2JzogJ04nLFxuICAgICdcXHUwMTQ1JzogJ04nLFxuICAgICdcXHUxRTRBJzogJ04nLFxuICAgICdcXHUxRTQ4JzogJ04nLFxuICAgICdcXHUwMjIwJzogJ04nLFxuICAgICdcXHUwMTlEJzogJ04nLFxuICAgICdcXHVBNzkwJzogJ04nLFxuICAgICdcXHVBN0E0JzogJ04nLFxuICAgICdcXHUwMUNBJzogJ05KJyxcbiAgICAnXFx1MDFDQic6ICdOaicsXG4gICAgJ1xcdTI0QzQnOiAnTycsXG4gICAgJ1xcdUZGMkYnOiAnTycsXG4gICAgJ1xcdTAwRDInOiAnTycsXG4gICAgJ1xcdTAwRDMnOiAnTycsXG4gICAgJ1xcdTAwRDQnOiAnTycsXG4gICAgJ1xcdTFFRDInOiAnTycsXG4gICAgJ1xcdTFFRDAnOiAnTycsXG4gICAgJ1xcdTFFRDYnOiAnTycsXG4gICAgJ1xcdTFFRDQnOiAnTycsXG4gICAgJ1xcdTAwRDUnOiAnTycsXG4gICAgJ1xcdTFFNEMnOiAnTycsXG4gICAgJ1xcdTAyMkMnOiAnTycsXG4gICAgJ1xcdTFFNEUnOiAnTycsXG4gICAgJ1xcdTAxNEMnOiAnTycsXG4gICAgJ1xcdTFFNTAnOiAnTycsXG4gICAgJ1xcdTFFNTInOiAnTycsXG4gICAgJ1xcdTAxNEUnOiAnTycsXG4gICAgJ1xcdTAyMkUnOiAnTycsXG4gICAgJ1xcdTAyMzAnOiAnTycsXG4gICAgJ1xcdTAwRDYnOiAnTycsXG4gICAgJ1xcdTAyMkEnOiAnTycsXG4gICAgJ1xcdTFFQ0UnOiAnTycsXG4gICAgJ1xcdTAxNTAnOiAnTycsXG4gICAgJ1xcdTAxRDEnOiAnTycsXG4gICAgJ1xcdTAyMEMnOiAnTycsXG4gICAgJ1xcdTAyMEUnOiAnTycsXG4gICAgJ1xcdTAxQTAnOiAnTycsXG4gICAgJ1xcdTFFREMnOiAnTycsXG4gICAgJ1xcdTFFREEnOiAnTycsXG4gICAgJ1xcdTFFRTAnOiAnTycsXG4gICAgJ1xcdTFFREUnOiAnTycsXG4gICAgJ1xcdTFFRTInOiAnTycsXG4gICAgJ1xcdTFFQ0MnOiAnTycsXG4gICAgJ1xcdTFFRDgnOiAnTycsXG4gICAgJ1xcdTAxRUEnOiAnTycsXG4gICAgJ1xcdTAxRUMnOiAnTycsXG4gICAgJ1xcdTAwRDgnOiAnTycsXG4gICAgJ1xcdTAxRkUnOiAnTycsXG4gICAgJ1xcdTAxODYnOiAnTycsXG4gICAgJ1xcdTAxOUYnOiAnTycsXG4gICAgJ1xcdUE3NEEnOiAnTycsXG4gICAgJ1xcdUE3NEMnOiAnTycsXG4gICAgJ1xcdTAxQTInOiAnT0knLFxuICAgICdcXHVBNzRFJzogJ09PJyxcbiAgICAnXFx1MDIyMic6ICdPVScsXG4gICAgJ1xcdTI0QzUnOiAnUCcsXG4gICAgJ1xcdUZGMzAnOiAnUCcsXG4gICAgJ1xcdTFFNTQnOiAnUCcsXG4gICAgJ1xcdTFFNTYnOiAnUCcsXG4gICAgJ1xcdTAxQTQnOiAnUCcsXG4gICAgJ1xcdTJDNjMnOiAnUCcsXG4gICAgJ1xcdUE3NTAnOiAnUCcsXG4gICAgJ1xcdUE3NTInOiAnUCcsXG4gICAgJ1xcdUE3NTQnOiAnUCcsXG4gICAgJ1xcdTI0QzYnOiAnUScsXG4gICAgJ1xcdUZGMzEnOiAnUScsXG4gICAgJ1xcdUE3NTYnOiAnUScsXG4gICAgJ1xcdUE3NTgnOiAnUScsXG4gICAgJ1xcdTAyNEEnOiAnUScsXG4gICAgJ1xcdTI0QzcnOiAnUicsXG4gICAgJ1xcdUZGMzInOiAnUicsXG4gICAgJ1xcdTAxNTQnOiAnUicsXG4gICAgJ1xcdTFFNTgnOiAnUicsXG4gICAgJ1xcdTAxNTgnOiAnUicsXG4gICAgJ1xcdTAyMTAnOiAnUicsXG4gICAgJ1xcdTAyMTInOiAnUicsXG4gICAgJ1xcdTFFNUEnOiAnUicsXG4gICAgJ1xcdTFFNUMnOiAnUicsXG4gICAgJ1xcdTAxNTYnOiAnUicsXG4gICAgJ1xcdTFFNUUnOiAnUicsXG4gICAgJ1xcdTAyNEMnOiAnUicsXG4gICAgJ1xcdTJDNjQnOiAnUicsXG4gICAgJ1xcdUE3NUEnOiAnUicsXG4gICAgJ1xcdUE3QTYnOiAnUicsXG4gICAgJ1xcdUE3ODInOiAnUicsXG4gICAgJ1xcdTI0QzgnOiAnUycsXG4gICAgJ1xcdUZGMzMnOiAnUycsXG4gICAgJ1xcdTFFOUUnOiAnUycsXG4gICAgJ1xcdTAxNUEnOiAnUycsXG4gICAgJ1xcdTFFNjQnOiAnUycsXG4gICAgJ1xcdTAxNUMnOiAnUycsXG4gICAgJ1xcdTFFNjAnOiAnUycsXG4gICAgJ1xcdTAxNjAnOiAnUycsXG4gICAgJ1xcdTFFNjYnOiAnUycsXG4gICAgJ1xcdTFFNjInOiAnUycsXG4gICAgJ1xcdTFFNjgnOiAnUycsXG4gICAgJ1xcdTAyMTgnOiAnUycsXG4gICAgJ1xcdTAxNUUnOiAnUycsXG4gICAgJ1xcdTJDN0UnOiAnUycsXG4gICAgJ1xcdUE3QTgnOiAnUycsXG4gICAgJ1xcdUE3ODQnOiAnUycsXG4gICAgJ1xcdTI0QzknOiAnVCcsXG4gICAgJ1xcdUZGMzQnOiAnVCcsXG4gICAgJ1xcdTFFNkEnOiAnVCcsXG4gICAgJ1xcdTAxNjQnOiAnVCcsXG4gICAgJ1xcdTFFNkMnOiAnVCcsXG4gICAgJ1xcdTAyMUEnOiAnVCcsXG4gICAgJ1xcdTAxNjInOiAnVCcsXG4gICAgJ1xcdTFFNzAnOiAnVCcsXG4gICAgJ1xcdTFFNkUnOiAnVCcsXG4gICAgJ1xcdTAxNjYnOiAnVCcsXG4gICAgJ1xcdTAxQUMnOiAnVCcsXG4gICAgJ1xcdTAxQUUnOiAnVCcsXG4gICAgJ1xcdTAyM0UnOiAnVCcsXG4gICAgJ1xcdUE3ODYnOiAnVCcsXG4gICAgJ1xcdUE3MjgnOiAnVFonLFxuICAgICdcXHUyNENBJzogJ1UnLFxuICAgICdcXHVGRjM1JzogJ1UnLFxuICAgICdcXHUwMEQ5JzogJ1UnLFxuICAgICdcXHUwMERBJzogJ1UnLFxuICAgICdcXHUwMERCJzogJ1UnLFxuICAgICdcXHUwMTY4JzogJ1UnLFxuICAgICdcXHUxRTc4JzogJ1UnLFxuICAgICdcXHUwMTZBJzogJ1UnLFxuICAgICdcXHUxRTdBJzogJ1UnLFxuICAgICdcXHUwMTZDJzogJ1UnLFxuICAgICdcXHUwMERDJzogJ1UnLFxuICAgICdcXHUwMURCJzogJ1UnLFxuICAgICdcXHUwMUQ3JzogJ1UnLFxuICAgICdcXHUwMUQ1JzogJ1UnLFxuICAgICdcXHUwMUQ5JzogJ1UnLFxuICAgICdcXHUxRUU2JzogJ1UnLFxuICAgICdcXHUwMTZFJzogJ1UnLFxuICAgICdcXHUwMTcwJzogJ1UnLFxuICAgICdcXHUwMUQzJzogJ1UnLFxuICAgICdcXHUwMjE0JzogJ1UnLFxuICAgICdcXHUwMjE2JzogJ1UnLFxuICAgICdcXHUwMUFGJzogJ1UnLFxuICAgICdcXHUxRUVBJzogJ1UnLFxuICAgICdcXHUxRUU4JzogJ1UnLFxuICAgICdcXHUxRUVFJzogJ1UnLFxuICAgICdcXHUxRUVDJzogJ1UnLFxuICAgICdcXHUxRUYwJzogJ1UnLFxuICAgICdcXHUxRUU0JzogJ1UnLFxuICAgICdcXHUxRTcyJzogJ1UnLFxuICAgICdcXHUwMTcyJzogJ1UnLFxuICAgICdcXHUxRTc2JzogJ1UnLFxuICAgICdcXHUxRTc0JzogJ1UnLFxuICAgICdcXHUwMjQ0JzogJ1UnLFxuICAgICdcXHUyNENCJzogJ1YnLFxuICAgICdcXHVGRjM2JzogJ1YnLFxuICAgICdcXHUxRTdDJzogJ1YnLFxuICAgICdcXHUxRTdFJzogJ1YnLFxuICAgICdcXHUwMUIyJzogJ1YnLFxuICAgICdcXHVBNzVFJzogJ1YnLFxuICAgICdcXHUwMjQ1JzogJ1YnLFxuICAgICdcXHVBNzYwJzogJ1ZZJyxcbiAgICAnXFx1MjRDQyc6ICdXJyxcbiAgICAnXFx1RkYzNyc6ICdXJyxcbiAgICAnXFx1MUU4MCc6ICdXJyxcbiAgICAnXFx1MUU4Mic6ICdXJyxcbiAgICAnXFx1MDE3NCc6ICdXJyxcbiAgICAnXFx1MUU4Nic6ICdXJyxcbiAgICAnXFx1MUU4NCc6ICdXJyxcbiAgICAnXFx1MUU4OCc6ICdXJyxcbiAgICAnXFx1MkM3Mic6ICdXJyxcbiAgICAnXFx1MjRDRCc6ICdYJyxcbiAgICAnXFx1RkYzOCc6ICdYJyxcbiAgICAnXFx1MUU4QSc6ICdYJyxcbiAgICAnXFx1MUU4Qyc6ICdYJyxcbiAgICAnXFx1MjRDRSc6ICdZJyxcbiAgICAnXFx1RkYzOSc6ICdZJyxcbiAgICAnXFx1MUVGMic6ICdZJyxcbiAgICAnXFx1MDBERCc6ICdZJyxcbiAgICAnXFx1MDE3Nic6ICdZJyxcbiAgICAnXFx1MUVGOCc6ICdZJyxcbiAgICAnXFx1MDIzMic6ICdZJyxcbiAgICAnXFx1MUU4RSc6ICdZJyxcbiAgICAnXFx1MDE3OCc6ICdZJyxcbiAgICAnXFx1MUVGNic6ICdZJyxcbiAgICAnXFx1MUVGNCc6ICdZJyxcbiAgICAnXFx1MDFCMyc6ICdZJyxcbiAgICAnXFx1MDI0RSc6ICdZJyxcbiAgICAnXFx1MUVGRSc6ICdZJyxcbiAgICAnXFx1MjRDRic6ICdaJyxcbiAgICAnXFx1RkYzQSc6ICdaJyxcbiAgICAnXFx1MDE3OSc6ICdaJyxcbiAgICAnXFx1MUU5MCc6ICdaJyxcbiAgICAnXFx1MDE3Qic6ICdaJyxcbiAgICAnXFx1MDE3RCc6ICdaJyxcbiAgICAnXFx1MUU5Mic6ICdaJyxcbiAgICAnXFx1MUU5NCc6ICdaJyxcbiAgICAnXFx1MDFCNSc6ICdaJyxcbiAgICAnXFx1MDIyNCc6ICdaJyxcbiAgICAnXFx1MkM3Ric6ICdaJyxcbiAgICAnXFx1MkM2Qic6ICdaJyxcbiAgICAnXFx1QTc2Mic6ICdaJyxcbiAgICAnXFx1MjREMCc6ICdhJyxcbiAgICAnXFx1RkY0MSc6ICdhJyxcbiAgICAnXFx1MUU5QSc6ICdhJyxcbiAgICAnXFx1MDBFMCc6ICdhJyxcbiAgICAnXFx1MDBFMSc6ICdhJyxcbiAgICAnXFx1MDBFMic6ICdhJyxcbiAgICAnXFx1MUVBNyc6ICdhJyxcbiAgICAnXFx1MUVBNSc6ICdhJyxcbiAgICAnXFx1MUVBQic6ICdhJyxcbiAgICAnXFx1MUVBOSc6ICdhJyxcbiAgICAnXFx1MDBFMyc6ICdhJyxcbiAgICAnXFx1MDEwMSc6ICdhJyxcbiAgICAnXFx1MDEwMyc6ICdhJyxcbiAgICAnXFx1MUVCMSc6ICdhJyxcbiAgICAnXFx1MUVBRic6ICdhJyxcbiAgICAnXFx1MUVCNSc6ICdhJyxcbiAgICAnXFx1MUVCMyc6ICdhJyxcbiAgICAnXFx1MDIyNyc6ICdhJyxcbiAgICAnXFx1MDFFMSc6ICdhJyxcbiAgICAnXFx1MDBFNCc6ICdhJyxcbiAgICAnXFx1MDFERic6ICdhJyxcbiAgICAnXFx1MUVBMyc6ICdhJyxcbiAgICAnXFx1MDBFNSc6ICdhJyxcbiAgICAnXFx1MDFGQic6ICdhJyxcbiAgICAnXFx1MDFDRSc6ICdhJyxcbiAgICAnXFx1MDIwMSc6ICdhJyxcbiAgICAnXFx1MDIwMyc6ICdhJyxcbiAgICAnXFx1MUVBMSc6ICdhJyxcbiAgICAnXFx1MUVBRCc6ICdhJyxcbiAgICAnXFx1MUVCNyc6ICdhJyxcbiAgICAnXFx1MUUwMSc6ICdhJyxcbiAgICAnXFx1MDEwNSc6ICdhJyxcbiAgICAnXFx1MkM2NSc6ICdhJyxcbiAgICAnXFx1MDI1MCc6ICdhJyxcbiAgICAnXFx1QTczMyc6ICdhYScsXG4gICAgJ1xcdTAwRTYnOiAnYWUnLFxuICAgICdcXHUwMUZEJzogJ2FlJyxcbiAgICAnXFx1MDFFMyc6ICdhZScsXG4gICAgJ1xcdUE3MzUnOiAnYW8nLFxuICAgICdcXHVBNzM3JzogJ2F1JyxcbiAgICAnXFx1QTczOSc6ICdhdicsXG4gICAgJ1xcdUE3M0InOiAnYXYnLFxuICAgICdcXHVBNzNEJzogJ2F5JyxcbiAgICAnXFx1MjREMSc6ICdiJyxcbiAgICAnXFx1RkY0Mic6ICdiJyxcbiAgICAnXFx1MUUwMyc6ICdiJyxcbiAgICAnXFx1MUUwNSc6ICdiJyxcbiAgICAnXFx1MUUwNyc6ICdiJyxcbiAgICAnXFx1MDE4MCc6ICdiJyxcbiAgICAnXFx1MDE4Myc6ICdiJyxcbiAgICAnXFx1MDI1Myc6ICdiJyxcbiAgICAnXFx1MjREMic6ICdjJyxcbiAgICAnXFx1RkY0Myc6ICdjJyxcbiAgICAnXFx1MDEwNyc6ICdjJyxcbiAgICAnXFx1MDEwOSc6ICdjJyxcbiAgICAnXFx1MDEwQic6ICdjJyxcbiAgICAnXFx1MDEwRCc6ICdjJyxcbiAgICAnXFx1MDBFNyc6ICdjJyxcbiAgICAnXFx1MUUwOSc6ICdjJyxcbiAgICAnXFx1MDE4OCc6ICdjJyxcbiAgICAnXFx1MDIzQyc6ICdjJyxcbiAgICAnXFx1QTczRic6ICdjJyxcbiAgICAnXFx1MjE4NCc6ICdjJyxcbiAgICAnXFx1MjREMyc6ICdkJyxcbiAgICAnXFx1RkY0NCc6ICdkJyxcbiAgICAnXFx1MUUwQic6ICdkJyxcbiAgICAnXFx1MDEwRic6ICdkJyxcbiAgICAnXFx1MUUwRCc6ICdkJyxcbiAgICAnXFx1MUUxMSc6ICdkJyxcbiAgICAnXFx1MUUxMyc6ICdkJyxcbiAgICAnXFx1MUUwRic6ICdkJyxcbiAgICAnXFx1MDExMSc6ICdkJyxcbiAgICAnXFx1MDE4Qyc6ICdkJyxcbiAgICAnXFx1MDI1Nic6ICdkJyxcbiAgICAnXFx1MDI1Nyc6ICdkJyxcbiAgICAnXFx1QTc3QSc6ICdkJyxcbiAgICAnXFx1MDFGMyc6ICdkeicsXG4gICAgJ1xcdTAxQzYnOiAnZHonLFxuICAgICdcXHUyNEQ0JzogJ2UnLFxuICAgICdcXHVGRjQ1JzogJ2UnLFxuICAgICdcXHUwMEU4JzogJ2UnLFxuICAgICdcXHUwMEU5JzogJ2UnLFxuICAgICdcXHUwMEVBJzogJ2UnLFxuICAgICdcXHUxRUMxJzogJ2UnLFxuICAgICdcXHUxRUJGJzogJ2UnLFxuICAgICdcXHUxRUM1JzogJ2UnLFxuICAgICdcXHUxRUMzJzogJ2UnLFxuICAgICdcXHUxRUJEJzogJ2UnLFxuICAgICdcXHUwMTEzJzogJ2UnLFxuICAgICdcXHUxRTE1JzogJ2UnLFxuICAgICdcXHUxRTE3JzogJ2UnLFxuICAgICdcXHUwMTE1JzogJ2UnLFxuICAgICdcXHUwMTE3JzogJ2UnLFxuICAgICdcXHUwMEVCJzogJ2UnLFxuICAgICdcXHUxRUJCJzogJ2UnLFxuICAgICdcXHUwMTFCJzogJ2UnLFxuICAgICdcXHUwMjA1JzogJ2UnLFxuICAgICdcXHUwMjA3JzogJ2UnLFxuICAgICdcXHUxRUI5JzogJ2UnLFxuICAgICdcXHUxRUM3JzogJ2UnLFxuICAgICdcXHUwMjI5JzogJ2UnLFxuICAgICdcXHUxRTFEJzogJ2UnLFxuICAgICdcXHUwMTE5JzogJ2UnLFxuICAgICdcXHUxRTE5JzogJ2UnLFxuICAgICdcXHUxRTFCJzogJ2UnLFxuICAgICdcXHUwMjQ3JzogJ2UnLFxuICAgICdcXHUwMjVCJzogJ2UnLFxuICAgICdcXHUwMUREJzogJ2UnLFxuICAgICdcXHUyNEQ1JzogJ2YnLFxuICAgICdcXHVGRjQ2JzogJ2YnLFxuICAgICdcXHUxRTFGJzogJ2YnLFxuICAgICdcXHUwMTkyJzogJ2YnLFxuICAgICdcXHVBNzdDJzogJ2YnLFxuICAgICdcXHUyNEQ2JzogJ2cnLFxuICAgICdcXHVGRjQ3JzogJ2cnLFxuICAgICdcXHUwMUY1JzogJ2cnLFxuICAgICdcXHUwMTFEJzogJ2cnLFxuICAgICdcXHUxRTIxJzogJ2cnLFxuICAgICdcXHUwMTFGJzogJ2cnLFxuICAgICdcXHUwMTIxJzogJ2cnLFxuICAgICdcXHUwMUU3JzogJ2cnLFxuICAgICdcXHUwMTIzJzogJ2cnLFxuICAgICdcXHUwMUU1JzogJ2cnLFxuICAgICdcXHUwMjYwJzogJ2cnLFxuICAgICdcXHVBN0ExJzogJ2cnLFxuICAgICdcXHUxRDc5JzogJ2cnLFxuICAgICdcXHVBNzdGJzogJ2cnLFxuICAgICdcXHUyNEQ3JzogJ2gnLFxuICAgICdcXHVGRjQ4JzogJ2gnLFxuICAgICdcXHUwMTI1JzogJ2gnLFxuICAgICdcXHUxRTIzJzogJ2gnLFxuICAgICdcXHUxRTI3JzogJ2gnLFxuICAgICdcXHUwMjFGJzogJ2gnLFxuICAgICdcXHUxRTI1JzogJ2gnLFxuICAgICdcXHUxRTI5JzogJ2gnLFxuICAgICdcXHUxRTJCJzogJ2gnLFxuICAgICdcXHUxRTk2JzogJ2gnLFxuICAgICdcXHUwMTI3JzogJ2gnLFxuICAgICdcXHUyQzY4JzogJ2gnLFxuICAgICdcXHUyQzc2JzogJ2gnLFxuICAgICdcXHUwMjY1JzogJ2gnLFxuICAgICdcXHUwMTk1JzogJ2h2JyxcbiAgICAnXFx1MjREOCc6ICdpJyxcbiAgICAnXFx1RkY0OSc6ICdpJyxcbiAgICAnXFx1MDBFQyc6ICdpJyxcbiAgICAnXFx1MDBFRCc6ICdpJyxcbiAgICAnXFx1MDBFRSc6ICdpJyxcbiAgICAnXFx1MDEyOSc6ICdpJyxcbiAgICAnXFx1MDEyQic6ICdpJyxcbiAgICAnXFx1MDEyRCc6ICdpJyxcbiAgICAnXFx1MDBFRic6ICdpJyxcbiAgICAnXFx1MUUyRic6ICdpJyxcbiAgICAnXFx1MUVDOSc6ICdpJyxcbiAgICAnXFx1MDFEMCc6ICdpJyxcbiAgICAnXFx1MDIwOSc6ICdpJyxcbiAgICAnXFx1MDIwQic6ICdpJyxcbiAgICAnXFx1MUVDQic6ICdpJyxcbiAgICAnXFx1MDEyRic6ICdpJyxcbiAgICAnXFx1MUUyRCc6ICdpJyxcbiAgICAnXFx1MDI2OCc6ICdpJyxcbiAgICAnXFx1MDEzMSc6ICdpJyxcbiAgICAnXFx1MjREOSc6ICdqJyxcbiAgICAnXFx1RkY0QSc6ICdqJyxcbiAgICAnXFx1MDEzNSc6ICdqJyxcbiAgICAnXFx1MDFGMCc6ICdqJyxcbiAgICAnXFx1MDI0OSc6ICdqJyxcbiAgICAnXFx1MjREQSc6ICdrJyxcbiAgICAnXFx1RkY0Qic6ICdrJyxcbiAgICAnXFx1MUUzMSc6ICdrJyxcbiAgICAnXFx1MDFFOSc6ICdrJyxcbiAgICAnXFx1MUUzMyc6ICdrJyxcbiAgICAnXFx1MDEzNyc6ICdrJyxcbiAgICAnXFx1MUUzNSc6ICdrJyxcbiAgICAnXFx1MDE5OSc6ICdrJyxcbiAgICAnXFx1MkM2QSc6ICdrJyxcbiAgICAnXFx1QTc0MSc6ICdrJyxcbiAgICAnXFx1QTc0Myc6ICdrJyxcbiAgICAnXFx1QTc0NSc6ICdrJyxcbiAgICAnXFx1QTdBMyc6ICdrJyxcbiAgICAnXFx1MjREQic6ICdsJyxcbiAgICAnXFx1RkY0Qyc6ICdsJyxcbiAgICAnXFx1MDE0MCc6ICdsJyxcbiAgICAnXFx1MDEzQSc6ICdsJyxcbiAgICAnXFx1MDEzRSc6ICdsJyxcbiAgICAnXFx1MUUzNyc6ICdsJyxcbiAgICAnXFx1MUUzOSc6ICdsJyxcbiAgICAnXFx1MDEzQyc6ICdsJyxcbiAgICAnXFx1MUUzRCc6ICdsJyxcbiAgICAnXFx1MUUzQic6ICdsJyxcbiAgICAnXFx1MDE3Ric6ICdsJyxcbiAgICAnXFx1MDE0Mic6ICdsJyxcbiAgICAnXFx1MDE5QSc6ICdsJyxcbiAgICAnXFx1MDI2Qic6ICdsJyxcbiAgICAnXFx1MkM2MSc6ICdsJyxcbiAgICAnXFx1QTc0OSc6ICdsJyxcbiAgICAnXFx1QTc4MSc6ICdsJyxcbiAgICAnXFx1QTc0Nyc6ICdsJyxcbiAgICAnXFx1MDFDOSc6ICdsaicsXG4gICAgJ1xcdTI0REMnOiAnbScsXG4gICAgJ1xcdUZGNEQnOiAnbScsXG4gICAgJ1xcdTFFM0YnOiAnbScsXG4gICAgJ1xcdTFFNDEnOiAnbScsXG4gICAgJ1xcdTFFNDMnOiAnbScsXG4gICAgJ1xcdTAyNzEnOiAnbScsXG4gICAgJ1xcdTAyNkYnOiAnbScsXG4gICAgJ1xcdTI0REQnOiAnbicsXG4gICAgJ1xcdUZGNEUnOiAnbicsXG4gICAgJ1xcdTAxRjknOiAnbicsXG4gICAgJ1xcdTAxNDQnOiAnbicsXG4gICAgJ1xcdTAwRjEnOiAnbicsXG4gICAgJ1xcdTFFNDUnOiAnbicsXG4gICAgJ1xcdTAxNDgnOiAnbicsXG4gICAgJ1xcdTFFNDcnOiAnbicsXG4gICAgJ1xcdTAxNDYnOiAnbicsXG4gICAgJ1xcdTFFNEInOiAnbicsXG4gICAgJ1xcdTFFNDknOiAnbicsXG4gICAgJ1xcdTAxOUUnOiAnbicsXG4gICAgJ1xcdTAyNzInOiAnbicsXG4gICAgJ1xcdTAxNDknOiAnbicsXG4gICAgJ1xcdUE3OTEnOiAnbicsXG4gICAgJ1xcdUE3QTUnOiAnbicsXG4gICAgJ1xcdTAxQ0MnOiAnbmonLFxuICAgICdcXHUyNERFJzogJ28nLFxuICAgICdcXHVGRjRGJzogJ28nLFxuICAgICdcXHUwMEYyJzogJ28nLFxuICAgICdcXHUwMEYzJzogJ28nLFxuICAgICdcXHUwMEY0JzogJ28nLFxuICAgICdcXHUxRUQzJzogJ28nLFxuICAgICdcXHUxRUQxJzogJ28nLFxuICAgICdcXHUxRUQ3JzogJ28nLFxuICAgICdcXHUxRUQ1JzogJ28nLFxuICAgICdcXHUwMEY1JzogJ28nLFxuICAgICdcXHUxRTREJzogJ28nLFxuICAgICdcXHUwMjJEJzogJ28nLFxuICAgICdcXHUxRTRGJzogJ28nLFxuICAgICdcXHUwMTREJzogJ28nLFxuICAgICdcXHUxRTUxJzogJ28nLFxuICAgICdcXHUxRTUzJzogJ28nLFxuICAgICdcXHUwMTRGJzogJ28nLFxuICAgICdcXHUwMjJGJzogJ28nLFxuICAgICdcXHUwMjMxJzogJ28nLFxuICAgICdcXHUwMEY2JzogJ28nLFxuICAgICdcXHUwMjJCJzogJ28nLFxuICAgICdcXHUxRUNGJzogJ28nLFxuICAgICdcXHUwMTUxJzogJ28nLFxuICAgICdcXHUwMUQyJzogJ28nLFxuICAgICdcXHUwMjBEJzogJ28nLFxuICAgICdcXHUwMjBGJzogJ28nLFxuICAgICdcXHUwMUExJzogJ28nLFxuICAgICdcXHUxRUREJzogJ28nLFxuICAgICdcXHUxRURCJzogJ28nLFxuICAgICdcXHUxRUUxJzogJ28nLFxuICAgICdcXHUxRURGJzogJ28nLFxuICAgICdcXHUxRUUzJzogJ28nLFxuICAgICdcXHUxRUNEJzogJ28nLFxuICAgICdcXHUxRUQ5JzogJ28nLFxuICAgICdcXHUwMUVCJzogJ28nLFxuICAgICdcXHUwMUVEJzogJ28nLFxuICAgICdcXHUwMEY4JzogJ28nLFxuICAgICdcXHUwMUZGJzogJ28nLFxuICAgICdcXHUwMjU0JzogJ28nLFxuICAgICdcXHVBNzRCJzogJ28nLFxuICAgICdcXHVBNzREJzogJ28nLFxuICAgICdcXHUwMjc1JzogJ28nLFxuICAgICdcXHUwMUEzJzogJ29pJyxcbiAgICAnXFx1MDIyMyc6ICdvdScsXG4gICAgJ1xcdUE3NEYnOiAnb28nLFxuICAgICdcXHUyNERGJzogJ3AnLFxuICAgICdcXHVGRjUwJzogJ3AnLFxuICAgICdcXHUxRTU1JzogJ3AnLFxuICAgICdcXHUxRTU3JzogJ3AnLFxuICAgICdcXHUwMUE1JzogJ3AnLFxuICAgICdcXHUxRDdEJzogJ3AnLFxuICAgICdcXHVBNzUxJzogJ3AnLFxuICAgICdcXHVBNzUzJzogJ3AnLFxuICAgICdcXHVBNzU1JzogJ3AnLFxuICAgICdcXHUyNEUwJzogJ3EnLFxuICAgICdcXHVGRjUxJzogJ3EnLFxuICAgICdcXHUwMjRCJzogJ3EnLFxuICAgICdcXHVBNzU3JzogJ3EnLFxuICAgICdcXHVBNzU5JzogJ3EnLFxuICAgICdcXHUyNEUxJzogJ3InLFxuICAgICdcXHVGRjUyJzogJ3InLFxuICAgICdcXHUwMTU1JzogJ3InLFxuICAgICdcXHUxRTU5JzogJ3InLFxuICAgICdcXHUwMTU5JzogJ3InLFxuICAgICdcXHUwMjExJzogJ3InLFxuICAgICdcXHUwMjEzJzogJ3InLFxuICAgICdcXHUxRTVCJzogJ3InLFxuICAgICdcXHUxRTVEJzogJ3InLFxuICAgICdcXHUwMTU3JzogJ3InLFxuICAgICdcXHUxRTVGJzogJ3InLFxuICAgICdcXHUwMjREJzogJ3InLFxuICAgICdcXHUwMjdEJzogJ3InLFxuICAgICdcXHVBNzVCJzogJ3InLFxuICAgICdcXHVBN0E3JzogJ3InLFxuICAgICdcXHVBNzgzJzogJ3InLFxuICAgICdcXHUyNEUyJzogJ3MnLFxuICAgICdcXHVGRjUzJzogJ3MnLFxuICAgICdcXHUwMERGJzogJ3MnLFxuICAgICdcXHUwMTVCJzogJ3MnLFxuICAgICdcXHUxRTY1JzogJ3MnLFxuICAgICdcXHUwMTVEJzogJ3MnLFxuICAgICdcXHUxRTYxJzogJ3MnLFxuICAgICdcXHUwMTYxJzogJ3MnLFxuICAgICdcXHUxRTY3JzogJ3MnLFxuICAgICdcXHUxRTYzJzogJ3MnLFxuICAgICdcXHUxRTY5JzogJ3MnLFxuICAgICdcXHUwMjE5JzogJ3MnLFxuICAgICdcXHUwMTVGJzogJ3MnLFxuICAgICdcXHUwMjNGJzogJ3MnLFxuICAgICdcXHVBN0E5JzogJ3MnLFxuICAgICdcXHVBNzg1JzogJ3MnLFxuICAgICdcXHUxRTlCJzogJ3MnLFxuICAgICdcXHUyNEUzJzogJ3QnLFxuICAgICdcXHVGRjU0JzogJ3QnLFxuICAgICdcXHUxRTZCJzogJ3QnLFxuICAgICdcXHUxRTk3JzogJ3QnLFxuICAgICdcXHUwMTY1JzogJ3QnLFxuICAgICdcXHUxRTZEJzogJ3QnLFxuICAgICdcXHUwMjFCJzogJ3QnLFxuICAgICdcXHUwMTYzJzogJ3QnLFxuICAgICdcXHUxRTcxJzogJ3QnLFxuICAgICdcXHUxRTZGJzogJ3QnLFxuICAgICdcXHUwMTY3JzogJ3QnLFxuICAgICdcXHUwMUFEJzogJ3QnLFxuICAgICdcXHUwMjg4JzogJ3QnLFxuICAgICdcXHUyQzY2JzogJ3QnLFxuICAgICdcXHVBNzg3JzogJ3QnLFxuICAgICdcXHVBNzI5JzogJ3R6JyxcbiAgICAnXFx1MjRFNCc6ICd1JyxcbiAgICAnXFx1RkY1NSc6ICd1JyxcbiAgICAnXFx1MDBGOSc6ICd1JyxcbiAgICAnXFx1MDBGQSc6ICd1JyxcbiAgICAnXFx1MDBGQic6ICd1JyxcbiAgICAnXFx1MDE2OSc6ICd1JyxcbiAgICAnXFx1MUU3OSc6ICd1JyxcbiAgICAnXFx1MDE2Qic6ICd1JyxcbiAgICAnXFx1MUU3Qic6ICd1JyxcbiAgICAnXFx1MDE2RCc6ICd1JyxcbiAgICAnXFx1MDBGQyc6ICd1JyxcbiAgICAnXFx1MDFEQyc6ICd1JyxcbiAgICAnXFx1MDFEOCc6ICd1JyxcbiAgICAnXFx1MDFENic6ICd1JyxcbiAgICAnXFx1MDFEQSc6ICd1JyxcbiAgICAnXFx1MUVFNyc6ICd1JyxcbiAgICAnXFx1MDE2Ric6ICd1JyxcbiAgICAnXFx1MDE3MSc6ICd1JyxcbiAgICAnXFx1MDFENCc6ICd1JyxcbiAgICAnXFx1MDIxNSc6ICd1JyxcbiAgICAnXFx1MDIxNyc6ICd1JyxcbiAgICAnXFx1MDFCMCc6ICd1JyxcbiAgICAnXFx1MUVFQic6ICd1JyxcbiAgICAnXFx1MUVFOSc6ICd1JyxcbiAgICAnXFx1MUVFRic6ICd1JyxcbiAgICAnXFx1MUVFRCc6ICd1JyxcbiAgICAnXFx1MUVGMSc6ICd1JyxcbiAgICAnXFx1MUVFNSc6ICd1JyxcbiAgICAnXFx1MUU3Myc6ICd1JyxcbiAgICAnXFx1MDE3Myc6ICd1JyxcbiAgICAnXFx1MUU3Nyc6ICd1JyxcbiAgICAnXFx1MUU3NSc6ICd1JyxcbiAgICAnXFx1MDI4OSc6ICd1JyxcbiAgICAnXFx1MjRFNSc6ICd2JyxcbiAgICAnXFx1RkY1Nic6ICd2JyxcbiAgICAnXFx1MUU3RCc6ICd2JyxcbiAgICAnXFx1MUU3Ric6ICd2JyxcbiAgICAnXFx1MDI4Qic6ICd2JyxcbiAgICAnXFx1QTc1Ric6ICd2JyxcbiAgICAnXFx1MDI4Qyc6ICd2JyxcbiAgICAnXFx1QTc2MSc6ICd2eScsXG4gICAgJ1xcdTI0RTYnOiAndycsXG4gICAgJ1xcdUZGNTcnOiAndycsXG4gICAgJ1xcdTFFODEnOiAndycsXG4gICAgJ1xcdTFFODMnOiAndycsXG4gICAgJ1xcdTAxNzUnOiAndycsXG4gICAgJ1xcdTFFODcnOiAndycsXG4gICAgJ1xcdTFFODUnOiAndycsXG4gICAgJ1xcdTFFOTgnOiAndycsXG4gICAgJ1xcdTFFODknOiAndycsXG4gICAgJ1xcdTJDNzMnOiAndycsXG4gICAgJ1xcdTI0RTcnOiAneCcsXG4gICAgJ1xcdUZGNTgnOiAneCcsXG4gICAgJ1xcdTFFOEInOiAneCcsXG4gICAgJ1xcdTFFOEQnOiAneCcsXG4gICAgJ1xcdTI0RTgnOiAneScsXG4gICAgJ1xcdUZGNTknOiAneScsXG4gICAgJ1xcdTFFRjMnOiAneScsXG4gICAgJ1xcdTAwRkQnOiAneScsXG4gICAgJ1xcdTAxNzcnOiAneScsXG4gICAgJ1xcdTFFRjknOiAneScsXG4gICAgJ1xcdTAyMzMnOiAneScsXG4gICAgJ1xcdTFFOEYnOiAneScsXG4gICAgJ1xcdTAwRkYnOiAneScsXG4gICAgJ1xcdTFFRjcnOiAneScsXG4gICAgJ1xcdTFFOTknOiAneScsXG4gICAgJ1xcdTFFRjUnOiAneScsXG4gICAgJ1xcdTAxQjQnOiAneScsXG4gICAgJ1xcdTAyNEYnOiAneScsXG4gICAgJ1xcdTFFRkYnOiAneScsXG4gICAgJ1xcdTI0RTknOiAneicsXG4gICAgJ1xcdUZGNUEnOiAneicsXG4gICAgJ1xcdTAxN0EnOiAneicsXG4gICAgJ1xcdTFFOTEnOiAneicsXG4gICAgJ1xcdTAxN0MnOiAneicsXG4gICAgJ1xcdTAxN0UnOiAneicsXG4gICAgJ1xcdTFFOTMnOiAneicsXG4gICAgJ1xcdTFFOTUnOiAneicsXG4gICAgJ1xcdTAxQjYnOiAneicsXG4gICAgJ1xcdTAyMjUnOiAneicsXG4gICAgJ1xcdTAyNDAnOiAneicsXG4gICAgJ1xcdTJDNkMnOiAneicsXG4gICAgJ1xcdUE3NjMnOiAneicsXG4gICAgJ1xcdTAzODYnOiAnXFx1MDM5MScsXG4gICAgJ1xcdTAzODgnOiAnXFx1MDM5NScsXG4gICAgJ1xcdTAzODknOiAnXFx1MDM5NycsXG4gICAgJ1xcdTAzOEEnOiAnXFx1MDM5OScsXG4gICAgJ1xcdTAzQUEnOiAnXFx1MDM5OScsXG4gICAgJ1xcdTAzOEMnOiAnXFx1MDM5RicsXG4gICAgJ1xcdTAzOEUnOiAnXFx1MDNBNScsXG4gICAgJ1xcdTAzQUInOiAnXFx1MDNBNScsXG4gICAgJ1xcdTAzOEYnOiAnXFx1MDNBOScsXG4gICAgJ1xcdTAzQUMnOiAnXFx1MDNCMScsXG4gICAgJ1xcdTAzQUQnOiAnXFx1MDNCNScsXG4gICAgJ1xcdTAzQUUnOiAnXFx1MDNCNycsXG4gICAgJ1xcdTAzQUYnOiAnXFx1MDNCOScsXG4gICAgJ1xcdTAzQ0EnOiAnXFx1MDNCOScsXG4gICAgJ1xcdTAzOTAnOiAnXFx1MDNCOScsXG4gICAgJ1xcdTAzQ0MnOiAnXFx1MDNCRicsXG4gICAgJ1xcdTAzQ0QnOiAnXFx1MDNDNScsXG4gICAgJ1xcdTAzQ0InOiAnXFx1MDNDNScsXG4gICAgJ1xcdTAzQjAnOiAnXFx1MDNDNScsXG4gICAgJ1xcdTAzQzknOiAnXFx1MDNDOScsXG4gICAgJ1xcdTAzQzInOiAnXFx1MDNDMydcbiAgfTtcblxuICByZXR1cm4gZGlhY3JpdGljcztcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZGF0YS9iYXNlJyxbXG4gICcuLi91dGlscydcbl0sIGZ1bmN0aW9uIChVdGlscykge1xuICBmdW5jdGlvbiBCYXNlQWRhcHRlciAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBCYXNlQWRhcHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIFV0aWxzLkV4dGVuZChCYXNlQWRhcHRlciwgVXRpbHMuT2JzZXJ2YWJsZSk7XG5cbiAgQmFzZUFkYXB0ZXIucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgY3VycmVudGAgbWV0aG9kIG11c3QgYmUgZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzLicpO1xuICB9O1xuXG4gIEJhc2VBZGFwdGVyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHF1ZXJ5YCBtZXRob2QgbXVzdCBiZSBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXMuJyk7XG4gIH07XG5cbiAgQmFzZUFkYXB0ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCAkY29udGFpbmVyKSB7XG4gICAgLy8gQ2FuIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcbiAgfTtcblxuICBCYXNlQWRhcHRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDYW4gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xuICB9O1xuXG4gIEJhc2VBZGFwdGVyLnByb3RvdHlwZS5nZW5lcmF0ZVJlc3VsdElkID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgZGF0YSkge1xuICAgIHZhciBpZCA9IGNvbnRhaW5lci5pZCArICctcmVzdWx0LSc7XG5cbiAgICBpZCArPSBVdGlscy5nZW5lcmF0ZUNoYXJzKDQpO1xuXG4gICAgaWYgKGRhdGEuaWQgIT0gbnVsbCkge1xuICAgICAgaWQgKz0gJy0nICsgZGF0YS5pZC50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCArPSAnLScgKyBVdGlscy5nZW5lcmF0ZUNoYXJzKDQpO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2VBZGFwdGVyO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kYXRhL3NlbGVjdCcsW1xuICAnLi9iYXNlJyxcbiAgJy4uL3V0aWxzJyxcbiAgJ2pxdWVyeSdcbl0sIGZ1bmN0aW9uIChCYXNlQWRhcHRlciwgVXRpbHMsICQpIHtcbiAgZnVuY3Rpb24gU2VsZWN0QWRhcHRlciAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIFNlbGVjdEFkYXB0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gIH1cblxuICBVdGlscy5FeHRlbmQoU2VsZWN0QWRhcHRlciwgQmFzZUFkYXB0ZXIpO1xuXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IFtdO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnOnNlbGVjdGVkJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJG9wdGlvbiA9ICQodGhpcyk7XG5cbiAgICAgIHZhciBvcHRpb24gPSBzZWxmLml0ZW0oJG9wdGlvbik7XG5cbiAgICAgIGRhdGEucHVzaChvcHRpb24pO1xuICAgIH0pO1xuXG4gICAgY2FsbGJhY2soZGF0YSk7XG4gIH07XG5cbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBkYXRhLnNlbGVjdGVkID0gdHJ1ZTtcblxuICAgIC8vIElmIGRhdGEuZWxlbWVudCBpcyBhIERPTSBub2RlLCB1c2UgaXQgaW5zdGVhZFxuICAgIGlmICgkKGRhdGEuZWxlbWVudCkuaXMoJ29wdGlvbicpKSB7XG4gICAgICBkYXRhLmVsZW1lbnQuc2VsZWN0ZWQgPSB0cnVlO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZScpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuJGVsZW1lbnQucHJvcCgnbXVsdGlwbGUnKSkge1xuICAgICAgdGhpcy5jdXJyZW50KGZ1bmN0aW9uIChjdXJyZW50RGF0YSkge1xuICAgICAgICB2YXIgdmFsID0gW107XG5cbiAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgZGF0YS5wdXNoLmFwcGx5KGRhdGEsIGN1cnJlbnREYXRhKTtcblxuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcbiAgICAgICAgICB2YXIgaWQgPSBkYXRhW2RdLmlkO1xuXG4gICAgICAgICAgaWYgKCQuaW5BcnJheShpZCwgdmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhbC5wdXNoKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlbGVtZW50LnZhbCh2YWwpO1xuICAgICAgICBzZWxmLiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWwgPSBkYXRhLmlkO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnZhbCh2YWwpO1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9XG4gIH07XG5cbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUudW5zZWxlY3QgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICghdGhpcy4kZWxlbWVudC5wcm9wKCdtdWx0aXBsZScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGF0YS5zZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCQoZGF0YS5lbGVtZW50KS5pcygnb3B0aW9uJykpIHtcbiAgICAgIGRhdGEuZWxlbWVudC5zZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZScpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50KGZ1bmN0aW9uIChjdXJyZW50RGF0YSkge1xuICAgICAgdmFyIHZhbCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGN1cnJlbnREYXRhLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgIHZhciBpZCA9IGN1cnJlbnREYXRhW2RdLmlkO1xuXG4gICAgICAgIGlmIChpZCAhPT0gZGF0YS5pZCAmJiAkLmluQXJyYXkoaWQsIHZhbCkgPT09IC0xKSB7XG4gICAgICAgICAgdmFsLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVsZW1lbnQudmFsKHZhbCk7XG5cbiAgICAgIHNlbGYuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChjb250YWluZXIsICRjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgIGNvbnRhaW5lci5vbignc2VsZWN0JywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgc2VsZi5zZWxlY3QocGFyYW1zLmRhdGEpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCd1bnNlbGVjdCcsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIHNlbGYudW5zZWxlY3QocGFyYW1zLmRhdGEpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmVtb3ZlIGFueXRoaW5nIGFkZGVkIHRvIGNoaWxkIGVsZW1lbnRzXG4gICAgdGhpcy4kZWxlbWVudC5maW5kKCcqJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBSZW1vdmUgYW55IGN1c3RvbSBkYXRhIHNldCBieSBTZWxlY3QyXG4gICAgICAkLnJlbW92ZURhdGEodGhpcywgJ2RhdGEnKTtcbiAgICB9KTtcbiAgfTtcblxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSBbXTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgJG9wdGlvbnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCk7XG5cbiAgICAkb3B0aW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkb3B0aW9uID0gJCh0aGlzKTtcblxuICAgICAgaWYgKCEkb3B0aW9uLmlzKCdvcHRpb24nKSAmJiAhJG9wdGlvbi5pcygnb3B0Z3JvdXAnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvcHRpb24gPSBzZWxmLml0ZW0oJG9wdGlvbik7XG5cbiAgICAgIHZhciBtYXRjaGVzID0gc2VsZi5tYXRjaGVzKHBhcmFtcywgb3B0aW9uKTtcblxuICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgICAgZGF0YS5wdXNoKG1hdGNoZXMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY2FsbGJhY2soe1xuICAgICAgcmVzdWx0czogZGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLmFkZE9wdGlvbnMgPSBmdW5jdGlvbiAoJG9wdGlvbnMpIHtcbiAgICBVdGlscy5hcHBlbmRNYW55KHRoaXMuJGVsZW1lbnQsICRvcHRpb25zKTtcbiAgfTtcblxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBvcHRpb247XG5cbiAgICBpZiAoZGF0YS5jaGlsZHJlbikge1xuICAgICAgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0Z3JvdXAnKTtcbiAgICAgIG9wdGlvbi5sYWJlbCA9IGRhdGEudGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG5cbiAgICAgIGlmIChvcHRpb24udGV4dENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb24udGV4dENvbnRlbnQgPSBkYXRhLnRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb24uaW5uZXJUZXh0ID0gZGF0YS50ZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhLmlkKSB7XG4gICAgICBvcHRpb24udmFsdWUgPSBkYXRhLmlkO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmRpc2FibGVkKSB7XG4gICAgICBvcHRpb24uZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnNlbGVjdGVkKSB7XG4gICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnRpdGxlKSB7XG4gICAgICBvcHRpb24udGl0bGUgPSBkYXRhLnRpdGxlO1xuICAgIH1cblxuICAgIHZhciAkb3B0aW9uID0gJChvcHRpb24pO1xuXG4gICAgdmFyIG5vcm1hbGl6ZWREYXRhID0gdGhpcy5fbm9ybWFsaXplSXRlbShkYXRhKTtcbiAgICBub3JtYWxpemVkRGF0YS5lbGVtZW50ID0gb3B0aW9uO1xuXG4gICAgLy8gT3ZlcnJpZGUgdGhlIG9wdGlvbidzIGRhdGEgd2l0aCB0aGUgY29tYmluZWQgZGF0YVxuICAgICQuZGF0YShvcHRpb24sICdkYXRhJywgbm9ybWFsaXplZERhdGEpO1xuXG4gICAgcmV0dXJuICRvcHRpb247XG4gIH07XG5cbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUuaXRlbSA9IGZ1bmN0aW9uICgkb3B0aW9uKSB7XG4gICAgdmFyIGRhdGEgPSB7fTtcblxuICAgIGRhdGEgPSAkLmRhdGEoJG9wdGlvblswXSwgJ2RhdGEnKTtcblxuICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGlmICgkb3B0aW9uLmlzKCdvcHRpb24nKSkge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgaWQ6ICRvcHRpb24udmFsKCksXG4gICAgICAgIHRleHQ6ICRvcHRpb24udGV4dCgpLFxuICAgICAgICBkaXNhYmxlZDogJG9wdGlvbi5wcm9wKCdkaXNhYmxlZCcpLFxuICAgICAgICBzZWxlY3RlZDogJG9wdGlvbi5wcm9wKCdzZWxlY3RlZCcpLFxuICAgICAgICB0aXRsZTogJG9wdGlvbi5wcm9wKCd0aXRsZScpXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoJG9wdGlvbi5pcygnb3B0Z3JvdXAnKSkge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgdGV4dDogJG9wdGlvbi5wcm9wKCdsYWJlbCcpLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIHRpdGxlOiAkb3B0aW9uLnByb3AoJ3RpdGxlJylcbiAgICAgIH07XG5cbiAgICAgIHZhciAkY2hpbGRyZW4gPSAkb3B0aW9uLmNoaWxkcmVuKCdvcHRpb24nKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8ICRjaGlsZHJlbi5sZW5ndGg7IGMrKykge1xuICAgICAgICB2YXIgJGNoaWxkID0gJCgkY2hpbGRyZW5bY10pO1xuXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuaXRlbSgkY2hpbGQpO1xuXG4gICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBkYXRhLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgfVxuXG4gICAgZGF0YSA9IHRoaXMuX25vcm1hbGl6ZUl0ZW0oZGF0YSk7XG4gICAgZGF0YS5lbGVtZW50ID0gJG9wdGlvblswXTtcblxuICAgICQuZGF0YSgkb3B0aW9uWzBdLCAnZGF0YScsIGRhdGEpO1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUuX25vcm1hbGl6ZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmICghJC5pc1BsYWluT2JqZWN0KGl0ZW0pKSB7XG4gICAgICBpdGVtID0ge1xuICAgICAgICBpZDogaXRlbSxcbiAgICAgICAgdGV4dDogaXRlbVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpdGVtID0gJC5leHRlbmQoe30sIHtcbiAgICAgIHRleHQ6ICcnXG4gICAgfSwgaXRlbSk7XG5cbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICBkaXNhYmxlZDogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKGl0ZW0uaWQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5pZCA9IGl0ZW0uaWQudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIGl0ZW0udGV4dCA9IGl0ZW0udGV4dC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChpdGVtLl9yZXN1bHRJZCA9PSBudWxsICYmIGl0ZW0uaWQgJiYgdGhpcy5jb250YWluZXIgIT0gbnVsbCkge1xuICAgICAgaXRlbS5fcmVzdWx0SWQgPSB0aGlzLmdlbmVyYXRlUmVzdWx0SWQodGhpcy5jb250YWluZXIsIGl0ZW0pO1xuICAgIH1cblxuICAgIHJldHVybiAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGl0ZW0pO1xuICB9O1xuXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAocGFyYW1zLCBkYXRhKSB7XG4gICAgdmFyIG1hdGNoZXIgPSB0aGlzLm9wdGlvbnMuZ2V0KCdtYXRjaGVyJyk7XG5cbiAgICByZXR1cm4gbWF0Y2hlcihwYXJhbXMsIGRhdGEpO1xuICB9O1xuXG4gIHJldHVybiBTZWxlY3RBZGFwdGVyO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kYXRhL2FycmF5JyxbXG4gICcuL3NlbGVjdCcsXG4gICcuLi91dGlscycsXG4gICdqcXVlcnknXG5dLCBmdW5jdGlvbiAoU2VsZWN0QWRhcHRlciwgVXRpbHMsICQpIHtcbiAgZnVuY3Rpb24gQXJyYXlBZGFwdGVyICgkZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBkYXRhID0gb3B0aW9ucy5nZXQoJ2RhdGEnKSB8fCBbXTtcblxuICAgIEFycmF5QWRhcHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCAkZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmFkZE9wdGlvbnModGhpcy5jb252ZXJ0VG9PcHRpb25zKGRhdGEpKTtcbiAgfVxuXG4gIFV0aWxzLkV4dGVuZChBcnJheUFkYXB0ZXIsIFNlbGVjdEFkYXB0ZXIpO1xuXG4gIEFycmF5QWRhcHRlci5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgJG9wdGlvbiA9IHRoaXMuJGVsZW1lbnQuZmluZCgnb3B0aW9uJykuZmlsdGVyKGZ1bmN0aW9uIChpLCBlbG0pIHtcbiAgICAgIHJldHVybiBlbG0udmFsdWUgPT0gZGF0YS5pZC50b1N0cmluZygpO1xuICAgIH0pO1xuXG4gICAgaWYgKCRvcHRpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAkb3B0aW9uID0gdGhpcy5vcHRpb24oZGF0YSk7XG5cbiAgICAgIHRoaXMuYWRkT3B0aW9ucygkb3B0aW9uKTtcbiAgICB9XG5cbiAgICBBcnJheUFkYXB0ZXIuX19zdXBlcl9fLnNlbGVjdC5jYWxsKHRoaXMsIGRhdGEpO1xuICB9O1xuXG4gIEFycmF5QWRhcHRlci5wcm90b3R5cGUuY29udmVydFRvT3B0aW9ucyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyICRleGlzdGluZyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnb3B0aW9uJyk7XG4gICAgdmFyIGV4aXN0aW5nSWRzID0gJGV4aXN0aW5nLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2VsZi5pdGVtKCQodGhpcykpLmlkO1xuICAgIH0pLmdldCgpO1xuXG4gICAgdmFyICRvcHRpb25zID0gW107XG5cbiAgICAvLyBGaWx0ZXIgb3V0IGFsbCBpdGVtcyBleGNlcHQgZm9yIHRoZSBvbmUgcGFzc2VkIGluIHRoZSBhcmd1bWVudFxuICAgIGZ1bmN0aW9uIG9ubHlJdGVtIChpdGVtKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS52YWwoKSA9PSBpdGVtLmlkO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcbiAgICAgIHZhciBpdGVtID0gdGhpcy5fbm9ybWFsaXplSXRlbShkYXRhW2RdKTtcblxuICAgICAgLy8gU2tpcCBpdGVtcyB3aGljaCB3ZXJlIHByZS1sb2FkZWQsIG9ubHkgbWVyZ2UgdGhlIGRhdGFcbiAgICAgIGlmICgkLmluQXJyYXkoaXRlbS5pZCwgZXhpc3RpbmdJZHMpID49IDApIHtcbiAgICAgICAgdmFyICRleGlzdGluZ09wdGlvbiA9ICRleGlzdGluZy5maWx0ZXIob25seUl0ZW0oaXRlbSkpO1xuXG4gICAgICAgIHZhciBleGlzdGluZ0RhdGEgPSB0aGlzLml0ZW0oJGV4aXN0aW5nT3B0aW9uKTtcbiAgICAgICAgdmFyIG5ld0RhdGEgPSAkLmV4dGVuZCh0cnVlLCB7fSwgaXRlbSwgZXhpc3RpbmdEYXRhKTtcblxuICAgICAgICB2YXIgJG5ld09wdGlvbiA9IHRoaXMub3B0aW9uKG5ld0RhdGEpO1xuXG4gICAgICAgICRleGlzdGluZ09wdGlvbi5yZXBsYWNlV2l0aCgkbmV3T3B0aW9uKTtcblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyICRvcHRpb24gPSB0aGlzLm9wdGlvbihpdGVtKTtcblxuICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyICRjaGlsZHJlbiA9IHRoaXMuY29udmVydFRvT3B0aW9ucyhpdGVtLmNoaWxkcmVuKTtcblxuICAgICAgICBVdGlscy5hcHBlbmRNYW55KCRvcHRpb24sICRjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgICRvcHRpb25zLnB1c2goJG9wdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuICRvcHRpb25zO1xuICB9O1xuXG4gIHJldHVybiBBcnJheUFkYXB0ZXI7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvYWpheCcsW1xuICAnLi9hcnJheScsXG4gICcuLi91dGlscycsXG4gICdqcXVlcnknXG5dLCBmdW5jdGlvbiAoQXJyYXlBZGFwdGVyLCBVdGlscywgJCkge1xuICBmdW5jdGlvbiBBamF4QWRhcHRlciAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmFqYXhPcHRpb25zID0gdGhpcy5fYXBwbHlEZWZhdWx0cyhvcHRpb25zLmdldCgnYWpheCcpKTtcblxuICAgIGlmICh0aGlzLmFqYXhPcHRpb25zLnByb2Nlc3NSZXN1bHRzICE9IG51bGwpIHtcbiAgICAgIHRoaXMucHJvY2Vzc1Jlc3VsdHMgPSB0aGlzLmFqYXhPcHRpb25zLnByb2Nlc3NSZXN1bHRzO1xuICAgIH1cblxuICAgIEFqYXhBZGFwdGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zKTtcbiAgfVxuXG4gIFV0aWxzLkV4dGVuZChBamF4QWRhcHRlciwgQXJyYXlBZGFwdGVyKTtcblxuICBBamF4QWRhcHRlci5wcm90b3R5cGUuX2FwcGx5RGVmYXVsdHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGRhdGE6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBwYXJhbXMsIHtcbiAgICAgICAgICBxOiBwYXJhbXMudGVybVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc3BvcnQ6IGZ1bmN0aW9uIChwYXJhbXMsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICAgICAgdmFyICRyZXF1ZXN0ID0gJC5hamF4KHBhcmFtcyk7XG5cbiAgICAgICAgJHJlcXVlc3QudGhlbihzdWNjZXNzKTtcbiAgICAgICAgJHJlcXVlc3QuZmFpbChmYWlsdXJlKTtcblxuICAgICAgICByZXR1cm4gJHJlcXVlc3Q7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMsIHRydWUpO1xuICB9O1xuXG4gIEFqYXhBZGFwdGVyLnByb3RvdHlwZS5wcm9jZXNzUmVzdWx0cyA9IGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgQWpheEFkYXB0ZXIucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9IG51bGwpIHtcbiAgICAgIC8vIEpTT05QIHJlcXVlc3RzIGNhbm5vdCBhbHdheXMgYmUgYWJvcnRlZFxuICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLl9yZXF1ZXN0LmFib3J0KSkge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0LmFib3J0KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgdHlwZTogJ0dFVCdcbiAgICB9LCB0aGlzLmFqYXhPcHRpb25zKTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy51cmwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwuY2FsbCh0aGlzLiRlbGVtZW50LCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zLmRhdGEgPSBvcHRpb25zLmRhdGEuY2FsbCh0aGlzLiRlbGVtZW50LCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcXVlc3QgKCkge1xuICAgICAgdmFyICRyZXF1ZXN0ID0gb3B0aW9ucy50cmFuc3BvcnQob3B0aW9ucywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBzZWxmLnByb2Nlc3NSZXN1bHRzKGRhdGEsIHBhcmFtcyk7XG5cbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5nZXQoJ2RlYnVnJykgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIC8vIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSByZXNwb25zZSBpbmNsdWRlZCBhIGByZXN1bHRzYCBrZXkuXG4gICAgICAgICAgaWYgKCFyZXN1bHRzIHx8ICFyZXN1bHRzLnJlc3VsdHMgfHwgISQuaXNBcnJheShyZXN1bHRzLnJlc3VsdHMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnU2VsZWN0MjogVGhlIEFKQVggcmVzdWx0cyBkaWQgbm90IHJldHVybiBhbiBhcnJheSBpbiB0aGUgJyArXG4gICAgICAgICAgICAgICdgcmVzdWx0c2Aga2V5IG9mIHRoZSByZXNwb25zZS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdHMpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGRldGVjdCBpZiBhIHJlcXVlc3Qgd2FzIGFib3J0ZWRcbiAgICAgICAgLy8gT25seSB3b3JrcyBpZiB0aGUgdHJhbnNwb3J0IGV4cG9zZXMgYSBzdGF0dXMgcHJvcGVydHlcbiAgICAgICAgaWYgKCRyZXF1ZXN0LnN0YXR1cyAmJiAkcmVxdWVzdC5zdGF0dXMgPT09ICcwJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czptZXNzYWdlJywge1xuICAgICAgICAgIG1lc3NhZ2U6ICdlcnJvckxvYWRpbmcnXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuX3JlcXVlc3QgPSAkcmVxdWVzdDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hamF4T3B0aW9ucy5kZWxheSAmJiBwYXJhbXMudGVybSAhPSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5fcXVlcnlUaW1lb3V0KSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fcXVlcnlUaW1lb3V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcXVlcnlUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQocmVxdWVzdCwgdGhpcy5hamF4T3B0aW9ucy5kZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEFqYXhBZGFwdGVyO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kYXRhL3RhZ3MnLFtcbiAgJ2pxdWVyeSdcbl0sIGZ1bmN0aW9uICgkKSB7XG4gIGZ1bmN0aW9uIFRhZ3MgKGRlY29yYXRlZCwgJGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGFncyA9IG9wdGlvbnMuZ2V0KCd0YWdzJyk7XG5cbiAgICB2YXIgY3JlYXRlVGFnID0gb3B0aW9ucy5nZXQoJ2NyZWF0ZVRhZycpO1xuXG4gICAgaWYgKGNyZWF0ZVRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNyZWF0ZVRhZyA9IGNyZWF0ZVRhZztcbiAgICB9XG5cbiAgICB2YXIgaW5zZXJ0VGFnID0gb3B0aW9ucy5nZXQoJ2luc2VydFRhZycpO1xuXG4gICAgaWYgKGluc2VydFRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0VGFnID0gaW5zZXJ0VGFnO1xuICAgIH1cblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zKTtcblxuICAgIGlmICgkLmlzQXJyYXkodGFncykpIHtcbiAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGFncy5sZW5ndGg7IHQrKykge1xuICAgICAgICB2YXIgdGFnID0gdGFnc1t0XTtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9ub3JtYWxpemVJdGVtKHRhZyk7XG5cbiAgICAgICAgdmFyICRvcHRpb24gPSB0aGlzLm9wdGlvbihpdGVtKTtcblxuICAgICAgICB0aGlzLiRlbGVtZW50LmFwcGVuZCgkb3B0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBUYWdzLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLl9yZW1vdmVPbGRUYWdzKCk7XG5cbiAgICBpZiAocGFyYW1zLnRlcm0gPT0gbnVsbCB8fCBwYXJhbXMucGFnZSAhPSBudWxsKSB7XG4gICAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwcGVyIChvYmosIGNoaWxkKSB7XG4gICAgICB2YXIgZGF0YSA9IG9iai5yZXN1bHRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IGRhdGFbaV07XG5cbiAgICAgICAgdmFyIGNoZWNrQ2hpbGRyZW4gPSAoXG4gICAgICAgICAgb3B0aW9uLmNoaWxkcmVuICE9IG51bGwgJiZcbiAgICAgICAgICAhd3JhcHBlcih7XG4gICAgICAgICAgICByZXN1bHRzOiBvcHRpb24uY2hpbGRyZW5cbiAgICAgICAgICB9LCB0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBjaGVja1RleHQgPSBvcHRpb24udGV4dCA9PT0gcGFyYW1zLnRlcm07XG5cbiAgICAgICAgaWYgKGNoZWNrVGV4dCB8fCBjaGVja0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JqLmRhdGEgPSBkYXRhO1xuICAgICAgICAgIGNhbGxiYWNrKG9iaik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFnID0gc2VsZi5jcmVhdGVUYWcocGFyYW1zKTtcblxuICAgICAgaWYgKHRhZyAhPSBudWxsKSB7XG4gICAgICAgIHZhciAkb3B0aW9uID0gc2VsZi5vcHRpb24odGFnKTtcbiAgICAgICAgJG9wdGlvbi5hdHRyKCdkYXRhLXNlbGVjdDItdGFnJywgdHJ1ZSk7XG5cbiAgICAgICAgc2VsZi5hZGRPcHRpb25zKFskb3B0aW9uXSk7XG5cbiAgICAgICAgc2VsZi5pbnNlcnRUYWcoZGF0YSwgdGFnKTtcbiAgICAgIH1cblxuICAgICAgb2JqLnJlc3VsdHMgPSBkYXRhO1xuXG4gICAgICBjYWxsYmFjayhvYmopO1xuICAgIH1cblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIHBhcmFtcywgd3JhcHBlcik7XG4gIH07XG5cbiAgVGFncy5wcm90b3R5cGUuY3JlYXRlVGFnID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgcGFyYW1zKSB7XG4gICAgdmFyIHRlcm0gPSAkLnRyaW0ocGFyYW1zLnRlcm0pO1xuXG4gICAgaWYgKHRlcm0gPT09ICcnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRlcm0sXG4gICAgICB0ZXh0OiB0ZXJtXG4gICAgfTtcbiAgfTtcblxuICBUYWdzLnByb3RvdHlwZS5pbnNlcnRUYWcgPSBmdW5jdGlvbiAoXywgZGF0YSwgdGFnKSB7XG4gICAgZGF0YS51bnNoaWZ0KHRhZyk7XG4gIH07XG5cbiAgVGFncy5wcm90b3R5cGUuX3JlbW92ZU9sZFRhZ3MgPSBmdW5jdGlvbiAoXykge1xuICAgIHZhciB0YWcgPSB0aGlzLl9sYXN0VGFnO1xuXG4gICAgdmFyICRvcHRpb25zID0gdGhpcy4kZWxlbWVudC5maW5kKCdvcHRpb25bZGF0YS1zZWxlY3QyLXRhZ10nKTtcblxuICAgICRvcHRpb25zLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAkKHRoaXMpLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUYWdzO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kYXRhL3Rva2VuaXplcicsW1xuICAnanF1ZXJ5J1xuXSwgZnVuY3Rpb24gKCQpIHtcbiAgZnVuY3Rpb24gVG9rZW5pemVyIChkZWNvcmF0ZWQsICRlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHRva2VuaXplciA9IG9wdGlvbnMuZ2V0KCd0b2tlbml6ZXInKTtcblxuICAgIGlmICh0b2tlbml6ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgfVxuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcblxuICAgIHRoaXMuJHNlYXJjaCA9ICBjb250YWluZXIuZHJvcGRvd24uJHNlYXJjaCB8fCBjb250YWluZXIuc2VsZWN0aW9uLiRzZWFyY2ggfHxcbiAgICAgICRjb250YWluZXIuZmluZCgnLnNlbGVjdDItc2VhcmNoX19maWVsZCcpO1xuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlQW5kU2VsZWN0IChkYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemUgdGhlIGRhdGEgb2JqZWN0IHNvIHdlIGNhbiB1c2UgaXQgZm9yIGNoZWNrc1xuICAgICAgdmFyIGl0ZW0gPSBzZWxmLl9ub3JtYWxpemVJdGVtKGRhdGEpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgZGF0YSBvYmplY3QgYWxyZWFkeSBleGlzdHMgYXMgYSB0YWdcbiAgICAgIC8vIFNlbGVjdCBpdCBpZiBpdCBkb2Vzbid0XG4gICAgICB2YXIgJGV4aXN0aW5nT3B0aW9ucyA9IHNlbGYuJGVsZW1lbnQuZmluZCgnb3B0aW9uJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykudmFsKCkgPT09IGl0ZW0uaWQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgYW4gZXhpc3Rpbmcgb3B0aW9uIHdhc24ndCBmb3VuZCBmb3IgaXQsIGNyZWF0ZSB0aGUgb3B0aW9uXG4gICAgICBpZiAoISRleGlzdGluZ09wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciAkb3B0aW9uID0gc2VsZi5vcHRpb24oaXRlbSk7XG4gICAgICAgICRvcHRpb24uYXR0cignZGF0YS1zZWxlY3QyLXRhZycsIHRydWUpO1xuXG4gICAgICAgIHNlbGYuX3JlbW92ZU9sZFRhZ3MoKTtcbiAgICAgICAgc2VsZi5hZGRPcHRpb25zKFskb3B0aW9uXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlbGVjdCB0aGUgaXRlbSwgbm93IHRoYXQgd2Uga25vdyB0aGVyZSBpcyBhbiBvcHRpb24gZm9yIGl0XG4gICAgICBzZWxlY3QoaXRlbSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0IChkYXRhKSB7XG4gICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdCcsIHtcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGFyYW1zLnRlcm0gPSBwYXJhbXMudGVybSB8fCAnJztcblxuICAgIHZhciB0b2tlbkRhdGEgPSB0aGlzLnRva2VuaXplcihwYXJhbXMsIHRoaXMub3B0aW9ucywgY3JlYXRlQW5kU2VsZWN0KTtcblxuICAgIGlmICh0b2tlbkRhdGEudGVybSAhPT0gcGFyYW1zLnRlcm0pIHtcbiAgICAgIC8vIFJlcGxhY2UgdGhlIHNlYXJjaCB0ZXJtIGlmIHdlIGhhdmUgdGhlIHNlYXJjaCBib3hcbiAgICAgIGlmICh0aGlzLiRzZWFyY2gubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuJHNlYXJjaC52YWwodG9rZW5EYXRhLnRlcm0pO1xuICAgICAgICB0aGlzLiRzZWFyY2guZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgcGFyYW1zLnRlcm0gPSB0b2tlbkRhdGEudGVybTtcbiAgICB9XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnRva2VuaXplciA9IGZ1bmN0aW9uIChfLCBwYXJhbXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlcGFyYXRvcnMgPSBvcHRpb25zLmdldCgndG9rZW5TZXBhcmF0b3JzJykgfHwgW107XG4gICAgdmFyIHRlcm0gPSBwYXJhbXMudGVybTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB2YXIgY3JlYXRlVGFnID0gdGhpcy5jcmVhdGVUYWcgfHwgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHBhcmFtcy50ZXJtLFxuICAgICAgICB0ZXh0OiBwYXJhbXMudGVybVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgd2hpbGUgKGkgPCB0ZXJtLmxlbmd0aCkge1xuICAgICAgdmFyIHRlcm1DaGFyID0gdGVybVtpXTtcblxuICAgICAgaWYgKCQuaW5BcnJheSh0ZXJtQ2hhciwgc2VwYXJhdG9ycykgPT09IC0xKSB7XG4gICAgICAgIGkrKztcblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnQgPSB0ZXJtLnN1YnN0cigwLCBpKTtcbiAgICAgIHZhciBwYXJ0UGFyYW1zID0gJC5leHRlbmQoe30sIHBhcmFtcywge1xuICAgICAgICB0ZXJtOiBwYXJ0XG4gICAgICB9KTtcblxuICAgICAgdmFyIGRhdGEgPSBjcmVhdGVUYWcocGFydFBhcmFtcyk7XG5cbiAgICAgIGlmIChkYXRhID09IG51bGwpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soZGF0YSk7XG5cbiAgICAgIC8vIFJlc2V0IHRoZSB0ZXJtIHRvIG5vdCBpbmNsdWRlIHRoZSB0b2tlbml6ZWQgcG9ydGlvblxuICAgICAgdGVybSA9IHRlcm0uc3Vic3RyKGkgKyAxKSB8fCAnJztcbiAgICAgIGkgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0ZXJtOiB0ZXJtXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gVG9rZW5pemVyO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kYXRhL21pbmltdW1JbnB1dExlbmd0aCcsW1xuXG5dLCBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1pbmltdW1JbnB1dExlbmd0aCAoZGVjb3JhdGVkLCAkZSwgb3B0aW9ucykge1xuICAgIHRoaXMubWluaW11bUlucHV0TGVuZ3RoID0gb3B0aW9ucy5nZXQoJ21pbmltdW1JbnB1dExlbmd0aCcpO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgTWluaW11bUlucHV0TGVuZ3RoLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBwYXJhbXMudGVybSA9IHBhcmFtcy50ZXJtIHx8ICcnO1xuXG4gICAgaWYgKHBhcmFtcy50ZXJtLmxlbmd0aCA8IHRoaXMubWluaW11bUlucHV0TGVuZ3RoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3Jlc3VsdHM6bWVzc2FnZScsIHtcbiAgICAgICAgbWVzc2FnZTogJ2lucHV0VG9vU2hvcnQnLFxuICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgbWluaW11bTogdGhpcy5taW5pbXVtSW5wdXRMZW5ndGgsXG4gICAgICAgICAgaW5wdXQ6IHBhcmFtcy50ZXJtLFxuICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgcmV0dXJuIE1pbmltdW1JbnB1dExlbmd0aDtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZGF0YS9tYXhpbXVtSW5wdXRMZW5ndGgnLFtcblxuXSwgZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXhpbXVtSW5wdXRMZW5ndGggKGRlY29yYXRlZCwgJGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm1heGltdW1JbnB1dExlbmd0aCA9IG9wdGlvbnMuZ2V0KCdtYXhpbXVtSW5wdXRMZW5ndGgnKTtcblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIE1heGltdW1JbnB1dExlbmd0aC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgcGFyYW1zLnRlcm0gPSBwYXJhbXMudGVybSB8fCAnJztcblxuICAgIGlmICh0aGlzLm1heGltdW1JbnB1dExlbmd0aCA+IDAgJiZcbiAgICAgICAgcGFyYW1zLnRlcm0ubGVuZ3RoID4gdGhpcy5tYXhpbXVtSW5wdXRMZW5ndGgpIHtcbiAgICAgIHRoaXMudHJpZ2dlcigncmVzdWx0czptZXNzYWdlJywge1xuICAgICAgICBtZXNzYWdlOiAnaW5wdXRUb29Mb25nJyxcbiAgICAgICAgYXJnczoge1xuICAgICAgICAgIG1heGltdW06IHRoaXMubWF4aW11bUlucHV0TGVuZ3RoLFxuICAgICAgICAgIGlucHV0OiBwYXJhbXMudGVybSxcbiAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9O1xuXG4gIHJldHVybiBNYXhpbXVtSW5wdXRMZW5ndGg7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvbWF4aW11bVNlbGVjdGlvbkxlbmd0aCcsW1xuXG5dLCBmdW5jdGlvbiAoKXtcbiAgZnVuY3Rpb24gTWF4aW11bVNlbGVjdGlvbkxlbmd0aCAoZGVjb3JhdGVkLCAkZSwgb3B0aW9ucykge1xuICAgIHRoaXMubWF4aW11bVNlbGVjdGlvbkxlbmd0aCA9IG9wdGlvbnMuZ2V0KCdtYXhpbXVtU2VsZWN0aW9uTGVuZ3RoJyk7XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZSwgb3B0aW9ucyk7XG4gIH1cblxuICBNYXhpbXVtU2VsZWN0aW9uTGVuZ3RoLnByb3RvdHlwZS5xdWVyeSA9XG4gICAgZnVuY3Rpb24gKGRlY29yYXRlZCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB0aGlzLmN1cnJlbnQoZnVuY3Rpb24gKGN1cnJlbnREYXRhKSB7XG4gICAgICAgIHZhciBjb3VudCA9IGN1cnJlbnREYXRhICE9IG51bGwgPyBjdXJyZW50RGF0YS5sZW5ndGggOiAwO1xuICAgICAgICBpZiAoc2VsZi5tYXhpbXVtU2VsZWN0aW9uTGVuZ3RoID4gMCAmJlxuICAgICAgICAgIGNvdW50ID49IHNlbGYubWF4aW11bVNlbGVjdGlvbkxlbmd0aCkge1xuICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czptZXNzYWdlJywge1xuICAgICAgICAgICAgbWVzc2FnZTogJ21heGltdW1TZWxlY3RlZCcsXG4gICAgICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgICAgIG1heGltdW06IHNlbGYubWF4aW11bVNlbGVjdGlvbkxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWNvcmF0ZWQuY2FsbChzZWxmLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBNYXhpbXVtU2VsZWN0aW9uTGVuZ3RoO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bicsW1xuICAnanF1ZXJ5JyxcbiAgJy4vdXRpbHMnXG5dLCBmdW5jdGlvbiAoJCwgVXRpbHMpIHtcbiAgZnVuY3Rpb24gRHJvcGRvd24gKCRlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICBEcm9wZG93bi5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIFV0aWxzLkV4dGVuZChEcm9wZG93biwgVXRpbHMuT2JzZXJ2YWJsZSk7XG5cbiAgRHJvcGRvd24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGRyb3Bkb3duID0gJChcbiAgICAgICc8c3BhbiBjbGFzcz1cInNlbGVjdDItZHJvcGRvd25cIj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VsZWN0Mi1yZXN1bHRzXCI+PC9zcGFuPicgK1xuICAgICAgJzwvc3Bhbj4nXG4gICAgKTtcblxuICAgICRkcm9wZG93bi5hdHRyKCdkaXInLCB0aGlzLm9wdGlvbnMuZ2V0KCdkaXInKSk7XG5cbiAgICB0aGlzLiRkcm9wZG93biA9ICRkcm9wZG93bjtcblxuICAgIHJldHVybiAkZHJvcGRvd247XG4gIH07XG5cbiAgRHJvcGRvd24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcbiAgfTtcblxuICBEcm9wZG93bi5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoJGRyb3Bkb3duLCAkY29udGFpbmVyKSB7XG4gICAgLy8gU2hvdWxkIGJlIGltcGxtZW50ZWQgaW4gc3ViY2xhc3Nlc1xuICB9O1xuXG4gIERyb3Bkb3duLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFJlbW92ZSB0aGUgZHJvcGRvd24gZnJvbSB0aGUgRE9NXG4gICAgdGhpcy4kZHJvcGRvd24ucmVtb3ZlKCk7XG4gIH07XG5cbiAgcmV0dXJuIERyb3Bkb3duO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9zZWFyY2gnLFtcbiAgJ2pxdWVyeScsXG4gICcuLi91dGlscydcbl0sIGZ1bmN0aW9uICgkLCBVdGlscykge1xuICBmdW5jdGlvbiBTZWFyY2ggKCkgeyB9XG5cbiAgU2VhcmNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XG4gICAgdmFyICRyZW5kZXJlZCA9IGRlY29yYXRlZC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyICRzZWFyY2ggPSAkKFxuICAgICAgJzxzcGFuIGNsYXNzPVwic2VsZWN0Mi1zZWFyY2ggc2VsZWN0Mi1zZWFyY2gtLWRyb3Bkb3duXCI+JyArXG4gICAgICAgICc8aW5wdXQgY2xhc3M9XCJzZWxlY3QyLXNlYXJjaF9fZmllbGRcIiB0eXBlPVwic2VhcmNoXCIgdGFiaW5kZXg9XCItMVwiJyArXG4gICAgICAgICcgYXV0b2NvbXBsZXRlPVwib2ZmXCIgYXV0b2NvcnJlY3Q9XCJvZmZcIiBhdXRvY2FwaXRhbGl6ZT1cIm9mZlwiJyArXG4gICAgICAgICcgc3BlbGxjaGVjaz1cImZhbHNlXCIgcm9sZT1cInRleHRib3hcIiAvPicgK1xuICAgICAgJzwvc3Bhbj4nXG4gICAgKTtcblxuICAgIHRoaXMuJHNlYXJjaENvbnRhaW5lciA9ICRzZWFyY2g7XG4gICAgdGhpcy4kc2VhcmNoID0gJHNlYXJjaC5maW5kKCdpbnB1dCcpO1xuXG4gICAgJHJlbmRlcmVkLnByZXBlbmQoJHNlYXJjaCk7XG5cbiAgICByZXR1cm4gJHJlbmRlcmVkO1xuICB9O1xuXG4gIFNlYXJjaC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XG5cbiAgICB0aGlzLiRzZWFyY2gub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBzZWxmLnRyaWdnZXIoJ2tleXByZXNzJywgZXZ0KTtcblxuICAgICAgc2VsZi5fa2V5VXBQcmV2ZW50ZWQgPSBldnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgfSk7XG5cbiAgICAvLyBXb3JrYXJvdW5kIGZvciBicm93c2VycyB3aGljaCBkbyBub3Qgc3VwcG9ydCB0aGUgYGlucHV0YCBldmVudFxuICAgIC8vIFRoaXMgd2lsbCBwcmV2ZW50IGRvdWJsZS10cmlnZ2VyaW5nIG9mIGV2ZW50cyBmb3IgYnJvd3NlcnMgd2hpY2ggc3VwcG9ydFxuICAgIC8vIGJvdGggdGhlIGBrZXl1cGAgYW5kIGBpbnB1dGAgZXZlbnRzLlxuICAgIHRoaXMuJHNlYXJjaC5vbignaW5wdXQnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAvLyBVbmJpbmQgdGhlIGR1cGxpY2F0ZWQgYGtleXVwYCBldmVudFxuICAgICAgJCh0aGlzKS5vZmYoJ2tleXVwJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRzZWFyY2gub24oJ2tleXVwIGlucHV0JywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi5oYW5kbGVTZWFyY2goZXZ0KTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbignb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuJHNlYXJjaC5hdHRyKCd0YWJpbmRleCcsIDApO1xuXG4gICAgICBzZWxmLiRzZWFyY2guZm9jdXMoKTtcblxuICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLiRzZWFyY2guZm9jdXMoKTtcbiAgICAgIH0sIDApO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuJHNlYXJjaC5hdHRyKCd0YWJpbmRleCcsIC0xKTtcblxuICAgICAgc2VsZi4kc2VhcmNoLnZhbCgnJyk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5pc09wZW4oKSkge1xuICAgICAgICBzZWxmLiRzZWFyY2guZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czphbGwnLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW1zLnF1ZXJ5LnRlcm0gPT0gbnVsbCB8fCBwYXJhbXMucXVlcnkudGVybSA9PT0gJycpIHtcbiAgICAgICAgdmFyIHNob3dTZWFyY2ggPSBzZWxmLnNob3dTZWFyY2gocGFyYW1zKTtcblxuICAgICAgICBpZiAoc2hvd1NlYXJjaCkge1xuICAgICAgICAgIHNlbGYuJHNlYXJjaENvbnRhaW5lci5yZW1vdmVDbGFzcygnc2VsZWN0Mi1zZWFyY2gtLWhpZGUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLiRzZWFyY2hDb250YWluZXIuYWRkQ2xhc3MoJ3NlbGVjdDItc2VhcmNoLS1oaWRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBTZWFyY2gucHJvdG90eXBlLmhhbmRsZVNlYXJjaCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZiAoIXRoaXMuX2tleVVwUHJldmVudGVkKSB7XG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLiRzZWFyY2gudmFsKCk7XG5cbiAgICAgIHRoaXMudHJpZ2dlcigncXVlcnknLCB7XG4gICAgICAgIHRlcm06IGlucHV0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9rZXlVcFByZXZlbnRlZCA9IGZhbHNlO1xuICB9O1xuXG4gIFNlYXJjaC5wcm90b3R5cGUuc2hvd1NlYXJjaCA9IGZ1bmN0aW9uIChfLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4gU2VhcmNoO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9oaWRlUGxhY2Vob2xkZXInLFtcblxuXSwgZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIaWRlUGxhY2Vob2xkZXIgKGRlY29yYXRlZCwgJGVsZW1lbnQsIG9wdGlvbnMsIGRhdGFBZGFwdGVyKSB7XG4gICAgdGhpcy5wbGFjZWhvbGRlciA9IHRoaXMubm9ybWFsaXplUGxhY2Vob2xkZXIob3B0aW9ucy5nZXQoJ3BsYWNlaG9sZGVyJykpO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMsIGRhdGFBZGFwdGVyKTtcbiAgfVxuXG4gIEhpZGVQbGFjZWhvbGRlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0cyA9IHRoaXMucmVtb3ZlUGxhY2Vob2xkZXIoZGF0YS5yZXN1bHRzKTtcblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGRhdGEpO1xuICB9O1xuXG4gIEhpZGVQbGFjZWhvbGRlci5wcm90b3R5cGUubm9ybWFsaXplUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoXywgcGxhY2Vob2xkZXIpIHtcbiAgICBpZiAodHlwZW9mIHBsYWNlaG9sZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgcGxhY2Vob2xkZXIgPSB7XG4gICAgICAgIGlkOiAnJyxcbiAgICAgICAgdGV4dDogcGxhY2Vob2xkZXJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICB9O1xuXG4gIEhpZGVQbGFjZWhvbGRlci5wcm90b3R5cGUucmVtb3ZlUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoXywgZGF0YSkge1xuICAgIHZhciBtb2RpZmllZERhdGEgPSBkYXRhLnNsaWNlKDApO1xuXG4gICAgZm9yICh2YXIgZCA9IGRhdGEubGVuZ3RoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgIHZhciBpdGVtID0gZGF0YVtkXTtcblxuICAgICAgaWYgKHRoaXMucGxhY2Vob2xkZXIuaWQgPT09IGl0ZW0uaWQpIHtcbiAgICAgICAgbW9kaWZpZWREYXRhLnNwbGljZShkLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW9kaWZpZWREYXRhO1xuICB9O1xuXG4gIHJldHVybiBIaWRlUGxhY2Vob2xkZXI7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2Ryb3Bkb3duL2luZmluaXRlU2Nyb2xsJyxbXG4gICdqcXVlcnknXG5dLCBmdW5jdGlvbiAoJCkge1xuICBmdW5jdGlvbiBJbmZpbml0ZVNjcm9sbCAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucywgZGF0YUFkYXB0ZXIpIHtcbiAgICB0aGlzLmxhc3RQYXJhbXMgPSB7fTtcblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zLCBkYXRhQWRhcHRlcik7XG5cbiAgICB0aGlzLiRsb2FkaW5nTW9yZSA9IHRoaXMuY3JlYXRlTG9hZGluZ01vcmUoKTtcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBkYXRhKSB7XG4gICAgdGhpcy4kbG9hZGluZ01vcmUucmVtb3ZlKCk7XG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBkYXRhKTtcblxuICAgIGlmICh0aGlzLnNob3dMb2FkaW5nTW9yZShkYXRhKSkge1xuICAgICAgdGhpcy4kcmVzdWx0cy5hcHBlbmQodGhpcy4kbG9hZGluZ01vcmUpO1xuICAgIH1cbiAgfTtcblxuICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XG5cbiAgICBjb250YWluZXIub24oJ3F1ZXJ5JywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgc2VsZi5sYXN0UGFyYW1zID0gcGFyYW1zO1xuICAgICAgc2VsZi5sb2FkaW5nID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigncXVlcnk6YXBwZW5kJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgc2VsZi5sYXN0UGFyYW1zID0gcGFyYW1zO1xuICAgICAgc2VsZi5sb2FkaW5nID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHRoaXMuJHJlc3VsdHMub24oJ3Njcm9sbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpc0xvYWRNb3JlVmlzaWJsZSA9ICQuY29udGFpbnMoXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgc2VsZi4kbG9hZGluZ01vcmVbMF1cbiAgICAgICk7XG5cbiAgICAgIGlmIChzZWxmLmxvYWRpbmcgfHwgIWlzTG9hZE1vcmVWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSBzZWxmLiRyZXN1bHRzLm9mZnNldCgpLnRvcCArXG4gICAgICAgIHNlbGYuJHJlc3VsdHMub3V0ZXJIZWlnaHQoZmFsc2UpO1xuICAgICAgdmFyIGxvYWRpbmdNb3JlT2Zmc2V0ID0gc2VsZi4kbG9hZGluZ01vcmUub2Zmc2V0KCkudG9wICtcbiAgICAgICAgc2VsZi4kbG9hZGluZ01vcmUub3V0ZXJIZWlnaHQoZmFsc2UpO1xuXG4gICAgICBpZiAoY3VycmVudE9mZnNldCArIDUwID49IGxvYWRpbmdNb3JlT2Zmc2V0KSB7XG4gICAgICAgIHNlbGYubG9hZE1vcmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUubG9hZE1vcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcblxuICAgIHZhciBwYXJhbXMgPSAkLmV4dGVuZCh7fSwge3BhZ2U6IDF9LCB0aGlzLmxhc3RQYXJhbXMpO1xuXG4gICAgcGFyYW1zLnBhZ2UrKztcblxuICAgIHRoaXMudHJpZ2dlcigncXVlcnk6YXBwZW5kJywgcGFyYW1zKTtcbiAgfTtcblxuICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUuc2hvd0xvYWRpbmdNb3JlID0gZnVuY3Rpb24gKF8sIGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdpbmF0aW9uICYmIGRhdGEucGFnaW5hdGlvbi5tb3JlO1xuICB9O1xuXG4gIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5jcmVhdGVMb2FkaW5nTW9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJG9wdGlvbiA9ICQoXG4gICAgICAnPGxpICcgK1xuICAgICAgJ2NsYXNzPVwic2VsZWN0Mi1yZXN1bHRzX19vcHRpb24gc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24tLWxvYWQtbW9yZVwiJyArXG4gICAgICAncm9sZT1cInRyZWVpdGVtXCIgYXJpYS1kaXNhYmxlZD1cInRydWVcIj48L2xpPidcbiAgICApO1xuXG4gICAgdmFyIG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMuZ2V0KCd0cmFuc2xhdGlvbnMnKS5nZXQoJ2xvYWRpbmdNb3JlJyk7XG5cbiAgICAkb3B0aW9uLmh0bWwobWVzc2FnZSh0aGlzLmxhc3RQYXJhbXMpKTtcblxuICAgIHJldHVybiAkb3B0aW9uO1xuICB9O1xuXG4gIHJldHVybiBJbmZpbml0ZVNjcm9sbDtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZHJvcGRvd24vYXR0YWNoQm9keScsW1xuICAnanF1ZXJ5JyxcbiAgJy4uL3V0aWxzJ1xuXSwgZnVuY3Rpb24gKCQsIFV0aWxzKSB7XG4gIGZ1bmN0aW9uIEF0dGFjaEJvZHkgKGRlY29yYXRlZCwgJGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRkcm9wZG93blBhcmVudCA9IG9wdGlvbnMuZ2V0KCdkcm9wZG93blBhcmVudCcpIHx8ICQoZG9jdW1lbnQuYm9keSk7XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZWxlbWVudCwgb3B0aW9ucyk7XG4gIH1cblxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHNldHVwUmVzdWx0c0V2ZW50cyA9IGZhbHNlO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcblxuICAgIGNvbnRhaW5lci5vbignb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX3Nob3dEcm9wZG93bigpO1xuICAgICAgc2VsZi5fYXR0YWNoUG9zaXRpb25pbmdIYW5kbGVyKGNvbnRhaW5lcik7XG5cbiAgICAgIGlmICghc2V0dXBSZXN1bHRzRXZlbnRzKSB7XG4gICAgICAgIHNldHVwUmVzdWx0c0V2ZW50cyA9IHRydWU7XG5cbiAgICAgICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOmFsbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLl9wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICAgICAgc2VsZi5fcmVzaXplRHJvcGRvd24oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOmFwcGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLl9wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICAgICAgc2VsZi5fcmVzaXplRHJvcGRvd24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5faGlkZURyb3Bkb3duKCk7XG4gICAgICBzZWxmLl9kZXRhY2hQb3NpdGlvbmluZ0hhbmRsZXIoY29udGFpbmVyKTtcbiAgICB9KTtcblxuICAgIHRoaXMuJGRyb3Bkb3duQ29udGFpbmVyLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQpIHtcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuJGRyb3Bkb3duQ29udGFpbmVyLnJlbW92ZSgpO1xuICB9O1xuXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgJGRyb3Bkb3duLCAkY29udGFpbmVyKSB7XG4gICAgLy8gQ2xvbmUgYWxsIG9mIHRoZSBjb250YWluZXIgY2xhc3Nlc1xuICAgICRkcm9wZG93bi5hdHRyKCdjbGFzcycsICRjb250YWluZXIuYXR0cignY2xhc3MnKSk7XG5cbiAgICAkZHJvcGRvd24ucmVtb3ZlQ2xhc3MoJ3NlbGVjdDInKTtcbiAgICAkZHJvcGRvd24uYWRkQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS1vcGVuJyk7XG5cbiAgICAkZHJvcGRvd24uY3NzKHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAtOTk5OTk5XG4gICAgfSk7XG5cbiAgICB0aGlzLiRjb250YWluZXIgPSAkY29udGFpbmVyO1xuICB9O1xuXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQpIHtcbiAgICB2YXIgJGNvbnRhaW5lciA9ICQoJzxzcGFuPjwvc3Bhbj4nKTtcblxuICAgIHZhciAkZHJvcGRvd24gPSBkZWNvcmF0ZWQuY2FsbCh0aGlzKTtcbiAgICAkY29udGFpbmVyLmFwcGVuZCgkZHJvcGRvd24pO1xuXG4gICAgdGhpcy4kZHJvcGRvd25Db250YWluZXIgPSAkY29udGFpbmVyO1xuXG4gICAgcmV0dXJuICRjb250YWluZXI7XG4gIH07XG5cbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuX2hpZGVEcm9wZG93biA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQpIHtcbiAgICB0aGlzLiRkcm9wZG93bkNvbnRhaW5lci5kZXRhY2goKTtcbiAgfTtcblxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5fYXR0YWNoUG9zaXRpb25pbmdIYW5kbGVyID1cbiAgICAgIGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBzY3JvbGxFdmVudCA9ICdzY3JvbGwuc2VsZWN0Mi4nICsgY29udGFpbmVyLmlkO1xuICAgIHZhciByZXNpemVFdmVudCA9ICdyZXNpemUuc2VsZWN0Mi4nICsgY29udGFpbmVyLmlkO1xuICAgIHZhciBvcmllbnRhdGlvbkV2ZW50ID0gJ29yaWVudGF0aW9uY2hhbmdlLnNlbGVjdDIuJyArIGNvbnRhaW5lci5pZDtcblxuICAgIHZhciAkd2F0Y2hlcnMgPSB0aGlzLiRjb250YWluZXIucGFyZW50cygpLmZpbHRlcihVdGlscy5oYXNTY3JvbGwpO1xuICAgICR3YXRjaGVycy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICQodGhpcykuZGF0YSgnc2VsZWN0Mi1zY3JvbGwtcG9zaXRpb24nLCB7XG4gICAgICAgIHg6ICQodGhpcykuc2Nyb2xsTGVmdCgpLFxuICAgICAgICB5OiAkKHRoaXMpLnNjcm9sbFRvcCgpXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgICR3YXRjaGVycy5vbihzY3JvbGxFdmVudCwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAkKHRoaXMpLmRhdGEoJ3NlbGVjdDItc2Nyb2xsLXBvc2l0aW9uJyk7XG4gICAgICAkKHRoaXMpLnNjcm9sbFRvcChwb3NpdGlvbi55KTtcbiAgICB9KTtcblxuICAgICQod2luZG93KS5vbihzY3JvbGxFdmVudCArICcgJyArIHJlc2l6ZUV2ZW50ICsgJyAnICsgb3JpZW50YXRpb25FdmVudCxcbiAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICBzZWxmLl9wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICBzZWxmLl9yZXNpemVEcm9wZG93bigpO1xuICAgIH0pO1xuICB9O1xuXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLl9kZXRhY2hQb3NpdGlvbmluZ0hhbmRsZXIgPVxuICAgICAgZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyKSB7XG4gICAgdmFyIHNjcm9sbEV2ZW50ID0gJ3Njcm9sbC5zZWxlY3QyLicgKyBjb250YWluZXIuaWQ7XG4gICAgdmFyIHJlc2l6ZUV2ZW50ID0gJ3Jlc2l6ZS5zZWxlY3QyLicgKyBjb250YWluZXIuaWQ7XG4gICAgdmFyIG9yaWVudGF0aW9uRXZlbnQgPSAnb3JpZW50YXRpb25jaGFuZ2Uuc2VsZWN0Mi4nICsgY29udGFpbmVyLmlkO1xuXG4gICAgdmFyICR3YXRjaGVycyA9IHRoaXMuJGNvbnRhaW5lci5wYXJlbnRzKCkuZmlsdGVyKFV0aWxzLmhhc1Njcm9sbCk7XG4gICAgJHdhdGNoZXJzLm9mZihzY3JvbGxFdmVudCk7XG5cbiAgICAkKHdpbmRvdykub2ZmKHNjcm9sbEV2ZW50ICsgJyAnICsgcmVzaXplRXZlbnQgKyAnICcgKyBvcmllbnRhdGlvbkV2ZW50KTtcbiAgfTtcblxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5fcG9zaXRpb25Ecm9wZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHdpbmRvdyA9ICQod2luZG93KTtcblxuICAgIHZhciBpc0N1cnJlbnRseUFib3ZlID0gdGhpcy4kZHJvcGRvd24uaGFzQ2xhc3MoJ3NlbGVjdDItZHJvcGRvd24tLWFib3ZlJyk7XG4gICAgdmFyIGlzQ3VycmVudGx5QmVsb3cgPSB0aGlzLiRkcm9wZG93bi5oYXNDbGFzcygnc2VsZWN0Mi1kcm9wZG93bi0tYmVsb3cnKTtcblxuICAgIHZhciBuZXdEaXJlY3Rpb24gPSBudWxsO1xuXG4gICAgdmFyIG9mZnNldCA9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKTtcblxuICAgIG9mZnNldC5ib3R0b20gPSBvZmZzZXQudG9wICsgdGhpcy4kY29udGFpbmVyLm91dGVySGVpZ2h0KGZhbHNlKTtcblxuICAgIHZhciBjb250YWluZXIgPSB7XG4gICAgICBoZWlnaHQ6IHRoaXMuJGNvbnRhaW5lci5vdXRlckhlaWdodChmYWxzZSlcbiAgICB9O1xuXG4gICAgY29udGFpbmVyLnRvcCA9IG9mZnNldC50b3A7XG4gICAgY29udGFpbmVyLmJvdHRvbSA9IG9mZnNldC50b3AgKyBjb250YWluZXIuaGVpZ2h0O1xuXG4gICAgdmFyIGRyb3Bkb3duID0ge1xuICAgICAgaGVpZ2h0OiB0aGlzLiRkcm9wZG93bi5vdXRlckhlaWdodChmYWxzZSlcbiAgICB9O1xuXG4gICAgdmFyIHZpZXdwb3J0ID0ge1xuICAgICAgdG9wOiAkd2luZG93LnNjcm9sbFRvcCgpLFxuICAgICAgYm90dG9tOiAkd2luZG93LnNjcm9sbFRvcCgpICsgJHdpbmRvdy5oZWlnaHQoKVxuICAgIH07XG5cbiAgICB2YXIgZW5vdWdoUm9vbUFib3ZlID0gdmlld3BvcnQudG9wIDwgKG9mZnNldC50b3AgLSBkcm9wZG93bi5oZWlnaHQpO1xuICAgIHZhciBlbm91Z2hSb29tQmVsb3cgPSB2aWV3cG9ydC5ib3R0b20gPiAob2Zmc2V0LmJvdHRvbSArIGRyb3Bkb3duLmhlaWdodCk7XG5cbiAgICB2YXIgY3NzID0ge1xuICAgICAgbGVmdDogb2Zmc2V0LmxlZnQsXG4gICAgICB0b3A6IGNvbnRhaW5lci5ib3R0b21cbiAgICB9O1xuXG4gICAgLy8gRGV0ZXJtaW5lIHdoYXQgdGhlIHBhcmVudCBlbGVtZW50IGlzIHRvIHVzZSBmb3IgY2FsY2l1bGF0aW5nIHRoZSBvZmZzZXRcbiAgICB2YXIgJG9mZnNldFBhcmVudCA9IHRoaXMuJGRyb3Bkb3duUGFyZW50O1xuXG4gICAgLy8gRm9yIHN0YXRpY2FsbHkgcG9zaXRvbmVkIGVsZW1lbnRzLCB3ZSBuZWVkIHRvIGdldCB0aGUgZWxlbWVudFxuICAgIC8vIHRoYXQgaXMgZGV0ZXJtaW5pbmcgdGhlIG9mZnNldFxuICAgIGlmICgkb2Zmc2V0UGFyZW50LmNzcygncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICRvZmZzZXRQYXJlbnQgPSAkb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudCgpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRPZmZzZXQgPSAkb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXG4gICAgY3NzLnRvcCAtPSBwYXJlbnRPZmZzZXQudG9wO1xuICAgIGNzcy5sZWZ0IC09IHBhcmVudE9mZnNldC5sZWZ0O1xuXG4gICAgaWYgKCFpc0N1cnJlbnRseUFib3ZlICYmICFpc0N1cnJlbnRseUJlbG93KSB7XG4gICAgICBuZXdEaXJlY3Rpb24gPSAnYmVsb3cnO1xuICAgIH1cblxuICAgIGlmICghZW5vdWdoUm9vbUJlbG93ICYmIGVub3VnaFJvb21BYm92ZSAmJiAhaXNDdXJyZW50bHlBYm92ZSkge1xuICAgICAgbmV3RGlyZWN0aW9uID0gJ2Fib3ZlJztcbiAgICB9IGVsc2UgaWYgKCFlbm91Z2hSb29tQWJvdmUgJiYgZW5vdWdoUm9vbUJlbG93ICYmIGlzQ3VycmVudGx5QWJvdmUpIHtcbiAgICAgIG5ld0RpcmVjdGlvbiA9ICdiZWxvdyc7XG4gICAgfVxuXG4gICAgaWYgKG5ld0RpcmVjdGlvbiA9PSAnYWJvdmUnIHx8XG4gICAgICAoaXNDdXJyZW50bHlBYm92ZSAmJiBuZXdEaXJlY3Rpb24gIT09ICdiZWxvdycpKSB7XG4gICAgICBjc3MudG9wID0gY29udGFpbmVyLnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBkcm9wZG93bi5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG5ld0RpcmVjdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aGlzLiRkcm9wZG93blxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NlbGVjdDItZHJvcGRvd24tLWJlbG93IHNlbGVjdDItZHJvcGRvd24tLWFib3ZlJylcbiAgICAgICAgLmFkZENsYXNzKCdzZWxlY3QyLWRyb3Bkb3duLS0nICsgbmV3RGlyZWN0aW9uKTtcbiAgICAgIHRoaXMuJGNvbnRhaW5lclxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS1iZWxvdyBzZWxlY3QyLWNvbnRhaW5lci0tYWJvdmUnKVxuICAgICAgICAuYWRkQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS0nICsgbmV3RGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLiRkcm9wZG93bkNvbnRhaW5lci5jc3MoY3NzKTtcbiAgfTtcblxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5fcmVzaXplRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNzcyA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLiRjb250YWluZXIub3V0ZXJXaWR0aChmYWxzZSkgKyAncHgnXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2V0KCdkcm9wZG93bkF1dG9XaWR0aCcpKSB7XG4gICAgICBjc3MubWluV2lkdGggPSBjc3Mud2lkdGg7XG4gICAgICBjc3MucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgY3NzLndpZHRoID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIHRoaXMuJGRyb3Bkb3duLmNzcyhjc3MpO1xuICB9O1xuXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLl9zaG93RHJvcGRvd24gPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XG4gICAgdGhpcy4kZHJvcGRvd25Db250YWluZXIuYXBwZW5kVG8odGhpcy4kZHJvcGRvd25QYXJlbnQpO1xuXG4gICAgdGhpcy5fcG9zaXRpb25Ecm9wZG93bigpO1xuICAgIHRoaXMuX3Jlc2l6ZURyb3Bkb3duKCk7XG4gIH07XG5cbiAgcmV0dXJuIEF0dGFjaEJvZHk7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2Ryb3Bkb3duL21pbmltdW1SZXN1bHRzRm9yU2VhcmNoJyxbXG5cbl0sIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gY291bnRSZXN1bHRzIChkYXRhKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGF0YS5sZW5ndGg7IGQrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW2RdO1xuXG4gICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICBjb3VudCArPSBjb3VudFJlc3VsdHMoaXRlbS5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIE1pbmltdW1SZXN1bHRzRm9yU2VhcmNoIChkZWNvcmF0ZWQsICRlbGVtZW50LCBvcHRpb25zLCBkYXRhQWRhcHRlcikge1xuICAgIHRoaXMubWluaW11bVJlc3VsdHNGb3JTZWFyY2ggPSBvcHRpb25zLmdldCgnbWluaW11bVJlc3VsdHNGb3JTZWFyY2gnKTtcblxuICAgIGlmICh0aGlzLm1pbmltdW1SZXN1bHRzRm9yU2VhcmNoIDwgMCkge1xuICAgICAgdGhpcy5taW5pbXVtUmVzdWx0c0ZvclNlYXJjaCA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zLCBkYXRhQWRhcHRlcik7XG4gIH1cblxuICBNaW5pbXVtUmVzdWx0c0ZvclNlYXJjaC5wcm90b3R5cGUuc2hvd1NlYXJjaCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcykge1xuICAgIGlmIChjb3VudFJlc3VsdHMocGFyYW1zLmRhdGEucmVzdWx0cykgPCB0aGlzLm1pbmltdW1SZXN1bHRzRm9yU2VhcmNoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY29yYXRlZC5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gIH07XG5cbiAgcmV0dXJuIE1pbmltdW1SZXN1bHRzRm9yU2VhcmNoO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9zZWxlY3RPbkNsb3NlJyxbXG5cbl0sIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VsZWN0T25DbG9zZSAoKSB7IH1cblxuICBTZWxlY3RPbkNsb3NlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcblxuICAgIGNvbnRhaW5lci5vbignY2xvc2UnLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBzZWxmLl9oYW5kbGVTZWxlY3RPbkNsb3NlKHBhcmFtcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgU2VsZWN0T25DbG9zZS5wcm90b3R5cGUuX2hhbmRsZVNlbGVjdE9uQ2xvc2UgPSBmdW5jdGlvbiAoXywgcGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMub3JpZ2luYWxTZWxlY3QyRXZlbnQgIT0gbnVsbCkge1xuICAgICAgdmFyIGV2ZW50ID0gcGFyYW1zLm9yaWdpbmFsU2VsZWN0MkV2ZW50O1xuXG4gICAgICAvLyBEb24ndCBzZWxlY3QgYW4gaXRlbSBpZiB0aGUgY2xvc2UgZXZlbnQgd2FzIHRyaWdnZXJlZCBmcm9tIGEgc2VsZWN0IG9yXG4gICAgICAvLyB1bnNlbGVjdCBldmVudFxuICAgICAgaWYgKGV2ZW50Ll90eXBlID09PSAnc2VsZWN0JyB8fCBldmVudC5fdHlwZSA9PT0gJ3Vuc2VsZWN0Jykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyICRoaWdobGlnaHRlZFJlc3VsdHMgPSB0aGlzLmdldEhpZ2hsaWdodGVkUmVzdWx0cygpO1xuXG4gICAgLy8gT25seSBzZWxlY3QgaGlnaGxpZ2h0ZWQgcmVzdWx0c1xuICAgIGlmICgkaGlnaGxpZ2h0ZWRSZXN1bHRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9ICRoaWdobGlnaHRlZFJlc3VsdHMuZGF0YSgnZGF0YScpO1xuXG4gICAgLy8gRG9uJ3QgcmUtc2VsZWN0IGFscmVhZHkgc2VsZWN0ZWQgcmVzdWx0ZVxuICAgIGlmIChcbiAgICAgIChkYXRhLmVsZW1lbnQgIT0gbnVsbCAmJiBkYXRhLmVsZW1lbnQuc2VsZWN0ZWQpIHx8XG4gICAgICAoZGF0YS5lbGVtZW50ID09IG51bGwgJiYgZGF0YS5zZWxlY3RlZClcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdCcsIHtcbiAgICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTZWxlY3RPbkNsb3NlO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9jbG9zZU9uU2VsZWN0JyxbXG5cbl0sIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2xvc2VPblNlbGVjdCAoKSB7IH1cblxuICBDbG9zZU9uU2VsZWN0LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcblxuICAgIGNvbnRhaW5lci5vbignc2VsZWN0JywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi5fc2VsZWN0VHJpZ2dlcmVkKGV2dCk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ3Vuc2VsZWN0JywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi5fc2VsZWN0VHJpZ2dlcmVkKGV2dCk7XG4gICAgfSk7XG4gIH07XG5cbiAgQ2xvc2VPblNlbGVjdC5wcm90b3R5cGUuX3NlbGVjdFRyaWdnZXJlZCA9IGZ1bmN0aW9uIChfLCBldnQpIHtcbiAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGV2dC5vcmlnaW5hbEV2ZW50O1xuXG4gICAgLy8gRG9uJ3QgY2xvc2UgaWYgdGhlIGNvbnRyb2wga2V5IGlzIGJlaW5nIGhlbGRcbiAgICBpZiAob3JpZ2luYWxFdmVudCAmJiBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2Nsb3NlJywge1xuICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCxcbiAgICAgIG9yaWdpbmFsU2VsZWN0MkV2ZW50OiBldnRcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ2xvc2VPblNlbGVjdDtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvaTE4bi9lbicsW10sZnVuY3Rpb24gKCkge1xuICAvLyBFbmdsaXNoXG4gIHJldHVybiB7XG4gICAgZXJyb3JMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJ1RoZSByZXN1bHRzIGNvdWxkIG5vdCBiZSBsb2FkZWQuJztcbiAgICB9LFxuICAgIGlucHV0VG9vTG9uZzogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHZhciBvdmVyQ2hhcnMgPSBhcmdzLmlucHV0Lmxlbmd0aCAtIGFyZ3MubWF4aW11bTtcblxuICAgICAgdmFyIG1lc3NhZ2UgPSAnUGxlYXNlIGRlbGV0ZSAnICsgb3ZlckNoYXJzICsgJyBjaGFyYWN0ZXInO1xuXG4gICAgICBpZiAob3ZlckNoYXJzICE9IDEpIHtcbiAgICAgICAgbWVzc2FnZSArPSAncyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgaW5wdXRUb29TaG9ydDogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHZhciByZW1haW5pbmdDaGFycyA9IGFyZ3MubWluaW11bSAtIGFyZ3MuaW5wdXQubGVuZ3RoO1xuXG4gICAgICB2YXIgbWVzc2FnZSA9ICdQbGVhc2UgZW50ZXIgJyArIHJlbWFpbmluZ0NoYXJzICsgJyBvciBtb3JlIGNoYXJhY3RlcnMnO1xuXG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGxvYWRpbmdNb3JlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJ0xvYWRpbmcgbW9yZSByZXN1bHRz4oCmJztcbiAgICB9LFxuICAgIG1heGltdW1TZWxlY3RlZDogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1lvdSBjYW4gb25seSBzZWxlY3QgJyArIGFyZ3MubWF4aW11bSArICcgaXRlbSc7XG5cbiAgICAgIGlmIChhcmdzLm1heGltdW0gIT0gMSkge1xuICAgICAgICBtZXNzYWdlICs9ICdzJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBub1Jlc3VsdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnTm8gcmVzdWx0cyBmb3VuZCc7XG4gICAgfSxcbiAgICBzZWFyY2hpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnU2VhcmNoaW5n4oCmJztcbiAgICB9XG4gIH07XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2RlZmF1bHRzJyxbXG4gICdqcXVlcnknLFxuICAncmVxdWlyZScsXG5cbiAgJy4vcmVzdWx0cycsXG5cbiAgJy4vc2VsZWN0aW9uL3NpbmdsZScsXG4gICcuL3NlbGVjdGlvbi9tdWx0aXBsZScsXG4gICcuL3NlbGVjdGlvbi9wbGFjZWhvbGRlcicsXG4gICcuL3NlbGVjdGlvbi9hbGxvd0NsZWFyJyxcbiAgJy4vc2VsZWN0aW9uL3NlYXJjaCcsXG4gICcuL3NlbGVjdGlvbi9ldmVudFJlbGF5JyxcblxuICAnLi91dGlscycsXG4gICcuL3RyYW5zbGF0aW9uJyxcbiAgJy4vZGlhY3JpdGljcycsXG5cbiAgJy4vZGF0YS9zZWxlY3QnLFxuICAnLi9kYXRhL2FycmF5JyxcbiAgJy4vZGF0YS9hamF4JyxcbiAgJy4vZGF0YS90YWdzJyxcbiAgJy4vZGF0YS90b2tlbml6ZXInLFxuICAnLi9kYXRhL21pbmltdW1JbnB1dExlbmd0aCcsXG4gICcuL2RhdGEvbWF4aW11bUlucHV0TGVuZ3RoJyxcbiAgJy4vZGF0YS9tYXhpbXVtU2VsZWN0aW9uTGVuZ3RoJyxcblxuICAnLi9kcm9wZG93bicsXG4gICcuL2Ryb3Bkb3duL3NlYXJjaCcsXG4gICcuL2Ryb3Bkb3duL2hpZGVQbGFjZWhvbGRlcicsXG4gICcuL2Ryb3Bkb3duL2luZmluaXRlU2Nyb2xsJyxcbiAgJy4vZHJvcGRvd24vYXR0YWNoQm9keScsXG4gICcuL2Ryb3Bkb3duL21pbmltdW1SZXN1bHRzRm9yU2VhcmNoJyxcbiAgJy4vZHJvcGRvd24vc2VsZWN0T25DbG9zZScsXG4gICcuL2Ryb3Bkb3duL2Nsb3NlT25TZWxlY3QnLFxuXG4gICcuL2kxOG4vZW4nXG5dLCBmdW5jdGlvbiAoJCwgcmVxdWlyZSxcblxuICAgICAgICAgICAgIFJlc3VsdHNMaXN0LFxuXG4gICAgICAgICAgICAgU2luZ2xlU2VsZWN0aW9uLCBNdWx0aXBsZVNlbGVjdGlvbiwgUGxhY2Vob2xkZXIsIEFsbG93Q2xlYXIsXG4gICAgICAgICAgICAgU2VsZWN0aW9uU2VhcmNoLCBFdmVudFJlbGF5LFxuXG4gICAgICAgICAgICAgVXRpbHMsIFRyYW5zbGF0aW9uLCBESUFDUklUSUNTLFxuXG4gICAgICAgICAgICAgU2VsZWN0RGF0YSwgQXJyYXlEYXRhLCBBamF4RGF0YSwgVGFncywgVG9rZW5pemVyLFxuICAgICAgICAgICAgIE1pbmltdW1JbnB1dExlbmd0aCwgTWF4aW11bUlucHV0TGVuZ3RoLCBNYXhpbXVtU2VsZWN0aW9uTGVuZ3RoLFxuXG4gICAgICAgICAgICAgRHJvcGRvd24sIERyb3Bkb3duU2VhcmNoLCBIaWRlUGxhY2Vob2xkZXIsIEluZmluaXRlU2Nyb2xsLFxuICAgICAgICAgICAgIEF0dGFjaEJvZHksIE1pbmltdW1SZXN1bHRzRm9yU2VhcmNoLCBTZWxlY3RPbkNsb3NlLCBDbG9zZU9uU2VsZWN0LFxuXG4gICAgICAgICAgICAgRW5nbGlzaFRyYW5zbGF0aW9uKSB7XG4gIGZ1bmN0aW9uIERlZmF1bHRzICgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICBEZWZhdWx0cy5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhQWRhcHRlciA9PSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5hamF4ICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IEFqYXhEYXRhO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmRhdGEgIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gQXJyYXlEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IFNlbGVjdERhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm1pbmltdW1JbnB1dExlbmd0aCA+IDApIHtcbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxuICAgICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIsXG4gICAgICAgICAgTWluaW11bUlucHV0TGVuZ3RoXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm1heGltdW1JbnB1dExlbmd0aCA+IDApIHtcbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxuICAgICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIsXG4gICAgICAgICAgTWF4aW11bUlucHV0TGVuZ3RoXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm1heGltdW1TZWxlY3Rpb25MZW5ndGggPiAwKSB7XG4gICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyLFxuICAgICAgICAgIE1heGltdW1TZWxlY3Rpb25MZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudGFncykge1xuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUob3B0aW9ucy5kYXRhQWRhcHRlciwgVGFncyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRva2VuU2VwYXJhdG9ycyAhPSBudWxsIHx8IG9wdGlvbnMudG9rZW5pemVyICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxuICAgICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIsXG4gICAgICAgICAgVG9rZW5pemVyXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnF1ZXJ5ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIFF1ZXJ5ID0gcmVxdWlyZShvcHRpb25zLmFtZEJhc2UgKyAnY29tcGF0L3F1ZXJ5Jyk7XG5cbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxuICAgICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIsXG4gICAgICAgICAgUXVlcnlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaW5pdFNlbGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHZhciBJbml0U2VsZWN0aW9uID0gcmVxdWlyZShvcHRpb25zLmFtZEJhc2UgKyAnY29tcGF0L2luaXRTZWxlY3Rpb24nKTtcblxuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXG4gICAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlcixcbiAgICAgICAgICBJbml0U2VsZWN0aW9uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucmVzdWx0c0FkYXB0ZXIgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5yZXN1bHRzQWRhcHRlciA9IFJlc3VsdHNMaXN0O1xuXG4gICAgICBpZiAob3B0aW9ucy5hamF4ICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5yZXN1bHRzQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxuICAgICAgICAgIG9wdGlvbnMucmVzdWx0c0FkYXB0ZXIsXG4gICAgICAgICAgSW5maW5pdGVTY3JvbGxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucGxhY2Vob2xkZXIgIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLnJlc3VsdHNBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXG4gICAgICAgICAgb3B0aW9ucy5yZXN1bHRzQWRhcHRlcixcbiAgICAgICAgICBIaWRlUGxhY2Vob2xkZXJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuc2VsZWN0T25DbG9zZSkge1xuICAgICAgICBvcHRpb25zLnJlc3VsdHNBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXG4gICAgICAgICAgb3B0aW9ucy5yZXN1bHRzQWRhcHRlcixcbiAgICAgICAgICBTZWxlY3RPbkNsb3NlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyID09IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLm11bHRpcGxlKSB7XG4gICAgICAgIG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyID0gRHJvcGRvd247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgU2VhcmNoYWJsZURyb3Bkb3duID0gVXRpbHMuRGVjb3JhdGUoRHJvcGRvd24sIERyb3Bkb3duU2VhcmNoKTtcblxuICAgICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlciA9IFNlYXJjaGFibGVEcm9wZG93bjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMubWluaW11bVJlc3VsdHNGb3JTZWFyY2ggIT09IDApIHtcbiAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlcixcbiAgICAgICAgICBNaW5pbXVtUmVzdWx0c0ZvclNlYXJjaFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jbG9zZU9uU2VsZWN0KSB7XG4gICAgICAgIG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXG4gICAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIsXG4gICAgICAgICAgQ2xvc2VPblNlbGVjdFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIG9wdGlvbnMuZHJvcGRvd25Dc3NDbGFzcyAhPSBudWxsIHx8XG4gICAgICAgIG9wdGlvbnMuZHJvcGRvd25Dc3MgIT0gbnVsbCB8fFxuICAgICAgICBvcHRpb25zLmFkYXB0RHJvcGRvd25Dc3NDbGFzcyAhPSBudWxsXG4gICAgICApIHtcbiAgICAgICAgdmFyIERyb3Bkb3duQ1NTID0gcmVxdWlyZShvcHRpb25zLmFtZEJhc2UgKyAnY29tcGF0L2Ryb3Bkb3duQ3NzJyk7XG5cbiAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlcixcbiAgICAgICAgICBEcm9wZG93bkNTU1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxuICAgICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlcixcbiAgICAgICAgQXR0YWNoQm9keVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyID09IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLm11bHRpcGxlKSB7XG4gICAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlciA9IE11bHRpcGxlU2VsZWN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyID0gU2luZ2xlU2VsZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIHBsYWNlaG9sZGVyIG1peGluIGlmIGEgcGxhY2Vob2xkZXIgd2FzIHNwZWNpZmllZFxuICAgICAgaWYgKG9wdGlvbnMucGxhY2Vob2xkZXIgIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIsXG4gICAgICAgICAgUGxhY2Vob2xkZXJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYWxsb3dDbGVhcikge1xuICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIsXG4gICAgICAgICAgQWxsb3dDbGVhclxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5tdWx0aXBsZSkge1xuICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIsXG4gICAgICAgICAgU2VsZWN0aW9uU2VhcmNoXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucy5jb250YWluZXJDc3NDbGFzcyAhPSBudWxsIHx8XG4gICAgICAgIG9wdGlvbnMuY29udGFpbmVyQ3NzICE9IG51bGwgfHxcbiAgICAgICAgb3B0aW9ucy5hZGFwdENvbnRhaW5lckNzc0NsYXNzICE9IG51bGxcbiAgICAgICkge1xuICAgICAgICB2YXIgQ29udGFpbmVyQ1NTID0gcmVxdWlyZShvcHRpb25zLmFtZEJhc2UgKyAnY29tcGF0L2NvbnRhaW5lckNzcycpO1xuXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxuICAgICAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlcixcbiAgICAgICAgICBDb250YWluZXJDU1NcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlcixcbiAgICAgICAgRXZlbnRSZWxheVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubGFuZ3VhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgbGFuZ3VhZ2UgaXMgc3BlY2lmaWVkIHdpdGggYSByZWdpb25cbiAgICAgIGlmIChvcHRpb25zLmxhbmd1YWdlLmluZGV4T2YoJy0nKSA+IDApIHtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgcmVnaW9uIGluZm9ybWF0aW9uIGlmIGl0IGlzIGluY2x1ZGVkXG4gICAgICAgIHZhciBsYW5ndWFnZVBhcnRzID0gb3B0aW9ucy5sYW5ndWFnZS5zcGxpdCgnLScpO1xuICAgICAgICB2YXIgYmFzZUxhbmd1YWdlID0gbGFuZ3VhZ2VQYXJ0c1swXTtcblxuICAgICAgICBvcHRpb25zLmxhbmd1YWdlID0gW29wdGlvbnMubGFuZ3VhZ2UsIGJhc2VMYW5ndWFnZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLmxhbmd1YWdlID0gW29wdGlvbnMubGFuZ3VhZ2VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgkLmlzQXJyYXkob3B0aW9ucy5sYW5ndWFnZSkpIHtcbiAgICAgIHZhciBsYW5ndWFnZXMgPSBuZXcgVHJhbnNsYXRpb24oKTtcbiAgICAgIG9wdGlvbnMubGFuZ3VhZ2UucHVzaCgnZW4nKTtcblxuICAgICAgdmFyIGxhbmd1YWdlTmFtZXMgPSBvcHRpb25zLmxhbmd1YWdlO1xuXG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxhbmd1YWdlTmFtZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBsYW5ndWFnZU5hbWVzW2xdO1xuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSB7fTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSB0byBsb2FkIGl0IHdpdGggdGhlIG9yaWdpbmFsIG5hbWVcbiAgICAgICAgICBsYW5ndWFnZSA9IFRyYW5zbGF0aW9uLmxvYWRQYXRoKG5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGxvYWQgaXQsIGNoZWNrIGlmIGl0IHdhc24ndCB0aGUgZnVsbCBwYXRoXG4gICAgICAgICAgICBuYW1lID0gdGhpcy5kZWZhdWx0cy5hbWRMYW5ndWFnZUJhc2UgKyBuYW1lO1xuICAgICAgICAgICAgbGFuZ3VhZ2UgPSBUcmFuc2xhdGlvbi5sb2FkUGF0aChuYW1lKTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgLy8gVGhlIHRyYW5zbGF0aW9uIGNvdWxkIG5vdCBiZSBsb2FkZWQgYXQgYWxsLiBTb21ldGltZXMgdGhpcyBpc1xuICAgICAgICAgICAgLy8gYmVjYXVzZSBvZiBhIGNvbmZpZ3VyYXRpb24gcHJvYmxlbSwgb3RoZXIgdGltZXMgdGhpcyBjYW4gYmVcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugb2YgaG93IFNlbGVjdDIgaGVscHMgbG9hZCBhbGwgcG9zc2libGUgdHJhbnNsYXRpb24gZmlsZXMuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdTZWxlY3QyOiBUaGUgbGFuZ3VhZ2UgZmlsZSBmb3IgXCInICsgbmFtZSArICdcIiBjb3VsZCBub3QgYmUgJyArXG4gICAgICAgICAgICAgICAgJ2F1dG9tYXRpY2FsbHkgbG9hZGVkLiBBIGZhbGxiYWNrIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFuZ3VhZ2VzLmV4dGVuZChsYW5ndWFnZSk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMudHJhbnNsYXRpb25zID0gbGFuZ3VhZ2VzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYmFzZVRyYW5zbGF0aW9uID0gVHJhbnNsYXRpb24ubG9hZFBhdGgoXG4gICAgICAgIHRoaXMuZGVmYXVsdHMuYW1kTGFuZ3VhZ2VCYXNlICsgJ2VuJ1xuICAgICAgKTtcbiAgICAgIHZhciBjdXN0b21UcmFuc2xhdGlvbiA9IG5ldyBUcmFuc2xhdGlvbihvcHRpb25zLmxhbmd1YWdlKTtcblxuICAgICAgY3VzdG9tVHJhbnNsYXRpb24uZXh0ZW5kKGJhc2VUcmFuc2xhdGlvbik7XG5cbiAgICAgIG9wdGlvbnMudHJhbnNsYXRpb25zID0gY3VzdG9tVHJhbnNsYXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH07XG5cbiAgRGVmYXVsdHMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHN0cmlwRGlhY3JpdGljcyAodGV4dCkge1xuICAgICAgLy8gVXNlZCAndW5pIHJhbmdlICsgbmFtZWQgZnVuY3Rpb24nIGZyb20gaHR0cDovL2pzcGVyZi5jb20vZGlhY3JpdGljcy8xOFxuICAgICAgZnVuY3Rpb24gbWF0Y2goYSkge1xuICAgICAgICByZXR1cm4gRElBQ1JJVElDU1thXSB8fCBhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bXlxcdTAwMDAtXFx1MDA3RV0vZywgbWF0Y2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoZXIgKHBhcmFtcywgZGF0YSkge1xuICAgICAgLy8gQWx3YXlzIHJldHVybiB0aGUgb2JqZWN0IGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gY29tcGFyZVxuICAgICAgaWYgKCQudHJpbShwYXJhbXMudGVybSkgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBEbyBhIHJlY3Vyc2l2ZSBjaGVjayBmb3Igb3B0aW9ucyB3aXRoIGNoaWxkcmVuXG4gICAgICBpZiAoZGF0YS5jaGlsZHJlbiAmJiBkYXRhLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ2xvbmUgdGhlIGRhdGEgb2JqZWN0IGlmIHRoZXJlIGFyZSBjaGlsZHJlblxuICAgICAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIGFzIHdlIG1vZGlmeSB0aGUgb2JqZWN0IHRvIHJlbW92ZSBhbnkgbm9uLW1hdGNoZXNcbiAgICAgICAgdmFyIG1hdGNoID0gJC5leHRlbmQodHJ1ZSwge30sIGRhdGEpO1xuXG4gICAgICAgIC8vIENoZWNrIGVhY2ggY2hpbGQgb2YgdGhlIG9wdGlvblxuICAgICAgICBmb3IgKHZhciBjID0gZGF0YS5jaGlsZHJlbi5sZW5ndGggLSAxOyBjID49IDA7IGMtLSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGRhdGEuY2hpbGRyZW5bY107XG5cbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IG1hdGNoZXIocGFyYW1zLCBjaGlsZCk7XG5cbiAgICAgICAgICAvLyBJZiB0aGVyZSB3YXNuJ3QgYSBtYXRjaCwgcmVtb3ZlIHRoZSBvYmplY3QgaW4gdGhlIGFycmF5XG4gICAgICAgICAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF0Y2guY2hpbGRyZW4uc3BsaWNlKGMsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGFueSBjaGlsZHJlbiBtYXRjaGVkLCByZXR1cm4gdGhlIG5ldyBvYmplY3RcbiAgICAgICAgaWYgKG1hdGNoLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSB3ZXJlIG5vIG1hdGNoaW5nIGNoaWxkcmVuLCBjaGVjayBqdXN0IHRoZSBwbGFpbiBvYmplY3RcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIocGFyYW1zLCBtYXRjaCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcmlnaW5hbCA9IHN0cmlwRGlhY3JpdGljcyhkYXRhLnRleHQpLnRvVXBwZXJDYXNlKCk7XG4gICAgICB2YXIgdGVybSA9IHN0cmlwRGlhY3JpdGljcyhwYXJhbXMudGVybSkudG9VcHBlckNhc2UoKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHRleHQgY29udGFpbnMgdGhlIHRlcm1cbiAgICAgIGlmIChvcmlnaW5hbC5pbmRleE9mKHRlcm0pID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGRvZXNuJ3QgY29udGFpbiB0aGUgdGVybSwgZG9uJ3QgcmV0dXJuIGFueXRoaW5nXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmRlZmF1bHRzID0ge1xuICAgICAgYW1kQmFzZTogJy4vJyxcbiAgICAgIGFtZExhbmd1YWdlQmFzZTogJy4vaTE4bi8nLFxuICAgICAgY2xvc2VPblNlbGVjdDogdHJ1ZSxcbiAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgIGRyb3Bkb3duQXV0b1dpZHRoOiBmYWxzZSxcbiAgICAgIGVzY2FwZU1hcmt1cDogVXRpbHMuZXNjYXBlTWFya3VwLFxuICAgICAgbGFuZ3VhZ2U6IEVuZ2xpc2hUcmFuc2xhdGlvbixcbiAgICAgIG1hdGNoZXI6IG1hdGNoZXIsXG4gICAgICBtaW5pbXVtSW5wdXRMZW5ndGg6IDAsXG4gICAgICBtYXhpbXVtSW5wdXRMZW5ndGg6IDAsXG4gICAgICBtYXhpbXVtU2VsZWN0aW9uTGVuZ3RoOiAwLFxuICAgICAgbWluaW11bVJlc3VsdHNGb3JTZWFyY2g6IDAsXG4gICAgICBzZWxlY3RPbkNsb3NlOiBmYWxzZSxcbiAgICAgIHNvcnRlcjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9LFxuICAgICAgdGVtcGxhdGVSZXN1bHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50ZXh0O1xuICAgICAgfSxcbiAgICAgIHRlbXBsYXRlU2VsZWN0aW9uOiBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb24udGV4dDtcbiAgICAgIH0sXG4gICAgICB0aGVtZTogJ2RlZmF1bHQnLFxuICAgICAgd2lkdGg6ICdyZXNvbHZlJ1xuICAgIH07XG4gIH07XG5cbiAgRGVmYXVsdHMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGNhbWVsS2V5ID0gJC5jYW1lbENhc2Uoa2V5KTtcblxuICAgIHZhciBkYXRhID0ge307XG4gICAgZGF0YVtjYW1lbEtleV0gPSB2YWx1ZTtcblxuICAgIHZhciBjb252ZXJ0ZWREYXRhID0gVXRpbHMuX2NvbnZlcnREYXRhKGRhdGEpO1xuXG4gICAgJC5leHRlbmQodGhpcy5kZWZhdWx0cywgY29udmVydGVkRGF0YSk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRzID0gbmV3IERlZmF1bHRzKCk7XG5cbiAgcmV0dXJuIGRlZmF1bHRzO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9vcHRpb25zJyxbXG4gICdyZXF1aXJlJyxcbiAgJ2pxdWVyeScsXG4gICcuL2RlZmF1bHRzJyxcbiAgJy4vdXRpbHMnXG5dLCBmdW5jdGlvbiAocmVxdWlyZSwgJCwgRGVmYXVsdHMsIFV0aWxzKSB7XG4gIGZ1bmN0aW9uIE9wdGlvbnMgKG9wdGlvbnMsICRlbGVtZW50KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIGlmICgkZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmZyb21FbGVtZW50KCRlbGVtZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBEZWZhdWx0cy5hcHBseSh0aGlzLm9wdGlvbnMpO1xuXG4gICAgaWYgKCRlbGVtZW50ICYmICRlbGVtZW50LmlzKCdpbnB1dCcpKSB7XG4gICAgICB2YXIgSW5wdXRDb21wYXQgPSByZXF1aXJlKHRoaXMuZ2V0KCdhbWRCYXNlJykgKyAnY29tcGF0L2lucHV0RGF0YScpO1xuXG4gICAgICB0aGlzLm9wdGlvbnMuZGF0YUFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLmRhdGFBZGFwdGVyLFxuICAgICAgICBJbnB1dENvbXBhdFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBPcHRpb25zLnByb3RvdHlwZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uICgkZSkge1xuICAgIHZhciBleGNsdWRlZERhdGEgPSBbJ3NlbGVjdDInXTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMubXVsdGlwbGUgPT0gbnVsbCkge1xuICAgICAgdGhpcy5vcHRpb25zLm11bHRpcGxlID0gJGUucHJvcCgnbXVsdGlwbGUnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkID09IG51bGwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9ICRlLnByb3AoJ2Rpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sYW5ndWFnZSA9PSBudWxsKSB7XG4gICAgICBpZiAoJGUucHJvcCgnbGFuZycpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sYW5ndWFnZSA9ICRlLnByb3AoJ2xhbmcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSBlbHNlIGlmICgkZS5jbG9zZXN0KCdbbGFuZ10nKS5wcm9wKCdsYW5nJykpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxhbmd1YWdlID0gJGUuY2xvc2VzdCgnW2xhbmddJykucHJvcCgnbGFuZycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlyID09IG51bGwpIHtcbiAgICAgIGlmICgkZS5wcm9wKCdkaXInKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZGlyID0gJGUucHJvcCgnZGlyJyk7XG4gICAgICB9IGVsc2UgaWYgKCRlLmNsb3Nlc3QoJ1tkaXJdJykucHJvcCgnZGlyJykpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmRpciA9ICRlLmNsb3Nlc3QoJ1tkaXJdJykucHJvcCgnZGlyJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZGlyID0gJ2x0cic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgJGUucHJvcCgnZGlzYWJsZWQnLCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQpO1xuICAgICRlLnByb3AoJ211bHRpcGxlJywgdGhpcy5vcHRpb25zLm11bHRpcGxlKTtcblxuICAgIGlmICgkZS5kYXRhKCdzZWxlY3QyVGFncycpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1NlbGVjdDI6IFRoZSBgZGF0YS1zZWxlY3QyLXRhZ3NgIGF0dHJpYnV0ZSBoYXMgYmVlbiBjaGFuZ2VkIHRvICcgK1xuICAgICAgICAgICd1c2UgdGhlIGBkYXRhLWRhdGFgIGFuZCBgZGF0YS10YWdzPVwidHJ1ZVwiYCBhdHRyaWJ1dGVzIGFuZCB3aWxsIGJlICcgK1xuICAgICAgICAgICdyZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBTZWxlY3QyLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgJGUuZGF0YSgnZGF0YScsICRlLmRhdGEoJ3NlbGVjdDJUYWdzJykpO1xuICAgICAgJGUuZGF0YSgndGFncycsIHRydWUpO1xuICAgIH1cblxuICAgIGlmICgkZS5kYXRhKCdhamF4VXJsJykpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnU2VsZWN0MjogVGhlIGBkYXRhLWFqYXgtdXJsYCBhdHRyaWJ1dGUgaGFzIGJlZW4gY2hhbmdlZCB0byAnICtcbiAgICAgICAgICAnYGRhdGEtYWpheC0tdXJsYCBhbmQgc3VwcG9ydCBmb3IgdGhlIG9sZCBhdHRyaWJ1dGUgd2lsbCBiZSByZW1vdmVkJyArXG4gICAgICAgICAgJyBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgU2VsZWN0Mi4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgICRlLmF0dHIoJ2FqYXgtLXVybCcsICRlLmRhdGEoJ2FqYXhVcmwnKSk7XG4gICAgICAkZS5kYXRhKCdhamF4LS11cmwnLCAkZS5kYXRhKCdhamF4VXJsJykpO1xuICAgIH1cblxuICAgIHZhciBkYXRhc2V0ID0ge307XG5cbiAgICAvLyBQcmVmZXIgdGhlIGVsZW1lbnQncyBgZGF0YXNldGAgYXR0cmlidXRlIGlmIGl0IGV4aXN0c1xuICAgIC8vIGpRdWVyeSAxLnggZG9lcyBub3QgY29ycmVjdGx5IGhhbmRsZSBkYXRhIGF0dHJpYnV0ZXMgd2l0aCBtdWx0aXBsZSBkYXNoZXNcbiAgICBpZiAoJC5mbi5qcXVlcnkgJiYgJC5mbi5qcXVlcnkuc3Vic3RyKDAsIDIpID09ICcxLicgJiYgJGVbMF0uZGF0YXNldCkge1xuICAgICAgZGF0YXNldCA9ICQuZXh0ZW5kKHRydWUsIHt9LCAkZVswXS5kYXRhc2V0LCAkZS5kYXRhKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhc2V0ID0gJGUuZGF0YSgpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gJC5leHRlbmQodHJ1ZSwge30sIGRhdGFzZXQpO1xuXG4gICAgZGF0YSA9IFV0aWxzLl9jb252ZXJ0RGF0YShkYXRhKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBpZiAoJC5pbkFycmF5KGtleSwgZXhjbHVkZWREYXRhKSA+IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KHRoaXMub3B0aW9uc1trZXldKSkge1xuICAgICAgICAkLmV4dGVuZCh0aGlzLm9wdGlvbnNba2V5XSwgZGF0YVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gZGF0YVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIE9wdGlvbnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zW2tleV07XG4gIH07XG5cbiAgT3B0aW9ucy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWw7XG4gIH07XG5cbiAgcmV0dXJuIE9wdGlvbnM7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2NvcmUnLFtcbiAgJ2pxdWVyeScsXG4gICcuL29wdGlvbnMnLFxuICAnLi91dGlscycsXG4gICcuL2tleXMnXG5dLCBmdW5jdGlvbiAoJCwgT3B0aW9ucywgVXRpbHMsIEtFWVMpIHtcbiAgdmFyIFNlbGVjdDIgPSBmdW5jdGlvbiAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAoJGVsZW1lbnQuZGF0YSgnc2VsZWN0MicpICE9IG51bGwpIHtcbiAgICAgICRlbGVtZW50LmRhdGEoJ3NlbGVjdDInKS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xuXG4gICAgdGhpcy5pZCA9IHRoaXMuX2dlbmVyYXRlSWQoJGVsZW1lbnQpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBuZXcgT3B0aW9ucyhvcHRpb25zLCAkZWxlbWVudCk7XG5cbiAgICBTZWxlY3QyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuXG4gICAgLy8gU2V0IHVwIHRoZSB0YWJpbmRleFxuXG4gICAgdmFyIHRhYmluZGV4ID0gJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnKSB8fCAwO1xuICAgICRlbGVtZW50LmRhdGEoJ29sZC10YWJpbmRleCcsIHRhYmluZGV4KTtcbiAgICAkZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsICctMScpO1xuXG4gICAgLy8gU2V0IHVwIGNvbnRhaW5lcnMgYW5kIGFkYXB0ZXJzXG5cbiAgICB2YXIgRGF0YUFkYXB0ZXIgPSB0aGlzLm9wdGlvbnMuZ2V0KCdkYXRhQWRhcHRlcicpO1xuICAgIHRoaXMuZGF0YUFkYXB0ZXIgPSBuZXcgRGF0YUFkYXB0ZXIoJGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG5cbiAgICB2YXIgJGNvbnRhaW5lciA9IHRoaXMucmVuZGVyKCk7XG5cbiAgICB0aGlzLl9wbGFjZUNvbnRhaW5lcigkY29udGFpbmVyKTtcblxuICAgIHZhciBTZWxlY3Rpb25BZGFwdGVyID0gdGhpcy5vcHRpb25zLmdldCgnc2VsZWN0aW9uQWRhcHRlcicpO1xuICAgIHRoaXMuc2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbkFkYXB0ZXIoJGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy4kc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24ucmVuZGVyKCk7XG5cbiAgICB0aGlzLnNlbGVjdGlvbi5wb3NpdGlvbih0aGlzLiRzZWxlY3Rpb24sICRjb250YWluZXIpO1xuXG4gICAgdmFyIERyb3Bkb3duQWRhcHRlciA9IHRoaXMub3B0aW9ucy5nZXQoJ2Ryb3Bkb3duQWRhcHRlcicpO1xuICAgIHRoaXMuZHJvcGRvd24gPSBuZXcgRHJvcGRvd25BZGFwdGVyKCRlbGVtZW50LCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuJGRyb3Bkb3duID0gdGhpcy5kcm9wZG93bi5yZW5kZXIoKTtcblxuICAgIHRoaXMuZHJvcGRvd24ucG9zaXRpb24odGhpcy4kZHJvcGRvd24sICRjb250YWluZXIpO1xuXG4gICAgdmFyIFJlc3VsdHNBZGFwdGVyID0gdGhpcy5vcHRpb25zLmdldCgncmVzdWx0c0FkYXB0ZXInKTtcbiAgICB0aGlzLnJlc3VsdHMgPSBuZXcgUmVzdWx0c0FkYXB0ZXIoJGVsZW1lbnQsIHRoaXMub3B0aW9ucywgdGhpcy5kYXRhQWRhcHRlcik7XG4gICAgdGhpcy4kcmVzdWx0cyA9IHRoaXMucmVzdWx0cy5yZW5kZXIoKTtcblxuICAgIHRoaXMucmVzdWx0cy5wb3NpdGlvbih0aGlzLiRyZXN1bHRzLCB0aGlzLiRkcm9wZG93bik7XG5cbiAgICAvLyBCaW5kIGV2ZW50c1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gQmluZCB0aGUgY29udGFpbmVyIHRvIGFsbCBvZiB0aGUgYWRhcHRlcnNcbiAgICB0aGlzLl9iaW5kQWRhcHRlcnMoKTtcblxuICAgIC8vIFJlZ2lzdGVyIGFueSBET00gZXZlbnQgaGFuZGxlcnNcbiAgICB0aGlzLl9yZWdpc3RlckRvbUV2ZW50cygpO1xuXG4gICAgLy8gUmVnaXN0ZXIgYW55IGludGVybmFsIGV2ZW50IGhhbmRsZXJzXG4gICAgdGhpcy5fcmVnaXN0ZXJEYXRhRXZlbnRzKCk7XG4gICAgdGhpcy5fcmVnaXN0ZXJTZWxlY3Rpb25FdmVudHMoKTtcbiAgICB0aGlzLl9yZWdpc3RlckRyb3Bkb3duRXZlbnRzKCk7XG4gICAgdGhpcy5fcmVnaXN0ZXJSZXN1bHRzRXZlbnRzKCk7XG4gICAgdGhpcy5fcmVnaXN0ZXJFdmVudHMoKTtcblxuICAgIC8vIFNldCB0aGUgaW5pdGlhbCBzdGF0ZVxuICAgIHRoaXMuZGF0YUFkYXB0ZXIuY3VycmVudChmdW5jdGlvbiAoaW5pdGlhbERhdGEpIHtcbiAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0aW9uOnVwZGF0ZScsIHtcbiAgICAgICAgZGF0YTogaW5pdGlhbERhdGFcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSGlkZSB0aGUgb3JpZ2luYWwgc2VsZWN0XG4gICAgJGVsZW1lbnQuYWRkQ2xhc3MoJ3NlbGVjdDItaGlkZGVuLWFjY2Vzc2libGUnKTtcbiAgICAkZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAvLyBTeW5jaHJvbml6ZSBhbnkgbW9uaXRvcmVkIGF0dHJpYnV0ZXNcbiAgICB0aGlzLl9zeW5jQXR0cmlidXRlcygpO1xuXG4gICAgJGVsZW1lbnQuZGF0YSgnc2VsZWN0MicsIHRoaXMpO1xuICB9O1xuXG4gIFV0aWxzLkV4dGVuZChTZWxlY3QyLCBVdGlscy5PYnNlcnZhYmxlKTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5fZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uICgkZWxlbWVudCkge1xuICAgIHZhciBpZCA9ICcnO1xuXG4gICAgaWYgKCRlbGVtZW50LmF0dHIoJ2lkJykgIT0gbnVsbCkge1xuICAgICAgaWQgPSAkZWxlbWVudC5hdHRyKCdpZCcpO1xuICAgIH0gZWxzZSBpZiAoJGVsZW1lbnQuYXR0cignbmFtZScpICE9IG51bGwpIHtcbiAgICAgIGlkID0gJGVsZW1lbnQuYXR0cignbmFtZScpICsgJy0nICsgVXRpbHMuZ2VuZXJhdGVDaGFycygyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWQgPSBVdGlscy5nZW5lcmF0ZUNoYXJzKDQpO1xuICAgIH1cblxuICAgIGlkID0gaWQucmVwbGFjZSgvKDp8XFwufFxcW3xcXF18LCkvZywgJycpO1xuICAgIGlkID0gJ3NlbGVjdDItJyArIGlkO1xuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLl9wbGFjZUNvbnRhaW5lciA9IGZ1bmN0aW9uICgkY29udGFpbmVyKSB7XG4gICAgJGNvbnRhaW5lci5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KTtcblxuICAgIHZhciB3aWR0aCA9IHRoaXMuX3Jlc29sdmVXaWR0aCh0aGlzLiRlbGVtZW50LCB0aGlzLm9wdGlvbnMuZ2V0KCd3aWR0aCcpKTtcblxuICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICAkY29udGFpbmVyLmNzcygnd2lkdGgnLCAnMTAwJScpO1xuICAgIH1cbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5fcmVzb2x2ZVdpZHRoID0gZnVuY3Rpb24gKCRlbGVtZW50LCBtZXRob2QpIHtcbiAgICB2YXIgV0lEVEggPSAvXndpZHRoOigoWy0rXT8oWzAtOV0qXFwuKT9bMC05XSspKHB4fGVtfGV4fCV8aW58Y218bW18cHR8cGMpKS9pO1xuXG4gICAgaWYgKG1ldGhvZCA9PSAncmVzb2x2ZScpIHtcbiAgICAgIHZhciBzdHlsZVdpZHRoID0gdGhpcy5fcmVzb2x2ZVdpZHRoKCRlbGVtZW50LCAnc3R5bGUnKTtcblxuICAgICAgaWYgKHN0eWxlV2lkdGggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3R5bGVXaWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVXaWR0aCgkZWxlbWVudCwgJ2VsZW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAobWV0aG9kID09ICdlbGVtZW50Jykge1xuICAgICAgdmFyIGVsZW1lbnRXaWR0aCA9ICRlbGVtZW50Lm91dGVyV2lkdGgoZmFsc2UpO1xuXG4gICAgICBpZiAoZWxlbWVudFdpZHRoIDw9IDApIHtcbiAgICAgICAgcmV0dXJuICdhdXRvJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnRXaWR0aCArICdweCc7XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCA9PSAnc3R5bGUnKSB7XG4gICAgICB2YXIgc3R5bGUgPSAkZWxlbWVudC5hdHRyKCdzdHlsZScpO1xuXG4gICAgICBpZiAodHlwZW9mKHN0eWxlKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRycyA9IHN0eWxlLnNwbGl0KCc7Jyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSA9IGkgKyAxKSB7XG4gICAgICAgIHZhciBhdHRyID0gYXR0cnNbaV0ucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBhdHRyLm1hdGNoKFdJRFRIKTtcblxuICAgICAgICBpZiAobWF0Y2hlcyAhPT0gbnVsbCAmJiBtYXRjaGVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5fYmluZEFkYXB0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGF0YUFkYXB0ZXIuYmluZCh0aGlzLCB0aGlzLiRjb250YWluZXIpO1xuICAgIHRoaXMuc2VsZWN0aW9uLmJpbmQodGhpcywgdGhpcy4kY29udGFpbmVyKTtcblxuICAgIHRoaXMuZHJvcGRvd24uYmluZCh0aGlzLCB0aGlzLiRjb250YWluZXIpO1xuICAgIHRoaXMucmVzdWx0cy5iaW5kKHRoaXMsIHRoaXMuJGNvbnRhaW5lcik7XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUuX3JlZ2lzdGVyRG9tRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuJGVsZW1lbnQub24oJ2NoYW5nZS5zZWxlY3QyJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5kYXRhQWRhcHRlci5jdXJyZW50KGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0aW9uOnVwZGF0ZScsIHtcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRlbGVtZW50Lm9uKCdmb2N1cy5zZWxlY3QyJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi50cmlnZ2VyKCdmb2N1cycsIGV2dCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zeW5jQSA9IFV0aWxzLmJpbmQodGhpcy5fc3luY0F0dHJpYnV0ZXMsIHRoaXMpO1xuICAgIHRoaXMuX3N5bmNTID0gVXRpbHMuYmluZCh0aGlzLl9zeW5jU3VidHJlZSwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy4kZWxlbWVudFswXS5hdHRhY2hFdmVudCkge1xuICAgICAgdGhpcy4kZWxlbWVudFswXS5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIHRoaXMuX3N5bmNBKTtcbiAgICB9XG5cbiAgICB2YXIgb2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fFxuICAgICAgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgfHxcbiAgICAgIHdpbmRvdy5Nb3pNdXRhdGlvbk9ic2VydmVyXG4gICAgO1xuXG4gICAgaWYgKG9ic2VydmVyICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IG9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcbiAgICAgICAgJC5lYWNoKG11dGF0aW9ucywgc2VsZi5fc3luY0EpO1xuICAgICAgICAkLmVhY2gobXV0YXRpb25zLCBzZWxmLl9zeW5jUyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy4kZWxlbWVudFswXSwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuJGVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGhpcy4kZWxlbWVudFswXS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAnRE9NQXR0ck1vZGlmaWVkJyxcbiAgICAgICAgc2VsZi5fc3luY0EsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgdGhpcy4kZWxlbWVudFswXS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAnRE9NTm9kZUluc2VydGVkJyxcbiAgICAgICAgc2VsZi5fc3luY1MsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgdGhpcy4kZWxlbWVudFswXS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAnRE9NTm9kZVJlbW92ZWQnLFxuICAgICAgICBzZWxmLl9zeW5jUyxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZWdpc3RlckRhdGFFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5kYXRhQWRhcHRlci5vbignKicsIGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcbiAgICAgIHNlbGYudHJpZ2dlcihuYW1lLCBwYXJhbXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZWdpc3RlclNlbGVjdGlvbkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG5vblJlbGF5RXZlbnRzID0gWyd0b2dnbGUnLCAnZm9jdXMnXTtcblxuICAgIHRoaXMuc2VsZWN0aW9uLm9uKCd0b2dnbGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnRvZ2dsZURyb3Bkb3duKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNlbGVjdGlvbi5vbignZm9jdXMnLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBzZWxmLmZvY3VzKHBhcmFtcyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNlbGVjdGlvbi5vbignKicsIGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcbiAgICAgIGlmICgkLmluQXJyYXkobmFtZSwgbm9uUmVsYXlFdmVudHMpICE9PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYudHJpZ2dlcihuYW1lLCBwYXJhbXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZWdpc3RlckRyb3Bkb3duRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuZHJvcGRvd24ub24oJyonLCBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XG4gICAgICBzZWxmLnRyaWdnZXIobmFtZSwgcGFyYW1zKTtcbiAgICB9KTtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5fcmVnaXN0ZXJSZXN1bHRzRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucmVzdWx0cy5vbignKicsIGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcbiAgICAgIHNlbGYudHJpZ2dlcihuYW1lLCBwYXJhbXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZWdpc3RlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLm9uKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi4kY29udGFpbmVyLmFkZENsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tb3BlbicpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLiRjb250YWluZXIucmVtb3ZlQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS1vcGVuJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdlbmFibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLiRjb250YWluZXIucmVtb3ZlQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS1kaXNhYmxlZCcpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignZGlzYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuJGNvbnRhaW5lci5hZGRDbGFzcygnc2VsZWN0Mi1jb250YWluZXItLWRpc2FibGVkJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdibHVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi4kY29udGFpbmVyLnJlbW92ZUNsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tZm9jdXMnKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ3F1ZXJ5JywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgaWYgKCFzZWxmLmlzT3BlbigpKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcignb3BlbicsIHt9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXRhQWRhcHRlci5xdWVyeShwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czphbGwnLCB7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBxdWVyeTogcGFyYW1zXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdxdWVyeTphcHBlbmQnLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICB0aGlzLmRhdGFBZGFwdGVyLnF1ZXJ5KHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdyZXN1bHRzOmFwcGVuZCcsIHtcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIHF1ZXJ5OiBwYXJhbXNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2tleXByZXNzJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgdmFyIGtleSA9IGV2dC53aGljaDtcblxuICAgICAgaWYgKHNlbGYuaXNPcGVuKCkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gS0VZUy5FU0MgfHwga2V5ID09PSBLRVlTLlRBQiB8fFxuICAgICAgICAgICAgKGtleSA9PT0gS0VZUy5VUCAmJiBldnQuYWx0S2V5KSkge1xuICAgICAgICAgIHNlbGYuY2xvc2UoKTtcblxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gS0VZUy5FTlRFUikge1xuICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czpzZWxlY3QnLCB7fSk7XG5cbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmICgoa2V5ID09PSBLRVlTLlNQQUNFICYmIGV2dC5jdHJsS2V5KSkge1xuICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czp0b2dnbGUnLCB7fSk7XG5cbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IEtFWVMuVVApIHtcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3Jlc3VsdHM6cHJldmlvdXMnLCB7fSk7XG5cbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IEtFWVMuRE9XTikge1xuICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czpuZXh0Jywge30pO1xuXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXkgPT09IEtFWVMuRU5URVIgfHwga2V5ID09PSBLRVlTLlNQQUNFIHx8XG4gICAgICAgICAgICAoa2V5ID09PSBLRVlTLkRPV04gJiYgZXZ0LmFsdEtleSkpIHtcbiAgICAgICAgICBzZWxmLm9wZW4oKTtcblxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUuX3N5bmNBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub3B0aW9ucy5zZXQoJ2Rpc2FibGVkJywgdGhpcy4kZWxlbWVudC5wcm9wKCdkaXNhYmxlZCcpKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2V0KCdkaXNhYmxlZCcpKSB7XG4gICAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlcignZGlzYWJsZScsIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmlnZ2VyKCdlbmFibGUnLCB7fSk7XG4gICAgfVxuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLl9zeW5jU3VidHJlZSA9IGZ1bmN0aW9uIChldnQsIG11dGF0aW9ucykge1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gSWdub3JlIGFueSBtdXRhdGlvbiBldmVudHMgcmFpc2VkIGZvciBlbGVtZW50cyB0aGF0IGFyZW4ndCBvcHRpb25zIG9yXG4gICAgLy8gb3B0Z3JvdXBzLiBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugd2hlbiB0aGUgc2VsZWN0IGVsZW1lbnQgaXMgZGVzdHJveWVkXG4gICAgaWYgKFxuICAgICAgZXZ0ICYmIGV2dC50YXJnZXQgJiYgKFxuICAgICAgICBldnQudGFyZ2V0Lm5vZGVOYW1lICE9PSAnT1BUSU9OJyAmJiBldnQudGFyZ2V0Lm5vZGVOYW1lICE9PSAnT1BUR1JPVVAnXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFtdXRhdGlvbnMpIHtcbiAgICAgIC8vIElmIG11dGF0aW9uIGV2ZW50cyBhcmVuJ3Qgc3VwcG9ydGVkLCB0aGVuIHdlIGNhbiBvbmx5IGFzc3VtZSB0aGF0IHRoZVxuICAgICAgLy8gY2hhbmdlIGFmZmVjdGVkIHRoZSBzZWxlY3Rpb25zXG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG11dGF0aW9ucy5hZGRlZE5vZGVzICYmIG11dGF0aW9ucy5hZGRlZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbXV0YXRpb25zLmFkZGVkTm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBtdXRhdGlvbnMuYWRkZWROb2Rlc1tuXTtcblxuICAgICAgICBpZiAobm9kZS5zZWxlY3RlZCkge1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtdXRhdGlvbnMucmVtb3ZlZE5vZGVzICYmIG11dGF0aW9ucy5yZW1vdmVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gT25seSByZS1wdWxsIHRoZSBkYXRhIGlmIHdlIHRoaW5rIHRoZXJlIGlzIGEgY2hhbmdlXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZGF0YUFkYXB0ZXIuY3VycmVudChmdW5jdGlvbiAoY3VycmVudERhdGEpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3Rpb246dXBkYXRlJywge1xuICAgICAgICAgIGRhdGE6IGN1cnJlbnREYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgdHJpZ2dlciBtZXRob2QgdG8gYXV0b21hdGljYWxseSB0cmlnZ2VyIHByZS1ldmVudHMgd2hlblxuICAgKiB0aGVyZSBhcmUgZXZlbnRzIHRoYXQgY2FuIGJlIHByZXZlbnRlZC5cbiAgICovXG4gIFNlbGVjdDIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHZhciBhY3R1YWxUcmlnZ2VyID0gU2VsZWN0Mi5fX3N1cGVyX18udHJpZ2dlcjtcbiAgICB2YXIgcHJlVHJpZ2dlck1hcCA9IHtcbiAgICAgICdvcGVuJzogJ29wZW5pbmcnLFxuICAgICAgJ2Nsb3NlJzogJ2Nsb3NpbmcnLFxuICAgICAgJ3NlbGVjdCc6ICdzZWxlY3RpbmcnLFxuICAgICAgJ3Vuc2VsZWN0JzogJ3Vuc2VsZWN0aW5nJ1xuICAgIH07XG5cbiAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhcmdzID0ge307XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgaW4gcHJlVHJpZ2dlck1hcCkge1xuICAgICAgdmFyIHByZVRyaWdnZXJOYW1lID0gcHJlVHJpZ2dlck1hcFtuYW1lXTtcbiAgICAgIHZhciBwcmVUcmlnZ2VyQXJncyA9IHtcbiAgICAgICAgcHJldmVudGVkOiBmYWxzZSxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgYXJnczogYXJnc1xuICAgICAgfTtcblxuICAgICAgYWN0dWFsVHJpZ2dlci5jYWxsKHRoaXMsIHByZVRyaWdnZXJOYW1lLCBwcmVUcmlnZ2VyQXJncyk7XG5cbiAgICAgIGlmIChwcmVUcmlnZ2VyQXJncy5wcmV2ZW50ZWQpIHtcbiAgICAgICAgYXJncy5wcmV2ZW50ZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhY3R1YWxUcmlnZ2VyLmNhbGwodGhpcywgbmFtZSwgYXJncyk7XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUudG9nZ2xlRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5nZXQoJ2Rpc2FibGVkJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcigncXVlcnknLCB7fSk7XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzT3BlbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKCdjbG9zZScsIHt9KTtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRhaW5lci5oYXNDbGFzcygnc2VsZWN0Mi1jb250YWluZXItLW9wZW4nKTtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5oYXNGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGFpbmVyLmhhc0NsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tZm9jdXMnKTtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLy8gTm8gbmVlZCB0byByZS10cmlnZ2VyIGZvY3VzIGV2ZW50cyBpZiB3ZSBhcmUgYWxyZWFkeSBmb2N1c2VkXG4gICAgaWYgKHRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcygnc2VsZWN0Mi1jb250YWluZXItLWZvY3VzJyk7XG4gICAgdGhpcy50cmlnZ2VyKCdmb2N1cycsIHt9KTtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2V0KCdkZWJ1ZycpICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnU2VsZWN0MjogVGhlIGBzZWxlY3QyKFwiZW5hYmxlXCIpYCBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCcgK1xuICAgICAgICAnIGJlIHJlbW92ZWQgaW4gbGF0ZXIgU2VsZWN0MiB2ZXJzaW9ucy4gVXNlICRlbGVtZW50LnByb3AoXCJkaXNhYmxlZFwiKScgK1xuICAgICAgICAnIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncyA9PSBudWxsIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBhcmdzID0gW3RydWVdO1xuICAgIH1cblxuICAgIHZhciBkaXNhYmxlZCA9ICFhcmdzWzBdO1xuXG4gICAgdGhpcy4kZWxlbWVudC5wcm9wKCdkaXNhYmxlZCcsIGRpc2FibGVkKTtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2V0KCdkZWJ1ZycpICYmXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnU2VsZWN0MjogRGF0YSBjYW4gbm8gbG9uZ2VyIGJlIHNldCB1c2luZyBgc2VsZWN0MihcImRhdGFcIilgLiBZb3UgJyArXG4gICAgICAgICdzaG91bGQgY29uc2lkZXIgc2V0dGluZyB0aGUgdmFsdWUgaW5zdGVhZCB1c2luZyBgJGVsZW1lbnQudmFsKClgLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSBbXTtcblxuICAgIHRoaXMuZGF0YUFkYXB0ZXIuY3VycmVudChmdW5jdGlvbiAoY3VycmVudERhdGEpIHtcbiAgICAgIGRhdGEgPSBjdXJyZW50RGF0YTtcbiAgICB9KTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5nZXQoJ2RlYnVnJykgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdTZWxlY3QyOiBUaGUgYHNlbGVjdDIoXCJ2YWxcIilgIG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlJyArXG4gICAgICAgICcgcmVtb3ZlZCBpbiBsYXRlciBTZWxlY3QyIHZlcnNpb25zLiBVc2UgJGVsZW1lbnQudmFsKCkgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChhcmdzID09IG51bGwgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50LnZhbCgpO1xuICAgIH1cblxuICAgIHZhciBuZXdWYWwgPSBhcmdzWzBdO1xuXG4gICAgaWYgKCQuaXNBcnJheShuZXdWYWwpKSB7XG4gICAgICBuZXdWYWwgPSAkLm1hcChuZXdWYWwsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC52YWwobmV3VmFsKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmUoKTtcblxuICAgIGlmICh0aGlzLiRlbGVtZW50WzBdLmRldGFjaEV2ZW50KSB7XG4gICAgICB0aGlzLiRlbGVtZW50WzBdLmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgdGhpcy5fc3luY0EpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vYnNlcnZlciAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0aGlzLiRlbGVtZW50WzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRbMF1cbiAgICAgICAgLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUF0dHJNb2RpZmllZCcsIHRoaXMuX3N5bmNBLCBmYWxzZSk7XG4gICAgICB0aGlzLiRlbGVtZW50WzBdXG4gICAgICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCB0aGlzLl9zeW5jUywgZmFsc2UpO1xuICAgICAgdGhpcy4kZWxlbWVudFswXVxuICAgICAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTm9kZVJlbW92ZWQnLCB0aGlzLl9zeW5jUywgZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMuX3N5bmNBID0gbnVsbDtcbiAgICB0aGlzLl9zeW5jUyA9IG51bGw7XG5cbiAgICB0aGlzLiRlbGVtZW50Lm9mZignLnNlbGVjdDInKTtcbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgdGhpcy4kZWxlbWVudC5kYXRhKCdvbGQtdGFiaW5kZXgnKSk7XG5cbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdzZWxlY3QyLWhpZGRlbi1hY2Nlc3NpYmxlJyk7XG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnc2VsZWN0MicpO1xuXG4gICAgdGhpcy5kYXRhQWRhcHRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5zZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgIHRoaXMuZHJvcGRvd24uZGVzdHJveSgpO1xuICAgIHRoaXMucmVzdWx0cy5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmRhdGFBZGFwdGVyID0gbnVsbDtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5kcm9wZG93biA9IG51bGw7XG4gICAgdGhpcy5yZXN1bHRzID0gbnVsbDtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRjb250YWluZXIgPSAkKFxuICAgICAgJzxzcGFuIGNsYXNzPVwic2VsZWN0MiBzZWxlY3QyLWNvbnRhaW5lclwiPicgK1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWxlY3Rpb25cIj48L3NwYW4+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImRyb3Bkb3duLXdyYXBwZXJcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+JyArXG4gICAgICAnPC9zcGFuPidcbiAgICApO1xuXG4gICAgJGNvbnRhaW5lci5hdHRyKCdkaXInLCB0aGlzLm9wdGlvbnMuZ2V0KCdkaXInKSk7XG5cbiAgICB0aGlzLiRjb250YWluZXIgPSAkY29udGFpbmVyO1xuXG4gICAgdGhpcy4kY29udGFpbmVyLmFkZENsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tJyArIHRoaXMub3B0aW9ucy5nZXQoJ3RoZW1lJykpO1xuXG4gICAgJGNvbnRhaW5lci5kYXRhKCdlbGVtZW50JywgdGhpcy4kZWxlbWVudCk7XG5cbiAgICByZXR1cm4gJGNvbnRhaW5lcjtcbiAgfTtcblxuICByZXR1cm4gU2VsZWN0Mjtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvY29tcGF0L3V0aWxzJyxbXG4gICdqcXVlcnknXG5dLCBmdW5jdGlvbiAoJCkge1xuICBmdW5jdGlvbiBzeW5jQ3NzQ2xhc3NlcyAoJGRlc3QsICRzcmMsIGFkYXB0ZXIpIHtcbiAgICB2YXIgY2xhc3NlcywgcmVwbGFjZW1lbnRzID0gW10sIGFkYXB0ZWQ7XG5cbiAgICBjbGFzc2VzID0gJC50cmltKCRkZXN0LmF0dHIoJ2NsYXNzJykpO1xuXG4gICAgaWYgKGNsYXNzZXMpIHtcbiAgICAgIGNsYXNzZXMgPSAnJyArIGNsYXNzZXM7IC8vIGZvciBJRSB3aGljaCByZXR1cm5zIG9iamVjdFxuXG4gICAgICAkKGNsYXNzZXMuc3BsaXQoL1xccysvKSkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFNhdmUgYWxsIFNlbGVjdDIgY2xhc3Nlc1xuICAgICAgICBpZiAodGhpcy5pbmRleE9mKCdzZWxlY3QyLScpID09PSAwKSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnRzLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsYXNzZXMgPSAkLnRyaW0oJHNyYy5hdHRyKCdjbGFzcycpKTtcblxuICAgIGlmIChjbGFzc2VzKSB7XG4gICAgICBjbGFzc2VzID0gJycgKyBjbGFzc2VzOyAvLyBmb3IgSUUgd2hpY2ggcmV0dXJucyBvYmplY3RcblxuICAgICAgJChjbGFzc2VzLnNwbGl0KC9cXHMrLykpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBPbmx5IGFkYXB0IG5vbi1TZWxlY3QyIGNsYXNzZXNcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhPZignc2VsZWN0Mi0nKSAhPT0gMCkge1xuICAgICAgICAgIGFkYXB0ZWQgPSBhZGFwdGVyKHRoaXMpO1xuXG4gICAgICAgICAgaWYgKGFkYXB0ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnRzLnB1c2goYWRhcHRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAkZGVzdC5hdHRyKCdjbGFzcycsIHJlcGxhY2VtZW50cy5qb2luKCcgJykpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzeW5jQ3NzQ2xhc3Nlczogc3luY0Nzc0NsYXNzZXNcbiAgfTtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvY29tcGF0L2NvbnRhaW5lckNzcycsW1xuICAnanF1ZXJ5JyxcbiAgJy4vdXRpbHMnXG5dLCBmdW5jdGlvbiAoJCwgQ29tcGF0VXRpbHMpIHtcbiAgLy8gTm8tb3AgQ1NTIGFkYXB0ZXIgdGhhdCBkaXNjYXJkcyBhbGwgY2xhc3NlcyBieSBkZWZhdWx0XG4gIGZ1bmN0aW9uIF9jb250YWluZXJBZGFwdGVyIChjbGF6eikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGFpbmVyQ1NTICgpIHsgfVxuXG4gIENvbnRhaW5lckNTUy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGRlY29yYXRlZCkge1xuICAgIHZhciAkY29udGFpbmVyID0gZGVjb3JhdGVkLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgY29udGFpbmVyQ3NzQ2xhc3MgPSB0aGlzLm9wdGlvbnMuZ2V0KCdjb250YWluZXJDc3NDbGFzcycpIHx8ICcnO1xuXG4gICAgaWYgKCQuaXNGdW5jdGlvbihjb250YWluZXJDc3NDbGFzcykpIHtcbiAgICAgIGNvbnRhaW5lckNzc0NsYXNzID0gY29udGFpbmVyQ3NzQ2xhc3ModGhpcy4kZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRhaW5lckNzc0FkYXB0ZXIgPSB0aGlzLm9wdGlvbnMuZ2V0KCdhZGFwdENvbnRhaW5lckNzc0NsYXNzJyk7XG4gICAgY29udGFpbmVyQ3NzQWRhcHRlciA9IGNvbnRhaW5lckNzc0FkYXB0ZXIgfHwgX2NvbnRhaW5lckFkYXB0ZXI7XG5cbiAgICBpZiAoY29udGFpbmVyQ3NzQ2xhc3MuaW5kZXhPZignOmFsbDonKSAhPT0gLTEpIHtcbiAgICAgIGNvbnRhaW5lckNzc0NsYXNzID0gY29udGFpbmVyQ3NzQ2xhc3MucmVwbGFjZSgnOmFsbDonLCAnJyk7XG5cbiAgICAgIHZhciBfY3NzQWRhcHRlciA9IGNvbnRhaW5lckNzc0FkYXB0ZXI7XG5cbiAgICAgIGNvbnRhaW5lckNzc0FkYXB0ZXIgPSBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgdmFyIGFkYXB0ZWQgPSBfY3NzQWRhcHRlcihjbGF6eik7XG5cbiAgICAgICAgaWYgKGFkYXB0ZWQgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIEFwcGVuZCB0aGUgb2xkIG9uZSBhbG9uZyB3aXRoIHRoZSBhZGFwdGVkIG9uZVxuICAgICAgICAgIHJldHVybiBhZGFwdGVkICsgJyAnICsgY2xheno7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xheno7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXJDc3MgPSB0aGlzLm9wdGlvbnMuZ2V0KCdjb250YWluZXJDc3MnKSB8fCB7fTtcblxuICAgIGlmICgkLmlzRnVuY3Rpb24oY29udGFpbmVyQ3NzKSkge1xuICAgICAgY29udGFpbmVyQ3NzID0gY29udGFpbmVyQ3NzKHRoaXMuJGVsZW1lbnQpO1xuICAgIH1cblxuICAgIENvbXBhdFV0aWxzLnN5bmNDc3NDbGFzc2VzKCRjb250YWluZXIsIHRoaXMuJGVsZW1lbnQsIGNvbnRhaW5lckNzc0FkYXB0ZXIpO1xuXG4gICAgJGNvbnRhaW5lci5jc3MoY29udGFpbmVyQ3NzKTtcbiAgICAkY29udGFpbmVyLmFkZENsYXNzKGNvbnRhaW5lckNzc0NsYXNzKTtcblxuICAgIHJldHVybiAkY29udGFpbmVyO1xuICB9O1xuXG4gIHJldHVybiBDb250YWluZXJDU1M7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2NvbXBhdC9kcm9wZG93bkNzcycsW1xuICAnanF1ZXJ5JyxcbiAgJy4vdXRpbHMnXG5dLCBmdW5jdGlvbiAoJCwgQ29tcGF0VXRpbHMpIHtcbiAgLy8gTm8tb3AgQ1NTIGFkYXB0ZXIgdGhhdCBkaXNjYXJkcyBhbGwgY2xhc3NlcyBieSBkZWZhdWx0XG4gIGZ1bmN0aW9uIF9kcm9wZG93bkFkYXB0ZXIgKGNsYXp6KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBEcm9wZG93bkNTUyAoKSB7IH1cblxuICBEcm9wZG93bkNTUy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGRlY29yYXRlZCkge1xuICAgIHZhciAkZHJvcGRvd24gPSBkZWNvcmF0ZWQuY2FsbCh0aGlzKTtcblxuICAgIHZhciBkcm9wZG93bkNzc0NsYXNzID0gdGhpcy5vcHRpb25zLmdldCgnZHJvcGRvd25Dc3NDbGFzcycpIHx8ICcnO1xuXG4gICAgaWYgKCQuaXNGdW5jdGlvbihkcm9wZG93bkNzc0NsYXNzKSkge1xuICAgICAgZHJvcGRvd25Dc3NDbGFzcyA9IGRyb3Bkb3duQ3NzQ2xhc3ModGhpcy4kZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdmFyIGRyb3Bkb3duQ3NzQWRhcHRlciA9IHRoaXMub3B0aW9ucy5nZXQoJ2FkYXB0RHJvcGRvd25Dc3NDbGFzcycpO1xuICAgIGRyb3Bkb3duQ3NzQWRhcHRlciA9IGRyb3Bkb3duQ3NzQWRhcHRlciB8fCBfZHJvcGRvd25BZGFwdGVyO1xuXG4gICAgaWYgKGRyb3Bkb3duQ3NzQ2xhc3MuaW5kZXhPZignOmFsbDonKSAhPT0gLTEpIHtcbiAgICAgIGRyb3Bkb3duQ3NzQ2xhc3MgPSBkcm9wZG93bkNzc0NsYXNzLnJlcGxhY2UoJzphbGw6JywgJycpO1xuXG4gICAgICB2YXIgX2Nzc0FkYXB0ZXIgPSBkcm9wZG93bkNzc0FkYXB0ZXI7XG5cbiAgICAgIGRyb3Bkb3duQ3NzQWRhcHRlciA9IGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICB2YXIgYWRhcHRlZCA9IF9jc3NBZGFwdGVyKGNsYXp6KTtcblxuICAgICAgICBpZiAoYWRhcHRlZCAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQXBwZW5kIHRoZSBvbGQgb25lIGFsb25nIHdpdGggdGhlIGFkYXB0ZWQgb25lXG4gICAgICAgICAgcmV0dXJuIGFkYXB0ZWQgKyAnICcgKyBjbGF6ejtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGF6ejtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRyb3Bkb3duQ3NzID0gdGhpcy5vcHRpb25zLmdldCgnZHJvcGRvd25Dc3MnKSB8fCB7fTtcblxuICAgIGlmICgkLmlzRnVuY3Rpb24oZHJvcGRvd25Dc3MpKSB7XG4gICAgICBkcm9wZG93bkNzcyA9IGRyb3Bkb3duQ3NzKHRoaXMuJGVsZW1lbnQpO1xuICAgIH1cblxuICAgIENvbXBhdFV0aWxzLnN5bmNDc3NDbGFzc2VzKCRkcm9wZG93biwgdGhpcy4kZWxlbWVudCwgZHJvcGRvd25Dc3NBZGFwdGVyKTtcblxuICAgICRkcm9wZG93bi5jc3MoZHJvcGRvd25Dc3MpO1xuICAgICRkcm9wZG93bi5hZGRDbGFzcyhkcm9wZG93bkNzc0NsYXNzKTtcblxuICAgIHJldHVybiAkZHJvcGRvd247XG4gIH07XG5cbiAgcmV0dXJuIERyb3Bkb3duQ1NTO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9jb21wYXQvaW5pdFNlbGVjdGlvbicsW1xuICAnanF1ZXJ5J1xuXSwgZnVuY3Rpb24gKCQpIHtcbiAgZnVuY3Rpb24gSW5pdFNlbGVjdGlvbiAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmdldCgnZGVidWcnKSAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1NlbGVjdDI6IFRoZSBgaW5pdFNlbGVjdGlvbmAgb3B0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3InICtcbiAgICAgICAgJyBvZiBhIGN1c3RvbSBkYXRhIGFkYXB0ZXIgdGhhdCBvdmVycmlkZXMgdGhlIGBjdXJyZW50YCBtZXRob2QuICcgK1xuICAgICAgICAnVGhpcyBtZXRob2QgaXMgbm93IGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbnN0ZWFkIG9mIGEgc2luZ2xlICcgK1xuICAgICAgICAndGltZSB3aGVuIHRoZSBpbnN0YW5jZSBpcyBpbml0aWFsaXplZC4gU3VwcG9ydCB3aWxsIGJlIHJlbW92ZWQgJyArXG4gICAgICAgICdmb3IgdGhlIGBpbml0U2VsZWN0aW9uYCBvcHRpb24gaW4gZnV0dXJlIHZlcnNpb25zIG9mIFNlbGVjdDInXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFNlbGVjdGlvbiA9IG9wdGlvbnMuZ2V0KCdpbml0U2VsZWN0aW9uJyk7XG4gICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgSW5pdFNlbGVjdGlvbi5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNhbGxiYWNrKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFNlbGVjdGlvbi5jYWxsKG51bGwsIHRoaXMuJGVsZW1lbnQsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBzZWxmLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgaWYgKCEkLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEluaXRTZWxlY3Rpb247XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2NvbXBhdC9pbnB1dERhdGEnLFtcbiAgJ2pxdWVyeSdcbl0sIGZ1bmN0aW9uICgkKSB7XG4gIGZ1bmN0aW9uIElucHV0RGF0YSAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuX2N1cnJlbnREYXRhID0gW107XG4gICAgdGhpcy5fdmFsdWVTZXBhcmF0b3IgPSBvcHRpb25zLmdldCgndmFsdWVTZXBhcmF0b3InKSB8fCAnLCc7XG5cbiAgICBpZiAoJGVsZW1lbnQucHJvcCgndHlwZScpID09PSAnaGlkZGVuJykge1xuICAgICAgaWYgKG9wdGlvbnMuZ2V0KCdkZWJ1ZycpICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnU2VsZWN0MjogVXNpbmcgYSBoaWRkZW4gaW5wdXQgd2l0aCBTZWxlY3QyIGlzIG5vIGxvbmdlciAnICtcbiAgICAgICAgICAnc3VwcG9ydGVkIGFuZCBtYXkgc3RvcCB3b3JraW5nIGluIHRoZSBmdXR1cmUuIEl0IGlzIHJlY29tbWVuZGVkICcgK1xuICAgICAgICAgICd0byB1c2UgYSBgPHNlbGVjdD5gIGVsZW1lbnQgaW5zdGVhZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgSW5wdXREYXRhLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKF8sIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gZ2V0U2VsZWN0ZWQgKGRhdGEsIHNlbGVjdGVkSWRzKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBbXTtcblxuICAgICAgaWYgKGRhdGEuc2VsZWN0ZWQgfHwgJC5pbkFycmF5KGRhdGEuaWQsIHNlbGVjdGVkSWRzKSAhPT0gLTEpIHtcbiAgICAgICAgZGF0YS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHNlbGVjdGVkLnB1c2goZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmNoaWxkcmVuKSB7XG4gICAgICAgIHNlbGVjdGVkLnB1c2guYXBwbHkoc2VsZWN0ZWQsIGdldFNlbGVjdGVkKGRhdGEuY2hpbGRyZW4sIHNlbGVjdGVkSWRzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ZWQgPSBbXTtcblxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgdGhpcy5fY3VycmVudERhdGEubGVuZ3RoOyBkKyspIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fY3VycmVudERhdGFbZF07XG5cbiAgICAgIHNlbGVjdGVkLnB1c2guYXBwbHkoXG4gICAgICAgIHNlbGVjdGVkLFxuICAgICAgICBnZXRTZWxlY3RlZChcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudmFsKCkuc3BsaXQoXG4gICAgICAgICAgICB0aGlzLl92YWx1ZVNlcGFyYXRvclxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhzZWxlY3RlZCk7XG4gIH07XG5cbiAgSW5wdXREYXRhLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoXywgZGF0YSkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmdldCgnbXVsdGlwbGUnKSkge1xuICAgICAgdGhpcy5jdXJyZW50KGZ1bmN0aW9uIChhbGxEYXRhKSB7XG4gICAgICAgICQubWFwKGFsbERhdGEsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgZGF0YS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnZhbChkYXRhLmlkKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuJGVsZW1lbnQudmFsKCk7XG4gICAgICB2YWx1ZSArPSB0aGlzLl92YWx1ZVNlcGFyYXRvciArIGRhdGEuaWQ7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudmFsKHZhbHVlKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfVxuICB9O1xuXG4gIElucHV0RGF0YS5wcm90b3R5cGUudW5zZWxlY3QgPSBmdW5jdGlvbiAoXywgZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGRhdGEuc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuY3VycmVudChmdW5jdGlvbiAoYWxsRGF0YSkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGFsbERhdGEubGVuZ3RoOyBkKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBhbGxEYXRhW2RdO1xuXG4gICAgICAgIGlmIChkYXRhLmlkID09IGl0ZW0uaWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlcy5wdXNoKGl0ZW0uaWQpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRlbGVtZW50LnZhbCh2YWx1ZXMuam9pbihzZWxmLl92YWx1ZVNlcGFyYXRvcikpO1xuICAgICAgc2VsZi4kZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9KTtcbiAgfTtcblxuICBJbnB1dERhdGEucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKF8sIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCB0aGlzLl9jdXJyZW50RGF0YS5sZW5ndGg7IGQrKykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9jdXJyZW50RGF0YVtkXTtcblxuICAgICAgdmFyIG1hdGNoZXMgPSB0aGlzLm1hdGNoZXMocGFyYW1zLCBkYXRhKTtcblxuICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG1hdGNoZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrKHtcbiAgICAgIHJlc3VsdHM6IHJlc3VsdHNcbiAgICB9KTtcbiAgfTtcblxuICBJbnB1dERhdGEucHJvdG90eXBlLmFkZE9wdGlvbnMgPSBmdW5jdGlvbiAoXywgJG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9ICQubWFwKCRvcHRpb25zLCBmdW5jdGlvbiAoJG9wdGlvbikge1xuICAgICAgcmV0dXJuICQuZGF0YSgkb3B0aW9uWzBdLCAnZGF0YScpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fY3VycmVudERhdGEucHVzaC5hcHBseSh0aGlzLl9jdXJyZW50RGF0YSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIElucHV0RGF0YTtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvY29tcGF0L21hdGNoZXInLFtcbiAgJ2pxdWVyeSdcbl0sIGZ1bmN0aW9uICgkKSB7XG4gIGZ1bmN0aW9uIG9sZE1hdGNoZXIgKG1hdGNoZXIpIHtcbiAgICBmdW5jdGlvbiB3cmFwcGVkTWF0Y2hlciAocGFyYW1zLCBkYXRhKSB7XG4gICAgICB2YXIgbWF0Y2ggPSAkLmV4dGVuZCh0cnVlLCB7fSwgZGF0YSk7XG5cbiAgICAgIGlmIChwYXJhbXMudGVybSA9PSBudWxsIHx8ICQudHJpbShwYXJhbXMudGVybSkgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IGRhdGEuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgYyA+PSAwOyBjLS0pIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBkYXRhLmNoaWxkcmVuW2NdO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkIG9iamVjdCBtYXRjaGVzXG4gICAgICAgICAgLy8gVGhlIG9sZCBtYXRjaGVyIHJldHVybmVkIGEgYm9vbGVhbiB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAgdmFyIGRvZXNNYXRjaCA9IG1hdGNoZXIocGFyYW1zLnRlcm0sIGNoaWxkLnRleHQsIGNoaWxkKTtcblxuICAgICAgICAgIC8vIElmIHRoZSBjaGlsZCBkaWRuJ3QgbWF0Y2gsIHBvcCBpdCBvZmZcbiAgICAgICAgICBpZiAoIWRvZXNNYXRjaCkge1xuICAgICAgICAgICAgbWF0Y2guY2hpbGRyZW4uc3BsaWNlKGMsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaGVyKHBhcmFtcy50ZXJtLCBkYXRhLnRleHQsIGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBwZWRNYXRjaGVyO1xuICB9XG5cbiAgcmV0dXJuIG9sZE1hdGNoZXI7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2NvbXBhdC9xdWVyeScsW1xuXG5dLCBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFF1ZXJ5IChkZWNvcmF0ZWQsICRlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZ2V0KCdkZWJ1ZycpICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnU2VsZWN0MjogVGhlIGBxdWVyeWAgb3B0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYSAnICtcbiAgICAgICAgJ2N1c3RvbSBkYXRhIGFkYXB0ZXIgdGhhdCBvdmVycmlkZXMgdGhlIGBxdWVyeWAgbWV0aG9kLiBTdXBwb3J0ICcgK1xuICAgICAgICAnd2lsbCBiZSByZW1vdmVkIGZvciB0aGUgYHF1ZXJ5YCBvcHRpb24gaW4gZnV0dXJlIHZlcnNpb25zIG9mICcgK1xuICAgICAgICAnU2VsZWN0Mi4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zKTtcbiAgfVxuXG4gIFF1ZXJ5LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChfLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgcGFyYW1zLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICB2YXIgcXVlcnkgPSB0aGlzLm9wdGlvbnMuZ2V0KCdxdWVyeScpO1xuXG4gICAgcXVlcnkuY2FsbChudWxsLCBwYXJhbXMpO1xuICB9O1xuXG4gIHJldHVybiBRdWVyeTtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZHJvcGRvd24vYXR0YWNoQ29udGFpbmVyJyxbXG5cbl0sIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXR0YWNoQ29udGFpbmVyIChkZWNvcmF0ZWQsICRlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgQXR0YWNoQ29udGFpbmVyLnByb3RvdHlwZS5wb3NpdGlvbiA9XG4gICAgZnVuY3Rpb24gKGRlY29yYXRlZCwgJGRyb3Bkb3duLCAkY29udGFpbmVyKSB7XG4gICAgdmFyICRkcm9wZG93bkNvbnRhaW5lciA9ICRjb250YWluZXIuZmluZCgnLmRyb3Bkb3duLXdyYXBwZXInKTtcbiAgICAkZHJvcGRvd25Db250YWluZXIuYXBwZW5kKCRkcm9wZG93bik7XG5cbiAgICAkZHJvcGRvd24uYWRkQ2xhc3MoJ3NlbGVjdDItZHJvcGRvd24tLWJlbG93Jyk7XG4gICAgJGNvbnRhaW5lci5hZGRDbGFzcygnc2VsZWN0Mi1jb250YWluZXItLWJlbG93Jyk7XG4gIH07XG5cbiAgcmV0dXJuIEF0dGFjaENvbnRhaW5lcjtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZHJvcGRvd24vc3RvcFByb3BhZ2F0aW9uJyxbXG5cbl0sIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RvcFByb3BhZ2F0aW9uICgpIHsgfVxuXG4gIFN0b3BQcm9wYWdhdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XG5cbiAgICB2YXIgc3RvcHBlZEV2ZW50cyA9IFtcbiAgICAnYmx1cicsXG4gICAgJ2NoYW5nZScsXG4gICAgJ2NsaWNrJyxcbiAgICAnZGJsY2xpY2snLFxuICAgICdmb2N1cycsXG4gICAgJ2ZvY3VzaW4nLFxuICAgICdmb2N1c291dCcsXG4gICAgJ2lucHV0JyxcbiAgICAna2V5ZG93bicsXG4gICAgJ2tleXVwJyxcbiAgICAna2V5cHJlc3MnLFxuICAgICdtb3VzZWRvd24nLFxuICAgICdtb3VzZWVudGVyJyxcbiAgICAnbW91c2VsZWF2ZScsXG4gICAgJ21vdXNlbW92ZScsXG4gICAgJ21vdXNlb3ZlcicsXG4gICAgJ21vdXNldXAnLFxuICAgICdzZWFyY2gnLFxuICAgICd0b3VjaGVuZCcsXG4gICAgJ3RvdWNoc3RhcnQnXG4gICAgXTtcblxuICAgIHRoaXMuJGRyb3Bkb3duLm9uKHN0b3BwZWRFdmVudHMuam9pbignICcpLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFN0b3BQcm9wYWdhdGlvbjtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvc2VsZWN0aW9uL3N0b3BQcm9wYWdhdGlvbicsW1xuXG5dLCBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0b3BQcm9wYWdhdGlvbiAoKSB7IH1cblxuICBTdG9wUHJvcGFnYXRpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIsICRjb250YWluZXIpIHtcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xuXG4gICAgdmFyIHN0b3BwZWRFdmVudHMgPSBbXG4gICAgICAnYmx1cicsXG4gICAgICAnY2hhbmdlJyxcbiAgICAgICdjbGljaycsXG4gICAgICAnZGJsY2xpY2snLFxuICAgICAgJ2ZvY3VzJyxcbiAgICAgICdmb2N1c2luJyxcbiAgICAgICdmb2N1c291dCcsXG4gICAgICAnaW5wdXQnLFxuICAgICAgJ2tleWRvd24nLFxuICAgICAgJ2tleXVwJyxcbiAgICAgICdrZXlwcmVzcycsXG4gICAgICAnbW91c2Vkb3duJyxcbiAgICAgICdtb3VzZWVudGVyJyxcbiAgICAgICdtb3VzZWxlYXZlJyxcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3ZlcicsXG4gICAgICAnbW91c2V1cCcsXG4gICAgICAnc2VhcmNoJyxcbiAgICAgICd0b3VjaGVuZCcsXG4gICAgICAndG91Y2hzdGFydCdcbiAgICBdO1xuXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKHN0b3BwZWRFdmVudHMuam9pbignICcpLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFN0b3BQcm9wYWdhdGlvbjtcbn0pO1xuXG4vKiFcbiAqIGpRdWVyeSBNb3VzZXdoZWVsIDMuMS4xM1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBpZiAoIHR5cGVvZiBTMi5kZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgUzIuZGVmaW5lLmFtZCApIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBTMi5kZWZpbmUoJ2pxdWVyeS1tb3VzZXdoZWVsJyxbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBOb2RlL0NvbW1vbkpTIHN0eWxlIGZvciBCcm93c2VyaWZ5XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICAgICAgZmFjdG9yeShqUXVlcnkpO1xuICAgIH1cbn0oZnVuY3Rpb24gKCQpIHtcblxuICAgIHZhciB0b0ZpeCAgPSBbJ3doZWVsJywgJ21vdXNld2hlZWwnLCAnRE9NTW91c2VTY3JvbGwnLCAnTW96TW91c2VQaXhlbFNjcm9sbCddLFxuICAgICAgICB0b0JpbmQgPSAoICdvbndoZWVsJyBpbiBkb2N1bWVudCB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPj0gOSApID9cbiAgICAgICAgICAgICAgICAgICAgWyd3aGVlbCddIDogWydtb3VzZXdoZWVsJywgJ0RvbU1vdXNlU2Nyb2xsJywgJ01vek1vdXNlUGl4ZWxTY3JvbGwnXSxcbiAgICAgICAgc2xpY2UgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuICAgICAgICBudWxsTG93ZXN0RGVsdGFUaW1lb3V0LCBsb3dlc3REZWx0YTtcblxuICAgIGlmICggJC5ldmVudC5maXhIb29rcyApIHtcbiAgICAgICAgZm9yICggdmFyIGkgPSB0b0ZpeC5sZW5ndGg7IGk7ICkge1xuICAgICAgICAgICAgJC5ldmVudC5maXhIb29rc1sgdG9GaXhbLS1pXSBdID0gJC5ldmVudC5tb3VzZUhvb2tzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNwZWNpYWwgPSAkLmV2ZW50LnNwZWNpYWwubW91c2V3aGVlbCA9IHtcbiAgICAgICAgdmVyc2lvbjogJzMuMS4xMicsXG5cbiAgICAgICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSB0b0JpbmQubGVuZ3RoOyBpOyApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCB0b0JpbmRbLS1pXSwgaGFuZGxlciwgZmFsc2UgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub25tb3VzZXdoZWVsID0gaGFuZGxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBsaW5lIGhlaWdodCBhbmQgcGFnZSBoZWlnaHQgZm9yIHRoaXMgcGFydGljdWxhciBlbGVtZW50XG4gICAgICAgICAgICAkLmRhdGEodGhpcywgJ21vdXNld2hlZWwtbGluZS1oZWlnaHQnLCBzcGVjaWFsLmdldExpbmVIZWlnaHQodGhpcykpO1xuICAgICAgICAgICAgJC5kYXRhKHRoaXMsICdtb3VzZXdoZWVsLXBhZ2UtaGVpZ2h0Jywgc3BlY2lhbC5nZXRQYWdlSGVpZ2h0KHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IHRvQmluZC5sZW5ndGg7IGk7ICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHRvQmluZFstLWldLCBoYW5kbGVyLCBmYWxzZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbm1vdXNld2hlZWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGRhdGEgd2UgYWRkZWQgdG8gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICQucmVtb3ZlRGF0YSh0aGlzLCAnbW91c2V3aGVlbC1saW5lLWhlaWdodCcpO1xuICAgICAgICAgICAgJC5yZW1vdmVEYXRhKHRoaXMsICdtb3VzZXdoZWVsLXBhZ2UtaGVpZ2h0Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGluZUhlaWdodDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgdmFyICRlbGVtID0gJChlbGVtKSxcbiAgICAgICAgICAgICAgICAkcGFyZW50ID0gJGVsZW1bJ29mZnNldFBhcmVudCcgaW4gJC5mbiA/ICdvZmZzZXRQYXJlbnQnIDogJ3BhcmVudCddKCk7XG4gICAgICAgICAgICBpZiAoISRwYXJlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgJHBhcmVudCA9ICQoJ2JvZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCgkcGFyZW50LmNzcygnZm9udFNpemUnKSwgMTApIHx8IHBhcnNlSW50KCRlbGVtLmNzcygnZm9udFNpemUnKSwgMTApIHx8IDE2O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFBhZ2VIZWlnaHQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiAkKGVsZW0pLmhlaWdodCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBhZGp1c3RPbGREZWx0YXM6IHRydWUsIC8vIHNlZSBzaG91bGRBZGp1c3RPbGREZWx0YXMoKSBiZWxvd1xuICAgICAgICAgICAgbm9ybWFsaXplT2Zmc2V0OiB0cnVlICAvLyBjYWxscyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZm9yIGVhY2ggZXZlbnRcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLmV4dGVuZCh7XG4gICAgICAgIG1vdXNld2hlZWw6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4gPyB0aGlzLmJpbmQoJ21vdXNld2hlZWwnLCBmbikgOiB0aGlzLnRyaWdnZXIoJ21vdXNld2hlZWwnKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bm1vdXNld2hlZWw6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmJpbmQoJ21vdXNld2hlZWwnLCBmbik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgICAgICB2YXIgb3JnRXZlbnQgICA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudCxcbiAgICAgICAgICAgIGFyZ3MgICAgICAgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBkZWx0YSAgICAgID0gMCxcbiAgICAgICAgICAgIGRlbHRhWCAgICAgPSAwLFxuICAgICAgICAgICAgZGVsdGFZICAgICA9IDAsXG4gICAgICAgICAgICBhYnNEZWx0YSAgID0gMCxcbiAgICAgICAgICAgIG9mZnNldFggICAgPSAwLFxuICAgICAgICAgICAgb2Zmc2V0WSAgICA9IDA7XG4gICAgICAgIGV2ZW50ID0gJC5ldmVudC5maXgob3JnRXZlbnQpO1xuICAgICAgICBldmVudC50eXBlID0gJ21vdXNld2hlZWwnO1xuXG4gICAgICAgIC8vIE9sZCBzY2hvb2wgc2Nyb2xsd2hlZWwgZGVsdGFcbiAgICAgICAgaWYgKCAnZGV0YWlsJyAgICAgIGluIG9yZ0V2ZW50ICkgeyBkZWx0YVkgPSBvcmdFdmVudC5kZXRhaWwgKiAtMTsgICAgICB9XG4gICAgICAgIGlmICggJ3doZWVsRGVsdGEnICBpbiBvcmdFdmVudCApIHsgZGVsdGFZID0gb3JnRXZlbnQud2hlZWxEZWx0YTsgICAgICAgfVxuICAgICAgICBpZiAoICd3aGVlbERlbHRhWScgaW4gb3JnRXZlbnQgKSB7IGRlbHRhWSA9IG9yZ0V2ZW50LndoZWVsRGVsdGFZOyAgICAgIH1cbiAgICAgICAgaWYgKCAnd2hlZWxEZWx0YVgnIGluIG9yZ0V2ZW50ICkgeyBkZWx0YVggPSBvcmdFdmVudC53aGVlbERlbHRhWCAqIC0xOyB9XG5cbiAgICAgICAgLy8gRmlyZWZveCA8IDE3IGhvcml6b250YWwgc2Nyb2xsaW5nIHJlbGF0ZWQgdG8gRE9NTW91c2VTY3JvbGwgZXZlbnRcbiAgICAgICAgaWYgKCAnYXhpcycgaW4gb3JnRXZlbnQgJiYgb3JnRXZlbnQuYXhpcyA9PT0gb3JnRXZlbnQuSE9SSVpPTlRBTF9BWElTICkge1xuICAgICAgICAgICAgZGVsdGFYID0gZGVsdGFZICogLTE7XG4gICAgICAgICAgICBkZWx0YVkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGRlbHRhIHRvIGJlIGRlbHRhWSBvciBkZWx0YVggaWYgZGVsdGFZIGlzIDAgZm9yIGJhY2t3YXJkcyBjb21wYXRhYmlsaXRpeVxuICAgICAgICBkZWx0YSA9IGRlbHRhWSA9PT0gMCA/IGRlbHRhWCA6IGRlbHRhWTtcblxuICAgICAgICAvLyBOZXcgc2Nob29sIHdoZWVsIGRlbHRhICh3aGVlbCBldmVudClcbiAgICAgICAgaWYgKCAnZGVsdGFZJyBpbiBvcmdFdmVudCApIHtcbiAgICAgICAgICAgIGRlbHRhWSA9IG9yZ0V2ZW50LmRlbHRhWSAqIC0xO1xuICAgICAgICAgICAgZGVsdGEgID0gZGVsdGFZO1xuICAgICAgICB9XG4gICAgICAgIGlmICggJ2RlbHRhWCcgaW4gb3JnRXZlbnQgKSB7XG4gICAgICAgICAgICBkZWx0YVggPSBvcmdFdmVudC5kZWx0YVg7XG4gICAgICAgICAgICBpZiAoIGRlbHRhWSA9PT0gMCApIHsgZGVsdGEgID0gZGVsdGFYICogLTE7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIGNoYW5nZSBhY3R1YWxseSBoYXBwZW5lZCwgbm8gcmVhc29uIHRvIGdvIGFueSBmdXJ0aGVyXG4gICAgICAgIGlmICggZGVsdGFZID09PSAwICYmIGRlbHRhWCA9PT0gMCApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgLy8gTmVlZCB0byBjb252ZXJ0IGxpbmVzIGFuZCBwYWdlcyB0byBwaXhlbHMgaWYgd2UgYXJlbid0IGFscmVhZHkgaW4gcGl4ZWxzXG4gICAgICAgIC8vIFRoZXJlIGFyZSB0aHJlZSBkZWx0YSBtb2RlczpcbiAgICAgICAgLy8gICAqIGRlbHRhTW9kZSAwIGlzIGJ5IHBpeGVscywgbm90aGluZyB0byBkb1xuICAgICAgICAvLyAgICogZGVsdGFNb2RlIDEgaXMgYnkgbGluZXNcbiAgICAgICAgLy8gICAqIGRlbHRhTW9kZSAyIGlzIGJ5IHBhZ2VzXG4gICAgICAgIGlmICggb3JnRXZlbnQuZGVsdGFNb2RlID09PSAxICkge1xuICAgICAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSAkLmRhdGEodGhpcywgJ21vdXNld2hlZWwtbGluZS1oZWlnaHQnKTtcbiAgICAgICAgICAgIGRlbHRhICAqPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgZGVsdGFZICo9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBkZWx0YVggKj0gbGluZUhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICggb3JnRXZlbnQuZGVsdGFNb2RlID09PSAyICkge1xuICAgICAgICAgICAgdmFyIHBhZ2VIZWlnaHQgPSAkLmRhdGEodGhpcywgJ21vdXNld2hlZWwtcGFnZS1oZWlnaHQnKTtcbiAgICAgICAgICAgIGRlbHRhICAqPSBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgZGVsdGFZICo9IHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBkZWx0YVggKj0gcGFnZUhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIGxvd2VzdCBhYnNvbHV0ZSBkZWx0YSB0byBub3JtYWxpemUgdGhlIGRlbHRhIHZhbHVlc1xuICAgICAgICBhYnNEZWx0YSA9IE1hdGgubWF4KCBNYXRoLmFicyhkZWx0YVkpLCBNYXRoLmFicyhkZWx0YVgpICk7XG5cbiAgICAgICAgaWYgKCAhbG93ZXN0RGVsdGEgfHwgYWJzRGVsdGEgPCBsb3dlc3REZWx0YSApIHtcbiAgICAgICAgICAgIGxvd2VzdERlbHRhID0gYWJzRGVsdGE7XG5cbiAgICAgICAgICAgIC8vIEFkanVzdCBvbGRlciBkZWx0YXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAoIHNob3VsZEFkanVzdE9sZERlbHRhcyhvcmdFdmVudCwgYWJzRGVsdGEpICkge1xuICAgICAgICAgICAgICAgIGxvd2VzdERlbHRhIC89IDQwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRqdXN0IG9sZGVyIGRlbHRhcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCBzaG91bGRBZGp1c3RPbGREZWx0YXMob3JnRXZlbnQsIGFic0RlbHRhKSApIHtcbiAgICAgICAgICAgIC8vIERpdmlkZSBhbGwgdGhlIHRoaW5ncyBieSA0MCFcbiAgICAgICAgICAgIGRlbHRhICAvPSA0MDtcbiAgICAgICAgICAgIGRlbHRhWCAvPSA0MDtcbiAgICAgICAgICAgIGRlbHRhWSAvPSA0MDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBhIHdob2xlLCBub3JtYWxpemVkIHZhbHVlIGZvciB0aGUgZGVsdGFzXG4gICAgICAgIGRlbHRhICA9IE1hdGhbIGRlbHRhICA+PSAxID8gJ2Zsb29yJyA6ICdjZWlsJyBdKGRlbHRhICAvIGxvd2VzdERlbHRhKTtcbiAgICAgICAgZGVsdGFYID0gTWF0aFsgZGVsdGFYID49IDEgPyAnZmxvb3InIDogJ2NlaWwnIF0oZGVsdGFYIC8gbG93ZXN0RGVsdGEpO1xuICAgICAgICBkZWx0YVkgPSBNYXRoWyBkZWx0YVkgPj0gMSA/ICdmbG9vcicgOiAnY2VpbCcgXShkZWx0YVkgLyBsb3dlc3REZWx0YSk7XG5cbiAgICAgICAgLy8gTm9ybWFsaXNlIG9mZnNldFggYW5kIG9mZnNldFkgcHJvcGVydGllc1xuICAgICAgICBpZiAoIHNwZWNpYWwuc2V0dGluZ3Mubm9ybWFsaXplT2Zmc2V0ICYmIHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICkge1xuICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBvZmZzZXRYID0gZXZlbnQuY2xpZW50WCAtIGJvdW5kaW5nUmVjdC5sZWZ0O1xuICAgICAgICAgICAgb2Zmc2V0WSA9IGV2ZW50LmNsaWVudFkgLSBib3VuZGluZ1JlY3QudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGluZm9ybWF0aW9uIHRvIHRoZSBldmVudCBvYmplY3RcbiAgICAgICAgZXZlbnQuZGVsdGFYID0gZGVsdGFYO1xuICAgICAgICBldmVudC5kZWx0YVkgPSBkZWx0YVk7XG4gICAgICAgIGV2ZW50LmRlbHRhRmFjdG9yID0gbG93ZXN0RGVsdGE7XG4gICAgICAgIGV2ZW50Lm9mZnNldFggPSBvZmZzZXRYO1xuICAgICAgICBldmVudC5vZmZzZXRZID0gb2Zmc2V0WTtcbiAgICAgICAgLy8gR28gYWhlYWQgYW5kIHNldCBkZWx0YU1vZGUgdG8gMCBzaW5jZSB3ZSBjb252ZXJ0ZWQgdG8gcGl4ZWxzXG4gICAgICAgIC8vIEFsdGhvdWdoIHRoaXMgaXMgYSBsaXR0bGUgb2RkIHNpbmNlIHdlIG92ZXJ3cml0ZSB0aGUgZGVsdGFYL1lcbiAgICAgICAgLy8gcHJvcGVydGllcyB3aXRoIG5vcm1hbGl6ZWQgZGVsdGFzLlxuICAgICAgICBldmVudC5kZWx0YU1vZGUgPSAwO1xuXG4gICAgICAgIC8vIEFkZCBldmVudCBhbmQgZGVsdGEgdG8gdGhlIGZyb250IG9mIHRoZSBhcmd1bWVudHNcbiAgICAgICAgYXJncy51bnNoaWZ0KGV2ZW50LCBkZWx0YSwgZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgICAgIC8vIENsZWFyb3V0IGxvd2VzdERlbHRhIGFmdGVyIHNvbWV0aW1lIHRvIGJldHRlclxuICAgICAgICAvLyBoYW5kbGUgbXVsdGlwbGUgZGV2aWNlIHR5cGVzIHRoYXQgZ2l2ZSBkaWZmZXJlbnRcbiAgICAgICAgLy8gYSBkaWZmZXJlbnQgbG93ZXN0RGVsdGFcbiAgICAgICAgLy8gRXg6IHRyYWNrcGFkID0gMyBhbmQgbW91c2Ugd2hlZWwgPSAxMjBcbiAgICAgICAgaWYgKG51bGxMb3dlc3REZWx0YVRpbWVvdXQpIHsgY2xlYXJUaW1lb3V0KG51bGxMb3dlc3REZWx0YVRpbWVvdXQpOyB9XG4gICAgICAgIG51bGxMb3dlc3REZWx0YVRpbWVvdXQgPSBzZXRUaW1lb3V0KG51bGxMb3dlc3REZWx0YSwgMjAwKTtcblxuICAgICAgICByZXR1cm4gKCQuZXZlbnQuZGlzcGF0Y2ggfHwgJC5ldmVudC5oYW5kbGUpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG51bGxMb3dlc3REZWx0YSgpIHtcbiAgICAgICAgbG93ZXN0RGVsdGEgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZEFkanVzdE9sZERlbHRhcyhvcmdFdmVudCwgYWJzRGVsdGEpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBvbGRlciBldmVudCBhbmQgdGhlIGRlbHRhIGlzIGRpdmlzYWJsZSBieSAxMjAsXG4gICAgICAgIC8vIHRoZW4gd2UgYXJlIGFzc3VtaW5nIHRoYXQgdGhlIGJyb3dzZXIgaXMgdHJlYXRpbmcgdGhpcyBhcyBhblxuICAgICAgICAvLyBvbGRlciBtb3VzZSB3aGVlbCBldmVudCBhbmQgdGhhdCB3ZSBzaG91bGQgZGl2aWRlIHRoZSBkZWx0YXNcbiAgICAgICAgLy8gYnkgNDAgdG8gdHJ5IGFuZCBnZXQgYSBtb3JlIHVzYWJsZSBkZWx0YUZhY3Rvci5cbiAgICAgICAgLy8gU2lkZSBub3RlLCB0aGlzIGFjdHVhbGx5IGltcGFjdHMgdGhlIHJlcG9ydGVkIHNjcm9sbCBkaXN0YW5jZVxuICAgICAgICAvLyBpbiBvbGRlciBicm93c2VycyBhbmQgY2FuIGNhdXNlIHNjcm9sbGluZyB0byBiZSBzbG93ZXIgdGhhbiBuYXRpdmUuXG4gICAgICAgIC8vIFR1cm4gdGhpcyBvZmYgYnkgc2V0dGluZyAkLmV2ZW50LnNwZWNpYWwubW91c2V3aGVlbC5zZXR0aW5ncy5hZGp1c3RPbGREZWx0YXMgdG8gZmFsc2UuXG4gICAgICAgIHJldHVybiBzcGVjaWFsLnNldHRpbmdzLmFkanVzdE9sZERlbHRhcyAmJiBvcmdFdmVudC50eXBlID09PSAnbW91c2V3aGVlbCcgJiYgYWJzRGVsdGEgJSAxMjAgPT09IDA7XG4gICAgfVxuXG59KSk7XG5cblMyLmRlZmluZSgnanF1ZXJ5LnNlbGVjdDInLFtcbiAgJ2pxdWVyeScsXG4gICdqcXVlcnktbW91c2V3aGVlbCcsXG5cbiAgJy4vc2VsZWN0Mi9jb3JlJyxcbiAgJy4vc2VsZWN0Mi9kZWZhdWx0cydcbl0sIGZ1bmN0aW9uICgkLCBfLCBTZWxlY3QyLCBEZWZhdWx0cykge1xuICBpZiAoJC5mbi5zZWxlY3QyID09IG51bGwpIHtcbiAgICAvLyBBbGwgbWV0aG9kcyB0aGF0IHNob3VsZCByZXR1cm4gdGhlIGVsZW1lbnRcbiAgICB2YXIgdGhpc01ldGhvZHMgPSBbJ29wZW4nLCAnY2xvc2UnLCAnZGVzdHJveSddO1xuXG4gICAgJC5mbi5zZWxlY3QyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlT3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBvcHRpb25zKTtcblxuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBTZWxlY3QyKCQodGhpcyksIGluc3RhbmNlT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gJCh0aGlzKS5kYXRhKCdzZWxlY3QyJyk7XG5cbiAgICAgICAgICBpZiAoaW5zdGFuY2UgPT0gbnVsbCAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnVGhlIHNlbGVjdDIoXFwnJyArIG9wdGlvbnMgKyAnXFwnKSBtZXRob2Qgd2FzIGNhbGxlZCBvbiBhbiAnICtcbiAgICAgICAgICAgICAgJ2VsZW1lbnQgdGhhdCBpcyBub3QgdXNpbmcgU2VsZWN0Mi4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldCA9IGluc3RhbmNlW29wdGlvbnNdLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIGJlIHJldHVybmluZyBgdGhpc2BcbiAgICAgICAgaWYgKCQuaW5BcnJheShvcHRpb25zLCB0aGlzTWV0aG9kcykgPiAtMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgZm9yIFNlbGVjdDI6ICcgKyBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKCQuZm4uc2VsZWN0Mi5kZWZhdWx0cyA9PSBudWxsKSB7XG4gICAgJC5mbi5zZWxlY3QyLmRlZmF1bHRzID0gRGVmYXVsdHM7XG4gIH1cblxuICByZXR1cm4gU2VsZWN0Mjtcbn0pO1xuXG4gIC8vIFJldHVybiB0aGUgQU1EIGxvYWRlciBjb25maWd1cmF0aW9uIHNvIGl0IGNhbiBiZSB1c2VkIG91dHNpZGUgb2YgdGhpcyBmaWxlXG4gIHJldHVybiB7XG4gICAgZGVmaW5lOiBTMi5kZWZpbmUsXG4gICAgcmVxdWlyZTogUzIucmVxdWlyZVxuICB9O1xufSgpKTtcblxuICAvLyBBdXRvbG9hZCB0aGUgalF1ZXJ5IGJpbmRpbmdzXG4gIC8vIFdlIGtub3cgdGhhdCBhbGwgb2YgdGhlIG1vZHVsZXMgZXhpc3QgYWJvdmUgdGhpcywgc28gd2UncmUgc2FmZVxuICB2YXIgc2VsZWN0MiA9IFMyLnJlcXVpcmUoJ2pxdWVyeS5zZWxlY3QyJyk7XG5cbiAgLy8gSG9sZCB0aGUgQU1EIG1vZHVsZSByZWZlcmVuY2VzIG9uIHRoZSBqUXVlcnkgZnVuY3Rpb24gdGhhdCB3YXMganVzdCBsb2FkZWRcbiAgLy8gVGhpcyBhbGxvd3MgU2VsZWN0MiB0byB1c2UgdGhlIGludGVybmFsIGxvYWRlciBvdXRzaWRlIG9mIHRoaXMgZmlsZSwgc3VjaFxuICAvLyBhcyBpbiB0aGUgbGFuZ3VhZ2UgZmlsZXMuXG4gIGpRdWVyeS5mbi5zZWxlY3QyLmFtZCA9IFMyO1xuXG4gIC8vIFJldHVybiB0aGUgU2VsZWN0MiBpbnN0YW5jZSBmb3IgYW55b25lIHdobyBpcyBpbXBvcnRpbmcgaXQuXG4gIHJldHVybiBzZWxlY3QyO1xufSkpO1xuIiwiLyoqXG4gKiBzaW1wbGVtZGUgdjEuMTEuMlxuICogQ29weXJpZ2h0IE5leHQgU3RlcCBXZWJzLCBJbmMuXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vTmV4dFN0ZXBXZWJzL3NpbXBsZW1kZS1tYXJrZG93bi1lZGl0b3JcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4hZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBtb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gZSgpOyBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoW10sIGUpOyBlbHNlIHtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBnbG9iYWwgPyBnbG9iYWwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBzZWxmID8gc2VsZiA6IHRoaXMsIHQuU2ltcGxlTURFID0gZSgpXG4gICAgfVxufShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHQoZSwgbiwgcikge1xuICAgICAgICBmdW5jdGlvbiBpKGEsIGwpIHtcbiAgICAgICAgICAgIGlmICghblthXSkge1xuICAgICAgICAgICAgICAgIGlmICghZVthXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcmVxdWlyZSAmJiByZXF1aXJlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWwgJiYgcylyZXR1cm4gcyhhLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvKXJldHVybiBvKGEsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgYSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYy5jb2RlID0gXCJNT0RVTEVfTk9UX0ZPVU5EXCIsIGNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHUgPSBuW2FdID0ge2V4cG9ydHM6IHt9fTtcbiAgICAgICAgICAgICAgICBlW2FdWzBdLmNhbGwodS5leHBvcnRzLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGVbYV1bMV1bdF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpKG4gPyBuIDogdClcbiAgICAgICAgICAgICAgICB9LCB1LCB1LmV4cG9ydHMsIHQsIGUsIG4sIHIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gblthXS5leHBvcnRzXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBvID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiByZXF1aXJlICYmIHJlcXVpcmUsIGEgPSAwOyBhIDwgci5sZW5ndGg7IGErKylpKHJbYV0pO1xuICAgICAgICByZXR1cm4gaVxuICAgIH0oe1xuICAgICAgICAxOiBbZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZnVuY3Rpb24gcigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIsIHQgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBlLmxlbmd0aDsgbiA+IHQ7ICsrdClzW3RdID0gZVt0XSwgY1tlLmNoYXJDb2RlQXQodCldID0gdDtcbiAgICAgICAgICAgICAgICBjW1wiLVwiLmNoYXJDb2RlQXQoMCldID0gNjIsIGNbXCJfXCIuY2hhckNvZGVBdCgwKV0gPSA2M1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCwgbiwgciwgaSwgbywgYSwgbCA9IGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsICUgNCA+IDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTtcbiAgICAgICAgICAgICAgICBvID0gXCI9XCIgPT09IGVbbCAtIDJdID8gMiA6IFwiPVwiID09PSBlW2wgLSAxXSA/IDEgOiAwLCBhID0gbmV3IHUoMyAqIGwgLyA0IC0gbyksIHIgPSBvID4gMCA/IGwgLSA0IDogbDtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh0ID0gMCwgbiA9IDA7IHIgPiB0OyB0ICs9IDQsIG4gKz0gMylpID0gY1tlLmNoYXJDb2RlQXQodCldIDw8IDE4IHwgY1tlLmNoYXJDb2RlQXQodCArIDEpXSA8PCAxMiB8IGNbZS5jaGFyQ29kZUF0KHQgKyAyKV0gPDwgNiB8IGNbZS5jaGFyQ29kZUF0KHQgKyAzKV0sIGFbcysrXSA9IGkgPj4gMTYgJiAyNTUsIGFbcysrXSA9IGkgPj4gOCAmIDI1NSwgYVtzKytdID0gMjU1ICYgaTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMiA9PT0gbyA/IChpID0gY1tlLmNoYXJDb2RlQXQodCldIDw8IDIgfCBjW2UuY2hhckNvZGVBdCh0ICsgMSldID4+IDQsIGFbcysrXSA9IDI1NSAmIGkpIDogMSA9PT0gbyAmJiAoaSA9IGNbZS5jaGFyQ29kZUF0KHQpXSA8PCAxMCB8IGNbZS5jaGFyQ29kZUF0KHQgKyAxKV0gPDwgNCB8IGNbZS5jaGFyQ29kZUF0KHQgKyAyKV0gPj4gMiwgYVtzKytdID0gaSA+PiA4ICYgMjU1LCBhW3MrK10gPSAyNTUgJiBpKSwgYVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBvKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc1tlID4+IDE4ICYgNjNdICsgc1tlID4+IDEyICYgNjNdICsgc1tlID4+IDYgJiA2M10gKyBzWzYzICYgZV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gYShlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgciwgaSA9IFtdLCBhID0gdDsgbiA+IGE7IGEgKz0gMylyID0gKGVbYV0gPDwgMTYpICsgKGVbYSArIDFdIDw8IDgpICsgZVthICsgMl0sIGkucHVzaChvKHIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5qb2luKFwiXCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHQsIG4gPSBlLmxlbmd0aCwgciA9IG4gJSAzLCBpID0gXCJcIiwgbyA9IFtdLCBsID0gMTYzODMsIGMgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBuIC0gcjsgdSA+IGM7IGMgKz0gbClvLnB1c2goYShlLCBjLCBjICsgbCA+IHUgPyB1IDogYyArIGwpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSA9PT0gciA/ICh0ID0gZVtuIC0gMV0sIGkgKz0gc1t0ID4+IDJdLCBpICs9IHNbdCA8PCA0ICYgNjNdLCBpICs9IFwiPT1cIikgOiAyID09PSByICYmICh0ID0gKGVbbiAtIDJdIDw8IDgpICsgZVtuIC0gMV0sIGkgKz0gc1t0ID4+IDEwXSwgaSArPSBzW3QgPj4gNCAmIDYzXSwgaSArPSBzW3QgPDwgMiAmIDYzXSwgaSArPSBcIj1cIiksIG8ucHVzaChpKSwgby5qb2luKFwiXCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG4udG9CeXRlQXJyYXkgPSBpLCBuLmZyb21CeXRlQXJyYXkgPSBsO1xuICAgICAgICAgICAgdmFyIHMgPSBbXSwgYyA9IFtdLCB1ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgVWludDhBcnJheSA/IFVpbnQ4QXJyYXkgOiBBcnJheTtcbiAgICAgICAgICAgIHIoKVxuICAgICAgICB9LCB7fV0sXG4gICAgICAgIDI6IFtmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICB9LCB7fV0sXG4gICAgICAgIDM6IFtmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5mb28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCA0MiA9PT0gZS5mb28oKSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUuc3ViYXJyYXkgJiYgMCA9PT0gZS5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuVFlQRURfQVJSQVlfU1VQUE9SVCA/IDIxNDc0ODM2NDcgOiAxMDczNzQxODIzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbyhlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpKCkgPCB0KXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgPyAoZSA9IG5ldyBVaW50OEFycmF5KHQpLCBlLl9fcHJvdG9fXyA9IGEucHJvdG90eXBlKSA6IChudWxsID09PSBlICYmIChlID0gbmV3IGEodCkpLCBlLmxlbmd0aCA9IHQpLCBlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYShlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGEuVFlQRURfQVJSQVlfU1VQUE9SVCB8fCB0aGlzIGluc3RhbmNlb2YgYSkpcmV0dXJuIG5ldyBhKGUsIHQsIG4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdSh0aGlzLCBlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsKHRoaXMsIGUsIHQsIG4pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbChlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQXJyYXlCdWZmZXIgJiYgdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gZChlLCB0LCBuLCByKSA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgPyBmKGUsIHQsIG4pIDogcChlLCB0KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHModCksIDAgPj0gdCA/IG8oZSwgdCkgOiB2b2lkIDAgIT09IG4gPyBcInN0cmluZ1wiID09IHR5cGVvZiByID8gbyhlLCB0KS5maWxsKG4sIHIpIDogbyhlLCB0KS5maWxsKG4pIDogbyhlLCB0KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocyh0KSwgZSA9IG8oZSwgMCA+IHQgPyAwIDogMCB8IG0odCkpLCAhYS5UWVBFRF9BUlJBWV9TVVBQT1JUKWZvciAodmFyIG4gPSAwOyB0ID4gbjsgbisrKWVbbl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgbiAmJiBcIlwiICE9PSBuIHx8IChuID0gXCJ1dGY4XCIpLCAhYS5pc0VuY29kaW5nKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gMCB8IHYodCwgbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlID0gbyhlLCByKSwgZS53cml0ZSh0LCBuKSwgZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGgoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IDAgfCBtKHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgZSA9IG8oZSwgbik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyBuID4gcjsgciArPSAxKWVbcl0gPSAyNTUgJiB0W3JdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGQoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodC5ieXRlTGVuZ3RoLCAwID4gbiB8fCB0LmJ5dGVMZW5ndGggPCBuKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ29mZnNldCcgaXMgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQuYnl0ZUxlbmd0aCA8IG4gKyAociB8fCAwKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidsZW5ndGgnIGlzIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ID0gdm9pZCAwID09PSByID8gbmV3IFVpbnQ4QXJyYXkodCwgbikgOiBuZXcgVWludDhBcnJheSh0LCBuLCByKSwgYS5UWVBFRF9BUlJBWV9TVVBQT1JUID8gKGUgPSB0LCBlLl9fcHJvdG9fXyA9IGEucHJvdG90eXBlKSA6IGUgPSBoKGUsIHQpLCBlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLmlzQnVmZmVyKHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IDAgfCBtKHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlID0gbyhlLCBuKSwgMCA9PT0gZS5sZW5ndGggPyBlIDogKHQuY29weShlLCAwLCAwLCBuKSwgZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEFycmF5QnVmZmVyICYmIHQuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgXCJsZW5ndGhcIiBpbiB0KXJldHVybiBcIm51bWJlclwiICE9IHR5cGVvZiB0Lmxlbmd0aCB8fCBLKHQubGVuZ3RoKSA/IG8oZSwgMCkgOiBoKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiQnVmZmVyXCIgPT09IHQudHlwZSAmJiBKKHQuZGF0YSkpcmV0dXJuIGgoZSwgdC5kYXRhKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuXCIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbShlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlID49IGkoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHhcIiArIGkoKS50b1N0cmluZygxNikgKyBcIiBieXRlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgfCBlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiArZSAhPSBlICYmIChlID0gMCksIGEuYWxsb2MoK2UpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLmlzQnVmZmVyKGUpKXJldHVybiBlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEFycmF5QnVmZmVyICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZSkgfHwgZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSlyZXR1cm4gZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiICE9IHR5cGVvZiBlICYmIChlID0gXCJcIiArIGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbilyZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9ICExOyA7KXN3aXRjaCAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwiYXNjaWlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcImJpbmFyeVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwicmF3XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJyYXdzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJ1dGY4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJ1dGYtOFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHEoZSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwidWNzMlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwidWNzLTJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcInV0ZjE2bGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcInV0Zi0xNmxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIgKiBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwiaGV4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gPj4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJiYXNlNjRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJChlKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyKXJldHVybiBxKGUpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFwiXCIgKyB0KS50b0xvd2VyQ2FzZSgpLCByID0gITBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHkoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9ICExO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHZvaWQgMCA9PT0gdCB8fCAwID4gdCkgJiYgKHQgPSAwKSwgdCA+IHRoaXMubGVuZ3RoKXJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHZvaWQgMCA9PT0gbiB8fCBuID4gdGhpcy5sZW5ndGgpICYmIChuID0gdGhpcy5sZW5ndGgpLCAwID49IG4pcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuID4+Pj0gMCwgdCA+Pj49IDAsIHQgPj0gbilyZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChlIHx8IChlID0gXCJ1dGY4XCIpOyA7KXN3aXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwiaGV4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEkodGhpcywgdCwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJ1dGY4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJ1dGYtOFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOKHRoaXMsIHQsIG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwiYXNjaWlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRSh0aGlzLCB0LCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcImJpbmFyeVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPKHRoaXMsIHQsIG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwiYmFzZTY0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE0odGhpcywgdCwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJ1Y3MyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJ1Y3MtMlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwidXRmMTZsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwidXRmLTE2bGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUCh0aGlzLCB0LCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IChlICsgXCJcIikudG9Mb3dlckNhc2UoKSwgciA9ICEwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB4KGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlW3RdO1xuICAgICAgICAgICAgICAgICAgICBlW3RdID0gZVtuXSwgZVtuXSA9IHJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSA9PT0gbyA/IGVbdF0gOiBlLnJlYWRVSW50MTZCRSh0ICogbylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gMSwgYSA9IGUubGVuZ3RoLCBsID0gdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHIgJiYgKHIgPSBTdHJpbmcocikudG9Mb3dlckNhc2UoKSwgXCJ1Y3MyXCIgPT09IHIgfHwgXCJ1Y3MtMlwiID09PSByIHx8IFwidXRmMTZsZVwiID09PSByIHx8IFwidXRmLTE2bGVcIiA9PT0gcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmxlbmd0aCA8IDIgfHwgdC5sZW5ndGggPCAyKXJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSAyLCBhIC89IDIsIGwgLz0gMiwgbiAvPSAyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IC0xLCBjID0gMDsgYSA+IG4gKyBjOyBjKyspaWYgKGkoZSwgbiArIGMpID09PSBpKHQsIC0xID09PSBzID8gMCA6IGMgLSBzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0xID09PSBzICYmIChzID0gYyksIGMgLSBzICsgMSA9PT0gbClyZXR1cm4gKG4gKyBzKSAqIG9cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlLTEgIT09IHMgJiYgKGMgLT0gYyAtIHMpLCBzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHcoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICBuID0gTnVtYmVyKG4pIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gZS5sZW5ndGggLSBuO1xuICAgICAgICAgICAgICAgICAgICByID8gKHIgPSBOdW1iZXIociksIHIgPiBpICYmIChyID0gaSkpIDogciA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvICUgMiAhPT0gMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGhleCBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHIgPiBvIC8gMiAmJiAociA9IG8gLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IHIgPiBhOyBhKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gcGFyc2VJbnQodC5zdWJzdHIoMiAqIGEsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obCkpcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlW24gKyBhXSA9IGxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGsoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVihxKHQsIGUubGVuZ3RoIC0gbiksIGUsIG4sIHIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUyhlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWKEcodCksIGUsIG4sIHIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQyhlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTKGUsIHQsIG4sIHIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTChlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWKCQodCksIGUsIG4sIHIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gVChlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWKFkodCwgZS5sZW5ndGggLSBuKSwgZSwgbiwgcilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgPT09IHQgJiYgbiA9PT0gZS5sZW5ndGggPyBYLmZyb21CeXRlQXJyYXkoZSkgOiBYLmZyb21CeXRlQXJyYXkoZS5zbGljZSh0LCBuKSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBOKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IE1hdGgubWluKGUubGVuZ3RoLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IFtdLCBpID0gdDsgbiA+IGk7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGVbaV0sIGEgPSBudWxsLCBsID0gbyA+IDIzOSA/IDQgOiBvID4gMjIzID8gMyA6IG8gPiAxOTEgPyAyIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuID49IGkgKyBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMsIGMsIHUsIGY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyOCA+IG8gJiYgKGEgPSBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gZVtpICsgMV0sIDEyOCA9PT0gKDE5MiAmIHMpICYmIChmID0gKDMxICYgbykgPDwgNiB8IDYzICYgcywgZiA+IDEyNyAmJiAoYSA9IGYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gZVtpICsgMV0sIGMgPSBlW2kgKyAyXSwgMTI4ID09PSAoMTkyICYgcykgJiYgMTI4ID09PSAoMTkyICYgYykgJiYgKGYgPSAoMTUgJiBvKSA8PCAxMiB8ICg2MyAmIHMpIDw8IDYgfCA2MyAmIGMsIGYgPiAyMDQ3ICYmICg1NTI5NiA+IGYgfHwgZiA+IDU3MzQzKSAmJiAoYSA9IGYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gZVtpICsgMV0sIGMgPSBlW2kgKyAyXSwgdSA9IGVbaSArIDNdLCAxMjggPT09ICgxOTIgJiBzKSAmJiAxMjggPT09ICgxOTIgJiBjKSAmJiAxMjggPT09ICgxOTIgJiB1KSAmJiAoZiA9ICgxNSAmIG8pIDw8IDE4IHwgKDYzICYgcykgPDwgMTIgfCAoNjMgJiBjKSA8PCA2IHwgNjMgJiB1LCBmID4gNjU1MzUgJiYgMTExNDExMiA+IGYgJiYgKGEgPSBmKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsID09PSBhID8gKGEgPSA2NTUzMywgbCA9IDEpIDogYSA+IDY1NTM1ICYmIChhIC09IDY1NTM2LCByLnB1c2goYSA+Pj4gMTAgJiAxMDIzIHwgNTUyOTYpLCBhID0gNTYzMjAgfCAxMDIzICYgYSksIHIucHVzaChhKSwgaSArPSBsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEEocilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBBKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFEgPj0gdClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gXCJcIiwgciA9IDA7IHQgPiByOyluICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBlLnNsaWNlKHIsIHIgKz0gUSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEUoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBNYXRoLm1pbihlLmxlbmd0aCwgbik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0OyBuID4gaTsgaSsrKXIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjcgJiBlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBPKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBuID0gTWF0aC5taW4oZS5sZW5ndGgsIG4pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdDsgbiA+IGk7IGkrKylyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSShlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICghdCB8fCAwID4gdCkgJiYgKHQgPSAwKSwgKCFuIHx8IDAgPiBuIHx8IG4gPiByKSAmJiAobiA9IHIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gXCJcIiwgbyA9IHQ7IG4gPiBvOyBvKyspaSArPSBVKGVbb10pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gZS5zbGljZSh0LCBuKSwgaSA9IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSAwOyBvIDwgci5sZW5ndGg7IG8gKz0gMilpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocltvXSArIDI1NiAqIHJbbyArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBSKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJSAxICE9PSAwIHx8IDAgPiBlKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSArIHQgPiBuKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEQoZSwgdCwgbiwgciwgaSwgbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWEuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID4gaSB8fCBvID4gdCl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gKyByID4gZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBIKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgMCA+IHQgJiYgKHQgPSA2NTUzNSArIHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBNYXRoLm1pbihlLmxlbmd0aCAtIG4sIDIpOyBvID4gaTsgaSsrKWVbbiArIGldID0gKHQgJiAyNTUgPDwgOCAqIChyID8gaSA6IDEgLSBpKSkgPj4+IDggKiAociA/IGkgOiAxIC0gaSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBXKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgMCA+IHQgJiYgKHQgPSA0Mjk0OTY3Mjk1ICsgdCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbyA9IE1hdGgubWluKGUubGVuZ3RoIC0gbiwgNCk7IG8gPiBpOyBpKyspZVtuICsgaV0gPSB0ID4+PiA4ICogKHIgPyBpIDogMyAtIGkpICYgMjU1XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQihlLCB0LCBuLCByLCBpLCBvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuICsgciA+IGUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA+IG4pdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfKGUsIHQsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgfHwgQihlLCB0LCBuLCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzgpLCBaLndyaXRlKGUsIHQsIG4sIHIsIDIzLCA0KSwgbiArIDRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBGKGUsIHQsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgfHwgQihlLCB0LCBuLCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdlMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3ZTMwOCksIFoud3JpdGUoZSwgdCwgbiwgciwgNTIsIDgpLCBuICsgOFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHooZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSA9IGooZSkucmVwbGFjZShlZSwgXCJcIiksIGUubGVuZ3RoIDwgMilyZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGUubGVuZ3RoICUgNCAhPT0gMDspZSArPSBcIj1cIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBqKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudHJpbSA/IGUudHJpbSgpIDogZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFUoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTYgPiBlID8gXCIwXCIgKyBlLnRvU3RyaW5nKDE2KSA6IGUudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSB0IHx8IDEgLyAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuLCByID0gZS5sZW5ndGgsIGkgPSBudWxsLCBvID0gW10sIGEgPSAwOyByID4gYTsgYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobiA9IGUuY2hhckNvZGVBdChhKSwgbiA+IDU1Mjk1ICYmIDU3MzQ0ID4gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobiA+IDU2MzE5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodCAtPSAzKSA+IC0xICYmIG8ucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgKyAxID09PSByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodCAtPSAzKSA+IC0xICYmIG8ucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICg1NjMyMCA+IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHQgLT0gMykgPiAtMSAmJiBvLnB1c2goMjM5LCAxOTEsIDE4OSksIGkgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gKGkgLSA1NTI5NiA8PCAxMCB8IG4gLSA1NjMyMCkgKyA2NTUzNlxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGkgJiYgKHQgLT0gMykgPiAtMSAmJiBvLnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9IG51bGwsIDEyOCA+IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHQgLT0gMSkgPCAwKWJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8ucHVzaChuKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgyMDQ4ID4gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodCAtPSAyKSA8IDApYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5wdXNoKG4gPj4gNiB8IDE5MiwgNjMgJiBuIHwgMTI4KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICg2NTUzNiA+IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHQgLT0gMykgPCAwKWJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8ucHVzaChuID4+IDEyIHwgMjI0LCBuID4+IDYgJiA2MyB8IDEyOCwgNjMgJiBuIHwgMTI4KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgxMTE0MTEyID4gbikpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodCAtPSA0KSA8IDApYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5wdXNoKG4gPj4gMTggfCAyNDAsIG4gPj4gMTIgJiA2MyB8IDEyOCwgbiA+PiA2ICYgNjMgfCAxMjgsIDYzICYgbiB8IDEyOClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEcoZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gW10sIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKyl0LnB1c2goMjU1ICYgZS5jaGFyQ29kZUF0KG4pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBZKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiwgciwgaSwgbyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gMDsgYSA8IGUubGVuZ3RoICYmICEoKHQgLT0gMikgPCAwKTsgYSsrKW4gPSBlLmNoYXJDb2RlQXQoYSksIHIgPSBuID4+IDgsIGkgPSBuICUgMjU2LCBvLnB1c2goaSksIG8ucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAkKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFgudG9CeXRlQXJyYXkoeihlKSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBWKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IHIgPiBpICYmICEoaSArIG4gPj0gdC5sZW5ndGggfHwgaSA+PSBlLmxlbmd0aCk7IGkrKyl0W2kgKyBuXSA9IGVbaV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlICE9PSBlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIFggPSBlKFwiYmFzZTY0LWpzXCIpLCBaID0gZShcImllZWU3NTRcIiksIEogPSBlKFwiaXNhcnJheVwiKTtcbiAgICAgICAgICAgICAgICBuLkJ1ZmZlciA9IGEsIG4uU2xvd0J1ZmZlciA9IGcsIG4uSU5TUEVDVF9NQVhfQllURVMgPSA1MCwgYS5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdm9pZCAwICE9PSB0LlRZUEVEX0FSUkFZX1NVUFBPUlQgPyB0LlRZUEVEX0FSUkFZX1NVUFBPUlQgOiByKCksIG4ua01heExlbmd0aCA9IGkoKSwgYS5wb29sU2l6ZSA9IDgxOTIsIGEuX2F1Z21lbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5fX3Byb3RvX18gPSBhLnByb3RvdHlwZSwgZVxuICAgICAgICAgICAgICAgIH0sIGEuZnJvbSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsKG51bGwsIGUsIHQsIG4pXG4gICAgICAgICAgICAgICAgfSwgYS5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIChhLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZSwgYS5fX3Byb3RvX18gPSBVaW50OEFycmF5LCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgU3ltYm9sLnNwZWNpZXMgJiYgYVtTeW1ib2wuc3BlY2llc10gPT09IGEgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgICAgICAgICAgfSkpLCBhLmFsbG9jID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMobnVsbCwgZSwgdCwgbilcbiAgICAgICAgICAgICAgICB9LCBhLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHUobnVsbCwgZSlcbiAgICAgICAgICAgICAgICB9LCBhLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1KG51bGwsIGUpXG4gICAgICAgICAgICAgICAgfSwgYS5pc0J1ZmZlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKG51bGwgPT0gZSB8fCAhZS5faXNCdWZmZXIpXG4gICAgICAgICAgICAgICAgfSwgYS5jb21wYXJlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhLmlzQnVmZmVyKGUpIHx8ICFhLmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSA9PT0gdClyZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IGUubGVuZ3RoLCByID0gdC5sZW5ndGgsIGkgPSAwLCBvID0gTWF0aC5taW4obiwgcik7IG8gPiBpOyArK2kpaWYgKGVbaV0gIT09IHRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBlW2ldLCByID0gdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgPiBuID8gLTEgOiBuID4gciA/IDEgOiAwXG4gICAgICAgICAgICAgICAgfSwgYS5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChTdHJpbmcoZSkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwiaGV4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJ1dGY4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJ1dGYtOFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwiYXNjaWlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcImJpbmFyeVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwiYmFzZTY0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJyYXdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcInVjczJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcInVjcy0yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJ1dGYxNmxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJ1dGYtMTZsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBhLmNvbmNhdCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGUubGVuZ3RoKXJldHVybiBhLmFsbG9jKDApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gdClmb3IgKHQgPSAwLCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspdCArPSBlW25dLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBhLmFsbG9jVW5zYWZlKHQpLCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZVtuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYS5pc0J1ZmZlcihvKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uY29weShyLCBpKSwgaSArPSBvLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgICAgICAgICAgfSwgYS5ieXRlTGVuZ3RoID0gdiwgYS5wcm90b3R5cGUuX2lzQnVmZmVyID0gITAsIGEucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJSAyICE9PSAwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHNcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyBlID4gdDsgdCArPSAyKXgodGhpcywgdCwgdCArIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJSA0ICE9PSAwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyBlID4gdDsgdCArPSA0KXgodGhpcywgdCwgdCArIDMpLCB4KHRoaXMsIHQgKyAxLCB0ICsgMik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gMCB8IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCA9PT0gZSA/IFwiXCIgOiAwID09PSBhcmd1bWVudHMubGVuZ3RoID8gTih0aGlzLCAwLCBlKSA6IHkuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYS5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMgPT09IGUgPyAhMCA6IDAgPT09IGEuY29tcGFyZSh0aGlzLCBlKVxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gXCJcIiwgdCA9IG4uSU5TUEVDVF9NQVhfQllURVM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDAgJiYgKGUgPSB0aGlzLnRvU3RyaW5nKFwiaGV4XCIsIDAsIHQpLm1hdGNoKC8uezJ9L2cpLmpvaW4oXCIgXCIpLCB0aGlzLmxlbmd0aCA+IHQgJiYgKGUgKz0gXCIgLi4uIFwiKSksIFwiPEJ1ZmZlciBcIiArIGUgKyBcIj5cIlxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoZSwgdCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWEuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHQgJiYgKHQgPSAwKSwgdm9pZCAwID09PSBuICYmIChuID0gZSA/IGUubGVuZ3RoIDogMCksIHZvaWQgMCA9PT0gciAmJiAociA9IDApLCB2b2lkIDAgPT09IGkgJiYgKGkgPSB0aGlzLmxlbmd0aCksIDAgPiB0IHx8IG4gPiBlLmxlbmd0aCB8fCAwID4gciB8fCBpID4gdGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyID49IGkgJiYgdCA+PSBuKXJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAociA+PSBpKXJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPj0gbilyZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPj4+PSAwLCBuID4+Pj0gMCwgciA+Pj49IDAsIGkgPj4+PSAwLCB0aGlzID09PSBlKXJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0gaSAtIHIsIGwgPSBuIC0gdCwgcyA9IE1hdGgubWluKG8sIGwpLCBjID0gdGhpcy5zbGljZShyLCBpKSwgdSA9IGUuc2xpY2UodCwgbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAwOyBzID4gZjsgKytmKWlmIChjW2ZdICE9PSB1W2ZdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gY1tmXSwgbCA9IHVbZl07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsID4gbyA/IC0xIDogbyA+IGwgPyAxIDogMFxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCA/IChuID0gdCwgdCA9IDApIDogdCA+IDIxNDc0ODM2NDcgPyB0ID0gMjE0NzQ4MzY0NyA6IC0yMTQ3NDgzNjQ4ID4gdCAmJiAodCA9IC0yMTQ3NDgzNjQ4KSwgdCA+Pj0gMCwgMCA9PT0gdGhpcy5sZW5ndGgpcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAodCA+PSB0aGlzLmxlbmd0aClyZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwID4gdCAmJiAodCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoICsgdCwgMCkpLCBcInN0cmluZ1wiID09IHR5cGVvZiBlICYmIChlID0gYS5mcm9tKGUsIG4pKSwgYS5pc0J1ZmZlcihlKSlyZXR1cm4gMCA9PT0gZS5sZW5ndGggPyAtMSA6IGIodGhpcywgZSwgdCwgbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBlKXJldHVybiBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgXCJmdW5jdGlvblwiID09PSBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID8gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIGUsIHQpIDogYih0aGlzLCBbZV0sIHQsIG4pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpXG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgIT09IHRoaXMuaW5kZXhPZihlLCB0LCBuKVxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gdCkgciA9IFwidXRmOFwiLCBuID0gdGhpcy5sZW5ndGgsIHQgPSAwOyBlbHNlIGlmICh2b2lkIDAgPT09IG4gJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkgciA9IHQsIG4gPSB0aGlzLmxlbmd0aCwgdCA9IDA7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZSh0KSl0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAwIHwgdCwgaXNGaW5pdGUobikgPyAobiA9IDAgfCBuLCB2b2lkIDAgPT09IHIgJiYgKHIgPSBcInV0ZjhcIikpIDogKHIgPSBuLCBuID0gdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSB0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHZvaWQgMCA9PT0gbiB8fCBuID4gaSkgJiYgKG4gPSBpKSwgZS5sZW5ndGggPiAwICYmICgwID4gbiB8fCAwID4gdCkgfHwgdCA+IHRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIik7XG4gICAgICAgICAgICAgICAgICAgIHIgfHwgKHIgPSBcInV0ZjhcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG8gPSAhMTsgOylzd2l0Y2ggKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcImhleFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3KHRoaXMsIGUsIHQsIG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwidXRmOFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwidXRmLThcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gayh0aGlzLCBlLCB0LCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcImFzY2lpXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFModGhpcywgZSwgdCwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJiaW5hcnlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQyh0aGlzLCBlLCB0LCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcImJhc2U2NFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBMKHRoaXMsIGUsIHQsIG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwidWNzMlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwidWNzLTJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcInV0ZjE2bGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcInV0Zi0xNmxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFQodGhpcywgZSwgdCwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIiArIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAoXCJcIiArIHIpLnRvTG93ZXJDYXNlKCksIG8gPSAhMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiQnVmZmVyXCIsIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKX1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBRID0gNDA5NjtcbiAgICAgICAgICAgICAgICBhLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGUgPSB+fmUsIHQgPSB2b2lkIDAgPT09IHQgPyBuIDogfn50LCAwID4gZSA/IChlICs9IG4sIDAgPiBlICYmIChlID0gMCkpIDogZSA+IG4gJiYgKGUgPSBuKSwgMCA+IHQgPyAodCArPSBuLCAwID4gdCAmJiAodCA9IDApKSA6IHQgPiBuICYmICh0ID0gbiksIGUgPiB0ICYmICh0ID0gZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYS5UWVBFRF9BUlJBWV9TVVBQT1JUKSByID0gdGhpcy5zdWJhcnJheShlLCB0KSwgci5fX3Byb3RvX18gPSBhLnByb3RvdHlwZTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHQgLSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IG5ldyBhKGksIHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0gMDsgaSA+IG87IG8rKylyW29dID0gdGhpc1tvICsgZV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gclxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBlID0gMCB8IGUsIHQgPSAwIHwgdCwgbiB8fCBSKGUsIHQsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IHRoaXNbZV0sIGkgPSAxLCBvID0gMDsgKytvIDwgdCAmJiAoaSAqPSAyNTYpOylyICs9IHRoaXNbZSArIG9dICogaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJcbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IDAgfCBlLCB0ID0gMCB8IHQsIG4gfHwgUihlLCB0LCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSB0aGlzW2UgKyAtLXRdLCBpID0gMTsgdCA+IDAgJiYgKGkgKj0gMjU2KTspciArPSB0aGlzW2UgKyAtLXRdICogaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJcbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCB8fCBSKGUsIDEsIHRoaXMubGVuZ3RoKSwgdGhpc1tlXVxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0IHx8IFIoZSwgMiwgdGhpcy5sZW5ndGgpLCB0aGlzW2VdIHwgdGhpc1tlICsgMV0gPDwgOFxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0IHx8IFIoZSwgMiwgdGhpcy5sZW5ndGgpLCB0aGlzW2VdIDw8IDggfCB0aGlzW2UgKyAxXVxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0IHx8IFIoZSwgNCwgdGhpcy5sZW5ndGgpLCAodGhpc1tlXSB8IHRoaXNbZSArIDFdIDw8IDggfCB0aGlzW2UgKyAyXSA8PCAxNikgKyAxNjc3NzIxNiAqIHRoaXNbZSArIDNdXG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgfHwgUihlLCA0LCB0aGlzLmxlbmd0aCksIDE2Nzc3MjE2ICogdGhpc1tlXSArICh0aGlzW2UgKyAxXSA8PCAxNiB8IHRoaXNbZSArIDJdIDw8IDggfCB0aGlzW2UgKyAzXSlcbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBlID0gMCB8IGUsIHQgPSAwIHwgdCwgbiB8fCBSKGUsIHQsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IHRoaXNbZV0sIGkgPSAxLCBvID0gMDsgKytvIDwgdCAmJiAoaSAqPSAyNTYpOylyICs9IHRoaXNbZSArIG9dICogaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKj0gMTI4LCByID49IGkgJiYgKHIgLT0gTWF0aC5wb3coMiwgOCAqIHQpKSwgclxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSAwIHwgZSwgdCA9IDAgfCB0LCBuIHx8IFIoZSwgdCwgdGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gdCwgaSA9IDEsIG8gPSB0aGlzW2UgKyAtLXJdOyByID4gMCAmJiAoaSAqPSAyNTYpOylvICs9IHRoaXNbZSArIC0tcl0gKiBpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAqPSAxMjgsIG8gPj0gaSAmJiAobyAtPSBNYXRoLnBvdygyLCA4ICogdCkpLCBvXG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCB8fCBSKGUsIDEsIHRoaXMubGVuZ3RoKSwgMTI4ICYgdGhpc1tlXSA/IC0xICogKDI1NSAtIHRoaXNbZV0gKyAxKSA6IHRoaXNbZV1cbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHQgfHwgUihlLCAyLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpc1tlXSB8IHRoaXNbZSArIDFdIDw8IDg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzMjc2OCAmIG4gPyA0Mjk0OTAxNzYwIHwgbiA6IG5cbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHQgfHwgUihlLCAyLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpc1tlICsgMV0gfCB0aGlzW2VdIDw8IDg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzMjc2OCAmIG4gPyA0Mjk0OTAxNzYwIHwgbiA6IG5cbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0IHx8IFIoZSwgNCwgdGhpcy5sZW5ndGgpLCB0aGlzW2VdIHwgdGhpc1tlICsgMV0gPDwgOCB8IHRoaXNbZSArIDJdIDw8IDE2IHwgdGhpc1tlICsgM10gPDwgMjRcbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0IHx8IFIoZSwgNCwgdGhpcy5sZW5ndGgpLCB0aGlzW2VdIDw8IDI0IHwgdGhpc1tlICsgMV0gPDwgMTYgfCB0aGlzW2UgKyAyXSA8PCA4IHwgdGhpc1tlICsgM11cbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0IHx8IFIoZSwgNCwgdGhpcy5sZW5ndGgpLCBaLnJlYWQodGhpcywgZSwgITAsIDIzLCA0KVxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgfHwgUihlLCA0LCB0aGlzLmxlbmd0aCksIFoucmVhZCh0aGlzLCBlLCAhMSwgMjMsIDQpXG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgfHwgUihlLCA4LCB0aGlzLmxlbmd0aCksIFoucmVhZCh0aGlzLCBlLCAhMCwgNTIsIDgpXG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgfHwgUihlLCA4LCB0aGlzLmxlbmd0aCksIFoucmVhZCh0aGlzLCBlLCAhMSwgNTIsIDgpXG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSA9ICtlLCB0ID0gMCB8IHQsIG4gPSAwIHwgbiwgIXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gTWF0aC5wb3coMiwgOCAqIG4pIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEQodGhpcywgZSwgdCwgbiwgaSwgMClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IDEsIGEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHRoaXNbdF0gPSAyNTUgJiBlOyArK2EgPCBuICYmIChvICo9IDI1Nik7KXRoaXNbdCArIGFdID0gZSAvIG8gJiAyNTU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ICsgblxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPSArZSwgdCA9IDAgfCB0LCBuID0gMCB8IG4sICFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IE1hdGgucG93KDIsIDggKiBuKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBEKHRoaXMsIGUsIHQsIG4sIGksIDApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBuIC0gMSwgYSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodGhpc1t0ICsgb10gPSAyNTUgJiBlOyAtLW8gPj0gMCAmJiAoYSAqPSAyNTYpOyl0aGlzW3QgKyBvXSA9IGUgLyBhICYgMjU1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCArIG5cbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPSArZSwgdCA9IDAgfCB0LCBuIHx8IEQodGhpcywgZSwgdCwgMSwgMjU1LCAwKSwgYS5UWVBFRF9BUlJBWV9TVVBQT1JUIHx8IChlID0gTWF0aC5mbG9vcihlKSksIHRoaXNbdF0gPSAyNTUgJiBlLCB0ICsgMVxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA9ICtlLCB0ID0gMCB8IHQsIG4gfHwgRCh0aGlzLCBlLCB0LCAyLCA2NTUzNSwgMCksIGEuVFlQRURfQVJSQVlfU1VQUE9SVCA/ICh0aGlzW3RdID0gMjU1ICYgZSwgdGhpc1t0ICsgMV0gPSBlID4+PiA4KSA6IEgodGhpcywgZSwgdCwgITApLCB0ICsgMlxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA9ICtlLCB0ID0gMCB8IHQsIG4gfHwgRCh0aGlzLCBlLCB0LCAyLCA2NTUzNSwgMCksIGEuVFlQRURfQVJSQVlfU1VQUE9SVCA/ICh0aGlzW3RdID0gZSA+Pj4gOCwgdGhpc1t0ICsgMV0gPSAyNTUgJiBlKSA6IEgodGhpcywgZSwgdCwgITEpLCB0ICsgMlxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA9ICtlLCB0ID0gMCB8IHQsIG4gfHwgRCh0aGlzLCBlLCB0LCA0LCA0Mjk0OTY3Mjk1LCAwKSwgYS5UWVBFRF9BUlJBWV9TVVBQT1JUID8gKHRoaXNbdCArIDNdID0gZSA+Pj4gMjQsIHRoaXNbdCArIDJdID0gZSA+Pj4gMTYsIHRoaXNbdCArIDFdID0gZSA+Pj4gOCwgdGhpc1t0XSA9IDI1NSAmIGUpIDogVyh0aGlzLCBlLCB0LCAhMCksIHQgKyA0XG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlID0gK2UsIHQgPSAwIHwgdCwgbiB8fCBEKHRoaXMsIGUsIHQsIDQsIDQyOTQ5NjcyOTUsIDApLCBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgPyAodGhpc1t0XSA9IGUgPj4+IDI0LCB0aGlzW3QgKyAxXSA9IGUgPj4+IDE2LCB0aGlzW3QgKyAyXSA9IGUgPj4+IDgsIHRoaXNbdCArIDNdID0gMjU1ICYgZSkgOiBXKHRoaXMsIGUsIHQsICExKSwgdCArIDRcbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPSArZSwgdCA9IDAgfCB0LCAhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBNYXRoLnBvdygyLCA4ICogbiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgRCh0aGlzLCBlLCB0LCBuLCBpIC0gMSwgLWkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSAwLCBhID0gMSwgbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodGhpc1t0XSA9IDI1NSAmIGU7ICsrbyA8IG4gJiYgKGEgKj0gMjU2KTspMCA+IGUgJiYgMCA9PT0gbCAmJiAwICE9PSB0aGlzW3QgKyBvIC0gMV0gJiYgKGwgPSAxKSwgdGhpc1t0ICsgb10gPSAoZSAvIGEgPj4gMCkgLSBsICYgMjU1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCArIG5cbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPSArZSwgdCA9IDAgfCB0LCAhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBNYXRoLnBvdygyLCA4ICogbiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgRCh0aGlzLCBlLCB0LCBuLCBpIC0gMSwgLWkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBuIC0gMSwgYSA9IDEsIGwgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHRoaXNbdCArIG9dID0gMjU1ICYgZTsgLS1vID49IDAgJiYgKGEgKj0gMjU2KTspMCA+IGUgJiYgMCA9PT0gbCAmJiAwICE9PSB0aGlzW3QgKyBvICsgMV0gJiYgKGwgPSAxKSwgdGhpc1t0ICsgb10gPSAoZSAvIGEgPj4gMCkgLSBsICYgMjU1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCArIG5cbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA9ICtlLCB0ID0gMCB8IHQsIG4gfHwgRCh0aGlzLCBlLCB0LCAxLCAxMjcsIC0xMjgpLCBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgfHwgKGUgPSBNYXRoLmZsb29yKGUpKSwgMCA+IGUgJiYgKGUgPSAyNTUgKyBlICsgMSksIHRoaXNbdF0gPSAyNTUgJiBlLCB0ICsgMVxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlID0gK2UsIHQgPSAwIHwgdCwgbiB8fCBEKHRoaXMsIGUsIHQsIDIsIDMyNzY3LCAtMzI3NjgpLCBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgPyAodGhpc1t0XSA9IDI1NSAmIGUsIHRoaXNbdCArIDFdID0gZSA+Pj4gOCkgOiBIKHRoaXMsIGUsIHQsICEwKSwgdCArIDJcbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA9ICtlLCB0ID0gMCB8IHQsIG4gfHwgRCh0aGlzLCBlLCB0LCAyLCAzMjc2NywgLTMyNzY4KSwgYS5UWVBFRF9BUlJBWV9TVVBQT1JUID8gKHRoaXNbdF0gPSBlID4+PiA4LCB0aGlzW3QgKyAxXSA9IDI1NSAmIGUpIDogSCh0aGlzLCBlLCB0LCAhMSksIHQgKyAyXG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPSArZSwgdCA9IDAgfCB0LCBuIHx8IEQodGhpcywgZSwgdCwgNCwgMjE0NzQ4MzY0NywgLTIxNDc0ODM2NDgpLCBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgPyAodGhpc1t0XSA9IDI1NSAmIGUsIHRoaXNbdCArIDFdID0gZSA+Pj4gOCwgdGhpc1t0ICsgMl0gPSBlID4+PiAxNiwgdGhpc1t0ICsgM10gPSBlID4+PiAyNCkgOiBXKHRoaXMsIGUsIHQsICEwKSwgdCArIDRcbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA9ICtlLCB0ID0gMCB8IHQsIG4gfHwgRCh0aGlzLCBlLCB0LCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCksIDAgPiBlICYmIChlID0gNDI5NDk2NzI5NSArIGUgKyAxKSwgYS5UWVBFRF9BUlJBWV9TVVBQT1JUID8gKHRoaXNbdF0gPSBlID4+PiAyNCwgdGhpc1t0ICsgMV0gPSBlID4+PiAxNiwgdGhpc1t0ICsgMl0gPSBlID4+PiA4LCB0aGlzW3QgKyAzXSA9IDI1NSAmIGUpIDogVyh0aGlzLCBlLCB0LCAhMSksIHQgKyA0XG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8odGhpcywgZSwgdCwgITAsIG4pXG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8odGhpcywgZSwgdCwgITEsIG4pXG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGKHRoaXMsIGUsIHQsICEwLCBuKVxuICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRih0aGlzLCBlLCB0LCAhMSwgbilcbiAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gfHwgKG4gPSAwKSwgciB8fCAwID09PSByIHx8IChyID0gdGhpcy5sZW5ndGgpLCB0ID49IGUubGVuZ3RoICYmICh0ID0gZS5sZW5ndGgpLCB0IHx8ICh0ID0gMCksIHIgPiAwICYmIG4gPiByICYmIChyID0gbiksIHIgPT09IG4pcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBlLmxlbmd0aCB8fCAwID09PSB0aGlzLmxlbmd0aClyZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPiB0KXRocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPiBuIHx8IG4gPj0gdGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA+IHIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgciA+IHRoaXMubGVuZ3RoICYmIChyID0gdGhpcy5sZW5ndGgpLCBlLmxlbmd0aCAtIHQgPCByIC0gbiAmJiAociA9IGUubGVuZ3RoIC0gdCArIG4pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgbyA9IHIgLSBuO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gZSAmJiB0ID4gbiAmJiByID4gdClmb3IgKGkgPSBvIC0gMTsgaSA+PSAwOyBpLS0pZVtpICsgdF0gPSB0aGlzW2kgKyBuXTsgZWxzZSBpZiAoMWUzID4gbyB8fCAhYS5UWVBFRF9BUlJBWV9TVVBQT1JUKWZvciAoaSA9IDA7IG8gPiBpOyBpKyspZVtpICsgdF0gPSB0aGlzW2kgKyBuXTsgZWxzZSBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChlLCB0aGlzLnN1YmFycmF5KG4sIG4gKyBvKSwgdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvXG4gICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCA/IChyID0gdCwgdCA9IDAsIG4gPSB0aGlzLmxlbmd0aCkgOiBcInN0cmluZ1wiID09IHR5cGVvZiBuICYmIChyID0gbiwgbiA9IHRoaXMubGVuZ3RoKSwgMSA9PT0gZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGUuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNTYgPiBpICYmIChlID0gaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHIgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByICYmICFhLmlzRW5jb2RpbmcocikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgcilcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXCJudW1iZXJcIiA9PSB0eXBlb2YgZSAmJiAoZSA9IDI1NSAmIGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA+IHQgfHwgdGhpcy5sZW5ndGggPCB0IHx8IHRoaXMubGVuZ3RoIDwgbil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPj0gbilyZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdCA+Pj49IDAsIG4gPSB2b2lkIDAgPT09IG4gPyB0aGlzLmxlbmd0aCA6IG4gPj4+IDAsIGUgfHwgKGUgPSAwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG87XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBlKWZvciAobyA9IHQ7IG4gPiBvOyBvKyspdGhpc1tvXSA9IGU7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBhLmlzQnVmZmVyKGUpID8gZSA6IHEobmV3IGEoZSwgcikudG9TdHJpbmcoKSksIHMgPSBsLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobyA9IDA7IG4gLSB0ID4gbzsgbysrKXRoaXNbbyArIHRdID0gbFtvICUgc11cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGVlID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMsIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGdsb2JhbCA/IGdsb2JhbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgPyBzZWxmIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDoge30pXG4gICAgICAgIH0sIHtcImJhc2U2NC1qc1wiOiAxLCBpZWVlNzU0OiAxNSwgaXNhcnJheTogMTZ9XSxcbiAgICAgICAgNDogW2Z1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHIoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlID0gZSB8fCB7fSwgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlLmNvZGVNaXJyb3JJbnN0YW5jZSB8fCBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUuY29kZU1pcnJvckluc3RhbmNlLmRlZmluZU1vZGUgPyB2b2lkIGNvbnNvbGUubG9nKFwiQ29kZU1pcnJvciBTcGVsbCBDaGVja2VyOiBZb3UgbXVzdCBwcm92aWRlIGFuIGluc3RhbmNlIG9mIENvZGVNaXJyb3IgdmlhIHRoZSBvcHRpb24gYGNvZGVNaXJyb3JJbnN0YW5jZWBcIikgOiAoU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyB8fCAoU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xICE9PSBTdHJpbmcucHJvdG90eXBlLmluZGV4T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIH0pLCB2b2lkIGUuY29kZU1pcnJvckluc3RhbmNlLmRlZmluZU1vZGUoXCJzcGVsbC1jaGVja2VyXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghci5hZmZfbG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgci5hZmZfbG9hZGluZyA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLm9wZW4oXCJHRVRcIiwgXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvY29kZW1pcnJvci5zcGVsbC1jaGVja2VyL2xhdGVzdC9lbl9VUy5hZmZcIiwgITApLCBuLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0ID09PSBuLnJlYWR5U3RhdGUgJiYgMjAwID09PSBuLnN0YXR1cyAmJiAoci5hZmZfZGF0YSA9IG4ucmVzcG9uc2VUZXh0LCByLm51bV9sb2FkZWQrKywgMiA9PSByLm51bV9sb2FkZWQgJiYgKHIudHlwbyA9IG5ldyBpKFwiZW5fVVNcIiwgci5hZmZfZGF0YSwgci5kaWNfZGF0YSwge3BsYXRmb3JtOiBcImFueVwifSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgbi5zZW5kKG51bGwpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyLmRpY19sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByLmRpY19sb2FkaW5nID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG5ldyBYTUxIdHRwUmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ub3BlbihcIkdFVFwiLCBcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9jb2RlbWlycm9yLnNwZWxsLWNoZWNrZXIvbGF0ZXN0L2VuX1VTLmRpY1wiLCAhMCksIG8ub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgPT09IG8ucmVhZHlTdGF0ZSAmJiAyMDAgPT09IG8uc3RhdHVzICYmIChyLmRpY19kYXRhID0gby5yZXNwb25zZVRleHQsIHIubnVtX2xvYWRlZCsrLCAyID09IHIubnVtX2xvYWRlZCAmJiAoci50eXBvID0gbmV3IGkoXCJlbl9VU1wiLCByLmFmZl9kYXRhLCByLmRpY19kYXRhLCB7cGxhdGZvcm06IFwiYW55XCJ9KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBvLnNlbmQobnVsbClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9ICchXCIjJCUmKCkqKywtLi86Ozw9Pj9AW1xcXFxdXl9ge3x9fiAnLCBsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLnBlZWsoKSwgbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEuaW5jbHVkZXModCkpcmV0dXJuIGUubmV4dCgpLCBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBudWxsICE9ICh0ID0gZS5wZWVrKCkpICYmICFhLmluY2x1ZGVzKHQpOyluICs9IHQsIGUubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByLnR5cG8gJiYgIXIudHlwby5jaGVjayhuKSA/IFwic3BlbGwtZXJyb3JcIiA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgcyA9IGUuY29kZU1pcnJvckluc3RhbmNlLmdldE1vZGUodCwgdC5iYWNrZHJvcCB8fCBcInRleHQvcGxhaW5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmNvZGVNaXJyb3JJbnN0YW5jZS5vdmVybGF5TW9kZShzLCBsLCAhMClcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGkgPSBlKFwidHlwby1qc1wiKTtcbiAgICAgICAgICAgIHIubnVtX2xvYWRlZCA9IDAsIHIuYWZmX2xvYWRpbmcgPSAhMSwgci5kaWNfbG9hZGluZyA9ICExLCByLmFmZl9kYXRhID0gXCJcIiwgci5kaWNfZGF0YSA9IFwiXCIsIHIudHlwbywgdC5leHBvcnRzID0gclxuICAgICAgICB9LCB7XCJ0eXBvLWpzXCI6IDE4fV0sXG4gICAgICAgIDU6IFtmdW5jdGlvbiAodCwgbiwgcikge1xuICAgICAgICAgICAgIWZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PSB0eXBlb2YgciAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBuID8gaSh0KFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBlICYmIGUuYW1kID8gZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgaSkgOiBpKENvZGVNaXJyb3IpXG4gICAgICAgICAgICB9KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0YXRlLmZ1bGxTY3JlZW5SZXN0b3JlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdC5zdHlsZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdC5zdHlsZS5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSwgdC5zdHlsZS53aWR0aCA9IFwiXCIsIHQuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCIsIHQuY2xhc3NOYW1lICs9IFwiIENvZGVNaXJyb3ItZnVsbHNjcmVlblwiLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiLCBlLnJlZnJlc2goKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG4oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUuZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdC5jbGFzc05hbWUgPSB0LmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqQ29kZU1pcnJvci1mdWxsc2NyZWVuXFxiLywgXCJcIiksIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS5zdGF0ZS5mdWxsU2NyZWVuUmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgdC5zdHlsZS53aWR0aCA9IG4ud2lkdGgsIHQuc3R5bGUuaGVpZ2h0ID0gbi5oZWlnaHQsIHdpbmRvdy5zY3JvbGxUbyhuLnNjcm9sbExlZnQsIG4uc2Nyb2xsVG9wKSwgZS5yZWZyZXNoKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlLmRlZmluZU9wdGlvbihcImZ1bGxTY3JlZW5cIiwgITEsIGZ1bmN0aW9uIChyLCBpLCBvKSB7XG4gICAgICAgICAgICAgICAgICAgIG8gPT0gZS5Jbml0ICYmIChvID0gITEpLCAhbyAhPSAhaSAmJiAoaSA/IHQocikgOiBuKHIpKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCB7XCIuLi8uLi9saWIvY29kZW1pcnJvclwiOiAxMH1dLFxuICAgICAgICA2OiBbZnVuY3Rpb24gKHQsIG4sIHIpIHtcbiAgICAgICAgICAgICFmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT0gdHlwZW9mIHIgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgbiA/IGkodChcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSAmJiBlLmFtZCA/IGUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIGkpIDogaShDb2RlTWlycm9yKVxuICAgICAgICAgICAgfShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHQoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0YXRlLnBsYWNlaG9sZGVyICYmIChlLnN0YXRlLnBsYWNlaG9sZGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZS5zdGF0ZS5wbGFjZWhvbGRlciksIGUuc3RhdGUucGxhY2Vob2xkZXIgPSBudWxsKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG4oZSkge1xuICAgICAgICAgICAgICAgICAgICB0KGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUuc3RhdGUucGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuICAgICAgICAgICAgICAgICAgICBuLnN0eWxlLmNzc1RleHQgPSBcImhlaWdodDogMDsgb3ZlcmZsb3c6IHZpc2libGVcIiwgbi5jbGFzc05hbWUgPSBcIkNvZGVNaXJyb3ItcGxhY2Vob2xkZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlLmdldE9wdGlvbihcInBsYWNlaG9sZGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09IHR5cGVvZiByICYmIChyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocikpLCBuLmFwcGVuZENoaWxkKHIpLCBlLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShuLCBlLmRpc3BsYXkubGluZVNwYWNlLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIG8oZSkgJiYgbihlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUuZ2V0V3JhcHBlckVsZW1lbnQoKSwgaSA9IG8oZSk7XG4gICAgICAgICAgICAgICAgICAgIHIuY2xhc3NOYW1lID0gci5jbGFzc05hbWUucmVwbGFjZShcIiBDb2RlTWlycm9yLWVtcHR5XCIsIFwiXCIpICsgKGkgPyBcIiBDb2RlTWlycm9yLWVtcHR5XCIgOiBcIlwiKSwgaSA/IG4oZSkgOiB0KGUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxID09PSBlLmxpbmVDb3VudCgpICYmIFwiXCIgPT09IGUuZ2V0TGluZSgwKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGUuZGVmaW5lT3B0aW9uKFwicGxhY2Vob2xkZXJcIiwgXCJcIiwgZnVuY3Rpb24gKG4sIG8sIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBhICYmIGEgIT0gZS5Jbml0O1xuICAgICAgICAgICAgICAgICAgICBpZiAobyAmJiAhbCkgbi5vbihcImJsdXJcIiwgciksIG4ub24oXCJjaGFuZ2VcIiwgaSksIG4ub24oXCJzd2FwRG9jXCIsIGkpLCBpKG4pOyBlbHNlIGlmICghbyAmJiBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLm9mZihcImJsdXJcIiwgciksIG4ub2ZmKFwiY2hhbmdlXCIsIGkpLCBuLm9mZihcInN3YXBEb2NcIiwgaSksIHQobik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG4uZ2V0V3JhcHBlckVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuY2xhc3NOYW1lID0gcy5jbGFzc05hbWUucmVwbGFjZShcIiBDb2RlTWlycm9yLWVtcHR5XCIsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbyAmJiAhbi5oYXNGb2N1cygpICYmIHIobilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwge1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIjogMTB9XSxcbiAgICAgICAgNzogW2Z1bmN0aW9uICh0LCBuLCByKSB7XG4gICAgICAgICAgICAhZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09IHR5cGVvZiByICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG4gPyBpKHQoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSkgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgJiYgZS5hbWQgPyBlKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBpKSA6IGkoQ29kZU1pcnJvcilcbiAgICAgICAgICAgIH0oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IC9eKFxccyopKD5bPiBdKnxbKistXVxcc3woXFxkKykoWy4pXSkpKFxccyopLywgbiA9IC9eKFxccyopKD5bPiBdKnxbKistXXwoXFxkKylbLildKShcXHMqKSQvLFxuICAgICAgICAgICAgICAgICAgICByID0gL1sqKy1dXFxzLztcbiAgICAgICAgICAgICAgICBlLmNvbW1hbmRzLm5ld2xpbmVBbmRJbmRlbnRDb250aW51ZU1hcmtkb3duTGlzdCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpLmdldE9wdGlvbihcImRpc2FibGVJbnB1dFwiKSlyZXR1cm4gZS5QYXNzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0gaS5saXN0U2VsZWN0aW9ucygpLCBhID0gW10sIGwgPSAwOyBsIDwgby5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBvW2xdLmhlYWQsIGMgPSBpLmdldFN0YXRlQWZ0ZXIocy5saW5lKSwgdSA9IGMubGlzdCAhPT0gITEsIGYgPSAwICE9PSBjLnF1b3RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBpLmdldExpbmUocy5saW5lKSwgZCA9IHQuZXhlYyhoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb1tsXS5lbXB0eSgpIHx8ICF1ICYmICFmIHx8ICFkKXJldHVybiB2b2lkIGkuZXhlY0NvbW1hbmQoXCJuZXdsaW5lQW5kSW5kZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4udGVzdChoKSkgaS5yZXBsYWNlUmFuZ2UoXCJcIiwge2xpbmU6IHMubGluZSwgY2g6IDB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoOiBzLmNoICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIGFbbF0gPSBcIlxcblwiOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGRbMV0sIG0gPSBkWzVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gci50ZXN0KGRbMl0pIHx8IGRbMl0uaW5kZXhPZihcIj5cIikgPj0gMCA/IGRbMl0gOiBwYXJzZUludChkWzNdLCAxMCkgKyAxICsgZFs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2xdID0gXCJcXG5cIiArIHAgKyBnICsgbVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGkucmVwbGFjZVNlbGVjdGlvbnMoYSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCB7XCIuLi8uLi9saWIvY29kZW1pcnJvclwiOiAxMH1dLFxuICAgICAgICA4OiBbZnVuY3Rpb24gKHQsIG4sIHIpIHtcbiAgICAgICAgICAgICFmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT0gdHlwZW9mIHIgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgbiA/IGkodChcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSAmJiBlLmFtZCA/IGUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIGkpIDogaShDb2RlTWlycm9yKVxuICAgICAgICAgICAgfShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgICAgIGUub3ZlcmxheU1vZGUgPSBmdW5jdGlvbiAodCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U6IGUuc3RhcnRTdGF0ZSh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheTogZS5zdGFydFN0YXRlKG4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlUG9zOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlQ3VyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5UG9zOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5Q3VyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1TZWVuOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29weVN0YXRlOiBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U6IGUuY29weVN0YXRlKHQsIHIuYmFzZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXk6IGUuY29weVN0YXRlKG4sIHIub3ZlcmxheSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VQb3M6IHIuYmFzZVBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZUN1cjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheVBvczogci5vdmVybGF5UG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5Q3VyOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdG9rZW46IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlICE9IGkuc3RyZWFtU2VlbiB8fCBNYXRoLm1pbihpLmJhc2VQb3MsIGkub3ZlcmxheVBvcykgPCBlLnN0YXJ0KSAmJiAoaS5zdHJlYW1TZWVuID0gZSwgaS5iYXNlUG9zID0gaS5vdmVybGF5UG9zID0gZS5zdGFydCksIGUuc3RhcnQgPT0gaS5iYXNlUG9zICYmIChpLmJhc2VDdXIgPSB0LnRva2VuKGUsIGkuYmFzZSksIGkuYmFzZVBvcyA9IGUucG9zKSwgZS5zdGFydCA9PSBpLm92ZXJsYXlQb3MgJiYgKGUucG9zID0gZS5zdGFydCwgaS5vdmVybGF5Q3VyID0gbi50b2tlbihlLCBpLm92ZXJsYXkpLCBpLm92ZXJsYXlQb3MgPSBlLnBvcyksIGUucG9zID0gTWF0aC5taW4oaS5iYXNlUG9zLCBpLm92ZXJsYXlQb3MpLCBudWxsID09IGkub3ZlcmxheUN1ciA/IGkuYmFzZUN1ciA6IG51bGwgIT0gaS5iYXNlQ3VyICYmIGkub3ZlcmxheS5jb21iaW5lVG9rZW5zIHx8IHIgJiYgbnVsbCA9PSBpLm92ZXJsYXkuY29tYmluZVRva2VucyA/IGkuYmFzZUN1ciArIFwiIFwiICsgaS5vdmVybGF5Q3VyIDogaS5vdmVybGF5Q3VyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBpbmRlbnQ6IHQuaW5kZW50ICYmIGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuaW5kZW50KGUuYmFzZSwgbilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGVsZWN0cmljQ2hhcnM6IHQuZWxlY3RyaWNDaGFycywgaW5uZXJNb2RlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7c3RhdGU6IGUuYmFzZSwgbW9kZTogdH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGJsYW5rTGluZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmJsYW5rTGluZSAmJiB0LmJsYW5rTGluZShlLmJhc2UpLCBuLmJsYW5rTGluZSAmJiBuLmJsYW5rTGluZShlLm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCB7XCIuLi8uLi9saWIvY29kZW1pcnJvclwiOiAxMH1dLFxuICAgICAgICA5OiBbZnVuY3Rpb24gKHQsIG4sIHIpIHtcbiAgICAgICAgICAgICFmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT0gdHlwZW9mIHIgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgbiA/IGkodChcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSAmJiBlLmFtZCA/IGUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIGkpIDogaShDb2RlTWlycm9yKVxuICAgICAgICAgICAgfShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHQoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhKGUpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RhdGUubWFya2VkU2VsZWN0aW9uLmxlbmd0aCAmJiBlLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKGUpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcihlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwICE9IGModCwgbikpZm9yICh2YXIgaSA9IGUuc3RhdGUubWFya2VkU2VsZWN0aW9uLCBvID0gZS5zdGF0ZS5tYXJrZWRTZWxlY3Rpb25TdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gdC5saW5lOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGEgPT0gdC5saW5lID8gdCA6IHMoYSwgMCksIGYgPSBhICsgbCwgaCA9IGYgPj0gbi5saW5lLCBkID0gaCA/IG4gOiBzKGYsIDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBlLm1hcmtUZXh0KHUsIGQsIHtjbGFzc05hbWU6IG99KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IHIgPyBpLnB1c2gocCkgOiBpLnNwbGljZShyKyssIDAsIHApLCBoKWJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGZcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gZS5zdGF0ZS5tYXJrZWRTZWxlY3Rpb24sIG4gPSAwOyBuIDwgdC5sZW5ndGg7ICsrbil0W25dLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHQubGVuZ3RoID0gMFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG8oZSkge1xuICAgICAgICAgICAgICAgICAgICBpKGUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gZS5saXN0U2VsZWN0aW9ucygpLCBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspcihlLCB0W25dLmZyb20oKSwgdFtuXS50bygpKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGEoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWUuc29tZXRoaW5nU2VsZWN0ZWQoKSlyZXR1cm4gaShlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubGlzdFNlbGVjdGlvbnMoKS5sZW5ndGggPiAxKXJldHVybiBvKGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUuZ2V0Q3Vyc29yKFwic3RhcnRcIiksIG4gPSBlLmdldEN1cnNvcihcImVuZFwiKSwgYSA9IGUuc3RhdGUubWFya2VkU2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWEubGVuZ3RoKXJldHVybiByKGUsIHQsIG4pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGFbMF0uZmluZCgpLCB1ID0gYVthLmxlbmd0aCAtIDFdLmZpbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzIHx8ICF1IHx8IG4ubGluZSAtIHQubGluZSA8IGwgfHwgYyh0LCB1LnRvKSA+PSAwIHx8IGMobiwgcy5mcm9tKSA8PSAwKXJldHVybiBvKGUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgYyh0LCBzLmZyb20pID4gMDspYS5zaGlmdCgpLmNsZWFyKCksIHMgPSBhWzBdLmZpbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjKHQsIHMuZnJvbSkgPCAwICYmIChzLnRvLmxpbmUgLSB0LmxpbmUgPCBsID8gKGEuc2hpZnQoKS5jbGVhcigpLCByKGUsIHQsIHMudG8sIDApKSA6IHIoZSwgdCwgcy5mcm9tLCAwKSk7IGMobiwgdS50bykgPCAwOylhLnBvcCgpLmNsZWFyKCksIHUgPSBhW2EubGVuZ3RoIC0gMV0uZmluZCgpO1xuICAgICAgICAgICAgICAgICAgICBjKG4sIHUudG8pID4gMCAmJiAobi5saW5lIC0gdS5mcm9tLmxpbmUgPCBsID8gKGEucG9wKCkuY2xlYXIoKSwgcihlLCB1LmZyb20sIG4pKSA6IHIoZSwgdS50bywgbikpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZS5kZWZpbmVPcHRpb24oXCJzdHlsZVNlbGVjdGVkVGV4dFwiLCAhMSwgZnVuY3Rpb24gKHIsIGEsIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBsICYmIGwgIT0gZS5Jbml0O1xuICAgICAgICAgICAgICAgICAgICBhICYmICFzID8gKHIuc3RhdGUubWFya2VkU2VsZWN0aW9uID0gW10sIHIuc3RhdGUubWFya2VkU2VsZWN0aW9uU3R5bGUgPSBcInN0cmluZ1wiID09IHR5cGVvZiBhID8gYSA6IFwiQ29kZU1pcnJvci1zZWxlY3RlZHRleHRcIiwgbyhyKSwgci5vbihcImN1cnNvckFjdGl2aXR5XCIsIHQpLCByLm9uKFwiY2hhbmdlXCIsIG4pKSA6ICFhICYmIHMgJiYgKHIub2ZmKFwiY3Vyc29yQWN0aXZpdHlcIiwgdCksIHIub2ZmKFwiY2hhbmdlXCIsIG4pLCBpKHIpLCByLnN0YXRlLm1hcmtlZFNlbGVjdGlvbiA9IHIuc3RhdGUubWFya2VkU2VsZWN0aW9uU3R5bGUgPSBudWxsKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBsID0gOCwgcyA9IGUuUG9zLCBjID0gZS5jbXBQb3NcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIHtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCI6IDEwfV0sXG4gICAgICAgIDEwOiBbZnVuY3Rpb24gKHQsIG4sIHIpIHtcbiAgICAgICAgICAgICFmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiByICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG4pIG4uZXhwb3J0cyA9IHQoKTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgJiYgZS5hbWQpcmV0dXJuIGUoW10sIHQpO1xuICAgICAgICAgICAgICAgICAgICAodGhpcyB8fCB3aW5kb3cpLkNvZGVNaXJyb3IgPSB0KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBlKG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGUpKXJldHVybiBuZXcgZShuLCByKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gciA9IHIgPyBXaShyKSA6IHt9LCBXaShlYSwgciwgITEpLCBkKHIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIGkgJiYgKGkgPSBuZXcgQ2EoaSwgci5tb2RlLCBudWxsLCByLmxpbmVTZXBhcmF0b3IpKSwgdGhpcy5kb2MgPSBpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG5ldyBlLmlucHV0U3R5bGVzW3IuaW5wdXRTdHlsZV0odGhpcyksIGEgPSB0aGlzLmRpc3BsYXkgPSBuZXcgdChuLCBpLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgYS53cmFwcGVyLkNvZGVNaXJyb3IgPSB0aGlzLCBjKHRoaXMpLCBsKHRoaXMpLCByLmxpbmVXcmFwcGluZyAmJiAodGhpcy5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lICs9IFwiIENvZGVNaXJyb3Itd3JhcFwiKSwgci5hdXRvZm9jdXMgJiYgIUFvICYmIGEuaW5wdXQuZm9jdXMoKSwgdih0aGlzKSwgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleU1hcHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZUdlbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0ZTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxheWluZ0JsdXJFdmVudDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c2VkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHByZXNzRWRpdHM6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzdGVJbmNvbWluZzogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXRJbmNvbWluZzogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RpbmdUZXh0OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nVGV4dDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQ6IG5ldyBFaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVNlcTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWxDaGFyczogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHhvICYmIDExID4gYm8gJiYgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLmRpc3BsYXkuaW5wdXQucmVzZXQoITApXG4gICAgICAgICAgICAgICAgICAgIH0sIDIwKSwganQodGhpcyksIEtpKCksIGJ0KHRoaXMpLCB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gITAsIFhyKHRoaXMsIGkpLCByLmF1dG9mb2N1cyAmJiAhQW8gfHwgcy5oYXNGb2N1cygpID8gc2V0VGltZW91dChCaSh2biwgdGhpcyksIDIwKSA6IHluKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB1IGluIHRhKXRhLmhhc093blByb3BlcnR5KHUpICYmIHRhW3VdKHRoaXMsIHJbdV0sIG5hKTtcbiAgICAgICAgICAgICAgICAgICAgayh0aGlzKSwgci5maW5pc2hJbml0ICYmIHIuZmluaXNoSW5pdCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCBhYS5sZW5ndGg7ICsrZilhYVtmXSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAga3QodGhpcyksIHdvICYmIHIubGluZVdyYXBwaW5nICYmIFwib3B0aW1pemVsZWdpYmlsaXR5XCIgPT0gZ2V0Q29tcHV0ZWRTdHlsZShhLmxpbmVEaXYpLnRleHRSZW5kZXJpbmcgJiYgKGEubGluZURpdi5zdHlsZS50ZXh0UmVuZGVyaW5nID0gXCJhdXRvXCIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dCA9IG4sIHIuc2Nyb2xsYmFyRmlsbGVyID0gamkoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLXNjcm9sbGJhci1maWxsZXJcIiksIHIuc2Nyb2xsYmFyRmlsbGVyLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsIFwidHJ1ZVwiKSwgci5ndXR0ZXJGaWxsZXIgPSBqaShcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlclwiKSwgci5ndXR0ZXJGaWxsZXIuc2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIiwgXCJ0cnVlXCIpLCByLmxpbmVEaXYgPSBqaShcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItY29kZVwiKSwgci5zZWxlY3Rpb25EaXYgPSBqaShcImRpdlwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZTsgei1pbmRleDogMVwiKSwgci5jdXJzb3JEaXYgPSBqaShcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItY3Vyc29yc1wiKSwgci5tZWFzdXJlID0gamkoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLW1lYXN1cmVcIiksIHIubGluZU1lYXN1cmUgPSBqaShcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKSwgci5saW5lU3BhY2UgPSBqaShcImRpdlwiLCBbci5tZWFzdXJlLCByLmxpbmVNZWFzdXJlLCByLnNlbGVjdGlvbkRpdiwgci5jdXJzb3JEaXYsIHIubGluZURpdl0sIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlOyBvdXRsaW5lOiBub25lXCIpLCByLm1vdmVyID0gamkoXCJkaXZcIiwgW2ppKFwiZGl2XCIsIFtyLmxpbmVTcGFjZV0sIFwiQ29kZU1pcnJvci1saW5lc1wiKV0sIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlXCIpLCByLnNpemVyID0gamkoXCJkaXZcIiwgW3IubW92ZXJdLCBcIkNvZGVNaXJyb3Itc2l6ZXJcIiksIHIuc2l6ZXJXaWR0aCA9IG51bGwsIHIuaGVpZ2h0Rm9yY2VyID0gamkoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogXCIgKyBEYSArIFwicHg7IHdpZHRoOiAxcHg7XCIpLCByLmd1dHRlcnMgPSBqaShcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyc1wiKSwgci5saW5lR3V0dGVyID0gbnVsbCwgci5zY3JvbGxlciA9IGppKFwiZGl2XCIsIFtyLnNpemVyLCByLmhlaWdodEZvcmNlciwgci5ndXR0ZXJzXSwgXCJDb2RlTWlycm9yLXNjcm9sbFwiKSwgci5zY3JvbGxlci5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCBcIi0xXCIpLCByLndyYXBwZXIgPSBqaShcImRpdlwiLCBbci5zY3JvbGxiYXJGaWxsZXIsIHIuZ3V0dGVyRmlsbGVyLCByLnNjcm9sbGVyXSwgXCJDb2RlTWlycm9yXCIpLCB4byAmJiA4ID4gYm8gJiYgKHIuZ3V0dGVycy5zdHlsZS56SW5kZXggPSAtMSwgci5zY3JvbGxlci5zdHlsZS5wYWRkaW5nUmlnaHQgPSAwKSwgd28gfHwgZ28gJiYgQW8gfHwgKHIuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gITApLCBlICYmIChlLmFwcGVuZENoaWxkID8gZS5hcHBlbmRDaGlsZChyLndyYXBwZXIpIDogZShyLndyYXBwZXIpKSwgci52aWV3RnJvbSA9IHIudmlld1RvID0gdC5maXJzdCwgci5yZXBvcnRlZFZpZXdGcm9tID0gci5yZXBvcnRlZFZpZXdUbyA9IHQuZmlyc3QsIHIudmlldyA9IFtdLCByLnJlbmRlcmVkVmlldyA9IG51bGwsIHIuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGwsIHIudmlld09mZnNldCA9IDAsIHIubGFzdFdyYXBIZWlnaHQgPSByLmxhc3RXcmFwV2lkdGggPSAwLCByLnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbCwgci5uYXRpdmVCYXJXaWR0aCA9IHIuYmFySGVpZ2h0ID0gci5iYXJXaWR0aCA9IDAsIHIuc2Nyb2xsYmFyc0NsaXBwZWQgPSAhMSwgci5saW5lTnVtV2lkdGggPSByLmxpbmVOdW1Jbm5lcldpZHRoID0gci5saW5lTnVtQ2hhcnMgPSBudWxsLCByLmFsaWduV2lkZ2V0cyA9ICExLCByLmNhY2hlZENoYXJXaWR0aCA9IHIuY2FjaGVkVGV4dEhlaWdodCA9IHIuY2FjaGVkUGFkZGluZ0ggPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgci5tYXhMaW5lID0gbnVsbCwgci5tYXhMaW5lTGVuZ3RoID0gMCwgci5tYXhMaW5lQ2hhbmdlZCA9ICExLCByLndoZWVsRFggPSByLndoZWVsRFkgPSByLndoZWVsU3RhcnRYID0gci53aGVlbFN0YXJ0WSA9IG51bGwsIHIuc2hpZnQgPSAhMSwgci5zZWxGb3JDb250ZXh0TWVudSA9IG51bGwsIHIuYWN0aXZlVG91Y2ggPSBudWxsLCBuLmluaXQocilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBuKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5kb2MubW9kZSA9IGUuZ2V0TW9kZSh0Lm9wdGlvbnMsIHQuZG9jLm1vZGVPcHRpb24pLCByKHQpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuZG9jLml0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RhdGVBZnRlciAmJiAoZS5zdGF0ZUFmdGVyID0gbnVsbCksIGUuc3R5bGVzICYmIChlLnN0eWxlcyA9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIH0pLCBlLmRvYy5mcm9udGllciA9IGUuZG9jLmZpcnN0LCBfZShlLCAxMDApLCBlLnN0YXRlLm1vZGVHZW4rKywgZS5jdXJPcCAmJiBEdChlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLm9wdGlvbnMubGluZVdyYXBwaW5nID8gKEphKGUuZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3Itd3JhcFwiKSwgZS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoID0gXCJcIiwgZS5kaXNwbGF5LnNpemVyV2lkdGggPSBudWxsKSA6IChaYShlLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLXdyYXBcIiksIGgoZSkpLCBhKGUpLCBEdChlKSwgbHQoZSksIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeShlKVxuICAgICAgICAgICAgICAgICAgICB9LCAxMDApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0geXQoZS5kaXNwbGF5KSwgbiA9IGUub3B0aW9ucy5saW5lV3JhcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gbiAmJiBNYXRoLm1heCg1LCBlLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGggLyB4dChlLmRpc3BsYXkpIC0gMyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtyKGUuZG9jLCBpKSlyZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpLndpZGdldHMpZm9yICh2YXIgYSA9IDA7IGEgPCBpLndpZGdldHMubGVuZ3RoOyBhKyspaS53aWRnZXRzW2FdLmhlaWdodCAmJiAobyArPSBpLndpZGdldHNbYV0uaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuID8gbyArIChNYXRoLmNlaWwoaS50ZXh0Lmxlbmd0aCAvIHIpIHx8IDEpICogdCA6IG8gKyB0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmRvYywgbiA9IG8oZSk7XG4gICAgICAgICAgICAgICAgICAgIHQuaXRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCAhPSBlLmhlaWdodCAmJiBlaShlLCB0KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgPSBlLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmNtLXMtXFxTKy9nLCBcIlwiKSArIGUub3B0aW9ucy50aGVtZS5yZXBsYWNlKC8oXnxcXHMpXFxzKi9nLCBcIiBjbS1zLVwiKSwgbHQoZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYyhlKSwgRHQoZSksIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyhlKVxuICAgICAgICAgICAgICAgICAgICB9LCAyMClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmRpc3BsYXkuZ3V0dGVycywgbiA9IGUub3B0aW9ucy5ndXR0ZXJzO1xuICAgICAgICAgICAgICAgICAgICBVaSh0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBuLmxlbmd0aDsgKytyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IG5bcl0sIG8gPSB0LmFwcGVuZENoaWxkKGppKFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXIgXCIgKyBpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIiA9PSBpICYmIChlLmRpc3BsYXkubGluZUd1dHRlciA9IG8sIG8uc3R5bGUud2lkdGggPSAoZS5kaXNwbGF5LmxpbmVOdW1XaWR0aCB8fCAxKSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0LnN0eWxlLmRpc3BsYXkgPSByID8gXCJcIiA6IFwibm9uZVwiLCB1KGUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGUuZGlzcGxheS5zaXplci5zdHlsZS5tYXJnaW5MZWZ0ID0gdCArIFwicHhcIlxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PSBlLmhlaWdodClyZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCwgbiA9IGUudGV4dC5sZW5ndGgsIHIgPSBlOyB0ID0gbXIocik7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHQuZmluZCgwLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gaS5mcm9tLmxpbmUsIG4gKz0gaS5mcm9tLmNoIC0gaS50by5jaFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAociA9IGU7IHQgPSBncihyKTspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gdC5maW5kKDAsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gLT0gci50ZXh0Lmxlbmd0aCAtIGkuZnJvbS5jaCwgciA9IGkudG8ubGluZSwgbiArPSByLnRleHQubGVuZ3RoIC0gaS50by5jaFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5kaXNwbGF5LCBuID0gZS5kb2M7XG4gICAgICAgICAgICAgICAgICAgIHQubWF4TGluZSA9IFpyKG4sIG4uZmlyc3QpLCB0Lm1heExpbmVMZW5ndGggPSBmKHQubWF4TGluZSksIHQubWF4TGluZUNoYW5nZWQgPSAhMCwgbi5pdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGYoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuID4gdC5tYXhMaW5lTGVuZ3RoICYmICh0Lm1heExpbmVMZW5ndGggPSBuLCB0Lm1heExpbmUgPSBlKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGQoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IFBpKGUuZ3V0dGVycywgXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIpO1xuICAgICAgICAgICAgICAgICAgICAtMSA9PSB0ICYmIGUubGluZU51bWJlcnMgPyBlLmd1dHRlcnMgPSBlLmd1dHRlcnMuY29uY2F0KFtcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0pIDogdCA+IC0xICYmICFlLmxpbmVOdW1iZXJzICYmIChlLmd1dHRlcnMgPSBlLmd1dHRlcnMuc2xpY2UoMCksIGUuZ3V0dGVycy5zcGxpY2UodCwgMSkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5kaXNwbGF5LCBuID0gdC5ndXR0ZXJzLm9mZnNldFdpZHRoLCByID0gTWF0aC5yb3VuZChlLmRvYy5oZWlnaHQgKyBxZShlLmRpc3BsYXkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudEhlaWdodDogdC5zY3JvbGxlci5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3SGVpZ2h0OiB0LndyYXBwZXIuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsV2lkdGg6IHQuc2Nyb2xsZXIuc2Nyb2xsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRXaWR0aDogdC5zY3JvbGxlci5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdXaWR0aDogdC53cmFwcGVyLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyTGVmdDogZS5vcHRpb25zLmZpeGVkR3V0dGVyID8gbiA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NIZWlnaHQ6IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQ6IHIgKyBZZShlKSArIHQuYmFySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlQmFyV2lkdGg6IHQubmF0aXZlQmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBndXR0ZXJXaWR0aDogblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbShlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY20gPSBuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMudmVydCA9IGppKFwiZGl2XCIsIFtqaShcImRpdlwiLCBudWxsLCBudWxsLCBcIm1pbi13aWR0aDogMXB4XCIpXSwgXCJDb2RlTWlycm9yLXZzY3JvbGxiYXJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy5ob3JpeiA9IGppKFwiZGl2XCIsIFtqaShcImRpdlwiLCBudWxsLCBudWxsLCBcImhlaWdodDogMTAwJTsgbWluLWhlaWdodDogMXB4XCIpXSwgXCJDb2RlTWlycm9yLWhzY3JvbGxiYXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGUociksIGUoaSksIEVhKHIsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuY2xpZW50SGVpZ2h0ICYmIHQoci5zY3JvbGxUb3AsIFwidmVydGljYWxcIilcbiAgICAgICAgICAgICAgICAgICAgfSksIEVhKGksIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuY2xpZW50V2lkdGggJiYgdChpLnNjcm9sbExlZnQsIFwiaG9yaXpvbnRhbFwiKVxuICAgICAgICAgICAgICAgICAgICB9KSwgdGhpcy5jaGVja2VkWmVyb1dpZHRoID0gITEsIHhvICYmIDggPiBibyAmJiAodGhpcy5ob3Jpei5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLnZlcnQuc3R5bGUubWluV2lkdGggPSBcIjE4cHhcIilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHYodCkge1xuICAgICAgICAgICAgICAgICAgICB0LmRpc3BsYXkuc2Nyb2xsYmFycyAmJiAodC5kaXNwbGF5LnNjcm9sbGJhcnMuY2xlYXIoKSwgdC5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MgJiYgWmEodC5kaXNwbGF5LndyYXBwZXIsIHQuZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKSksIHQuZGlzcGxheS5zY3JvbGxiYXJzID0gbmV3IGUuc2Nyb2xsYmFyTW9kZWxbdC5vcHRpb25zLnNjcm9sbGJhclN0eWxlXShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5kaXNwbGF5LndyYXBwZXIuaW5zZXJ0QmVmb3JlKGUsIHQuZGlzcGxheS5zY3JvbGxiYXJGaWxsZXIpLCBFYShlLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5zdGF0ZS5mb2N1c2VkICYmIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmRpc3BsYXkuaW5wdXQuZm9jdXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgZS5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIilcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaG9yaXpvbnRhbFwiID09IG4gPyBvbih0LCBlKSA6IHJuKHQsIGUpXG4gICAgICAgICAgICAgICAgICAgIH0sIHQpLCB0LmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyAmJiBKYSh0LmRpc3BsYXkud3JhcHBlciwgdC5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24geShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHQgfHwgKHQgPSBwKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmRpc3BsYXkuYmFyV2lkdGgsIHIgPSBlLmRpc3BsYXkuYmFySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB4KGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgNCA+IGkgJiYgbiAhPSBlLmRpc3BsYXkuYmFyV2lkdGggfHwgciAhPSBlLmRpc3BsYXkuYmFySGVpZ2h0OyBpKyspbiAhPSBlLmRpc3BsYXkuYmFyV2lkdGggJiYgZS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiBPKGUpLCB4KGUsIHAoZSkpLCBuID0gZS5kaXNwbGF5LmJhcldpZHRoLCByID0gZS5kaXNwbGF5LmJhckhlaWdodFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHgoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUuZGlzcGxheSwgciA9IG4uc2Nyb2xsYmFycy51cGRhdGUodCk7XG4gICAgICAgICAgICAgICAgICAgIG4uc2l6ZXIuc3R5bGUucGFkZGluZ1JpZ2h0ID0gKG4uYmFyV2lkdGggPSByLnJpZ2h0KSArIFwicHhcIiwgbi5zaXplci5zdHlsZS5wYWRkaW5nQm90dG9tID0gKG4uYmFySGVpZ2h0ID0gci5ib3R0b20pICsgXCJweFwiLCBuLmhlaWdodEZvcmNlci5zdHlsZS5ib3JkZXJCb3R0b20gPSByLmJvdHRvbSArIFwicHggc29saWQgdHJhbnNwYXJlbnRcIiwgci5yaWdodCAmJiByLmJvdHRvbSA/IChuLnNjcm9sbGJhckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCBuLnNjcm9sbGJhckZpbGxlci5zdHlsZS5oZWlnaHQgPSByLmJvdHRvbSArIFwicHhcIiwgbi5zY3JvbGxiYXJGaWxsZXIuc3R5bGUud2lkdGggPSByLnJpZ2h0ICsgXCJweFwiKSA6IG4uc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiLCByLmJvdHRvbSAmJiBlLm9wdGlvbnMuY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIgJiYgZS5vcHRpb25zLmZpeGVkR3V0dGVyID8gKG4uZ3V0dGVyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIG4uZ3V0dGVyRmlsbGVyLnN0eWxlLmhlaWdodCA9IHIuYm90dG9tICsgXCJweFwiLCBuLmd1dHRlckZpbGxlci5zdHlsZS53aWR0aCA9IHQuZ3V0dGVyV2lkdGggKyBcInB4XCIpIDogbi5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiXCJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBuICYmIG51bGwgIT0gbi50b3AgPyBNYXRoLm1heCgwLCBuLnRvcCkgOiBlLnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgciA9IE1hdGguZmxvb3IociAtIFVlKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBuICYmIG51bGwgIT0gbi5ib3R0b20gPyBuLmJvdHRvbSA6IHIgKyBlLndyYXBwZXIuY2xpZW50SGVpZ2h0LCBvID0gbmkodCwgciksIGEgPSBuaSh0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gJiYgbi5lbnN1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gbi5lbnN1cmUuZnJvbS5saW5lLCBzID0gbi5lbnN1cmUudG8ubGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPiBsID8gKG8gPSBsLCBhID0gbmkodCwgcmkoWnIodCwgbCkpICsgZS53cmFwcGVyLmNsaWVudEhlaWdodCkpIDogTWF0aC5taW4ocywgdC5sYXN0TGluZSgpKSA+PSBhICYmIChvID0gbmkodCwgcmkoWnIodCwgcykpIC0gZS53cmFwcGVyLmNsaWVudEhlaWdodCksIGEgPSBzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7ZnJvbTogbywgdG86IE1hdGgubWF4KGEsIG8gKyAxKX1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB3KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmRpc3BsYXksIG4gPSB0LnZpZXc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmFsaWduV2lkZ2V0cyB8fCB0Lmd1dHRlcnMuZmlyc3RDaGlsZCAmJiBlLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSBDKHQpIC0gdC5zY3JvbGxlci5zY3JvbGxMZWZ0ICsgZS5kb2Muc2Nyb2xsTGVmdCwgaSA9IHQuZ3V0dGVycy5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSByICsgXCJweFwiLCBhID0gMDsgYSA8IG4ubGVuZ3RoOyBhKyspaWYgKCFuW2FdLmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUub3B0aW9ucy5maXhlZEd1dHRlciAmJiBuW2FdLmd1dHRlciAmJiAoblthXS5ndXR0ZXIuc3R5bGUubGVmdCA9IG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gblthXS5hbGlnbmFibGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwpZm9yICh2YXIgcyA9IDA7IHMgPCBsLmxlbmd0aDsgcysrKWxbc10uc3R5bGUubGVmdCA9IG9cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGUub3B0aW9ucy5maXhlZEd1dHRlciAmJiAodC5ndXR0ZXJzLnN0eWxlLmxlZnQgPSByICsgaSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGsoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWUub3B0aW9ucy5saW5lTnVtYmVycylyZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5kb2MsIG4gPSBTKGUub3B0aW9ucywgdC5maXJzdCArIHQuc2l6ZSAtIDEpLCByID0gZS5kaXNwbGF5O1xuICAgICAgICAgICAgICAgICAgICBpZiAobi5sZW5ndGggIT0gci5saW5lTnVtQ2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gci5tZWFzdXJlLmFwcGVuZENoaWxkKGppKFwiZGl2XCIsIFtqaShcImRpdlwiLCBuKV0sIFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGkuZmlyc3RDaGlsZC5vZmZzZXRXaWR0aCwgYSA9IGkub2Zmc2V0V2lkdGggLSBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IFwiXCIsIHIubGluZU51bUlubmVyV2lkdGggPSBNYXRoLm1heChvLCByLmxpbmVHdXR0ZXIub2Zmc2V0V2lkdGggLSBhKSArIDEsIHIubGluZU51bVdpZHRoID0gci5saW5lTnVtSW5uZXJXaWR0aCArIGEsIHIubGluZU51bUNoYXJzID0gci5saW5lTnVtSW5uZXJXaWR0aCA/IG4ubGVuZ3RoIDogLTEsIHIubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IHIubGluZU51bVdpZHRoICsgXCJweFwiLCB1KGUpLCAhMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFMoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKGUubGluZU51bWJlckZvcm1hdHRlcih0ICsgZS5maXJzdExpbmVOdW1iZXIpKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEMoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gZS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5kaXNwbGF5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdCwgdGhpcy52aXNpYmxlID0gYihyLCBlLmRvYywgdCksIHRoaXMuZWRpdG9ySXNIaWRkZW4gPSAhci53cmFwcGVyLm9mZnNldFdpZHRoLCB0aGlzLndyYXBwZXJIZWlnaHQgPSByLndyYXBwZXIuY2xpZW50SGVpZ2h0LCB0aGlzLndyYXBwZXJXaWR0aCA9IHIud3JhcHBlci5jbGllbnRXaWR0aCwgdGhpcy5vbGREaXNwbGF5V2lkdGggPSAkZShlKSwgdGhpcy5mb3JjZSA9IG4sIHRoaXMuZGltcyA9IFAoZSksIHRoaXMuZXZlbnRzID0gW11cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBUKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgICF0LnNjcm9sbGJhcnNDbGlwcGVkICYmIHQuc2Nyb2xsZXIub2Zmc2V0V2lkdGggJiYgKHQubmF0aXZlQmFyV2lkdGggPSB0LnNjcm9sbGVyLm9mZnNldFdpZHRoIC0gdC5zY3JvbGxlci5jbGllbnRXaWR0aCwgdC5oZWlnaHRGb3JjZXIuc3R5bGUuaGVpZ2h0ID0gWWUoZSkgKyBcInB4XCIsIHQuc2l6ZXIuc3R5bGUubWFyZ2luQm90dG9tID0gLXQubmF0aXZlQmFyV2lkdGggKyBcInB4XCIsIHQuc2l6ZXIuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IFllKGUpICsgXCJweFwiLCB0LnNjcm9sbGJhcnNDbGlwcGVkID0gITApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS5kaXNwbGF5LCByID0gZS5kb2M7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmVkaXRvcklzSGlkZGVuKXJldHVybiBXdChlKSwgITE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdC5mb3JjZSAmJiB0LnZpc2libGUuZnJvbSA+PSBuLnZpZXdGcm9tICYmIHQudmlzaWJsZS50byA8PSBuLnZpZXdUbyAmJiAobnVsbCA9PSBuLnVwZGF0ZUxpbmVOdW1iZXJzIHx8IG4udXBkYXRlTGluZU51bWJlcnMgPj0gbi52aWV3VG8pICYmIG4ucmVuZGVyZWRWaWV3ID09IG4udmlldyAmJiAwID09IHp0KGUpKXJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgayhlKSAmJiAoV3QoZSksIHQuZGltcyA9IFAoZSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHIuZmlyc3QgKyByLnNpemUsIG8gPSBNYXRoLm1heCh0LnZpc2libGUuZnJvbSAtIGUub3B0aW9ucy52aWV3cG9ydE1hcmdpbiwgci5maXJzdCksXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gTWF0aC5taW4oaSwgdC52aXNpYmxlLnRvICsgZS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgbi52aWV3RnJvbSA8IG8gJiYgbyAtIG4udmlld0Zyb20gPCAyMCAmJiAobyA9IE1hdGgubWF4KHIuZmlyc3QsIG4udmlld0Zyb20pKSwgbi52aWV3VG8gPiBhICYmIG4udmlld1RvIC0gYSA8IDIwICYmIChhID0gTWF0aC5taW4oaSwgbi52aWV3VG8pKSwgV28gJiYgKG8gPSBicihlLmRvYywgbyksIGEgPSB3cihlLmRvYywgYSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IG8gIT0gbi52aWV3RnJvbSB8fCBhICE9IG4udmlld1RvIHx8IG4ubGFzdFdyYXBIZWlnaHQgIT0gdC53cmFwcGVySGVpZ2h0IHx8IG4ubGFzdFdyYXBXaWR0aCAhPSB0LndyYXBwZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgRnQoZSwgbywgYSksIG4udmlld09mZnNldCA9IHJpKFpyKGUuZG9jLCBuLnZpZXdGcm9tKSksIGUuZGlzcGxheS5tb3Zlci5zdHlsZS50b3AgPSBuLnZpZXdPZmZzZXQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0genQoZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbCAmJiAwID09IHMgJiYgIXQuZm9yY2UgJiYgbi5yZW5kZXJlZFZpZXcgPT0gbi52aWV3ICYmIChudWxsID09IG4udXBkYXRlTGluZU51bWJlcnMgfHwgbi51cGRhdGVMaW5lTnVtYmVycyA+PSBuLnZpZXdUbykpcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IEdpKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzID4gNCAmJiAobi5saW5lRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiksIFIoZSwgbi51cGRhdGVMaW5lTnVtYmVycywgdC5kaW1zKSwgcyA+IDQgJiYgKG4ubGluZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJcIiksIG4ucmVuZGVyZWRWaWV3ID0gbi52aWV3LCBjICYmIEdpKCkgIT0gYyAmJiBjLm9mZnNldEhlaWdodCAmJiBjLmZvY3VzKCksIFVpKG4uY3Vyc29yRGl2KSwgVWkobi5zZWxlY3Rpb25EaXYpLCBuLmd1dHRlcnMuc3R5bGUuaGVpZ2h0ID0gbi5zaXplci5zdHlsZS5taW5IZWlnaHQgPSAwLCBsICYmIChuLmxhc3RXcmFwSGVpZ2h0ID0gdC53cmFwcGVySGVpZ2h0LCBuLmxhc3RXcmFwV2lkdGggPSB0LndyYXBwZXJXaWR0aCwgX2UoZSwgNDAwKSksIG4udXBkYXRlTGluZU51bWJlcnMgPSBudWxsLCAhMFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE4oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gdC52aWV3cG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9ICEwOyAociAmJiBlLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHQub2xkRGlzcGxheVdpZHRoICE9ICRlKGUpIHx8IChuICYmIG51bGwgIT0gbi50b3AgJiYgKG4gPSB7dG9wOiBNYXRoLm1pbihlLmRvYy5oZWlnaHQgKyBxZShlLmRpc3BsYXkpIC0gVmUoZSksIG4udG9wKX0pLCB0LnZpc2libGUgPSBiKGUuZGlzcGxheSwgZS5kb2MsIG4pLCAhKHQudmlzaWJsZS5mcm9tID49IGUuZGlzcGxheS52aWV3RnJvbSAmJiB0LnZpc2libGUudG8gPD0gZS5kaXNwbGF5LnZpZXdUbykpKSAmJiBNKGUsIHQpOyByID0gITEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE8oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHAoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZShlKSwgeShlLCBpKSwgRShlLCBpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHQuc2lnbmFsKGUsIFwidXBkYXRlXCIsIGUpLCBlLmRpc3BsYXkudmlld0Zyb20gPT0gZS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gJiYgZS5kaXNwbGF5LnZpZXdUbyA9PSBlLmRpc3BsYXkucmVwb3J0ZWRWaWV3VG8gfHwgKHQuc2lnbmFsKGUsIFwidmlld3BvcnRDaGFuZ2VcIiwgZSwgZS5kaXNwbGF5LnZpZXdGcm9tLCBlLmRpc3BsYXkudmlld1RvKSwgZS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gPSBlLmRpc3BsYXkudmlld0Zyb20sIGUuZGlzcGxheS5yZXBvcnRlZFZpZXdUbyA9IGUuZGlzcGxheS52aWV3VG8pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gbmV3IEwoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNKGUsIG4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPKGUpLCBOKGUsIG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBwKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgUmUoZSksIHkoZSwgciksIEUoZSwgciksIG4uZmluaXNoKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEUoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBlLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gdC5kb2NIZWlnaHQgKyBcInB4XCIsIGUuZGlzcGxheS5oZWlnaHRGb3JjZXIuc3R5bGUudG9wID0gdC5kb2NIZWlnaHQgKyBcInB4XCIsIGUuZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodCA9IHQuZG9jSGVpZ2h0ICsgZS5kaXNwbGF5LmJhckhlaWdodCArIFllKGUpICsgXCJweFwiXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSBlLmRpc3BsYXksIG4gPSB0LmxpbmVEaXYub2Zmc2V0VG9wLCByID0gMDsgciA8IHQudmlldy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8gPSB0LnZpZXdbcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW8uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhvICYmIDggPiBibykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG8ubm9kZS5vZmZzZXRUb3AgKyBvLm5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gYSAtIG4sIG4gPSBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBvLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBsLmJvdHRvbSAtIGwudG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gby5saW5lLmhlaWdodCAtIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDIgPiBpICYmIChpID0geXQodCkpLCAocyA+IC4wMDEgfHwgLS4wMDEgPiBzKSAmJiAoZWkoby5saW5lLCBpKSwgSShvLmxpbmUpLCBvLnJlc3QpKWZvciAodmFyIGMgPSAwOyBjIDwgby5yZXN0Lmxlbmd0aDsgYysrKUkoby5yZXN0W2NdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSShlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLndpZGdldHMpZm9yICh2YXIgdCA9IDA7IHQgPCBlLndpZGdldHMubGVuZ3RoOyArK3QpZS53aWRnZXRzW3RdLmhlaWdodCA9IGUud2lkZ2V0c1t0XS5ub2RlLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSBlLmRpc3BsYXksIG4gPSB7fSwgciA9IHt9LCBpID0gdC5ndXR0ZXJzLmNsaWVudExlZnQsIG8gPSB0Lmd1dHRlcnMuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IDA7IG87IG8gPSBvLm5leHRTaWJsaW5nLCArK2EpbltlLm9wdGlvbnMuZ3V0dGVyc1thXV0gPSBvLm9mZnNldExlZnQgKyBvLmNsaWVudExlZnQgKyBpLCByW2Uub3B0aW9ucy5ndXR0ZXJzW2FdXSA9IG8uY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhlZFBvczogQyh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGd1dHRlclRvdGFsV2lkdGg6IHQuZ3V0dGVycy5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGd1dHRlckxlZnQ6IG4sXG4gICAgICAgICAgICAgICAgICAgICAgICBndXR0ZXJXaWR0aDogcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJXaWR0aDogdC53cmFwcGVyLmNsaWVudFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBSKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd28gJiYgRW8gJiYgZS5kaXNwbGF5LmN1cnJlbnRXaGVlbFRhcmdldCA9PSB0ID8gdC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIgOiB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCksIG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBlLmRpc3BsYXksIG8gPSBlLm9wdGlvbnMubGluZU51bWJlcnMsIGEgPSBpLmxpbmVEaXYsIGwgPSBhLmZpcnN0Q2hpbGQsIHMgPSBpLnZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBpLnZpZXdGcm9tLCB1ID0gMDsgdSA8IHMubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gc1t1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmLmhpZGRlbik7IGVsc2UgaWYgKGYubm9kZSAmJiBmLm5vZGUucGFyZW50Tm9kZSA9PSBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGwgIT0gZi5ub2RlOylsID0gcihsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IG8gJiYgbnVsbCAhPSB0ICYmIGMgPj0gdCAmJiBmLmxpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5jaGFuZ2VzICYmIChQaShmLmNoYW5nZXMsIFwiZ3V0dGVyXCIpID4gLTEgJiYgKGggPSAhMSksIEQoZSwgZiwgYywgbikpLCBoICYmIChVaShmLmxpbmVOdW1iZXIpLCBmLmxpbmVOdW1iZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoUyhlLm9wdGlvbnMsIGMpKSkpLCBsID0gZi5ub2RlLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gVShlLCBmLCBjLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmluc2VydEJlZm9yZShkLCBsKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYyArPSBmLnNpemVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbDspbCA9IHIobClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBEKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0LmNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gdC5jaGFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCIgPT0gbyA/IF8oZSwgdCkgOiBcImd1dHRlclwiID09IG8gPyB6KGUsIHQsIG4sIHIpIDogXCJjbGFzc1wiID09IG8gPyBGKHQpIDogXCJ3aWRnZXRcIiA9PSBvICYmIGooZSwgdCwgcilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0LmNoYW5nZXMgPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLm5vZGUgPT0gZS50ZXh0ICYmIChlLm5vZGUgPSBqaShcImRpdlwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZVwiKSwgZS50ZXh0LnBhcmVudE5vZGUgJiYgZS50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGUubm9kZSwgZS50ZXh0KSwgZS5ub2RlLmFwcGVuZENoaWxkKGUudGV4dCksIHhvICYmIDggPiBibyAmJiAoZS5ub2RlLnN0eWxlLnpJbmRleCA9IDIpKSwgZS5ub2RlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gVyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5iZ0NsYXNzID8gZS5iZ0NsYXNzICsgXCIgXCIgKyAoZS5saW5lLmJnQ2xhc3MgfHwgXCJcIikgOiBlLmxpbmUuYmdDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgKHQgKz0gXCIgQ29kZU1pcnJvci1saW5lYmFja2dyb3VuZFwiKSwgZS5iYWNrZ3JvdW5kKSB0ID8gZS5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9IHQgOiAoZS5iYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZS5iYWNrZ3JvdW5kKSwgZS5iYWNrZ3JvdW5kID0gbnVsbCk7IGVsc2UgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gSChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuYmFja2dyb3VuZCA9IG4uaW5zZXJ0QmVmb3JlKGppKFwiZGl2XCIsIG51bGwsIHQpLCBuLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBCKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gJiYgbi5saW5lID09IHQubGluZSA/IChlLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGwsIHQubWVhc3VyZSA9IG4ubWVhc3VyZSwgbi5idWlsdCkgOiBCcihlLCB0KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF8oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHQudGV4dC5jbGFzc05hbWUsIHIgPSBCKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICB0LnRleHQgPT0gdC5ub2RlICYmICh0Lm5vZGUgPSByLnByZSksIHQudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChyLnByZSwgdC50ZXh0KSwgdC50ZXh0ID0gci5wcmUsIHIuYmdDbGFzcyAhPSB0LmJnQ2xhc3MgfHwgci50ZXh0Q2xhc3MgIT0gdC50ZXh0Q2xhc3MgPyAodC5iZ0NsYXNzID0gci5iZ0NsYXNzLCB0LnRleHRDbGFzcyA9IHIudGV4dENsYXNzLCBGKHQpKSA6IG4gJiYgKHQudGV4dC5jbGFzc05hbWUgPSBuKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEYoZSkge1xuICAgICAgICAgICAgICAgICAgICBXKGUpLCBlLmxpbmUud3JhcENsYXNzID8gSChlKS5jbGFzc05hbWUgPSBlLmxpbmUud3JhcENsYXNzIDogZS5ub2RlICE9IGUudGV4dCAmJiAoZS5ub2RlLmNsYXNzTmFtZSA9IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUudGV4dENsYXNzID8gZS50ZXh0Q2xhc3MgKyBcIiBcIiArIChlLmxpbmUudGV4dENsYXNzIHx8IFwiXCIpIDogZS5saW5lLnRleHRDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgZS50ZXh0LmNsYXNzTmFtZSA9IHQgfHwgXCJcIlxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHooZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodC5ndXR0ZXIgJiYgKHQubm9kZS5yZW1vdmVDaGlsZCh0Lmd1dHRlciksIHQuZ3V0dGVyID0gbnVsbCksIHQuZ3V0dGVyQmFja2dyb3VuZCAmJiAodC5ub2RlLnJlbW92ZUNoaWxkKHQuZ3V0dGVyQmFja2dyb3VuZCksIHQuZ3V0dGVyQmFja2dyb3VuZCA9IG51bGwpLCB0LmxpbmUuZ3V0dGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gSCh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuZ3V0dGVyQmFja2dyb3VuZCA9IGppKFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItYmFja2dyb3VuZCBcIiArIHQubGluZS5ndXR0ZXJDbGFzcywgXCJsZWZ0OiBcIiArIChlLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyByLmZpeGVkUG9zIDogLXIuZ3V0dGVyVG90YWxXaWR0aCkgKyBcInB4OyB3aWR0aDogXCIgKyByLmd1dHRlclRvdGFsV2lkdGggKyBcInB4XCIpLCBpLmluc2VydEJlZm9yZSh0Lmd1dHRlckJhY2tncm91bmQsIHQudGV4dClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHQubGluZS5ndXR0ZXJNYXJrZXJzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vcHRpb25zLmxpbmVOdW1iZXJzIHx8IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gSCh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gdC5ndXR0ZXIgPSBqaShcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXJcIiwgXCJsZWZ0OiBcIiArIChlLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyByLmZpeGVkUG9zIDogLXIuZ3V0dGVyVG90YWxXaWR0aCkgKyBcInB4XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGEpLCBpLmluc2VydEJlZm9yZShhLCB0LnRleHQpLCB0LmxpbmUuZ3V0dGVyQ2xhc3MgJiYgKGEuY2xhc3NOYW1lICs9IFwiIFwiICsgdC5saW5lLmd1dHRlckNsYXNzKSwgIWUub3B0aW9ucy5saW5lTnVtYmVycyB8fCBvICYmIG9bXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCJdIHx8ICh0LmxpbmVOdW1iZXIgPSBhLmFwcGVuZENoaWxkKGppKFwiZGl2XCIsIFMoZS5vcHRpb25zLCBuKSwgXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsIFwibGVmdDogXCIgKyByLmd1dHRlckxlZnRbXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCJdICsgXCJweDsgd2lkdGg6IFwiICsgZS5kaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoICsgXCJweFwiKSkpLCBvKWZvciAodmFyIGwgPSAwOyBsIDwgZS5vcHRpb25zLmd1dHRlcnMubGVuZ3RoOyArK2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGUub3B0aW9ucy5ndXR0ZXJzW2xdLCBjID0gby5oYXNPd25Qcm9wZXJ0eShzKSAmJiBvW3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgJiYgYS5hcHBlbmRDaGlsZChqaShcImRpdlwiLCBbY10sIFwiQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsIFwibGVmdDogXCIgKyByLmd1dHRlckxlZnRbc10gKyBcInB4OyB3aWR0aDogXCIgKyByLmd1dHRlcldpZHRoW3NdICsgXCJweFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGooZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB0LmFsaWduYWJsZSAmJiAodC5hbGlnbmFibGUgPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciwgaSA9IHQubm9kZS5maXJzdENoaWxkOyBpOyBpID0gcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBpLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIiA9PSBpLmNsYXNzTmFtZSAmJiB0Lm5vZGUucmVtb3ZlQ2hpbGQoaSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBxKGUsIHQsIG4pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gVShlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gQihlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQudGV4dCA9IHQubm9kZSA9IGkucHJlLCBpLmJnQ2xhc3MgJiYgKHQuYmdDbGFzcyA9IGkuYmdDbGFzcyksIGkudGV4dENsYXNzICYmICh0LnRleHRDbGFzcyA9IGkudGV4dENsYXNzKSwgRih0KSwgeihlLCB0LCBuLCByKSwgcShlLCB0LCByKSwgdC5ub2RlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcShlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChHKGUsIHQubGluZSwgdCwgbiwgITApLCB0LnJlc3QpZm9yICh2YXIgciA9IDA7IHIgPCB0LnJlc3QubGVuZ3RoOyByKyspRyhlLCB0LnJlc3Rbcl0sIHQsIG4sICExKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEcoZSwgdCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodC53aWRnZXRzKWZvciAodmFyIG8gPSBIKG4pLCBhID0gMCwgbCA9IHQud2lkZ2V0czsgYSA8IGwubGVuZ3RoOyArK2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gbFthXSwgYyA9IGppKFwiZGl2XCIsIFtzLm5vZGVdLCBcIkNvZGVNaXJyb3ItbGluZXdpZGdldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuaGFuZGxlTW91c2VFdmVudHMgfHwgYy5zZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIsIFwidHJ1ZVwiKSwgWShzLCBjLCBuLCByKSwgZS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUoYyksIGkgJiYgcy5hYm92ZSA/IG8uaW5zZXJ0QmVmb3JlKGMsIG4uZ3V0dGVyIHx8IG4udGV4dCkgOiBvLmFwcGVuZENoaWxkKGMpLCBDaShzLCBcInJlZHJhd1wiKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gWShlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm5vSFNjcm9sbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKG4uYWxpZ25hYmxlIHx8IChuLmFsaWduYWJsZSA9IFtdKSkucHVzaCh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gci53cmFwcGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnN0eWxlLmxlZnQgPSByLmZpeGVkUG9zICsgXCJweFwiLCBlLmNvdmVyR3V0dGVyIHx8IChpIC09IHIuZ3V0dGVyVG90YWxXaWR0aCwgdC5zdHlsZS5wYWRkaW5nTGVmdCA9IHIuZ3V0dGVyVG90YWxXaWR0aCArIFwicHhcIiksIHQuc3R5bGUud2lkdGggPSBpICsgXCJweFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZS5jb3Zlckd1dHRlciAmJiAodC5zdHlsZS56SW5kZXggPSA1LCB0LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiLCBlLm5vSFNjcm9sbCB8fCAodC5zdHlsZS5tYXJnaW5MZWZ0ID0gLXIuZ3V0dGVyVG90YWxXaWR0aCArIFwicHhcIikpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gJChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCbyhlLmxpbmUsIGUuY2gpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gVihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfbyhlLCB0KSA8IDAgPyB0IDogZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEsoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX28oZSwgdCkgPCAwID8gZSA6IHRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBYKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdGF0ZS5mb2N1c2VkIHx8IChlLmRpc3BsYXkuaW5wdXQuZm9jdXMoKSwgdm4oZSkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gWihlLCB0LCBuLCByLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gZS5kb2M7XG4gICAgICAgICAgICAgICAgICAgIGUuZGlzcGxheS5zaGlmdCA9ICExLCByIHx8IChyID0gby5zZWwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGUuc3RhdGUucGFzdGVJbmNvbWluZyB8fCBcInBhc3RlXCIgPT0gaSwgbCA9IG8uc3BsaXRMaW5lcyh0KSwgcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhICYmIHIucmFuZ2VzLmxlbmd0aCA+IDEpaWYgKEZvICYmIEZvLnRleHQuam9pbihcIlxcblwiKSA9PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5yYW5nZXMubGVuZ3RoICUgRm8udGV4dC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IEZvLnRleHQubGVuZ3RoOyBjKyspcy5wdXNoKG8uc3BsaXRMaW5lcyhGby50ZXh0W2NdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGwubGVuZ3RoID09IHIucmFuZ2VzLmxlbmd0aCAmJiAocyA9IFJpKGwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2VdXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IHIucmFuZ2VzLmxlbmd0aCAtIDE7IGMgPj0gMDsgYy0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IHIucmFuZ2VzW2NdLCBmID0gdS5mcm9tKCksIGggPSB1LnRvKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1LmVtcHR5KCkgJiYgKG4gJiYgbiA+IDAgPyBmID0gQm8oZi5saW5lLCBmLmNoIC0gbikgOiBlLnN0YXRlLm92ZXJ3cml0ZSAmJiAhYSA/IGggPSBCbyhoLmxpbmUsIE1hdGgubWluKFpyKG8sIGgubGluZSkudGV4dC5sZW5ndGgsIGguY2ggKyBJaShsKS5sZW5ndGgpKSA6IEZvICYmIEZvLmxpbmVXaXNlICYmIEZvLnRleHQuam9pbihcIlxcblwiKSA9PSB0ICYmIChmID0gaCA9IEJvKGYubGluZSwgMCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gZS5jdXJPcC51cGRhdGVJbnB1dCwgcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHMgPyBzW2MgJSBzLmxlbmd0aF0gOiBsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogaSB8fCAoYSA/IFwicGFzdGVcIiA6IGUuc3RhdGUuY3V0SW5jb21pbmcgPyBcImN1dFwiIDogXCIraW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBUbihlLmRvYywgcCksIENpKGUsIFwiaW5wdXRSZWFkXCIsIGUsIHApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdCAmJiAhYSAmJiBRKGUsIHQpLCBCbihlKSwgZS5jdXJPcC51cGRhdGVJbnB1dCA9IGQsIGUuY3VyT3AudHlwaW5nID0gITAsIGUuc3RhdGUucGFzdGVJbmNvbWluZyA9IGUuc3RhdGUuY3V0SW5jb21pbmcgPSAhMVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEooZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUuY2xpcGJvYXJkRGF0YSAmJiBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuID8gKGUucHJldmVudERlZmF1bHQoKSwgdC5pc1JlYWRPbmx5KCkgfHwgdC5vcHRpb25zLmRpc2FibGVJbnB1dCB8fCBBdCh0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBaKHQsIG4sIDAsIG51bGwsIFwicGFzdGVcIilcbiAgICAgICAgICAgICAgICAgICAgfSksICEwKSA6IHZvaWQgMFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFEoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vcHRpb25zLmVsZWN0cmljQ2hhcnMgJiYgZS5vcHRpb25zLnNtYXJ0SW5kZW50KWZvciAodmFyIG4gPSBlLmRvYy5zZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IG4ucmFuZ2VzLmxlbmd0aCAtIDE7IHIgPj0gMDsgci0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IG4ucmFuZ2VzW3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaS5oZWFkLmNoID4gMTAwIHx8IHIgJiYgbi5yYW5nZXNbciAtIDFdLmhlYWQubGluZSA9PSBpLmhlYWQubGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGUuZ2V0TW9kZUF0KGkuaGVhZCksIGEgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5lbGVjdHJpY0NoYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgby5lbGVjdHJpY0NoYXJzLmxlbmd0aDsgbCsrKWlmICh0LmluZGV4T2Yoby5lbGVjdHJpY0NoYXJzLmNoYXJBdChsKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IEZuKGUsIGkuaGVhZC5saW5lLCBcInNtYXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBvLmVsZWN0cmljSW5wdXQgJiYgby5lbGVjdHJpY0lucHV0LnRlc3QoWnIoZS5kb2MsIGkuaGVhZC5saW5lKS50ZXh0LnNsaWNlKDAsIGkuaGVhZC5jaCkpICYmIChhID0gRm4oZSwgaS5oZWFkLmxpbmUsIFwic21hcnRcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgJiYgQ2koZSwgXCJlbGVjdHJpY0lucHV0XCIsIGUsIGkuaGVhZC5saW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZWUoZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gW10sIG4gPSBbXSwgciA9IDA7IHIgPCBlLmRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGUuZG9jLnNlbC5yYW5nZXNbcl0uaGVhZC5saW5lLCBvID0ge2FuY2hvcjogQm8oaSwgMCksIGhlYWQ6IEJvKGkgKyAxLCAwKX07XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnB1c2gobyksIHQucHVzaChlLmdldFJhbmdlKG8uYW5jaG9yLCBvLmhlYWQpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7dGV4dDogdCwgcmFuZ2VzOiBufVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRlKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiLCBcIm9mZlwiKSwgZS5zZXRBdHRyaWJ1dGUoXCJhdXRvY2FwaXRhbGl6ZVwiLCBcIm9mZlwiKSwgZS5zZXRBdHRyaWJ1dGUoXCJzcGVsbGNoZWNrXCIsIFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBuZShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY20gPSBlLCB0aGlzLnByZXZJbnB1dCA9IFwiXCIsIHRoaXMucG9sbGluZ0Zhc3QgPSAhMSwgdGhpcy5wb2xsaW5nID0gbmV3IEVpLCB0aGlzLmluYWNjdXJhdGVTZWxlY3Rpb24gPSAhMSwgdGhpcy5oYXNTZWxlY3Rpb24gPSAhMSwgdGhpcy5jb21wb3NpbmcgPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gamkoXCJ0ZXh0YXJlYVwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgcGFkZGluZzogMDsgd2lkdGg6IDFweDsgaGVpZ2h0OiAxZW07IG91dGxpbmU6IG5vbmVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gamkoXCJkaXZcIiwgW2VdLCBudWxsLCBcIm92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsgd2lkdGg6IDNweDsgaGVpZ2h0OiAwcHg7XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd28gPyBlLnN0eWxlLndpZHRoID0gXCIxMDAwcHhcIiA6IGUuc2V0QXR0cmlidXRlKFwid3JhcFwiLCBcIm9mZlwiKSwgTm8gJiYgKGUuc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgYmxhY2tcIiksIHRlKGUpLCB0XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaWUoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNtID0gZSwgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHRoaXMubGFzdEFuY2hvck9mZnNldCA9IHRoaXMubGFzdEZvY3VzTm9kZSA9IHRoaXMubGFzdEZvY3VzT2Zmc2V0ID0gbnVsbCwgdGhpcy5wb2xsaW5nID0gbmV3IEVpLCB0aGlzLmdyYWNlUGVyaW9kID0gITFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvZShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gUWUoZSwgdC5saW5lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuIHx8IG4uaGlkZGVuKXJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IFpyKGUuZG9jLCB0LmxpbmUpLCBpID0gWGUobiwgciwgdC5saW5lKSwgbyA9IGlpKHIpLCBhID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGNvKG8sIHQuY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGwgJSAyID8gXCJyaWdodFwiIDogXCJsZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG50KGkubWFwLCB0LmNoLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMub2Zmc2V0ID0gXCJyaWdodFwiID09IHMuY29sbGFwc2UgPyBzLmVuZCA6IHMuc3RhcnQsIHNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ICYmIChlLmJhZCA9ICEwKSwgZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGxlKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09IGUuZGlzcGxheS5saW5lRGl2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9IGUuZGlzcGxheS5saW5lRGl2LmNoaWxkTm9kZXNbbl0sICFyKXJldHVybiBhZShlLmNsaXBQb3MoQm8oZS5kaXNwbGF5LnZpZXdUbyAtIDEpKSwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG51bGwsIG4gPSAwXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBmb3IgKHIgPSB0OyA7IHIgPSByLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghciB8fCByID09IGUuZGlzcGxheS5saW5lRGl2KXJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIucGFyZW50Tm9kZSAmJiByLnBhcmVudE5vZGUgPT0gZS5kaXNwbGF5LmxpbmVEaXYpYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGUuZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGUuZGlzcGxheS52aWV3W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8ubm9kZSA9PSByKXJldHVybiBzZShvLCB0LCBuKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2UoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByKHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAtMTsgaSA8ICh1ID8gdS5sZW5ndGggOiAwKTsgaSsrKWZvciAodmFyIG8gPSAwID4gaSA/IGMubWFwIDogdVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSAwOyBhIDwgby5sZW5ndGg7IGEgKz0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gb1thICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwgPT0gdCB8fCBsID09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0aSgwID4gaSA/IGUubGluZSA6IGUucmVzdFtpXSksIGYgPSBvW2FdICsgcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwID4gciB8fCBsICE9IHQpICYmIChmID0gb1thICsgKHIgPyAxIDogMCldKSwgQm8ocywgZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGUudGV4dC5maXJzdENoaWxkLCBvID0gITE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdCB8fCAhVmEoaSwgdCkpcmV0dXJuIGFlKEJvKHRpKGUubGluZSksIDApLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09IGkgJiYgKG8gPSAhMCwgdCA9IGkuY2hpbGROb2Rlc1tuXSwgbiA9IDAsICF0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBlLnJlc3QgPyBJaShlLnJlc3QpIDogZS5saW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFlKEJvKHRpKGEpLCBhLnRleHQubGVuZ3RoKSwgbylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IDMgPT0gdC5ub2RlVHlwZSA/IHQgOiBudWxsLCBzID0gdDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsIHx8IDEgIT0gdC5jaGlsZE5vZGVzLmxlbmd0aCB8fCAzICE9IHQuZmlyc3RDaGlsZC5ub2RlVHlwZSB8fCAobCA9IHQuZmlyc3RDaGlsZCwgbiAmJiAobiA9IGwubm9kZVZhbHVlLmxlbmd0aCkpOyBzLnBhcmVudE5vZGUgIT0gaTspcyA9IHMucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBlLm1lYXN1cmUsIHUgPSBjLm1hcHMsIGYgPSByKGwsIHMsIG4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZilyZXR1cm4gYWUoZiwgbyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGggPSBzLm5leHRTaWJsaW5nLCBkID0gbCA/IGwubm9kZVZhbHVlLmxlbmd0aCAtIG4gOiAwOyBoOyBoID0gaC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYgPSByKGgsIGguZmlyc3RDaGlsZCwgMCkpcmV0dXJuIGFlKEJvKGYubGluZSwgZi5jaCAtIGQpLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgKz0gaC50ZXh0Q29udGVudC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gcy5wcmV2aW91c1NpYmxpbmcsIGQgPSBuOyBwOyBwID0gcC5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmID0gcihwLCBwLmZpcnN0Q2hpbGQsIC0xKSlyZXR1cm4gYWUoQm8oZi5saW5lLCBmLmNoICsgZCksIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZCArPSBoLnRleHRDb250ZW50Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2UoZSwgdCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlkID09IGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGEodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDEgPT0gdC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdC5nZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IG4pcmV0dXJuIFwiXCIgPT0gbiAmJiAobiA9IHQudGV4dENvbnRlbnQucmVwbGFjZSgvXFx1MjAwYi9nLCBcIlwiKSksIHZvaWQobCArPSBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSwgZiA9IHQuZ2V0QXR0cmlidXRlKFwiY20tbWFya2VyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gZS5maW5kTWFya3MoQm8ociwgMCksIEJvKGkgKyAxLCAwKSwgbygrZikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZChoLmxlbmd0aCAmJiAodSA9IGhbMF0uZmluZCgpKSAmJiAobCArPSBKcihlLmRvYywgdS5mcm9tLCB1LnRvKS5qb2luKGMpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZmFsc2VcIiA9PSB0LmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSlyZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCB0LmNoaWxkTm9kZXMubGVuZ3RoOyBkKyspYSh0LmNoaWxkTm9kZXNbZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9eKHByZXxkaXZ8cCkkL2kudGVzdCh0Lm5vZGVOYW1lKSAmJiAocyA9ICEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgzID09IHQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHQubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcClyZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyAmJiAobCArPSBjLCBzID0gITEpLCBsICs9IHBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSBcIlwiLCBzID0gITEsIGMgPSBlLmRvYy5saW5lU2VwYXJhdG9yKCk7IGEodCksIHQgIT0gbjspdCA9IHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdWUoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhbmdlcyA9IGUsIHRoaXMucHJpbUluZGV4ID0gdFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZlKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmNob3IgPSBlLCB0aGlzLmhlYWQgPSB0XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaGUoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGVbdF07XG4gICAgICAgICAgICAgICAgICAgIGUuc29ydChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9vKGUuZnJvbSgpLCB0LmZyb20oKSlcbiAgICAgICAgICAgICAgICAgICAgfSksIHQgPSBQaShlLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCBlLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGVbcl0sIG8gPSBlW3IgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbyhvLnRvKCksIGkuZnJvbSgpKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBLKG8uZnJvbSgpLCBpLmZyb20oKSksIGwgPSBWKG8udG8oKSwgaS50bygpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IG8uZW1wdHkoKSA/IGkuZnJvbSgpID09IGkuaGVhZCA6IG8uZnJvbSgpID09IG8uaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID49IHIgJiYgLS10LCBlLnNwbGljZSgtLXIsIDIsIG5ldyBmZShzID8gbCA6IGEsIHMgPyBhIDogbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB1ZShlLCB0KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB1ZShbbmV3IGZlKGUsIHQgfHwgZSldLCAwKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHBlKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGUuZmlyc3QsIE1hdGgubWluKHQsIGUuZmlyc3QgKyBlLnNpemUgLSAxKSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBtZShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmxpbmUgPCBlLmZpcnN0KXJldHVybiBCbyhlLmZpcnN0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmZpcnN0ICsgZS5zaXplIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQubGluZSA+IG4gPyBCbyhuLCBacihlLCBuKS50ZXh0Lmxlbmd0aCkgOiBnZSh0LCBacihlLCB0LmxpbmUpLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdlKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmNoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBuIHx8IG4gPiB0ID8gQm8oZS5saW5lLCB0KSA6IDAgPiBuID8gQm8oZS5saW5lLCAwKSA6IGVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB2ZShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ID49IGUuZmlyc3QgJiYgdCA8IGUuZmlyc3QgKyBlLnNpemVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB5ZShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBbXSwgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKW5bcl0gPSBtZShlLCB0W3JdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB4ZShlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNtICYmIGUuY20uZGlzcGxheS5zaGlmdCB8fCBlLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0LmFuY2hvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBfbyhuLCBpKSA8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAhPSBfbyhyLCBpKSA8IDAgPyAoaSA9IG4sIG4gPSByKSA6IG8gIT0gX28obiwgcikgPCAwICYmIChuID0gcilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZmUoaSwgbilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGZlKHIgfHwgbiwgbilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiZShlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIFRlKGUsIG5ldyB1ZShbeGUoZSwgZS5zZWwucHJpbWFyeSgpLCB0LCBuKV0sIDApLCByKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdlKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IFtdLCBpID0gMDsgaSA8IGUuc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylyW2ldID0geGUoZSwgZS5zZWwucmFuZ2VzW2ldLCB0W2ldLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBoZShyLCBlLnNlbC5wcmltSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBUZShlLCBvLCBuKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGtlKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlLnNlbC5yYW5nZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGlbdF0gPSBuLCBUZShlLCBoZShpLCBlLnNlbC5wcmltSW5kZXgpLCByKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNlKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgVGUoZSwgZGUodCwgbiksIHIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQ2UoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlczogdC5yYW5nZXMsIHVwZGF0ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKyl0aGlzLnJhbmdlc1tuXSA9IG5ldyBmZShtZShlLCB0W25dLmFuY2hvciksIG1lKGUsIHRbbl0uaGVhZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBvcmlnaW46IG4gJiYgbi5vcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhKGUsIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGUsIHIpLCBlLmNtICYmIFBhKGUuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGUuY20sIHIpLCByLnJhbmdlcyAhPSB0LnJhbmdlcyA/IGhlKHIucmFuZ2VzLCByLnJhbmdlcy5sZW5ndGggLSAxKSA6IHRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBMZShlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5oaXN0b3J5LmRvbmUsIGkgPSBJaShyKTtcbiAgICAgICAgICAgICAgICAgICAgaSAmJiBpLnJhbmdlcyA/IChyW3IubGVuZ3RoIC0gMV0gPSB0LCBNZShlLCB0LCBuKSkgOiBUZShlLCB0LCBuKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFRlKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgTWUoZSwgdCwgbiksIGZpKGUsIGUuc2VsLCBlLmNtID8gZS5jbS5jdXJPcC5pZCA6IE5hTiwgbilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNZShlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIChOaShlLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKSB8fCBlLmNtICYmIE5pKGUuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpKSAmJiAodCA9IENlKGUsIHQsIG4pKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBuICYmIG4uYmlhcyB8fCAoX28odC5wcmltYXJ5KCkuaGVhZCwgZS5zZWwucHJpbWFyeSgpLmhlYWQpIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgICAgIE5lKGUsIEVlKGUsIHQsIHIsICEwKSksIG4gJiYgbi5zY3JvbGwgPT09ICExIHx8ICFlLmNtIHx8IEJuKGUuY20pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTmUoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB0LmVxdWFscyhlLnNlbCkgfHwgKGUuc2VsID0gdCwgZS5jbSAmJiAoZS5jbS5jdXJPcC51cGRhdGVJbnB1dCA9IGUuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9ICEwLCBNaShlLmNtKSksIENpKGUsIFwiY3Vyc29yQWN0aXZpdHlcIiwgZSkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQWUoZSkge1xuICAgICAgICAgICAgICAgICAgICBOZShlLCBFZShlLCBlLnNlbCwgbnVsbCwgITEpLCBXYSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBFZShlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGksIG8gPSAwOyBvIDwgdC5yYW5nZXMubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gdC5yYW5nZXNbb10sIGwgPSB0LnJhbmdlcy5sZW5ndGggPT0gZS5zZWwucmFuZ2VzLmxlbmd0aCAmJiBlLnNlbC5yYW5nZXNbb10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IEllKGUsIGEuYW5jaG9yLCBsICYmIGwuYW5jaG9yLCBuLCByKSwgYyA9IEllKGUsIGEuaGVhZCwgbCAmJiBsLmhlYWQsIG4sIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGkgfHwgcyAhPSBhLmFuY2hvciB8fCBjICE9IGEuaGVhZCkgJiYgKGkgfHwgKGkgPSB0LnJhbmdlcy5zbGljZSgwLCBvKSksIGlbb10gPSBuZXcgZmUocywgYykpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPyBoZShpLCB0LnByaW1JbmRleCkgOiB0XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gT2UoZSwgdCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IFpyKGUsIHQubGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLm1hcmtlZFNwYW5zKWZvciAodmFyIGEgPSAwOyBhIDwgby5tYXJrZWRTcGFucy5sZW5ndGg7ICsrYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBvLm1hcmtlZFNwYW5zW2FdLCBzID0gbC5tYXJrZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG51bGwgPT0gbC5mcm9tIHx8IChzLmluY2x1c2l2ZUxlZnQgPyBsLmZyb20gPD0gdC5jaCA6IGwuZnJvbSA8IHQuY2gpKSAmJiAobnVsbCA9PSBsLnRvIHx8IChzLmluY2x1c2l2ZVJpZ2h0ID8gbC50byA+PSB0LmNoIDogbC50byA+IHQuY2gpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICYmIChQYShzLCBcImJlZm9yZUN1cnNvckVudGVyXCIpLCBzLmV4cGxpY2l0bHlDbGVhcmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5tYXJrZWRTcGFucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXMuYXRvbWljKWNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjLCB1ID0gcy5maW5kKDAgPiByID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwID4gciA/IHMuaW5jbHVzaXZlUmlnaHQgOiBzLmluY2x1c2l2ZUxlZnQpICYmICh1ID0gUGUoZSwgdSwgLXIsIHUgJiYgdS5saW5lID09IHQubGluZSA/IG8gOiBudWxsKSksIHUgJiYgdS5saW5lID09IHQubGluZSAmJiAoYyA9IF9vKHUsIG4pKSAmJiAoMCA+IHIgPyAwID4gYyA6IGMgPiAwKSlyZXR1cm4gT2UoZSwgdSwgdCwgciwgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBzLmZpbmQoMCA+IHIgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCA+IHIgPyBzLmluY2x1c2l2ZUxlZnQgOiBzLmluY2x1c2l2ZVJpZ2h0KSAmJiAoZiA9IFBlKGUsIGYsIHIsIGYubGluZSA9PSB0LmxpbmUgPyBvIDogbnVsbCkpLCBmID8gT2UoZSwgZiwgdCwgciwgaSkgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBJZShlLCB0LCBuLCByLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gciB8fCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IE9lKGUsIHQsIG4sIG8sIGkpIHx8ICFpICYmIE9lKGUsIHQsIG4sIG8sICEwKSB8fCBPZShlLCB0LCBuLCAtbywgaSkgfHwgIWkgJiYgT2UoZSwgdCwgbiwgLW8sICEwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPyBhIDogKGUuY2FudEVkaXQgPSAhMCwgQm8oZS5maXJzdCwgMCkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUGUoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCA+IG4gJiYgMCA9PSB0LmNoID8gdC5saW5lID4gZS5maXJzdCA/IG1lKGUsIEJvKHQubGluZSAtIDEpKSA6IG51bGwgOiBuID4gMCAmJiB0LmNoID09IChyIHx8IFpyKGUsIHQubGluZSkpLnRleHQubGVuZ3RoID8gdC5saW5lIDwgZS5maXJzdCArIGUuc2l6ZSAtIDEgPyBCbyh0LmxpbmUgKyAxLCAwKSA6IG51bGwgOiBuZXcgQm8odC5saW5lLCB0LmNoICsgbilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBSZShlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuZGlzcGxheS5pbnB1dC5zaG93U2VsZWN0aW9uKGUuZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRGUoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gZS5kb2MsIHIgPSB7fSwgaSA9IHIuY3Vyc29ycyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHIuc2VsZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gMDsgYSA8IG4uc2VsLnJhbmdlcy5sZW5ndGg7IGErKylpZiAodCAhPT0gITEgfHwgYSAhPSBuLnNlbC5wcmltSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gbi5zZWwucmFuZ2VzW2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobC5mcm9tKCkubGluZSA+PSBlLmRpc3BsYXkudmlld1RvIHx8IGwudG8oKS5saW5lIDwgZS5kaXNwbGF5LnZpZXdGcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gbC5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzIHx8IGUub3B0aW9ucy5zaG93Q3Vyc29yV2hlblNlbGVjdGluZykgJiYgSGUoZSwgbC5oZWFkLCBpKSwgcyB8fCBXZShlLCBsLCBvKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSGUoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGR0KGUsIHQsIFwiZGl2XCIsIG51bGwsIG51bGwsICFlLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gbi5hcHBlbmRDaGlsZChqaShcImRpdlwiLCBcIsKgXCIsIFwiQ29kZU1pcnJvci1jdXJzb3JcIikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaS5zdHlsZS5sZWZ0ID0gci5sZWZ0ICsgXCJweFwiLCBpLnN0eWxlLnRvcCA9IHIudG9wICsgXCJweFwiLCBpLnN0eWxlLmhlaWdodCA9IE1hdGgubWF4KDAsIHIuYm90dG9tIC0gci50b3ApICogZS5vcHRpb25zLmN1cnNvckhlaWdodCArIFwicHhcIiwgci5vdGhlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBuLmFwcGVuZENoaWxkKGppKFwiZGl2XCIsIFwiwqBcIiwgXCJDb2RlTWlycm9yLWN1cnNvciBDb2RlTWlycm9yLXNlY29uZGFyeWN1cnNvclwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLnN0eWxlLmRpc3BsYXkgPSBcIlwiLCBvLnN0eWxlLmxlZnQgPSByLm90aGVyLmxlZnQgKyBcInB4XCIsIG8uc3R5bGUudG9wID0gci5vdGhlci50b3AgKyBcInB4XCIsIG8uc3R5bGUuaGVpZ2h0ID0gLjg1ICogKHIub3RoZXIuYm90dG9tIC0gci5vdGhlci50b3ApICsgXCJweFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBXZShlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHIoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgMCA+IHQgJiYgKHQgPSAwKSwgdCA9IE1hdGgucm91bmQodCksIHIgPSBNYXRoLnJvdW5kKHIpLCBsLmFwcGVuZENoaWxkKGppKFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1zZWxlY3RlZFwiLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogXCIgKyBlICsgXCJweDsgdG9wOiBcIiArIHQgKyBcInB4OyB3aWR0aDogXCIgKyAobnVsbCA9PSBuID8gdSAtIGUgOiBuKSArIFwicHg7IGhlaWdodDogXCIgKyAociAtIHQpICsgXCJweFwiKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkodCwgbiwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbyhuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGh0KGUsIEJvKHQsIG4pLCBcImRpdlwiLCBmLCByKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCwgcywgZiA9IFpyKGEsIHQpLCBoID0gZi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbyhpaShmKSwgbiB8fCAwLCBudWxsID09IGkgPyBoIDogaSwgZnVuY3Rpb24gKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiwgZCwgcCwgbSA9IG8oZSwgXCJsZWZ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlID09IHQpIGYgPSBtLCBkID0gcCA9IG0ubGVmdDsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmID0gbyh0IC0gMSwgXCJyaWdodFwiKSwgXCJydGxcIiA9PSBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IG07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gZiwgZiA9IGdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gbS5sZWZ0LCBwID0gZi5yaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsID09IG4gJiYgMCA9PSBlICYmIChkID0gYyksIGYudG9wIC0gbS50b3AgPiAzICYmIChyKGQsIG0udG9wLCBudWxsLCBtLmJvdHRvbSksIGQgPSBjLCBtLmJvdHRvbSA8IGYudG9wICYmIHIoZCwgbS5ib3R0b20sIG51bGwsIGYudG9wKSksIG51bGwgPT0gaSAmJiB0ID09IGggJiYgKHAgPSB1KSwgKCFsIHx8IG0udG9wIDwgbC50b3AgfHwgbS50b3AgPT0gbC50b3AgJiYgbS5sZWZ0IDwgbC5sZWZ0KSAmJiAobCA9IG0pLCAoIXMgfHwgZi5ib3R0b20gPiBzLmJvdHRvbSB8fCBmLmJvdHRvbSA9PSBzLmJvdHRvbSAmJiBmLnJpZ2h0ID4gcy5yaWdodCkgJiYgKHMgPSBmKSwgYyArIDEgPiBkICYmIChkID0gYyksIHIoZCwgZi50b3AsIHAgLSBkLCBmLmJvdHRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCB7c3RhcnQ6IGwsIGVuZDogc31cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gZS5kaXNwbGF5LCBhID0gZS5kb2MsIGwgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHMgPSBHZShlLmRpc3BsYXkpLCBjID0gcy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdSA9IE1hdGgubWF4KG8uc2l6ZXJXaWR0aCwgJGUoZSkgLSBvLnNpemVyLm9mZnNldExlZnQpIC0gcy5yaWdodCwgZiA9IHQuZnJvbSgpLCBoID0gdC50bygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi5saW5lID09IGgubGluZSkgaShmLmxpbmUsIGYuY2gsIGguY2gpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gWnIoYSwgZi5saW5lKSwgcCA9IFpyKGEsIGgubGluZSksIG0gPSB5cihkKSA9PSB5cihwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gaShmLmxpbmUsIGYuY2gsIG0gPyBkLnRleHQubGVuZ3RoICsgMSA6IG51bGwpLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gaShoLmxpbmUsIG0gPyAwIDogbnVsbCwgaC5jaCkuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtICYmIChnLnRvcCA8IHYudG9wIC0gMiA/IChyKGcucmlnaHQsIGcudG9wLCBudWxsLCBnLmJvdHRvbSksIHIoYywgdi50b3AsIHYubGVmdCwgdi5ib3R0b20pKSA6IHIoZy5yaWdodCwgZy50b3AsIHYubGVmdCAtIGcucmlnaHQsIGcuYm90dG9tKSksIGcuYm90dG9tIDwgdi50b3AgJiYgcihjLCBnLmJvdHRvbSwgbnVsbCwgdi50b3ApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbi5hcHBlbmRDaGlsZChsKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEJlKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuc3RhdGUuZm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHQuYmxpbmtlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCIsIGUub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUgPiAwID8gdC5ibGlua2VyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSAobiA9ICFuKSA/IFwiXCIgOiBcImhpZGRlblwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBlLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlKSA6IGUub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUgPCAwICYmICh0LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9lKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kb2MubW9kZS5zdGFydFN0YXRlICYmIGUuZG9jLmZyb250aWVyIDwgZS5kaXNwbGF5LnZpZXdUbyAmJiBlLnN0YXRlLmhpZ2hsaWdodC5zZXQodCwgQmkoRmUsIGUpKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEZlKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmRvYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQuZnJvbnRpZXIgPCB0LmZpcnN0ICYmICh0LmZyb250aWVyID0gdC5maXJzdCksICEodC5mcm9udGllciA+PSBlLmRpc3BsYXkudmlld1RvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSArbmV3IERhdGUgKyBlLm9wdGlvbnMud29ya1RpbWUsIHIgPSBzYSh0Lm1vZGUsIGplKGUsIHQuZnJvbnRpZXIpKSwgaSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5pdGVyKHQuZnJvbnRpZXIsIE1hdGgubWluKHQuZmlyc3QgKyB0LnNpemUsIGUuZGlzcGxheS52aWV3VG8gKyA1MDApLCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LmZyb250aWVyID49IGUuZGlzcGxheS52aWV3RnJvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG8uc3R5bGVzLCBsID0gby50ZXh0Lmxlbmd0aCA+IGUub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gUnIoZSwgbywgbCA/IHNhKHQubW9kZSwgcikgOiByLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uc3R5bGVzID0gcy5zdHlsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gby5zdHlsZUNsYXNzZXMsIHUgPSBzLmNsYXNzZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPyBvLnN0eWxlQ2xhc3NlcyA9IHUgOiBjICYmIChvLnN0eWxlQ2xhc3NlcyA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmID0gIWEgfHwgYS5sZW5ndGggIT0gby5zdHlsZXMubGVuZ3RoIHx8IGMgIT0gdSAmJiAoIWMgfHwgIXUgfHwgYy5iZ0NsYXNzICE9IHUuYmdDbGFzcyB8fCBjLnRleHRDbGFzcyAhPSB1LnRleHRDbGFzcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSAwOyAhZiAmJiBoIDwgYS5sZW5ndGg7ICsraClmID0gYVtoXSAhPSBvLnN0eWxlc1toXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiAmJiBpLnB1c2godC5mcm9udGllciksIG8uc3RhdGVBZnRlciA9IGwgPyByIDogc2EodC5tb2RlLCByKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBvLnRleHQubGVuZ3RoIDw9IGUub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGggJiYgSHIoZSwgby50ZXh0LCByKSwgby5zdGF0ZUFmdGVyID0gdC5mcm9udGllciAlIDUgPT0gMCA/IHNhKHQubW9kZSwgcikgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiArK3QuZnJvbnRpZXIsICtuZXcgRGF0ZSA+IG4gPyAoX2UoZSwgZS5vcHRpb25zLndvcmtEZWxheSksICEwKSA6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIGkubGVuZ3RoICYmIEF0KGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGkubGVuZ3RoOyB0KyspSHQoZSwgaVt0XSwgXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gemUoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByLCBpLCBvID0gZS5kb2MsIGEgPSBuID8gLTEgOiB0IC0gKGUuZG9jLm1vZGUuaW5uZXJNb2RlID8gMWUzIDogMTAwKSwgbCA9IHQ7IGwgPiBhOyAtLWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsIDw9IG8uZmlyc3QpcmV0dXJuIG8uZmlyc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IFpyKG8sIGwgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnN0YXRlQWZ0ZXIgJiYgKCFuIHx8IGwgPD0gby5mcm9udGllcikpcmV0dXJuIGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IEZhKHMudGV4dCwgbnVsbCwgZS5vcHRpb25zLnRhYlNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gaSB8fCByID4gYykgJiYgKGkgPSBsIC0gMSwgciA9IGMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBqZShlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5kb2MsIGkgPSBlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghci5tb2RlLnN0YXJ0U3RhdGUpcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHplKGUsIHQsIG4pLCBhID0gbyA+IHIuZmlyc3QgJiYgWnIociwgbyAtIDEpLnN0YXRlQWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhID0gYSA/IHNhKHIubW9kZSwgYSkgOiBjYShyLm1vZGUpLCByLml0ZXIobywgdCwgZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhyKGUsIG4udGV4dCwgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IG8gPT0gdCAtIDEgfHwgbyAlIDUgPT0gMCB8fCBvID49IGkudmlld0Zyb20gJiYgbyA8IGkudmlld1RvO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5zdGF0ZUFmdGVyID0gbCA/IHNhKHIubW9kZSwgYSkgOiBudWxsLCArK29cbiAgICAgICAgICAgICAgICAgICAgfSksIG4gJiYgKHIuZnJvbnRpZXIgPSBvKSwgYVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFVlKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubGluZVNwYWNlLm9mZnNldFRvcFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHFlKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubW92ZXIub2Zmc2V0SGVpZ2h0IC0gZS5saW5lU3BhY2Uub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gR2UoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jYWNoZWRQYWRkaW5nSClyZXR1cm4gZS5jYWNoZWRQYWRkaW5nSDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBxaShlLm1lYXN1cmUsIGppKFwicHJlXCIsIFwieFwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KSA6IHQuY3VycmVudFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHtsZWZ0OiBwYXJzZUludChuLnBhZGRpbmdMZWZ0KSwgcmlnaHQ6IHBhcnNlSW50KG4ucGFkZGluZ1JpZ2h0KX07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc05hTihyLmxlZnQpIHx8IGlzTmFOKHIucmlnaHQpIHx8IChlLmNhY2hlZFBhZGRpbmdIID0gciksIHJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBZZShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEYSAtIGUuZGlzcGxheS5uYXRpdmVCYXJXaWR0aFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICRlKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAtIFllKGUpIC0gZS5kaXNwbGF5LmJhcldpZHRoXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gVmUoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodCAtIFllKGUpIC0gZS5kaXNwbGF5LmJhckhlaWdodFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEtlKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlLm9wdGlvbnMubGluZVdyYXBwaW5nLCBpID0gciAmJiAkZShlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0Lm1lYXN1cmUuaGVpZ2h0cyB8fCByICYmIHQubWVhc3VyZS53aWR0aCAhPSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHQubWVhc3VyZS5oZWlnaHRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQubWVhc3VyZS53aWR0aCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IHQudGV4dC5maXJzdENoaWxkLmdldENsaWVudFJlY3RzKCksIGwgPSAwOyBsIDwgYS5sZW5ndGggLSAxOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBhW2xdLCBjID0gYVtsICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHMuYm90dG9tIC0gYy5ib3R0b20pID4gMiAmJiBvLnB1c2goKHMuYm90dG9tICsgYy50b3ApIC8gMiAtIG4udG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucHVzaChuLmJvdHRvbSAtIG4udG9wKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gWGUoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5saW5lID09IHQpcmV0dXJuIHttYXA6IGUubWVhc3VyZS5tYXAsIGNhY2hlOiBlLm1lYXN1cmUuY2FjaGV9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGUucmVzdC5sZW5ndGg7IHIrKylpZiAoZS5yZXN0W3JdID09IHQpcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcDogZS5tZWFzdXJlLm1hcHNbcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogZS5tZWFzdXJlLmNhY2hlc1tyXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGUucmVzdC5sZW5ndGg7IHIrKylpZiAodGkoZS5yZXN0W3JdKSA+IG4pcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcDogZS5tZWFzdXJlLm1hcHNbcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogZS5tZWFzdXJlLmNhY2hlc1tyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZTogITBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFplKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHlyKHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRpKHQpLCByID0gZS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBuZXcgUHQoZS5kb2MsIHQsIG4pO1xuICAgICAgICAgICAgICAgICAgICByLmxpbmVOID0gbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSByLmJ1aWx0ID0gQnIoZSwgcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByLnRleHQgPSBpLnByZSwgcWkoZS5kaXNwbGF5LmxpbmVNZWFzdXJlLCBpLnByZSksIHJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBKZShlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0dChlLCBldChlLCB0KSwgbiwgcilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBRZShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID49IGUuZGlzcGxheS52aWV3RnJvbSAmJiB0IDwgZS5kaXNwbGF5LnZpZXdUbylyZXR1cm4gZS5kaXNwbGF5LnZpZXdbQnQoZSwgdCldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUuZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiAmJiB0ID49IG4ubGluZU4gJiYgdCA8IG4ubGluZU4gKyBuLnNpemUgPyBuIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZXQoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRpKHQpLCByID0gUWUoZSwgbik7XG4gICAgICAgICAgICAgICAgICAgIHIgJiYgIXIudGV4dCA/IHIgPSBudWxsIDogciAmJiByLmNoYW5nZXMgJiYgKEQoZSwgciwgbiwgUChlKSksIGUuY3VyT3AuZm9yY2VVcGRhdGUgPSAhMCksIHIgfHwgKHIgPSBaZShlLCB0KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gWGUociwgdCwgbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7bGluZTogdCwgdmlldzogciwgcmVjdDogbnVsbCwgbWFwOiBpLm1hcCwgY2FjaGU6IGkuY2FjaGUsIGJlZm9yZTogaS5iZWZvcmUsIGhhc0hlaWdodHM6ICExfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHR0KGUsIHQsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5iZWZvcmUgJiYgKG4gPSAtMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvLCBhID0gbiArIChyIHx8IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5jYWNoZS5oYXNPd25Qcm9wZXJ0eShhKSA/IG8gPSB0LmNhY2hlW2FdIDogKHQucmVjdCB8fCAodC5yZWN0ID0gdC52aWV3LnRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLCB0Lmhhc0hlaWdodHMgfHwgKEtlKGUsIHQudmlldywgdC5yZWN0KSwgdC5oYXNIZWlnaHRzID0gITApLCBvID0gcnQoZSwgdCwgbiwgciksIG8uYm9ndXMgfHwgKHQuY2FjaGVbYV0gPSBvKSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG8ubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBvLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBpID8gby5ydG9wIDogby50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IGkgPyBvLnJib3R0b20gOiBvLmJvdHRvbVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbnQoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByLCBpLCBvLCBhLCBsID0gMDsgbCA8IGUubGVuZ3RoOyBsICs9IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gZVtsXSwgYyA9IGVbbCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPiB0ID8gKGkgPSAwLCBvID0gMSwgYSA9IFwibGVmdFwiKSA6IGMgPiB0ID8gKGkgPSB0IC0gcywgbyA9IGkgKyAxKSA6IChsID09IGUubGVuZ3RoIC0gMyB8fCB0ID09IGMgJiYgZVtsICsgM10gPiB0KSAmJiAobyA9IGMgLSBzLCBpID0gbyAtIDEsIHQgPj0gYyAmJiAoYSA9IFwicmlnaHRcIikpLCBudWxsICE9IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9IGVbbCArIDJdLCBzID09IGMgJiYgbiA9PSAoci5pbnNlcnRMZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpICYmIChhID0gbiksIFwibGVmdFwiID09IG4gJiYgMCA9PSBpKWZvciAoOyBsICYmIGVbbCAtIDJdID09IGVbbCAtIDNdICYmIGVbbCAtIDFdLmluc2VydExlZnQ7KXIgPSBlWyhsIC09IDMpICsgMl0sIGEgPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJyaWdodFwiID09IG4gJiYgaSA9PSBjIC0gcylmb3IgKDsgbCA8IGUubGVuZ3RoIC0gMyAmJiBlW2wgKyAzXSA9PSBlW2wgKyA0XSAmJiAhZVtsICsgNV0uaW5zZXJ0TGVmdDspciA9IGVbKGwgKz0gMykgKyAyXSwgYSA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7bm9kZTogciwgc3RhcnQ6IGksIGVuZDogbywgY29sbGFwc2U6IGEsIGNvdmVyU3RhcnQ6IHMsIGNvdmVyRW5kOiBjfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJ0KGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8gPSBudCh0Lm1hcCwgbiwgciksIGEgPSBvLm5vZGUsIGwgPSBvLnN0YXJ0LCBzID0gby5lbmQsIGMgPSBvLmNvbGxhcHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMyA9PSBhLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB1ID0gMDsgNCA+IHU7IHUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBsICYmIHppKHQubGluZS50ZXh0LmNoYXJBdChvLmNvdmVyU3RhcnQgKyBsKSk7KS0tbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgby5jb3ZlclN0YXJ0ICsgcyA8IG8uY292ZXJFbmQgJiYgemkodC5saW5lLnRleHQuY2hhckF0KG8uY292ZXJTdGFydCArIHMpKTspKytzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4byAmJiA5ID4gYm8gJiYgMCA9PSBsICYmIHMgPT0gby5jb3ZlckVuZCAtIG8uY292ZXJTdGFydCkgaSA9IGEucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgZWxzZSBpZiAoeG8gJiYgZS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHFhKGEsIGwsIHMpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBmLmxlbmd0aCA/IGZbXCJyaWdodFwiID09IHIgPyBmLmxlbmd0aCAtIDEgOiAwXSA6IHFvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGkgPSBxYShhLCBsLCBzKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB8fCBxbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaS5sZWZ0IHx8IGkucmlnaHQgfHwgMCA9PSBsKWJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBsLCBsIC09IDEsIGMgPSBcInJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHhvICYmIDExID4gYm8gJiYgKGkgPSBpdChlLmRpc3BsYXkubWVhc3VyZSwgaSkpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsID4gMCAmJiAoYyA9IHIgPSBcInJpZ2h0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiAoZiA9IGEuZ2V0Q2xpZW50UmVjdHMoKSkubGVuZ3RoID4gMSA/IGZbXCJyaWdodFwiID09IHIgPyBmLmxlbmd0aCAtIDEgOiAwXSA6IGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoeG8gJiYgOSA+IGJvICYmICFsICYmICghaSB8fCAhaS5sZWZ0ICYmICFpLnJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBhLnBhcmVudE5vZGUuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBoID8ge2xlZnQ6IGgubGVmdCwgcmlnaHQ6IGgubGVmdCArIHh0KGUuZGlzcGxheSksIHRvcDogaC50b3AsIGJvdHRvbTogaC5ib3R0b219IDogcW9cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gaS50b3AgLSB0LnJlY3QudG9wLCBwID0gaS5ib3R0b20gLSB0LnJlY3QudG9wLCBtID0gKGQgKyBwKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSB0LnZpZXcubWVhc3VyZS5oZWlnaHRzLCB1ID0gMDsgdSA8IGcubGVuZ3RoIC0gMSAmJiAhKG0gPCBnW3VdKTsgdSsrKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB1ID8gZ1t1IC0gMV0gOiAwLCB5ID0gZ1t1XSwgeCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IChcInJpZ2h0XCIgPT0gYyA/IGkucmlnaHQgOiBpLmxlZnQpIC0gdC5yZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogKFwibGVmdFwiID09IGMgPyBpLmxlZnQgOiBpLnJpZ2h0KSAtIHQucmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB2LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiB5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpLmxlZnQgfHwgaS5yaWdodCB8fCAoeC5ib2d1cyA9ICEwKSwgZS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUgfHwgKHgucnRvcCA9IGQsIHgucmJvdHRvbSA9IHApLCB4XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXQoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5zY3JlZW4gfHwgbnVsbCA9PSBzY3JlZW4ubG9naWNhbFhEUEkgfHwgc2NyZWVuLmxvZ2ljYWxYRFBJID09IHNjcmVlbi5kZXZpY2VYRFBJIHx8ICFRaShlKSlyZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBzY3JlZW4ubG9naWNhbFhEUEkgLyBzY3JlZW4uZGV2aWNlWERQSSwgciA9IHNjcmVlbi5sb2dpY2FsWURQSSAvIHNjcmVlbi5kZXZpY2VZRFBJO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2xlZnQ6IHQubGVmdCAqIG4sIHJpZ2h0OiB0LnJpZ2h0ICogbiwgdG9wOiB0LnRvcCAqIHIsIGJvdHRvbTogdC5ib3R0b20gKiByfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG90KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubWVhc3VyZSAmJiAoZS5tZWFzdXJlLmNhY2hlID0ge30sIGUubWVhc3VyZS5oZWlnaHRzID0gbnVsbCwgZS5yZXN0KSlmb3IgKHZhciB0ID0gMDsgdCA8IGUucmVzdC5sZW5ndGg7IHQrKyllLm1lYXN1cmUuY2FjaGVzW3RdID0ge31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhdChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuZGlzcGxheS5leHRlcm5hbE1lYXN1cmUgPSBudWxsLCBVaShlLmRpc3BsYXkubGluZU1lYXN1cmUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGUuZGlzcGxheS52aWV3Lmxlbmd0aDsgdCsrKW90KGUuZGlzcGxheS52aWV3W3RdKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGx0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXQoZSksIGUuZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggPSBlLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCA9IGUuZGlzcGxheS5jYWNoZWRQYWRkaW5nSCA9IG51bGwsIGUub3B0aW9ucy5saW5lV3JhcHBpbmcgfHwgKGUuZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9ICEwKSwgZS5kaXNwbGF5LmxpbmVOdW1DaGFycyA9IG51bGxcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbExlZnRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHV0KGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQud2lkZ2V0cylmb3IgKHZhciBpID0gMDsgaSA8IHQud2lkZ2V0cy5sZW5ndGg7ICsraSlpZiAodC53aWRnZXRzW2ldLmFib3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IExyKHQud2lkZ2V0c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnRvcCArPSBvLCBuLmJvdHRvbSArPSBvXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFwibGluZVwiID09IHIpcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgICAgIHIgfHwgKHIgPSBcImxvY2FsXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHJpKHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJsb2NhbFwiID09IHIgPyBhICs9IFVlKGUuZGlzcGxheSkgOiBhIC09IGUuZGlzcGxheS52aWV3T2Zmc2V0LCBcInBhZ2VcIiA9PSByIHx8IFwid2luZG93XCIgPT0gcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBlLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBsLnRvcCArIChcIndpbmRvd1wiID09IHIgPyAwIDogY3QoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGwubGVmdCArIChcIndpbmRvd1wiID09IHIgPyAwIDogc3QoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLmxlZnQgKz0gcywgbi5yaWdodCArPSBzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4udG9wICs9IGEsIG4uYm90dG9tICs9IGEsIG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmdChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImRpdlwiID09IG4pcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gdC5sZWZ0LCBpID0gdC50b3A7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInBhZ2VcIiA9PSBuKSByIC09IHN0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpIC09IGN0KCk7IGVsc2UgaWYgKFwibG9jYWxcIiA9PSBuIHx8ICFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGUuZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gby5sZWZ0LCBpICs9IG8udG9wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBlLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2xlZnQ6IHIgLSBhLmxlZnQsIHRvcDogaSAtIGEudG9wfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGh0KGUsIHQsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgfHwgKHIgPSBacihlLmRvYywgdC5saW5lKSksIHV0KGUsIHIsIEplKGUsIHIsIHQuY2gsIGkpLCBuKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGR0KGUsIHQsIG4sIHIsIGksIG8pIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYSh0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHR0KGUsIGksIHQsIGEgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA/IGwubGVmdCA9IGwucmlnaHQgOiBsLnJpZ2h0ID0gbC5sZWZ0LCB1dChlLCByLCBsLCBuKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHNbdF0sIHIgPSBuLmxldmVsICUgMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlID09IHRvKG4pICYmIHQgJiYgbi5sZXZlbCA8IHNbdCAtIDFdLmxldmVsID8gKG4gPSBzWy0tdF0sIGUgPSBubyhuKSAtIChuLmxldmVsICUgMiA/IDAgOiAxKSwgciA9ICEwKSA6IGUgPT0gbm8obikgJiYgdCA8IHMubGVuZ3RoIC0gMSAmJiBuLmxldmVsIDwgc1t0ICsgMV0ubGV2ZWwgJiYgKG4gPSBzWysrdF0sIGUgPSB0byhuKSAtIG4ubGV2ZWwgJSAyLCByID0gITEpLCByICYmIGUgPT0gbi50byAmJiBlID4gbi5mcm9tID8gYShlIC0gMSkgOiBhKGUsIHIpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByID0gciB8fCBacihlLmRvYywgdC5saW5lKSwgaSB8fCAoaSA9IGV0KGUsIHIpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBpaShyKSwgYyA9IHQuY2g7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcylyZXR1cm4gYShjKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBjbyhzLCBjKSwgZiA9IGwoYywgdSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsICE9IGFsICYmIChmLm90aGVyID0gbChjLCBhbCkpLCBmXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHQoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IDAsIHQgPSBtZShlLmRvYywgdCk7XG4gICAgICAgICAgICAgICAgICAgIGUub3B0aW9ucy5saW5lV3JhcHBpbmcgfHwgKG4gPSB4dChlLmRpc3BsYXkpICogdC5jaCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gWnIoZS5kb2MsIHQubGluZSksIGkgPSByaShyKSArIFVlKGUuZGlzcGxheSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7bGVmdDogbiwgcmlnaHQ6IG4sIHRvcDogaSwgYm90dG9tOiBpICsgci5oZWlnaHR9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbXQoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IEJvKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaS54UmVsID0gciwgbiAmJiAoaS5vdXRzaWRlID0gITApLCBpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ3QoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUuZG9jO1xuICAgICAgICAgICAgICAgICAgICBpZiAobiArPSBlLmRpc3BsYXkudmlld09mZnNldCwgMCA+IG4pcmV0dXJuIG10KHIuZmlyc3QsIDAsICEwLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gbmkociwgbiksIG8gPSByLmZpcnN0ICsgci5zaXplIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiBvKXJldHVybiBtdChyLmZpcnN0ICsgci5zaXplIC0gMSwgWnIociwgbykudGV4dC5sZW5ndGgsICEwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgMCA+IHQgJiYgKHQgPSAwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IFpyKHIsIGkpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHZ0KGUsIGEsIGksIHQsIG4pLCBzID0gZ3IoYSksIGMgPSBzICYmIHMuZmluZCgwLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXMgfHwgIShsLmNoID4gYy5mcm9tLmNoIHx8IGwuY2ggPT0gYy5mcm9tLmNoICYmIGwueFJlbCA+IDApKXJldHVybiBsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHRpKGEgPSBjLnRvLmxpbmUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB2dChlLCB0LCBuLCByLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG8ocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBkdChlLCBCbyhuLCByKSwgXCJsaW5lXCIsIHQsIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwgPSAhMCwgYSA+IGkuYm90dG9tID8gaS5sZWZ0IC0gcyA6IGEgPCBpLnRvcCA/IGkubGVmdCArIHMgOiAobCA9ICExLCBpLmxlZnQpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGkgLSByaSh0KSwgbCA9ICExLCBzID0gMiAqIGUuZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoLCBjID0gZXQoZSwgdCksIHUgPSBpaSh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSB0LnRleHQubGVuZ3RoLCBoID0gcm8odCksIGQgPSBpbyh0KSwgcCA9IG8oaCksIG0gPSBsLCBnID0gbyhkKSwgdiA9IGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyID4gZylyZXR1cm4gbXQobiwgZCwgdiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodSA/IGQgPT0gaCB8fCBkID09IGZvKHQsIGgsIDEpIDogMSA+PSBkIC0gaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSBwID4gciB8fCBnIC0gciA+PSByIC0gcCA/IGggOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSByIC0gKHkgPT0gaCA/IHAgOiBnKTsgemkodC50ZXh0LmNoYXJBdCh5KSk7KSsreTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IG10KG4sIHksIHkgPT0gaCA/IG0gOiB2LCAtMSA+IHggPyAtMSA6IHggPiAxID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IE1hdGguY2VpbChmIC8gMiksIGsgPSBoICsgdztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgUyA9IDA7IHcgPiBTOyArK1MpayA9IGZvKHQsIGssIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgQyA9IG8oayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBDID4gciA/IChkID0gaywgZyA9IEMsICh2ID0gbCkgJiYgKGcgKz0gMWUzKSwgZiA9IHcpIDogKGggPSBrLCBwID0gQywgbSA9IGwsIGYgLT0gdylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHl0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gZS5jYWNoZWRUZXh0SGVpZ2h0KXJldHVybiBlLmNhY2hlZFRleHRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IHpvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6byA9IGppKFwicHJlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IDQ5ID4gdDsgKyt0KXpvLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSksIHpvLmFwcGVuZENoaWxkKGppKFwiYnJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgem8uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHFpKGUubWVhc3VyZSwgem8pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHpvLm9mZnNldEhlaWdodCAvIDUwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiA+IDMgJiYgKGUuY2FjaGVkVGV4dEhlaWdodCA9IG4pLCBVaShlLm1lYXN1cmUpLCBuIHx8IDFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB4dChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IGUuY2FjaGVkQ2hhcldpZHRoKXJldHVybiBlLmNhY2hlZENoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBqaShcInNwYW5cIiwgXCJ4eHh4eHh4eHh4XCIpLCBuID0gamkoXCJwcmVcIiwgW3RdKTtcbiAgICAgICAgICAgICAgICAgICAgcWkoZS5tZWFzdXJlLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBpID0gKHIucmlnaHQgLSByLmxlZnQpIC8gMTA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpID4gMiAmJiAoZS5jYWNoZWRDaGFyV2lkdGggPSBpKSwgaSB8fCAxMFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJ0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5jdXJPcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0NoYW5nZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRIZWlnaHQ6IGUuZG9jLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUlucHV0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwaW5nOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZU9ianM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JBY3Rpdml0eUhhbmRsZXJzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yQWN0aXZpdHlDYWxsZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2VkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZU1heExpbmU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvUG9zOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICsrWW9cbiAgICAgICAgICAgICAgICAgICAgfSwgR28gPyBHby5vcHMucHVzaChlLmN1ck9wKSA6IGUuY3VyT3Aub3duc0dyb3VwID0gR28gPSB7b3BzOiBbZS5jdXJPcF0sIGRlbGF5ZWRDYWxsYmFja3M6IFtdfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHd0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmRlbGF5ZWRDYWxsYmFja3MsIG4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbiA8IHQubGVuZ3RoOyBuKyspdFtuXS5jYWxsKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBlLm9wcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZS5vcHNbcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkuY3Vyc29yQWN0aXZpdHlIYW5kbGVycylmb3IgKDsgaS5jdXJzb3JBY3Rpdml0eUNhbGxlZCA8IGkuY3Vyc29yQWN0aXZpdHlIYW5kbGVycy5sZW5ndGg7KWkuY3Vyc29yQWN0aXZpdHlIYW5kbGVyc1tpLmN1cnNvckFjdGl2aXR5Q2FsbGVkKytdLmNhbGwobnVsbCwgaS5jbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobiA8IHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGt0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmN1ck9wLCBuID0gdC5vd25zR3JvdXA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuKXRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3dChuKVxuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgR28gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBuLm9wcy5sZW5ndGg7IHIrKyluLm9wc1tyXS5jbS5jdXJPcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBTdChuKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU3QoZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gZS5vcHMsIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKylDdCh0W25dKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKUx0KHRbbl0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspVHQodFtuXSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKylNdCh0W25dKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKU50KHRbbl0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQ3QoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUuY20sIG4gPSB0LmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgIFQodCksIGUudXBkYXRlTWF4TGluZSAmJiBoKHQpLCBlLm11c3RVcGRhdGUgPSBlLnZpZXdDaGFuZ2VkIHx8IGUuZm9yY2VVcGRhdGUgfHwgbnVsbCAhPSBlLnNjcm9sbFRvcCB8fCBlLnNjcm9sbFRvUG9zICYmIChlLnNjcm9sbFRvUG9zLmZyb20ubGluZSA8IG4udmlld0Zyb20gfHwgZS5zY3JvbGxUb1Bvcy50by5saW5lID49IG4udmlld1RvKSB8fCBuLm1heExpbmVDaGFuZ2VkICYmIHQub3B0aW9ucy5saW5lV3JhcHBpbmcsIGUudXBkYXRlID0gZS5tdXN0VXBkYXRlICYmIG5ldyBMKHQsIGUubXVzdFVwZGF0ZSAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogZS5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuc3VyZTogZS5zY3JvbGxUb1Bvc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGUuZm9yY2VVcGRhdGUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTHQoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnVwZGF0ZWREaXNwbGF5ID0gZS5tdXN0VXBkYXRlICYmIE0oZS5jbSwgZS51cGRhdGUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gVHQoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUuY20sIG4gPSB0LmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgIGUudXBkYXRlZERpc3BsYXkgJiYgTyh0KSwgZS5iYXJNZWFzdXJlID0gcCh0KSwgbi5tYXhMaW5lQ2hhbmdlZCAmJiAhdC5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiAoZS5hZGp1c3RXaWR0aFRvID0gSmUodCwgbi5tYXhMaW5lLCBuLm1heExpbmUudGV4dC5sZW5ndGgpLmxlZnQgKyAzLCB0LmRpc3BsYXkuc2l6ZXJXaWR0aCA9IGUuYWRqdXN0V2lkdGhUbywgZS5iYXJNZWFzdXJlLnNjcm9sbFdpZHRoID0gTWF0aC5tYXgobi5zY3JvbGxlci5jbGllbnRXaWR0aCwgbi5zaXplci5vZmZzZXRMZWZ0ICsgZS5hZGp1c3RXaWR0aFRvICsgWWUodCkgKyB0LmRpc3BsYXkuYmFyV2lkdGgpLCBlLm1heFNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBuLnNpemVyLm9mZnNldExlZnQgKyBlLmFkanVzdFdpZHRoVG8gLSAkZSh0KSkpLCAoZS51cGRhdGVkRGlzcGxheSB8fCBlLnNlbGVjdGlvbkNoYW5nZWQpICYmIChlLnByZXBhcmVkU2VsZWN0aW9uID0gbi5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKGUuZm9jdXMpKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE10KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmNtO1xuICAgICAgICAgICAgICAgICAgICBudWxsICE9IGUuYWRqdXN0V2lkdGhUbyAmJiAodC5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoID0gZS5hZGp1c3RXaWR0aFRvICsgXCJweFwiLCBlLm1heFNjcm9sbExlZnQgPCB0LmRvYy5zY3JvbGxMZWZ0ICYmIG9uKHQsIE1hdGgubWluKHQuZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0LCBlLm1heFNjcm9sbExlZnQpLCAhMCksIHQuZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmZvY3VzICYmIGUuZm9jdXMgPT0gR2koKSAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXBhcmVkU2VsZWN0aW9uICYmIHQuZGlzcGxheS5pbnB1dC5zaG93U2VsZWN0aW9uKGUucHJlcGFyZWRTZWxlY3Rpb24sIG4pLCAoZS51cGRhdGVkRGlzcGxheSB8fCBlLnN0YXJ0SGVpZ2h0ICE9IHQuZG9jLmhlaWdodCkgJiYgeSh0LCBlLmJhck1lYXN1cmUpLCBlLnVwZGF0ZWREaXNwbGF5ICYmIEUodCwgZS5iYXJNZWFzdXJlKSwgZS5zZWxlY3Rpb25DaGFuZ2VkICYmIEJlKHQpLCB0LnN0YXRlLmZvY3VzZWQgJiYgZS51cGRhdGVJbnB1dCAmJiB0LmRpc3BsYXkuaW5wdXQucmVzZXQoZS50eXBpbmcpLCBuICYmIFgoZS5jbSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBOdChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5jbSwgbiA9IHQuZGlzcGxheSwgciA9IHQuZG9jO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS51cGRhdGVkRGlzcGxheSAmJiBOKHQsIGUudXBkYXRlKSwgbnVsbCA9PSBuLndoZWVsU3RhcnRYIHx8IG51bGwgPT0gZS5zY3JvbGxUb3AgJiYgbnVsbCA9PSBlLnNjcm9sbExlZnQgJiYgIWUuc2Nyb2xsVG9Qb3MgfHwgKG4ud2hlZWxTdGFydFggPSBuLndoZWVsU3RhcnRZID0gbnVsbCksIG51bGwgPT0gZS5zY3JvbGxUb3AgfHwgbi5zY3JvbGxlci5zY3JvbGxUb3AgPT0gZS5zY3JvbGxUb3AgJiYgIWUuZm9yY2VTY3JvbGwgfHwgKHIuc2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obi5zY3JvbGxlci5zY3JvbGxIZWlnaHQgLSBuLnNjcm9sbGVyLmNsaWVudEhlaWdodCwgZS5zY3JvbGxUb3ApKSwgbi5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChyLnNjcm9sbFRvcCksIG4uc2Nyb2xsZXIuc2Nyb2xsVG9wID0gci5zY3JvbGxUb3ApLCBudWxsID09IGUuc2Nyb2xsTGVmdCB8fCBuLnNjcm9sbGVyLnNjcm9sbExlZnQgPT0gZS5zY3JvbGxMZWZ0ICYmICFlLmZvcmNlU2Nyb2xsIHx8IChyLnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihuLnNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gbi5zY3JvbGxlci5jbGllbnRXaWR0aCwgZS5zY3JvbGxMZWZ0KSksIG4uc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KHIuc2Nyb2xsTGVmdCksIG4uc2Nyb2xsZXIuc2Nyb2xsTGVmdCA9IHIuc2Nyb2xsTGVmdCwgdyh0KSksIGUuc2Nyb2xsVG9Qb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gUm4odCwgbWUociwgZS5zY3JvbGxUb1Bvcy5mcm9tKSwgbWUociwgZS5zY3JvbGxUb1Bvcy50byksIGUuc2Nyb2xsVG9Qb3MubWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2Nyb2xsVG9Qb3MuaXNDdXJzb3IgJiYgdC5zdGF0ZS5mb2N1c2VkICYmIFBuKHQsIGkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBlLm1heWJlSGlkZGVuTWFya2VycywgYSA9IGUubWF5YmVVbmhpZGRlbk1hcmtlcnM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvKWZvciAodmFyIGwgPSAwOyBsIDwgby5sZW5ndGg7ICsrbClvW2xdLmxpbmVzLmxlbmd0aCB8fCBQYShvW2xdLCBcImhpZGVcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhKWZvciAodmFyIGwgPSAwOyBsIDwgYS5sZW5ndGg7ICsrbClhW2xdLmxpbmVzLmxlbmd0aCAmJiBQYShhW2xdLCBcInVuaGlkZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbi53cmFwcGVyLm9mZnNldEhlaWdodCAmJiAoci5zY3JvbGxUb3AgPSB0LmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wKSwgZS5jaGFuZ2VPYmpzICYmIFBhKHQsIFwiY2hhbmdlc1wiLCB0LCBlLmNoYW5nZU9ianMpLCBlLnVwZGF0ZSAmJiBlLnVwZGF0ZS5maW5pc2goKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEF0KGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY3VyT3ApcmV0dXJuIHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnQoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCgpXG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrdChlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRXQoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY3VyT3ApcmV0dXJuIHQuYXBwbHkoZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5hcHBseShlLCBhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGt0KGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBPdChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJPcClyZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga3QodGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEl0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5jbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdCB8fCB0LmN1ck9wKXJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidCh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrdCh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUHQoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmUgPSB0LCB0aGlzLnJlc3QgPSB4cih0KSwgdGhpcy5zaXplID0gdGhpcy5yZXN0ID8gdGkoSWkodGhpcy5yZXN0KSkgLSBuICsgMSA6IDEsIHRoaXMubm9kZSA9IHRoaXMudGV4dCA9IG51bGwsIHRoaXMuaGlkZGVuID0ga3IoZSwgdClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBSdChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIsIGkgPSBbXSwgbyA9IHQ7IG4gPiBvOyBvID0gcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgUHQoZS5kb2MsIFpyKGUuZG9jLCBvKSwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gbyArIGEuc2l6ZSwgaS5wdXNoKGEpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBEdChlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT0gdCAmJiAodCA9IGUuZG9jLmZpcnN0KSwgbnVsbCA9PSBuICYmIChuID0gZS5kb2MuZmlyc3QgKyBlLmRvYy5zaXplKSwgciB8fCAociA9IDApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGUuZGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgJiYgbiA8IGkudmlld1RvICYmIChudWxsID09IGkudXBkYXRlTGluZU51bWJlcnMgfHwgaS51cGRhdGVMaW5lTnVtYmVycyA+IHQpICYmIChpLnVwZGF0ZUxpbmVOdW1iZXJzID0gdCksIGUuY3VyT3Audmlld0NoYW5nZWQgPSAhMCwgdCA+PSBpLnZpZXdUbykgV28gJiYgYnIoZS5kb2MsIHQpIDwgaS52aWV3VG8gJiYgV3QoZSk7IGVsc2UgaWYgKG4gPD0gaS52aWV3RnJvbSkgV28gJiYgd3IoZS5kb2MsIG4gKyByKSA+IGkudmlld0Zyb20gPyBXdChlKSA6IChpLnZpZXdGcm9tICs9IHIsIGkudmlld1RvICs9IHIpOyBlbHNlIGlmICh0IDw9IGkudmlld0Zyb20gJiYgbiA+PSBpLnZpZXdUbykgV3QoZSk7IGVsc2UgaWYgKHQgPD0gaS52aWV3RnJvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBfdChlLCBuLCBuICsgciwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvID8gKGkudmlldyA9IGkudmlldy5zbGljZShvLmluZGV4KSwgaS52aWV3RnJvbSA9IG8ubGluZU4sIGkudmlld1RvICs9IHIpIDogV3QoZSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuID49IGkudmlld1RvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IF90KGUsIHQsIHQsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPyAoaS52aWV3ID0gaS52aWV3LnNsaWNlKDAsIG8uaW5kZXgpLCBpLnZpZXdUbyA9IG8ubGluZU4pIDogV3QoZSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gX3QoZSwgdCwgdCwgLTEpLCBsID0gX3QoZSwgbiwgbiArIHIsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYSAmJiBsID8gKGkudmlldyA9IGkudmlldy5zbGljZSgwLCBhLmluZGV4KS5jb25jYXQoUnQoZSwgYS5saW5lTiwgbC5saW5lTikpLmNvbmNhdChpLnZpZXcuc2xpY2UobC5pbmRleCkpLCBpLnZpZXdUbyArPSByKSA6IFd0KGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBpLmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgICAgICAgICAgICAgICAgIHMgJiYgKG4gPCBzLmxpbmVOID8gcy5saW5lTiArPSByIDogdCA8IHMubGluZU4gKyBzLnNpemUgJiYgKGkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGwpKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEh0KGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgZS5jdXJPcC52aWV3Q2hhbmdlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUuZGlzcGxheSwgaSA9IGUuZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAmJiB0ID49IGkubGluZU4gJiYgdCA8IGkubGluZU4gKyBpLnNpemUgJiYgKHIuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGwpLCAhKHQgPCByLnZpZXdGcm9tIHx8IHQgPj0gci52aWV3VG8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHIudmlld1tCdChlLCB0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBvLm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG8uY2hhbmdlcyB8fCAoby5jaGFuZ2VzID0gW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xID09IFBpKGEsIG4pICYmIGEucHVzaChuKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gV3QoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLmRpc3BsYXkudmlld0Zyb20gPSBlLmRpc3BsYXkudmlld1RvID0gZS5kb2MuZmlyc3QsIGUuZGlzcGxheS52aWV3ID0gW10sIGUuZGlzcGxheS52aWV3T2Zmc2V0ID0gMFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEJ0KGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPj0gZS5kaXNwbGF5LnZpZXdUbylyZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgLT0gZS5kaXNwbGF5LnZpZXdGcm9tLCAwID4gdClyZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IGUuZGlzcGxheS52aWV3LCByID0gMDsgciA8IG4ubGVuZ3RoOyByKyspaWYgKHQgLT0gbltyXS5zaXplLCAwID4gdClyZXR1cm4gclxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF90KGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8gPSBCdChlLCB0KSwgYSA9IGUuZGlzcGxheS52aWV3O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVdvIHx8IG4gPT0gZS5kb2MuZmlyc3QgKyBlLmRvYy5zaXplKXJldHVybiB7aW5kZXg6IG8sIGxpbmVOOiBufTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDAsIHMgPSBlLmRpc3BsYXkudmlld0Zyb207IG8gPiBsOyBsKyspcyArPSBhW2xdLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzICE9IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvID09IGEubGVuZ3RoIC0gMSlyZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gcyArIGFbb10uc2l6ZSAtIHQsIG8rK1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGkgPSBzIC0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgKz0gaSwgbiArPSBpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGJyKGUuZG9jLCBuKSAhPSBuOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8gPT0gKDAgPiByID8gMCA6IGEubGVuZ3RoIC0gMSkpcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IHIgKiBhW28gLSAoMCA+IHIgPyAxIDogMCldLnNpemUsIG8gKz0gclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IG8sIGxpbmVOOiBufVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEZ0KGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlLmRpc3BsYXksIGkgPSByLnZpZXc7XG4gICAgICAgICAgICAgICAgICAgIDAgPT0gaS5sZW5ndGggfHwgdCA+PSByLnZpZXdUbyB8fCBuIDw9IHIudmlld0Zyb20gPyAoci52aWV3ID0gUnQoZSwgdCwgbiksIHIudmlld0Zyb20gPSB0KSA6IChyLnZpZXdGcm9tID4gdCA/IHIudmlldyA9IFJ0KGUsIHQsIHIudmlld0Zyb20pLmNvbmNhdChyLnZpZXcpIDogci52aWV3RnJvbSA8IHQgJiYgKHIudmlldyA9IHIudmlldy5zbGljZShCdChlLCB0KSkpLCByLnZpZXdGcm9tID0gdCwgci52aWV3VG8gPCBuID8gci52aWV3ID0gci52aWV3LmNvbmNhdChSdChlLCByLnZpZXdUbywgbikpIDogci52aWV3VG8gPiBuICYmIChyLnZpZXcgPSByLnZpZXcuc2xpY2UoMCwgQnQoZSwgbikpKSksIHIudmlld1RvID0gblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHp0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IGUuZGlzcGxheS52aWV3LCBuID0gMCwgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRbcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpLmhpZGRlbiB8fCBpLm5vZGUgJiYgIWkuY2hhbmdlcyB8fCArK25cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGp0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuYWN0aXZlVG91Y2ggJiYgKG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLmFjdGl2ZVRvdWNoID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMWUzKSwgYSA9IGkuYWN0aXZlVG91Y2gsIGEuZW5kID0gK25ldyBEYXRlKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMSAhPSBlLnRvdWNoZXMubGVuZ3RoKXJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS50b3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQucmFkaXVzWCA8PSAxICYmIHQucmFkaXVzWSA8PSAxXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IHQubGVmdClyZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHQubGVmdCAtIGUubGVmdCwgciA9IHQudG9wIC0gZS50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiAqIG4gKyByICogciA+IDQwMFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgIEVhKGkuc2Nyb2xsZXIsIFwibW91c2Vkb3duXCIsIEV0KGUsICR0KSksIHhvICYmIDExID4gYm8gPyBFYShpLnNjcm9sbGVyLCBcImRibGNsaWNrXCIsIEV0KGUsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVRpKGUsIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBZdChlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobiAmJiAhSnQoZSwgdCkgJiYgIUd0KGUuZGlzcGxheSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWEodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5maW5kV29yZEF0KG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZShlLmRvYywgci5hbmNob3IsIHIuaGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKSA6IEVhKGkuc2Nyb2xsZXIsIFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRpKGUsIHQpIHx8IE1hKHQpXG4gICAgICAgICAgICAgICAgICAgIH0pLCBEbyB8fCBFYShpLnNjcm9sbGVyLCBcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bihlLCB0KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8sIGEgPSB7ZW5kOiAwfTtcbiAgICAgICAgICAgICAgICAgICAgRWEoaS5zY3JvbGxlciwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVRpKGUsIHQpICYmICFuKHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gK25ldyBEYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuYWN0aXZlVG91Y2ggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiByLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXY6IHIgLSBhLmVuZCA8PSAzMDAgPyBhIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEgPT0gdC50b3VjaGVzLmxlbmd0aCAmJiAoaS5hY3RpdmVUb3VjaC5sZWZ0ID0gdC50b3VjaGVzWzBdLnBhZ2VYLCBpLmFjdGl2ZVRvdWNoLnRvcCA9IHQudG91Y2hlc1swXS5wYWdlWSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSksIEVhKGkuc2Nyb2xsZXIsIFwidG91Y2htb3ZlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuYWN0aXZlVG91Y2ggJiYgKGkuYWN0aXZlVG91Y2gubW92ZWQgPSAhMClcbiAgICAgICAgICAgICAgICAgICAgfSksIEVhKGkuc2Nyb2xsZXIsIFwidG91Y2hlbmRcIiwgZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gaS5hY3RpdmVUb3VjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvICYmICFHdChpLCBuKSAmJiBudWxsICE9IG8ubGVmdCAmJiAhby5tb3ZlZCAmJiBuZXcgRGF0ZSAtIG8uc3RhcnQgPCAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSwgbCA9IGUuY29vcmRzQ2hhcihpLmFjdGl2ZVRvdWNoLCBcInBhZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9ICFvLnByZXYgfHwgcihvLCBvLnByZXYpID8gbmV3IGZlKGwsIGwpIDogIW8ucHJldi5wcmV2IHx8IHIobywgby5wcmV2LnByZXYpID8gZS5maW5kV29yZEF0KGwpIDogbmV3IGZlKEJvKGwubGluZSwgMCksIG1lKGUuZG9jLCBCbyhsLmxpbmUgKyAxLCAwKSkpLCBlLnNldFNlbGVjdGlvbihhLmFuY2hvciwgYS5oZWFkKSwgZS5mb2N1cygpLCBNYShuKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdCgpXG4gICAgICAgICAgICAgICAgICAgIH0pLCBFYShpLnNjcm9sbGVyLCBcInRvdWNoY2FuY2VsXCIsIHQpLCBFYShpLnNjcm9sbGVyLCBcInNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLnNjcm9sbGVyLmNsaWVudEhlaWdodCAmJiAocm4oZSwgaS5zY3JvbGxlci5zY3JvbGxUb3ApLCBvbihlLCBpLnNjcm9sbGVyLnNjcm9sbExlZnQsICEwKSwgUGEoZSwgXCJzY3JvbGxcIiwgZSkpXG4gICAgICAgICAgICAgICAgICAgIH0pLCBFYShpLnNjcm9sbGVyLCBcIm1vdXNld2hlZWxcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuKGUsIHQpXG4gICAgICAgICAgICAgICAgICAgIH0pLCBFYShpLnNjcm9sbGVyLCBcIkRPTU1vdXNlU2Nyb2xsXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbihlLCB0KVxuICAgICAgICAgICAgICAgICAgICB9KSwgRWEoaS53cmFwcGVyLCBcInNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLndyYXBwZXIuc2Nyb2xsVG9wID0gaS53cmFwcGVyLnNjcm9sbExlZnQgPSAwXG4gICAgICAgICAgICAgICAgICAgIH0pLCBpLmRyYWdGdW5jdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaShlLCB0KSB8fCBBYSh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3ZlcjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaShlLCB0KSB8fCAodG4oZSwgdCksIEFhKHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgc3RhcnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW4oZSwgdClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGRyb3A6IEV0KGUsIFF0KSwgbGVhdmU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVGkoZSwgdCkgfHwgbm4oZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBpLmlucHV0LmdldEZpZWxkKCk7XG4gICAgICAgICAgICAgICAgICAgIEVhKGwsIFwia2V5dXBcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBuLmNhbGwoZSwgdClcbiAgICAgICAgICAgICAgICAgICAgfSksIEVhKGwsIFwia2V5ZG93blwiLCBFdChlLCBobikpLCBFYShsLCBcImtleXByZXNzXCIsIEV0KGUsIG1uKSksIEVhKGwsIFwiZm9jdXNcIiwgQmkodm4sIGUpKSwgRWEobCwgXCJibHVyXCIsIEJpKHluLCBlKSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBVdCh0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gciAmJiByICE9IGUuSW5pdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuICE9ICFpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHQuZGlzcGxheS5kcmFnRnVuY3Rpb25zLCBhID0gbiA/IEVhIDogSWE7XG4gICAgICAgICAgICAgICAgICAgICAgICBhKHQuZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgby5zdGFydCksIGEodC5kaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdlbnRlclwiLCBvLmVudGVyKSwgYSh0LmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ292ZXJcIiwgby5vdmVyKSwgYSh0LmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ2xlYXZlXCIsIG8ubGVhdmUpLCBhKHQuZGlzcGxheS5zY3JvbGxlciwgXCJkcm9wXCIsIG8uZHJvcClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHF0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgIHQubGFzdFdyYXBIZWlnaHQgPT0gdC53cmFwcGVyLmNsaWVudEhlaWdodCAmJiB0Lmxhc3RXcmFwV2lkdGggPT0gdC53cmFwcGVyLmNsaWVudFdpZHRoIHx8ICh0LmNhY2hlZENoYXJXaWR0aCA9IHQuY2FjaGVkVGV4dEhlaWdodCA9IHQuY2FjaGVkUGFkZGluZ0ggPSBudWxsLCB0LnNjcm9sbGJhcnNDbGlwcGVkID0gITEsIGUuc2V0U2l6ZSgpKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEd0KGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IHdpKHQpOyBuICE9IGUud3JhcHBlcjsgbiA9IG4ucGFyZW50Tm9kZSlpZiAoIW4gfHwgMSA9PSBuLm5vZGVUeXBlICYmIFwidHJ1ZVwiID09IG4uZ2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiKSB8fCBuLnBhcmVudE5vZGUgPT0gZS5zaXplciAmJiBuICE9IGUubW92ZXIpcmV0dXJuICEwXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gWXQoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGUuZGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuICYmIFwidHJ1ZVwiID09IHdpKHQpLmdldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIpKXJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbywgYSwgbCA9IGkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHQuY2xpZW50WCAtIGwubGVmdCwgYSA9IHQuY2xpZW50WSAtIGwudG9wXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHMsIGMgPSBndChlLCBvLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgJiYgMSA9PSBjLnhSZWwgJiYgKHMgPSBacihlLmRvYywgYy5saW5lKS50ZXh0KS5sZW5ndGggPT0gYy5jaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBGYShzLCBzLmxlbmd0aCwgZS5vcHRpb25zLnRhYlNpemUpIC0gcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gQm8oYy5saW5lLCBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKChvIC0gR2UoZS5kaXNwbGF5KS5sZWZ0KSAvIHh0KGUuZGlzcGxheSkpIC0gdSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAkdChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcywgbiA9IHQuZGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoVGkodCwgZSkgfHwgbi5hY3RpdmVUb3VjaCAmJiBuLmlucHV0LnN1cHBvcnRzVG91Y2goKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnNoaWZ0ID0gZS5zaGlmdEtleSwgR3QobiwgZSkpcmV0dXJuIHZvaWQod28gfHwgKG4uc2Nyb2xsZXIuZHJhZ2dhYmxlID0gITEsIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uc2Nyb2xsZXIuZHJhZ2dhYmxlID0gITBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghSnQodCwgZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IFl0KHQsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAod2luZG93LmZvY3VzKCksIGtpKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuc3RhdGUuc2VsZWN0aW5nVGV4dCA/IHQuc3RhdGUuc2VsZWN0aW5nVGV4dChlKSA6IHIgPyBWdCh0LCBlLCByKSA6IHdpKGUpID09IG4uc2Nyb2xsZXIgJiYgTWEoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd28gJiYgKHQuc3RhdGUubGFzdE1pZGRsZURvd24gPSArbmV3IERhdGUpLCByICYmIGJlKHQuZG9jLCByKSwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5pbnB1dC5mb2N1cygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAyMCksIE1hKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERvID8geG4odCwgZSkgOiBnbih0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFZ0KGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgeG8gPyBzZXRUaW1lb3V0KEJpKFgsIGUpLCAwKSA6IGUuY3VyT3AuZm9jdXMgPSBHaSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciwgaSA9ICtuZXcgRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgVW8gJiYgVW8udGltZSA+IGkgLSA0MDAgJiYgMCA9PSBfbyhVby5wb3MsIG4pID8gciA9IFwidHJpcGxlXCIgOiBqbyAmJiBqby50aW1lID4gaSAtIDQwMCAmJiAwID09IF9vKGpvLnBvcywgbikgPyAociA9IFwiZG91YmxlXCIsIFVvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogblxuICAgICAgICAgICAgICAgICAgICB9KSA6IChyID0gXCJzaW5nbGVcIiwgam8gPSB7dGltZTogaSwgcG9zOiBufSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvLCBhID0gZS5kb2Muc2VsLCBsID0gRW8gPyB0Lm1ldGFLZXkgOiB0LmN0cmxLZXk7XG4gICAgICAgICAgICAgICAgICAgIGUub3B0aW9ucy5kcmFnRHJvcCAmJiBlbCAmJiAhZS5pc1JlYWRPbmx5KCkgJiYgXCJzaW5nbGVcIiA9PSByICYmIChvID0gYS5jb250YWlucyhuKSkgPiAtMSAmJiAoX28oKG8gPSBhLnJhbmdlc1tvXSkuZnJvbSgpLCBuKSA8IDAgfHwgbi54UmVsID4gMCkgJiYgKF9vKG8udG8oKSwgbikgPiAwIHx8IG4ueFJlbCA8IDApID8gS3QoZSwgdCwgbiwgbCkgOiBYdChlLCB0LCBuLCByLCBsKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEt0KGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlLmRpc3BsYXksIG8gPSArbmV3IERhdGUsIGEgPSBFdChlLCBmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd28gJiYgKGkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gITEpLCBlLnN0YXRlLmRyYWdnaW5nVGV4dCA9ICExLCBJYShkb2N1bWVudCwgXCJtb3VzZXVwXCIsIGEpLCBJYShpLnNjcm9sbGVyLCBcImRyb3BcIiwgYSksIE1hdGguYWJzKHQuY2xpZW50WCAtIGwuY2xpZW50WCkgKyBNYXRoLmFicyh0LmNsaWVudFkgLSBsLmNsaWVudFkpIDwgMTAgJiYgKE1hKGwpLCAhciAmJiArbmV3IERhdGUgLSAyMDAgPCBvICYmIGJlKGUuZG9jLCBuKSwgd28gfHwgeG8gJiYgOSA9PSBibyA/IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKSwgaS5pbnB1dC5mb2N1cygpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAyMCkgOiBpLmlucHV0LmZvY3VzKCkpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB3byAmJiAoaS5zY3JvbGxlci5kcmFnZ2FibGUgPSAhMCksIGUuc3RhdGUuZHJhZ2dpbmdUZXh0ID0gYSwgaS5zY3JvbGxlci5kcmFnRHJvcCAmJiBpLnNjcm9sbGVyLmRyYWdEcm9wKCksIEVhKGRvY3VtZW50LCBcIm1vdXNldXBcIiwgYSksIEVhKGkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBhKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFh0KGUsIHQsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbyh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCAhPSBfbyhnLCB0KSlpZiAoZyA9IHQsIFwicmVjdFwiID09IHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gW10sIG8gPSBlLm9wdGlvbnMudGFiU2l6ZSwgYSA9IEZhKFpyKGMsIG4ubGluZSkudGV4dCwgbi5jaCwgbyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IEZhKFpyKGMsIHQubGluZSkudGV4dCwgdC5jaCwgbyksIHMgPSBNYXRoLm1pbihhLCBsKSwgZCA9IE1hdGgubWF4KGEsIGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBNYXRoLm1pbihuLmxpbmUsIHQubGluZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IE1hdGgubWluKGUubGFzdExpbmUoKSwgTWF0aC5tYXgobi5saW5lLCB0LmxpbmUpKTsgbSA+PSBwOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBacihjLCBwKS50ZXh0LCB5ID0gemEodiwgcywgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPT0gZCA/IGkucHVzaChuZXcgZmUoQm8ocCwgeSksIEJvKHAsIHkpKSkgOiB2Lmxlbmd0aCA+IHkgJiYgaS5wdXNoKG5ldyBmZShCbyhwLCB5KSwgQm8ocCwgemEodiwgZCwgbykpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS5sZW5ndGggfHwgaS5wdXNoKG5ldyBmZShuLCBuKSksIFRlKGMsIGhlKGgucmFuZ2VzLnNsaWNlKDAsIGYpLmNvbmNhdChpKSwgZiksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcIiptb3VzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGw6ICExXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGUuc2Nyb2xsSW50b1ZpZXcodClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB1LCBiID0geC5hbmNob3IsIHcgPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInNpbmdsZVwiICE9IHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZG91YmxlXCIgPT0gcil2YXIgayA9IGUuZmluZFdvcmRBdCh0KTsgZWxzZSB2YXIgayA9IG5ldyBmZShCbyh0LmxpbmUsIDApLCBtZShjLCBCbyh0LmxpbmUgKyAxLCAwKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbyhrLmFuY2hvciwgYikgPiAwID8gKHcgPSBrLmhlYWQsIGIgPSBLKHguZnJvbSgpLCBrLmFuY2hvcikpIDogKHcgPSBrLmFuY2hvciwgYiA9IFYoeC50bygpLCBrLmhlYWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGgucmFuZ2VzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlbZl0gPSBuZXcgZmUobWUoYywgYiksIHcpLCBUZShjLCBoZShpLCBmKSwgQmEpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gKyt5LCBpID0gWXQoZSwgdCwgITAsIFwicmVjdFwiID09IHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpaWYgKDAgIT0gX28oaSwgZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmN1ck9wLmZvY3VzID0gR2koKSwgbyhpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGIocywgYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGkubGluZSA+PSBsLnRvIHx8IGkubGluZSA8IGwuZnJvbSkgJiYgc2V0VGltZW91dChFdChlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPT0gbiAmJiBhKHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDE1MClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSB0LmNsaWVudFkgPCB2LnRvcCA/IC0yMCA6IHQuY2xpZW50WSA+IHYuYm90dG9tID8gMjAgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgJiYgc2V0VGltZW91dChFdChlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPT0gbiAmJiAocy5zY3JvbGxlci5zY3JvbGxUb3AgKz0gdSwgYSh0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgNTApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBsKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RhdGUuc2VsZWN0aW5nVGV4dCA9ICExLCB5ID0gMSAvIDAsIE1hKHQpLCBzLmlucHV0LmZvY3VzKCksIElhKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCB4KSwgSWEoZG9jdW1lbnQsIFwibW91c2V1cFwiLCB3KSwgYy5oaXN0b3J5Lmxhc3RTZWxPcmlnaW4gPSBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGUuZGlzcGxheSwgYyA9IGUuZG9jO1xuICAgICAgICAgICAgICAgICAgICBNYSh0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHUsIGYsIGggPSBjLnNlbCwgZCA9IGgucmFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAmJiAhdC5zaGlmdEtleSA/IChmID0gYy5zZWwuY29udGFpbnMobiksIHUgPSBmID4gLTEgPyBkW2ZdIDogbmV3IGZlKG4sIG4pKSA6ICh1ID0gYy5zZWwucHJpbWFyeSgpLCBmID0gYy5zZWwucHJpbUluZGV4KSwgT28gPyB0LnNoaWZ0S2V5ICYmIHQubWV0YUtleSA6IHQuYWx0S2V5KSByID0gXCJyZWN0XCIsIGkgfHwgKHUgPSBuZXcgZmUobiwgbikpLCBuID0gWXQoZSwgdCwgITAsICEwKSwgZiA9IC0xOyBlbHNlIGlmIChcImRvdWJsZVwiID09IHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gZS5maW5kV29yZEF0KG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdSA9IGUuZGlzcGxheS5zaGlmdCB8fCBjLmV4dGVuZCA/IHhlKGMsIHUsIHAuYW5jaG9yLCBwLmhlYWQpIDogcFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwidHJpcGxlXCIgPT0gcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBuZXcgZmUoQm8obi5saW5lLCAwKSwgbWUoYywgQm8obi5saW5lICsgMSwgMCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBlLmRpc3BsYXkuc2hpZnQgfHwgYy5leHRlbmQgPyB4ZShjLCB1LCBtLmFuY2hvciwgbS5oZWFkKSA6IG1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHUgPSB4ZShjLCB1LCBuKTtcbiAgICAgICAgICAgICAgICAgICAgaSA/IC0xID09IGYgPyAoZiA9IGQubGVuZ3RoLCBUZShjLCBoZShkLmNvbmNhdChbdV0pLCBmKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCIqbW91c2VcIlxuICAgICAgICAgICAgICAgICAgICB9KSkgOiBkLmxlbmd0aCA+IDEgJiYgZFtmXS5lbXB0eSgpICYmIFwic2luZ2xlXCIgPT0gciAmJiAhdC5zaGlmdEtleSA/IChUZShjLCBoZShkLnNsaWNlKDAsIGYpLmNvbmNhdChkLnNsaWNlKGYgKyAxKSksIDApLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGw6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcIiptb3VzZVwiXG4gICAgICAgICAgICAgICAgICAgIH0pLCBoID0gYy5zZWwpIDoga2UoYywgZiwgdSwgQmEpIDogKGYgPSAwLCBUZShjLCBuZXcgdWUoW3VdLCAwKSwgQmEpLCBoID0gYy5zZWwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IG4sIHYgPSBzLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHkgPSAwLCB4ID0gRXQoZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpKGUpID8gYShlKSA6IGwoZSlcbiAgICAgICAgICAgICAgICAgICAgfSksIHcgPSBFdChlLCBsKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdGF0ZS5zZWxlY3RpbmdUZXh0ID0gdywgRWEoZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIHgpLCBFYShkb2N1bWVudCwgXCJtb3VzZXVwXCIsIHcpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gWnQoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0LmNsaWVudFgsIG8gPSB0LmNsaWVudFlcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gTWF0aC5mbG9vcihlLmRpc3BsYXkuZ3V0dGVycy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCkpcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICByICYmIE1hKHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGUuZGlzcGxheSwgbCA9IGEubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPiBsLmJvdHRvbSB8fCAhTmkoZSwgbikpcmV0dXJuIGJpKHQpO1xuICAgICAgICAgICAgICAgICAgICBvIC09IGwudG9wIC0gYS52aWV3T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IGUub3B0aW9ucy5ndXR0ZXJzLmxlbmd0aDsgKytzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGEuZ3V0dGVycy5jaGlsZE5vZGVzW3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgJiYgYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCA+PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBuaShlLmRvYywgbyksIGYgPSBlLm9wdGlvbnMuZ3V0dGVyc1tzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGEoZSwgbiwgZSwgdSwgZiwgdCksIGJpKHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBKdChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBadChlLCB0LCBcImd1dHRlckNsaWNrXCIsICEwKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFF0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm4odCksICFUaSh0LCBlKSAmJiAhR3QodC5kaXNwbGF5LCBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTWEoZSksIHhvICYmICgkbyA9ICtuZXcgRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFl0KHQsIGUsICEwKSwgciA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gJiYgIXQuaXNSZWFkT25seSgpKWlmIChyICYmIHIubGVuZ3RoICYmIHdpbmRvdy5GaWxlUmVhZGVyICYmIHdpbmRvdy5GaWxlKWZvciAodmFyIGkgPSByLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gQXJyYXkoaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdC5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcyB8fCAtMSAhPSBQaSh0Lm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzLCBlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbC5vbmxvYWQgPSBFdCh0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBsLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1tcXHgwMC1cXHgwOFxceDBlLVxceDFmXXsyfS8udGVzdChlKSAmJiAoZSA9IFwiXCIpLCBvW3JdID0gZSwgKythID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG1lKHQuZG9jLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IG4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0LmRvYy5zcGxpdExpbmVzKG8uam9pbih0LmRvYy5saW5lU2VwYXJhdG9yKCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJwYXN0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRuKHQuZG9jLCBzKSwgTGUodC5kb2MsIGRlKG4sIFFvKHMpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgbC5yZWFkQXNUZXh0KGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSAwOyBpID4gczsgKytzKWwocltzXSwgcyk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LnN0YXRlLmRyYWdnaW5nVGV4dCAmJiB0LmRvYy5zZWwuY29udGFpbnMobikgPiAtMSlyZXR1cm4gdC5zdGF0ZS5kcmFnZ2luZ1RleHQoZSksIHZvaWQgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuZGlzcGxheS5pbnB1dC5mb2N1cygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgIShFbyA/IGUuYWx0S2V5IDogZS5jdHJsS2V5KSl2YXIgYyA9IHQubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNZSh0LmRvYywgZGUobiwgbikpLCBjKWZvciAodmFyIHMgPSAwOyBzIDwgYy5sZW5ndGg7ICsrcylJbih0LmRvYywgXCJcIiwgY1tzXS5hbmNob3IsIGNbc10uaGVhZCwgXCJkcmFnXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5yZXBsYWNlU2VsZWN0aW9uKG8sIFwiYXJvdW5kXCIsIFwicGFzdGVcIiksIHQuZGlzcGxheS5pbnB1dC5mb2N1cygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZW4oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeG8gJiYgKCFlLnN0YXRlLmRyYWdnaW5nVGV4dCB8fCArbmV3IERhdGUgLSAkbyA8IDEwMCkpcmV0dXJuIHZvaWQgQWEodCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghVGkoZSwgdCkgJiYgIUd0KGUuZGlzcGxheSwgdCkgJiYgKHQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIGUuZ2V0U2VsZWN0aW9uKCkpLCB0LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiLCB0LmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UgJiYgIUxvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBqaShcImltZ1wiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogMDsgdG9wOiAwO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uc3JjID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiLCBDbyAmJiAobi53aWR0aCA9IG4uaGVpZ2h0ID0gMSwgZS5kaXNwbGF5LndyYXBwZXIuYXBwZW5kQ2hpbGQobiksIG4uX3RvcCA9IG4ub2Zmc2V0VG9wKSwgdC5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKG4sIDAsIDApLCBDbyAmJiBuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRuKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBZdChlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgSGUoZSwgbiwgciksIGUuZGlzcGxheS5kcmFnQ3Vyc29yIHx8IChlLmRpc3BsYXkuZHJhZ0N1cnNvciA9IGppKFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jdXJzb3JzIENvZGVNaXJyb3ItZHJhZ2N1cnNvcnNcIiksIGUuZGlzcGxheS5saW5lU3BhY2UuaW5zZXJ0QmVmb3JlKGUuZGlzcGxheS5kcmFnQ3Vyc29yLCBlLmRpc3BsYXkuY3Vyc29yRGl2KSksIHFpKGUuZGlzcGxheS5kcmFnQ3Vyc29yLCByKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbm4oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLmRpc3BsYXkuZHJhZ0N1cnNvciAmJiAoZS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChlLmRpc3BsYXkuZHJhZ0N1cnNvciksIGUuZGlzcGxheS5kcmFnQ3Vyc29yID0gbnVsbClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBybihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGUuZG9jLnNjcm9sbFRvcCAtIHQpIDwgMiB8fCAoZS5kb2Muc2Nyb2xsVG9wID0gdCwgZ28gfHwgQShlLCB7dG9wOiB0fSksIGUuZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgIT0gdCAmJiAoZS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IHQpLCBlLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AodCksIGdvICYmIEEoZSksIF9lKGUsIDEwMCkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAobiA/IHQgPT0gZS5kb2Muc2Nyb2xsTGVmdCA6IE1hdGguYWJzKGUuZG9jLnNjcm9sbExlZnQgLSB0KSA8IDIpIHx8ICh0ID0gTWF0aC5taW4odCwgZS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gZS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoKSwgZS5kb2Muc2Nyb2xsTGVmdCA9IHQsIHcoZSksIGUuZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICE9IHQgJiYgKGUuZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ID0gdCksIGUuZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQodCkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYW4oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFhvKHQpLCByID0gbi54LCBpID0gbi55LCBvID0gZS5kaXNwbGF5LCBhID0gby5zY3JvbGxlciwgbCA9IGEuc2Nyb2xsV2lkdGggPiBhLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGEuc2Nyb2xsSGVpZ2h0ID4gYS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyICYmIGwgfHwgaSAmJiBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSAmJiBFbyAmJiB3byllOmZvciAodmFyIGMgPSB0LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IG8udmlldzsgYyAhPSBhOyBjID0gYy5wYXJlbnROb2RlKWZvciAodmFyIGYgPSAwOyBmIDwgdS5sZW5ndGg7IGYrKylpZiAodVtmXS5ub2RlID09IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRpc3BsYXkuY3VycmVudFdoZWVsVGFyZ2V0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociAmJiAhZ28gJiYgIUNvICYmIG51bGwgIT0gS28pcmV0dXJuIGkgJiYgcyAmJiBybihlLCBNYXRoLm1heCgwLCBNYXRoLm1pbihhLnNjcm9sbFRvcCArIGkgKiBLbywgYS5zY3JvbGxIZWlnaHQgLSBhLmNsaWVudEhlaWdodCkpKSwgb24oZSwgTWF0aC5tYXgoMCwgTWF0aC5taW4oYS5zY3JvbGxMZWZ0ICsgciAqIEtvLCBhLnNjcm9sbFdpZHRoIC0gYS5jbGllbnRXaWR0aCkpKSwgKCFpIHx8IGkgJiYgcykgJiYgTWEodCksIHZvaWQoby53aGVlbFN0YXJ0WCA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgJiYgbnVsbCAhPSBLbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gaSAqIEtvLCBkID0gZS5kb2Muc2Nyb2xsVG9wLCBwID0gZCArIG8ud3JhcHBlci5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA+IGggPyBkID0gTWF0aC5tYXgoMCwgZCArIGggLSA1MCkgOiBwID0gTWF0aC5taW4oZS5kb2MuaGVpZ2h0LCBwICsgaCArIDUwKSwgQShlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDIwID4gVm8gJiYgKG51bGwgPT0gby53aGVlbFN0YXJ0WCA/IChvLndoZWVsU3RhcnRYID0gYS5zY3JvbGxMZWZ0LCBvLndoZWVsU3RhcnRZID0gYS5zY3JvbGxUb3AsIG8ud2hlZWxEWCA9IHIsIG8ud2hlZWxEWSA9IGksIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IG8ud2hlZWxTdGFydFgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBhLnNjcm9sbExlZnQgLSBvLndoZWVsU3RhcnRYLCB0ID0gYS5zY3JvbGxUb3AgLSBvLndoZWVsU3RhcnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHQgJiYgby53aGVlbERZICYmIHQgLyBvLndoZWVsRFkgfHwgZSAmJiBvLndoZWVsRFggJiYgZSAvIG8ud2hlZWxEWDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby53aGVlbFN0YXJ0WCA9IG8ud2hlZWxTdGFydFkgPSBudWxsLCBuICYmIChLbyA9IChLbyAqIFZvICsgbikgLyAoVm8gKyAxKSwgKytWbylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAyMDApKSA6IChvLndoZWVsRFggKz0gciwgby53aGVlbERZICs9IGkpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbG4oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCAmJiAodCA9IHVhW3RdLCAhdCkpcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICBlLmRpc3BsYXkuaW5wdXQuZW5zdXJlUG9sbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5kaXNwbGF5LnNoaWZ0LCBpID0gITE7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmlzUmVhZE9ubHkoKSAmJiAoZS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gITApLCBuICYmIChlLmRpc3BsYXkuc2hpZnQgPSAhMSksIGkgPSB0KGUpICE9IEhhXG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRpc3BsYXkuc2hpZnQgPSByLCBlLnN0YXRlLnN1cHByZXNzRWRpdHMgPSAhMVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGUuc3RhdGUua2V5TWFwcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBoYSh0LCBlLnN0YXRlLmtleU1hcHNbcl0sIG4sIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpcmV0dXJuIGlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5vcHRpb25zLmV4dHJhS2V5cyAmJiBoYSh0LCBlLm9wdGlvbnMuZXh0cmFLZXlzLCBuLCBlKSB8fCBoYSh0LCBlLm9wdGlvbnMua2V5TWFwLCBuLCBlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNuKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlLnN0YXRlLmtleVNlcTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYSh0KSlyZXR1cm4gXCJoYW5kbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBaby5zZXQoNTAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0YXRlLmtleVNlcSA9PSBpICYmIChlLnN0YXRlLmtleVNlcSA9IG51bGwsIGUuZGlzcGxheS5pbnB1dC5yZXNldCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIHQgPSBpICsgXCIgXCIgKyB0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBzbihlLCB0LCByKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibXVsdGlcIiA9PSBvICYmIChlLnN0YXRlLmtleVNlcSA9IHQpLCBcImhhbmRsZWRcIiA9PSBvICYmIENpKGUsIFwia2V5SGFuZGxlZFwiLCBlLCB0LCBuKSwgXCJoYW5kbGVkXCIgIT0gbyAmJiBcIm11bHRpXCIgIT0gbyB8fCAoTWEobiksIEJlKGUpKSwgaSAmJiAhbyAmJiAvXFwnJC8udGVzdCh0KSA/IChNYShuKSwgITApIDogISFvXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdW4oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHBhKHQsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gPyB0LnNoaWZ0S2V5ICYmICFlLnN0YXRlLmtleVNlcSA/IGNuKGUsIFwiU2hpZnQtXCIgKyBuLCB0LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsbihlLCB0LCAhMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIHx8IGNuKGUsIG4sIHQsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gL15nb1tBLVpdLy50ZXN0KHQpIDogdC5tb3Rpb24pID8gbG4oZSwgdCkgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogY24oZSwgbiwgdCwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsbihlLCB0KVxuICAgICAgICAgICAgICAgICAgICB9KSA6ICExXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZm4oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY24oZSwgXCInXCIgKyBuICsgXCInXCIsIHQsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG4oZSwgdCwgITApXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaG4oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmN1ck9wLmZvY3VzID0gR2koKSwgIVRpKHQsIGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4byAmJiAxMSA+IGJvICYmIDI3ID09IGUua2V5Q29kZSAmJiAoZS5yZXR1cm5WYWx1ZSA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS5rZXlDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5kaXNwbGF5LnNoaWZ0ID0gMTYgPT0gbiB8fCBlLnNoaWZ0S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB1bih0LCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIENvICYmIChKbyA9IHIgPyBuIDogbnVsbCwgIXIgJiYgODggPT0gbiAmJiAhcmwgJiYgKEVvID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSAmJiB0LnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIikpLCAxOCAhPSBuIHx8IC9cXGJDb2RlTWlycm9yLWNyb3NzaGFpclxcYi8udGVzdCh0LmRpc3BsYXkubGluZURpdi5jbGFzc05hbWUpIHx8IGRuKHQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHQoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgMTggIT0gZS5rZXlDb2RlICYmIGUuYWx0S2V5IHx8IChaYShuLCBcIkNvZGVNaXJyb3ItY3Jvc3NoYWlyXCIpLCBJYShkb2N1bWVudCwgXCJrZXl1cFwiLCB0KSwgSWEoZG9jdW1lbnQsIFwibW91c2VvdmVyXCIsIHQpKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmRpc3BsYXkubGluZURpdjtcbiAgICAgICAgICAgICAgICAgICAgSmEobiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKSwgRWEoZG9jdW1lbnQsIFwia2V5dXBcIiwgdCksIEVhKGRvY3VtZW50LCBcIm1vdXNlb3ZlclwiLCB0KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHBuKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgMTYgPT0gZS5rZXlDb2RlICYmICh0aGlzLmRvYy5zZWwuc2hpZnQgPSAhMSksIFRpKHRoaXMsIGUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbW4oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKEd0KHQuZGlzcGxheSwgZSkgfHwgVGkodCwgZSkgfHwgZS5jdHJsS2V5ICYmICFlLmFsdEtleSB8fCBFbyAmJiBlLm1ldGFLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUua2V5Q29kZSwgciA9IGUuY2hhckNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ28gJiYgbiA9PSBKbylyZXR1cm4gSm8gPSBudWxsLCB2b2lkIE1hKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFDbyB8fCBlLndoaWNoICYmICEoZS53aGljaCA8IDEwKSB8fCAhdW4odCwgZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobnVsbCA9PSByID8gbiA6IHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKHQsIGUsIGkpIHx8IHQuZGlzcGxheS5pbnB1dC5vbktleVByZXNzKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSAhMCwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ICYmIChlLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gITEsIHluKGUpKVxuICAgICAgICAgICAgICAgICAgICB9LCAxMDApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdm4oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ICYmIChlLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gITEpLCBcIm5vY3Vyc29yXCIgIT0gZS5vcHRpb25zLnJlYWRPbmx5ICYmIChlLnN0YXRlLmZvY3VzZWQgfHwgKFBhKGUsIFwiZm9jdXNcIiwgZSksIGUuc3RhdGUuZm9jdXNlZCA9ICEwLCBKYShlLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLWZvY3VzZWRcIiksIGUuY3VyT3AgfHwgZS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID09IGUuZG9jLnNlbCB8fCAoZS5kaXNwbGF5LmlucHV0LnJlc2V0KCksIHdvICYmIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5kaXNwbGF5LmlucHV0LnJlc2V0KCEwKVxuICAgICAgICAgICAgICAgICAgICB9LCAyMCkpLCBlLmRpc3BsYXkuaW5wdXQucmVjZWl2ZWRGb2N1cygpKSwgQmUoZSkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24geW4oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50IHx8IChlLnN0YXRlLmZvY3VzZWQgJiYgKFBhKGUsIFwiYmx1clwiLCBlKSwgZS5zdGF0ZS5mb2N1c2VkID0gITEsIFphKGUuZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3ItZm9jdXNlZFwiKSksIGNsZWFySW50ZXJ2YWwoZS5kaXNwbGF5LmJsaW5rZXIpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RhdGUuZm9jdXNlZCB8fCAoZS5kaXNwbGF5LnNoaWZ0ID0gITEpXG4gICAgICAgICAgICAgICAgICAgIH0sIDE1MCkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24geG4oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBHdChlLmRpc3BsYXksIHQpIHx8IGJuKGUsIHQpIHx8IFRpKGUsIHQsIFwiY29udGV4dG1lbnVcIikgfHwgZS5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUodClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBibihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOaShlLCBcImd1dHRlckNvbnRleHRNZW51XCIpID8gWnQoZSwgdCwgXCJndXR0ZXJDb250ZXh0TWVudVwiLCAhMSkgOiAhMVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHduKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9vKGUsIHQuZnJvbSkgPCAwKXJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX28oZSwgdC50bykgPD0gMClyZXR1cm4gUW8odCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS5saW5lICsgdC50ZXh0Lmxlbmd0aCAtICh0LnRvLmxpbmUgLSB0LmZyb20ubGluZSkgLSAxLCByID0gZS5jaDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubGluZSA9PSB0LnRvLmxpbmUgJiYgKHIgKz0gUW8odCkuY2ggLSB0LnRvLmNoKSwgQm8obiwgcilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBrbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBbXSwgciA9IDA7IHIgPCBlLnNlbC5yYW5nZXMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZS5zZWwucmFuZ2VzW3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5wdXNoKG5ldyBmZSh3bihpLmFuY2hvciwgdCksIHduKGkuaGVhZCwgdCkpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZShuLCBlLnNlbC5wcmltSW5kZXgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5saW5lID09IHQubGluZSA/IEJvKG4ubGluZSwgZS5jaCAtIHQuY2ggKyBuLmNoKSA6IEJvKG4ubGluZSArIChlLmxpbmUgLSB0LmxpbmUpLCBlLmNoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIENuKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IFtdLCBpID0gQm8oZS5maXJzdCwgMCksIG8gPSBpLCBhID0gMDsgYSA8IHQubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gdFthXSwgcyA9IFNuKGwuZnJvbSwgaSwgbyksIGMgPSBTbihRbyhsKSwgaSwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9IGwudG8sIG8gPSBjLCBcImFyb3VuZFwiID09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGUuc2VsLnJhbmdlc1thXSwgZiA9IF9vKHUuaGVhZCwgdS5hbmNob3IpIDwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByW2FdID0gbmV3IGZlKGYgPyBjIDogcywgZiA/IHMgOiBjKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHJbYV0gPSBuZXcgZmUocywgcylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHVlKHIsIGUuc2VsLnByaW1JbmRleClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBMbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsZWQ6ICExLCBmcm9tOiB0LmZyb20sIHRvOiB0LnRvLCB0ZXh0OiB0LnRleHQsIG9yaWdpbjogdC5vcmlnaW4sIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsZWQgPSAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiAmJiAoci51cGRhdGUgPSBmdW5jdGlvbiAodCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdCAmJiAodGhpcy5mcm9tID0gbWUoZSwgdCkpLCBuICYmICh0aGlzLnRvID0gbWUoZSwgbikpLCByICYmICh0aGlzLnRleHQgPSByKSwgdm9pZCAwICE9PSBpICYmICh0aGlzLm9yaWdpbiA9IGkpXG4gICAgICAgICAgICAgICAgICAgIH0pLCBQYShlLCBcImJlZm9yZUNoYW5nZVwiLCBlLCByKSwgZS5jbSAmJiBQYShlLmNtLCBcImJlZm9yZUNoYW5nZVwiLCBlLmNtLCByKSwgci5jYW5jZWxlZCA/IG51bGwgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiByLmZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogci50byxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHIudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogci5vcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFRuKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZS5jbS5jdXJPcClyZXR1cm4gRXQoZS5jbSwgVG4pKGUsIHQsIG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY20uc3RhdGUuc3VwcHJlc3NFZGl0cylyZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShOaShlLCBcImJlZm9yZUNoYW5nZVwiKSB8fCBlLmNtICYmIE5pKGUuY20sIFwiYmVmb3JlQ2hhbmdlXCIpKSB8fCAodCA9IExuKGUsIHQsICEwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gSG8gJiYgIW4gJiYgc3IoZSwgdC5mcm9tLCB0LnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyKWZvciAodmFyIGkgPSByLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKU1uKGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiByW2ldLmZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHJbaV0udG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogaSA/IFtcIlwiXSA6IHQudGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7IGVsc2UgTW4oZSwgdClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDEgIT0gdC50ZXh0Lmxlbmd0aCB8fCBcIlwiICE9IHQudGV4dFswXSB8fCAwICE9IF9vKHQuZnJvbSwgdC50bykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0ga24oZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaShlLCB0LCBuLCBlLmNtID8gZS5jbS5jdXJPcC5pZCA6IE5hTiksIEVuKGUsIHQsIG4sIG9yKGUsIHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBLcihlLCBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gfHwgLTEgIT0gUGkociwgZS5oaXN0b3J5KSB8fCAoeGkoZS5oaXN0b3J5LCB0KSwgci5wdXNoKGUuaGlzdG9yeSkpLCBFbihlLCB0LCBudWxsLCBvcihlLCB0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBObihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZS5jbSB8fCAhZS5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByLCBpID0gZS5oaXN0b3J5LCBvID0gZS5zZWwsIGEgPSBcInVuZG9cIiA9PSB0ID8gaS5kb25lIDogaS51bmRvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gXCJ1bmRvXCIgPT0gdCA/IGkudW5kb25lIDogaS5kb25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IDA7IHMgPCBhLmxlbmd0aCAmJiAociA9IGFbc10sIG4gPyAhci5yYW5nZXMgfHwgci5lcXVhbHMoZS5zZWwpIDogci5yYW5nZXMpOyBzKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgIT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkubGFzdE9yaWdpbiA9IGkubGFzdFNlbE9yaWdpbiA9IG51bGw7IHIgPSBhLnBvcCgpLCByLnJhbmdlczspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpKHIsIGwpLCBuICYmICFyLmVxdWFscyhlLnNlbCkpcmV0dXJuIHZvaWQgVGUoZSwgciwge2NsZWFyUmVkbzogITF9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaShvLCBsKSwgbC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbjogaS5nZW5lcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGkuZ2VuZXJhdGlvbiA9IHIuZ2VuZXJhdGlvbiB8fCArK2kubWF4R2VuZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB1ID0gTmkoZSwgXCJiZWZvcmVDaGFuZ2VcIikgfHwgZS5jbSAmJiBOaShlLmNtLCBcImJlZm9yZUNoYW5nZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gci5jaGFuZ2VzLmxlbmd0aCAtIDE7IHMgPj0gMDsgLS1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gci5jaGFuZ2VzW3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi5vcmlnaW4gPSB0LCB1ICYmICFMbihlLCBmLCAhMSkpcmV0dXJuIHZvaWQoYS5sZW5ndGggPSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5wdXNoKGFpKGUsIGYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBzID8ga24oZSwgZikgOiBJaShhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW4oZSwgZiwgaCwgbHIoZSwgZikpLCAhcyAmJiBlLmNtICYmIGUuY20uc2Nyb2xsSW50b1ZpZXcoe2Zyb206IGYuZnJvbSwgdG86IFFvKGYpfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtyKGUsIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0IHx8IC0xICE9IFBpKGQsIGUuaGlzdG9yeSkgfHwgKHhpKGUuaGlzdG9yeSwgZiksIGQucHVzaChlLmhpc3RvcnkpKSwgRW4oZSwgZiwgbnVsbCwgbHIoZSwgZikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQW4oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCAhPSB0ICYmIChlLmZpcnN0ICs9IHQsIGUuc2VsID0gbmV3IHVlKFJpKGUuc2VsLnJhbmdlcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGZlKEJvKGUuYW5jaG9yLmxpbmUgKyB0LCBlLmFuY2hvci5jaCksIEJvKGUuaGVhZC5saW5lICsgdCwgZS5oZWFkLmNoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBlLnNlbC5wcmltSW5kZXgpLCBlLmNtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgRHQoZS5jbSwgZS5maXJzdCwgZS5maXJzdCAtIHQsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IGUuY20uZGlzcGxheSwgciA9IG4udmlld0Zyb207IHIgPCBuLnZpZXdUbzsgcisrKUh0KGUuY20sIHIsIFwiZ3V0dGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBFbihlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNtICYmICFlLmNtLmN1ck9wKXJldHVybiBFdChlLmNtLCBFbikoZSwgdCwgbiwgcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LnRvLmxpbmUgPCBlLmZpcnN0KXJldHVybiB2b2lkIEFuKGUsIHQudGV4dC5sZW5ndGggLSAxIC0gKHQudG8ubGluZSAtIHQuZnJvbS5saW5lKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQuZnJvbS5saW5lID4gZS5sYXN0TGluZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuZnJvbS5saW5lIDwgZS5maXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gdC50ZXh0Lmxlbmd0aCAtIDEgLSAoZS5maXJzdCAtIHQuZnJvbS5saW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbihlLCBpKSwgdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogQm8oZS5maXJzdCwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBCbyh0LnRvLmxpbmUgKyBpLCB0LnRvLmNoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogW0lpKHQudGV4dCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IHQub3JpZ2luXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBlLmxhc3RMaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnRvLmxpbmUgPiBvICYmICh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHQuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogQm8obywgWnIoZSwgbykudGV4dC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFt0LnRleHRbMF1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogdC5vcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCB0LnJlbW92ZWQgPSBKcihlLCB0LmZyb20sIHQudG8pLCBuIHx8IChuID0ga24oZSwgdCkpLCBlLmNtID8gT24oZS5jbSwgdCwgcikgOiBZcihlLCB0LCByKSwgTWUoZSwgbiwgV2EpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBPbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5kb2MsIGkgPSBlLmRpc3BsYXksIGEgPSB0LmZyb20sIGwgPSB0LnRvLCBzID0gITEsIGMgPSBhLmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIGUub3B0aW9ucy5saW5lV3JhcHBpbmcgfHwgKGMgPSB0aSh5cihacihyLCBhLmxpbmUpKSksIHIuaXRlcihjLCBsLmxpbmUgKyAxLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPT0gaS5tYXhMaW5lID8gKHMgPSAhMCwgITApIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH0pKSwgci5zZWwuY29udGFpbnModC5mcm9tLCB0LnRvKSA+IC0xICYmIE1pKGUpLCBZcihyLCB0LCBuLCBvKGUpKSwgZS5vcHRpb25zLmxpbmVXcmFwcGluZyB8fCAoci5pdGVyKGMsIGEubGluZSArIHQudGV4dC5sZW5ndGgsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGYoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID4gaS5tYXhMaW5lTGVuZ3RoICYmIChpLm1heExpbmUgPSBlLCBpLm1heExpbmVMZW5ndGggPSB0LCBpLm1heExpbmVDaGFuZ2VkID0gITAsIHMgPSAhMSlcbiAgICAgICAgICAgICAgICAgICAgfSksIHMgJiYgKGUuY3VyT3AudXBkYXRlTWF4TGluZSA9ICEwKSksIHIuZnJvbnRpZXIgPSBNYXRoLm1pbihyLmZyb250aWVyLCBhLmxpbmUpLCBfZShlLCA0MDApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IHQudGV4dC5sZW5ndGggLSAobC5saW5lIC0gYS5saW5lKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHQuZnVsbCA/IER0KGUpIDogYS5saW5lICE9IGwubGluZSB8fCAxICE9IHQudGV4dC5sZW5ndGggfHwgR3IoZS5kb2MsIHQpID8gRHQoZSwgYS5saW5lLCBsLmxpbmUgKyAxLCB1KSA6IEh0KGUsIGEubGluZSwgXCJ0ZXh0XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IE5pKGUsIFwiY2hhbmdlc1wiKSwgZCA9IE5pKGUsIFwiY2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCB8fCBoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHtmcm9tOiBhLCB0bzogbCwgdGV4dDogdC50ZXh0LCByZW1vdmVkOiB0LnJlbW92ZWQsIG9yaWdpbjogdC5vcmlnaW59O1xuICAgICAgICAgICAgICAgICAgICAgICAgZCAmJiBDaShlLCBcImNoYW5nZVwiLCBlLCBwKSwgaCAmJiAoZS5jdXJPcC5jaGFuZ2VPYmpzIHx8IChlLmN1ck9wLmNoYW5nZU9ianMgPSBbXSkpLnB1c2gocClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSW4oZSwgdCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAociB8fCAociA9IG4pLCBfbyhyLCBuKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBuLCBuID0gb1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgKHQgPSBlLnNwbGl0TGluZXModCkpLCBUbihlLCB7ZnJvbTogbiwgdG86IHIsIHRleHQ6IHQsIG9yaWdpbjogaX0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUG4oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVRpKGUsIFwic2Nyb2xsQ3Vyc29ySW50b1ZpZXdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS5kaXNwbGF5LCByID0gbi5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgaSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC50b3AgKyByLnRvcCA8IDAgPyBpID0gITAgOiB0LmJvdHRvbSArIHIudG9wID4gKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSAmJiAoaSA9ICExKSwgbnVsbCAhPSBpICYmICFNbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gamkoXCJkaXZcIiwgXCLigItcIiwgbnVsbCwgXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogXCIgKyAodC50b3AgLSBuLnZpZXdPZmZzZXQgLSBVZShlLmRpc3BsYXkpKSArIFwicHg7IGhlaWdodDogXCIgKyAodC5ib3R0b20gLSB0LnRvcCArIFllKGUpICsgbi5iYXJIZWlnaHQpICsgXCJweDsgbGVmdDogXCIgKyB0LmxlZnQgKyBcInB4OyB3aWR0aDogMnB4O1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRpc3BsYXkubGluZVNwYWNlLmFwcGVuZENoaWxkKG8pLCBvLnNjcm9sbEludG9WaWV3KGkpLCBlLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKG8pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBSbihlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT0gciAmJiAociA9IDApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgNSA+IGk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSAhMSwgYSA9IGR0KGUsIHQpLCBsID0gbiAmJiBuICE9IHQgPyBkdChlLCBuKSA6IGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IEhuKGUsIE1hdGgubWluKGEubGVmdCwgbC5sZWZ0KSwgTWF0aC5taW4oYS50b3AsIGwudG9wKSAtIHIsIE1hdGgubWF4KGEubGVmdCwgbC5sZWZ0KSwgTWF0aC5tYXgoYS5ib3R0b20sIGwuYm90dG9tKSArIHIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBlLmRvYy5zY3JvbGxUb3AsIHUgPSBlLmRvYy5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcy5zY3JvbGxUb3AgJiYgKHJuKGUsIHMuc2Nyb2xsVG9wKSwgTWF0aC5hYnMoZS5kb2Muc2Nyb2xsVG9wIC0gYykgPiAxICYmIChvID0gITApKSwgbnVsbCAhPSBzLnNjcm9sbExlZnQgJiYgKG9uKGUsIHMuc2Nyb2xsTGVmdCksIE1hdGguYWJzKGUuZG9jLnNjcm9sbExlZnQgLSB1KSA+IDEgJiYgKG8gPSAhMCkpLCAhbylicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRG4oZSwgdCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IEhuKGUsIHQsIG4sIHIsIGkpO1xuICAgICAgICAgICAgICAgICAgICBudWxsICE9IG8uc2Nyb2xsVG9wICYmIHJuKGUsIG8uc2Nyb2xsVG9wKSwgbnVsbCAhPSBvLnNjcm9sbExlZnQgJiYgb24oZSwgby5zY3JvbGxMZWZ0KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEhuKGUsIHQsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBlLmRpc3BsYXksIGEgPSB5dChlLmRpc3BsYXkpO1xuICAgICAgICAgICAgICAgICAgICAwID4gbiAmJiAobiA9IDApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGUuY3VyT3AgJiYgbnVsbCAhPSBlLmN1ck9wLnNjcm9sbFRvcCA/IGUuY3VyT3Auc2Nyb2xsVG9wIDogby5zY3JvbGxlci5zY3JvbGxUb3AsIHMgPSBWZShlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaSAtIG4gPiBzICYmIChpID0gbiArIHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGUuZG9jLmhlaWdodCArIHFlKG8pLCBmID0gYSA+IG4sIGggPSBpID4gdSAtIGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsID4gbikgYy5zY3JvbGxUb3AgPSBmID8gMCA6IG47IGVsc2UgaWYgKGkgPiBsICsgcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBNYXRoLm1pbihuLCAoaCA/IHUgOiBpKSAtIHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZCAhPSBsICYmIChjLnNjcm9sbFRvcCA9IGQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBlLmN1ck9wICYmIG51bGwgIT0gZS5jdXJPcC5zY3JvbGxMZWZ0ID8gZS5jdXJPcC5zY3JvbGxMZWZ0IDogby5zY3JvbGxlci5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9ICRlKGUpIC0gKGUub3B0aW9ucy5maXhlZEd1dHRlciA/IG8uZ3V0dGVycy5vZmZzZXRXaWR0aCA6IDApLCBnID0gciAtIHQgPiBtO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZyAmJiAociA9IHQgKyBtKSwgMTAgPiB0ID8gYy5zY3JvbGxMZWZ0ID0gMCA6IHAgPiB0ID8gYy5zY3JvbGxMZWZ0ID0gTWF0aC5tYXgoMCwgdCAtIChnID8gMCA6IDEwKSkgOiByID4gbSArIHAgLSAzICYmIChjLnNjcm9sbExlZnQgPSByICsgKGcgPyAwIDogMTApIC0gbSksIGNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBXbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT0gdCAmJiBudWxsID09IG4gfHwgX24oZSksIG51bGwgIT0gdCAmJiAoZS5jdXJPcC5zY3JvbGxMZWZ0ID0gKG51bGwgPT0gZS5jdXJPcC5zY3JvbGxMZWZ0ID8gZS5kb2Muc2Nyb2xsTGVmdCA6IGUuY3VyT3Auc2Nyb2xsTGVmdCkgKyB0KSwgbnVsbCAhPSBuICYmIChlLmN1ck9wLnNjcm9sbFRvcCA9IChudWxsID09IGUuY3VyT3Auc2Nyb2xsVG9wID8gZS5kb2Muc2Nyb2xsVG9wIDogZS5jdXJPcC5zY3JvbGxUb3ApICsgbilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBCbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9uKGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUuZ2V0Q3Vyc29yKCksIG4gPSB0LCByID0gdDtcbiAgICAgICAgICAgICAgICAgICAgZS5vcHRpb25zLmxpbmVXcmFwcGluZyB8fCAobiA9IHQuY2ggPyBCbyh0LmxpbmUsIHQuY2ggLSAxKSA6IHQsIHIgPSBCbyh0LmxpbmUsIHQuY2ggKyAxKSksIGUuY3VyT3Auc2Nyb2xsVG9Qb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IGUub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0N1cnNvcjogITBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmN1ck9wLnNjcm9sbFRvUG9zO1xuICAgICAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5jdXJPcC5zY3JvbGxUb1BvcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHB0KGUsIHQuZnJvbSksIHIgPSBwdChlLCB0LnRvKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gSG4oZSwgTWF0aC5taW4obi5sZWZ0LCByLmxlZnQpLCBNYXRoLm1pbihuLnRvcCwgci50b3ApIC0gdC5tYXJnaW4sIE1hdGgubWF4KG4ucmlnaHQsIHIucmlnaHQpLCBNYXRoLm1heChuLmJvdHRvbSwgci5ib3R0b20pICsgdC5tYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zY3JvbGxUbyhpLnNjcm9sbExlZnQsIGkuc2Nyb2xsVG9wKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRm4oZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgbyA9IGUuZG9jO1xuICAgICAgICAgICAgICAgICAgICBudWxsID09IG4gJiYgKG4gPSBcImFkZFwiKSwgXCJzbWFydFwiID09IG4gJiYgKG8ubW9kZS5pbmRlbnQgPyBpID0gamUoZSwgdCkgOiBuID0gXCJwcmV2XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGUub3B0aW9ucy50YWJTaXplLCBsID0gWnIobywgdCksIHMgPSBGYShsLnRleHQsIG51bGwsIGEpO1xuICAgICAgICAgICAgICAgICAgICBsLnN0YXRlQWZ0ZXIgJiYgKGwuc3RhdGVBZnRlciA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYywgdSA9IGwudGV4dC5tYXRjaCgvXlxccyovKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgfHwgL1xcUy8udGVzdChsLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzbWFydFwiID09IG4gJiYgKGMgPSBvLm1vZGUuaW5kZW50KGksIGwudGV4dC5zbGljZSh1Lmxlbmd0aCksIGwudGV4dCksIGMgPT0gSGEgfHwgYyA+IDE1MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXIpcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBcInByZXZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgYyA9IDAsIG4gPSBcIm5vdFwiO1xuICAgICAgICAgICAgICAgICAgICBcInByZXZcIiA9PSBuID8gYyA9IHQgPiBvLmZpcnN0ID8gRmEoWnIobywgdCAtIDEpLnRleHQsIG51bGwsIGEpIDogMCA6IFwiYWRkXCIgPT0gbiA/IGMgPSBzICsgZS5vcHRpb25zLmluZGVudFVuaXQgOiBcInN1YnRyYWN0XCIgPT0gbiA/IGMgPSBzIC0gZS5vcHRpb25zLmluZGVudFVuaXQgOiBcIm51bWJlclwiID09IHR5cGVvZiBuICYmIChjID0gcyArIG4pLCBjID0gTWF0aC5tYXgoMCwgYyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gXCJcIiwgaCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm9wdGlvbnMuaW5kZW50V2l0aFRhYnMpZm9yICh2YXIgZCA9IE1hdGguZmxvb3IoYyAvIGEpOyBkOyAtLWQpaCArPSBhLCBmICs9IFwiXHRcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPiBoICYmIChmICs9IE9pKGMgLSBoKSksIGYgIT0gdSlyZXR1cm4gSW4obywgZiwgQm8odCwgMCksIEJvKHQsIHUubGVuZ3RoKSwgXCIraW5wdXRcIiksIGwuc3RhdGVBZnRlciA9IG51bGwsICEwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IG8uc2VsLnJhbmdlcy5sZW5ndGg7IGQrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBvLnNlbC5yYW5nZXNbZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5oZWFkLmxpbmUgPT0gdCAmJiBwLmhlYWQuY2ggPCB1Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gQm8odCwgdS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlKG8sIGQsIG5ldyBmZShoLCBoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHpuKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0LCBvID0gdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgPyBvID0gWnIoZSwgcGUoZSwgdCkpIDogaSA9IHRpKHQpLCBudWxsID09IGkgPyBudWxsIDogKHIobywgaSkgJiYgZS5jbSAmJiBIdChlLmNtLCBpLCBuKSwgbylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBqbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBlLmRvYy5zZWwucmFuZ2VzLCByID0gW10sIGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbyA9IHQobltpXSk7IHIubGVuZ3RoICYmIF9vKG8uZnJvbSwgSWkocikudG8pIDw9IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbyhhLmZyb20sIG8uZnJvbSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uZnJvbSA9IGEuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByLnB1c2gobylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBBdChlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gci5sZW5ndGggLSAxOyB0ID49IDA7IHQtLSlJbihlLmRvYywgXCJcIiwgclt0XS5mcm9tLCByW3RdLnRvLCBcIitkZWxldGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBCbihlKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFVuKGUsIHQsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbCArIG47XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCA8IGUuZmlyc3QgfHwgdCA+PSBlLmZpcnN0ICsgZS5zaXplID8gITEgOiAobCA9IHQsIHUgPSBacihlLCB0KSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGEoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSAoaSA/IGZvIDogaG8pKHUsIHMsIG4sICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSB8fCAhbygpKXJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gaSA/ICgwID4gbiA/IGlvIDogcm8pKHUpIDogMCA+IG4gPyB1LnRleHQubGVuZ3RoIDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHMgPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHQubGluZSwgcyA9IHQuY2gsIGMgPSBuLCB1ID0gWnIoZSwgbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImNoYXJcIiA9PSByKSBhKCk7IGVsc2UgaWYgKFwiY29sdW1uXCIgPT0gcikgYSghMCk7IGVsc2UgaWYgKFwid29yZFwiID09IHIgfHwgXCJncm91cFwiID09IHIpZm9yICh2YXIgZiA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBcImdyb3VwXCIgPT0gcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGUuY20gJiYgZS5jbS5nZXRIZWxwZXIodCwgXCJ3b3JkQ2hhcnNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAhMDsgISgwID4gbikgfHwgYSghcCk7IHAgPSAhMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSB1LnRleHQuY2hhckF0KHMpIHx8IFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IF9pKG0sIGQpID8gXCJ3XCIgOiBoICYmIFwiXFxuXCIgPT0gbSA/IFwiblwiIDogIWggfHwgL1xccy8udGVzdChtKSA/IG51bGwgOiBcInBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaCB8fCBwIHx8IGcgfHwgKGcgPSBcInNcIiksIGYgJiYgZiAhPSBnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA+IG4gJiYgKG4gPSAxLCBhKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZyAmJiAoZiA9IGcpLCBuID4gMCAmJiAhYSghcCkpYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IEllKGUsIEJvKGwsIHMpLCB0LCBjLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfbyh0LCB2KSB8fCAodi5oaXRTaWRlID0gITApLCB2XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcW4oZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgbyA9IGUuZG9jLCBhID0gdC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJwYWdlXCIgPT0gcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBNYXRoLm1pbihlLmRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB0LnRvcCArIG4gKiAobCAtICgwID4gbiA/IDEuNSA6IC41KSAqIHl0KGUuZGlzcGxheSkpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVwibGluZVwiID09IHIgJiYgKGkgPSBuID4gMCA/IHQuYm90dG9tICsgMyA6IHQudG9wIC0gMyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGd0KGUsIGEsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzLm91dHNpZGUpYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA+IG4gPyAwID49IGkgOiBpID49IG8uaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5oaXRTaWRlID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNSAqIG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEduKHQsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kZWZhdWx0c1t0XSA9IG4sIHIgJiYgKHRhW3RdID0gaSA/IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuICE9IG5hICYmIHIoZSwgdCwgbilcbiAgICAgICAgICAgICAgICAgICAgfSA6IHIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gWW4oZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0LCBuLCByLCBpLCBvID0gZS5zcGxpdCgvLSg/ISQpLyksIGUgPSBvW28ubGVuZ3RoIC0gMV0sIGEgPSAwOyBhIDwgby5sZW5ndGggLSAxOyBhKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gb1thXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KGwpKSBpID0gITA7IGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobCkpIHQgPSAhMDsgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobCkpIG4gPSAhMDsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEvXnMoaGlmdCkkL2kudGVzdChsKSl0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gITBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCAmJiAoZSA9IFwiQWx0LVwiICsgZSksIG4gJiYgKGUgPSBcIkN0cmwtXCIgKyBlKSwgaSAmJiAoZSA9IFwiQ21kLVwiICsgZSksIHIgJiYgKGUgPSBcIlNoaWZ0LVwiICsgZSksIGVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAkbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBlID8gZmFbZV0gOiBlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gVm4oZSwgdCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAociAmJiByLnNoYXJlZClyZXR1cm4gS24oZSwgdCwgbiwgciwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNtICYmICFlLmNtLmN1ck9wKXJldHVybiBFdChlLmNtLCBWbikoZSwgdCwgbiwgciwgaSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gbmV3IHZhKGUsIGkpLCBhID0gX28odCwgbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyICYmIFdpKHIsIG8sICExKSwgYSA+IDAgfHwgMCA9PSBhICYmIG8uY2xlYXJXaGVuRW1wdHkgIT09ICExKXJldHVybiBvO1xuICAgICAgICAgICAgICAgICAgICBpZiAoby5yZXBsYWNlZFdpdGggJiYgKG8uY29sbGFwc2VkID0gITAsIG8ud2lkZ2V0Tm9kZSA9IGppKFwic3BhblwiLCBbby5yZXBsYWNlZFdpdGhdLCBcIkNvZGVNaXJyb3Itd2lkZ2V0XCIpLCByLmhhbmRsZU1vdXNlRXZlbnRzIHx8IG8ud2lkZ2V0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIsIFwidHJ1ZVwiKSwgci5pbnNlcnRMZWZ0ICYmIChvLndpZGdldE5vZGUuaW5zZXJ0TGVmdCA9ICEwKSksIG8uY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodnIoZSwgdC5saW5lLCB0LCBuLCBvKSB8fCB0LmxpbmUgIT0gbi5saW5lICYmIHZyKGUsIG4ubGluZSwgdCwgbiwgbykpdGhyb3cgbmV3IEVycm9yKFwiSW5zZXJ0aW5nIGNvbGxhcHNlZCBtYXJrZXIgcGFydGlhbGx5IG92ZXJsYXBwaW5nIGFuIGV4aXN0aW5nIG9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFdvID0gITBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvLmFkZFRvSGlzdG9yeSAmJiBjaShlLCB7ZnJvbTogdCwgdG86IG4sIG9yaWdpbjogXCJtYXJrVGV4dFwifSwgZS5zZWwsIE5hTik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsLCBzID0gdC5saW5lLCBjID0gZS5jbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuaXRlcihzLCBuLmxpbmUgKyAxLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgJiYgby5jb2xsYXBzZWQgJiYgIWMub3B0aW9ucy5saW5lV3JhcHBpbmcgJiYgeXIoZSkgPT0gYy5kaXNwbGF5Lm1heExpbmUgJiYgKGwgPSAhMCksIG8uY29sbGFwc2VkICYmIHMgIT0gdC5saW5lICYmIGVpKGUsIDApLCBucihlLCBuZXcgUW4obywgcyA9PSB0LmxpbmUgPyB0LmNoIDogbnVsbCwgcyA9PSBuLmxpbmUgPyBuLmNoIDogbnVsbCkpLCArK3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBvLmNvbGxhcHNlZCAmJiBlLml0ZXIodC5saW5lLCBuLmxpbmUgKyAxLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtyKGUsIHQpICYmIGVpKHQsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgby5jbGVhck9uRW50ZXIgJiYgRWEobywgXCJiZWZvcmVDdXJzb3JFbnRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5jbGVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgby5yZWFkT25seSAmJiAoSG8gPSAhMCwgKGUuaGlzdG9yeS5kb25lLmxlbmd0aCB8fCBlLmhpc3RvcnkudW5kb25lLmxlbmd0aCkgJiYgZS5jbGVhckhpc3RvcnkoKSksIG8uY29sbGFwc2VkICYmIChvLmlkID0gKytnYSwgby5hdG9taWMgPSAhMCksIGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsICYmIChjLmN1ck9wLnVwZGF0ZU1heExpbmUgPSAhMCksIG8uY29sbGFwc2VkKSBEdChjLCB0LmxpbmUsIG4ubGluZSArIDEpOyBlbHNlIGlmIChvLmNsYXNzTmFtZSB8fCBvLnRpdGxlIHx8IG8uc3RhcnRTdHlsZSB8fCBvLmVuZFN0eWxlIHx8IG8uY3NzKWZvciAodmFyIHUgPSB0LmxpbmU7IHUgPD0gbi5saW5lOyB1KyspSHQoYywgdSwgXCJ0ZXh0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5hdG9taWMgJiYgQWUoYy5kb2MpLCBDaShjLCBcIm1hcmtlckFkZGVkXCIsIGMsIG8pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBLbihlLCB0LCBuLCByLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBXaShyKSwgci5zaGFyZWQgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBbVm4oZSwgdCwgbiwgciwgaSldLCBhID0gb1swXSwgbCA9IHIud2lkZ2V0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEtyKGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsICYmIChyLndpZGdldE5vZGUgPSBsLmNsb25lTm9kZSghMCkpLCBvLnB1c2goVm4oZSwgbWUoZSwgdCksIG1lKGUsIG4pLCByLCBpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IGUubGlua2VkLmxlbmd0aDsgKytzKWlmIChlLmxpbmtlZFtzXS5pc1BhcmVudClyZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gSWkobylcbiAgICAgICAgICAgICAgICAgICAgfSksIG5ldyB5YShvLCBhKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFhuKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuZmluZE1hcmtzKEJvKGUuZmlyc3QsIDApLCBlLmNsaXBQb3MoQm8oZS5sYXN0TGluZSgpKSksIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5wYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBabihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0W25dLCBpID0gci5maW5kKCksIG8gPSBlLmNsaXBQb3MoaS5mcm9tKSwgYSA9IGUuY2xpcFBvcyhpLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbyhvLCBhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gVm4oZSwgbywgYSwgci5wcmltYXJ5LCByLnByaW1hcnkudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5tYXJrZXJzLnB1c2gobCksIGwucGFyZW50ID0gclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSm4oZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZVt0XSwgciA9IFtuLnByaW1hcnkuZG9jXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtyKG4ucHJpbWFyeS5kb2MsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5wdXNoKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbi5tYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBuLm1hcmtlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEgPT0gUGkociwgby5kb2MpICYmIChvLnBhcmVudCA9IG51bGwsIG4ubWFya2Vycy5zcGxpY2UoaS0tLCAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFFuKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSBlLCB0aGlzLmZyb20gPSB0LCB0aGlzLnRvID0gblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVyKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpZm9yICh2YXIgbiA9IDA7IG4gPCBlLmxlbmd0aDsgKytuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGVbbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5tYXJrZXIgPT0gdClyZXR1cm4gclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdHIoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuLCByID0gMDsgciA8IGUubGVuZ3RoOyArK3IpZVtyXSAhPSB0ICYmIChuIHx8IChuID0gW10pKS5wdXNoKGVbcl0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG5yKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5tYXJrZWRTcGFucyA9IGUubWFya2VkU3BhbnMgPyBlLm1hcmtlZFNwYW5zLmNvbmNhdChbdF0pIDogW3RdLCB0Lm1hcmtlci5hdHRhY2hMaW5lKGUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcnIoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSlmb3IgKHZhciByLCBpID0gMDsgaSA8IGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZVtpXSwgYSA9IG8ubWFya2VyLCBsID0gbnVsbCA9PSBvLmZyb20gfHwgKGEuaW5jbHVzaXZlTGVmdCA/IG8uZnJvbSA8PSB0IDogby5mcm9tIDwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobCB8fCBvLmZyb20gPT0gdCAmJiBcImJvb2ttYXJrXCIgPT0gYS50eXBlICYmICghbiB8fCAhby5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG51bGwgPT0gby50byB8fCAoYS5pbmNsdXNpdmVSaWdodCA/IG8udG8gPj0gdCA6IG8udG8gPiB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAociB8fCAociA9IFtdKSkucHVzaChuZXcgUW4oYSwgby5mcm9tLCBzID8gbnVsbCA6IG8udG8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXIoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSlmb3IgKHZhciByLCBpID0gMDsgaSA8IGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZVtpXSwgYSA9IG8ubWFya2VyLCBsID0gbnVsbCA9PSBvLnRvIHx8IChhLmluY2x1c2l2ZVJpZ2h0ID8gby50byA+PSB0IDogby50byA+IHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwgfHwgby5mcm9tID09IHQgJiYgXCJib29rbWFya1wiID09IGEudHlwZSAmJiAoIW4gfHwgby5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG51bGwgPT0gby5mcm9tIHx8IChhLmluY2x1c2l2ZUxlZnQgPyBvLmZyb20gPD0gdCA6IG8uZnJvbSA8IHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyIHx8IChyID0gW10pKS5wdXNoKG5ldyBRbihhLCBzID8gbnVsbCA6IG8uZnJvbSAtIHQsIG51bGwgPT0gby50byA/IG51bGwgOiBvLnRvIC0gdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvcihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmZ1bGwpcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdmUoZSwgdC5mcm9tLmxpbmUpICYmIFpyKGUsIHQuZnJvbS5saW5lKS5tYXJrZWRTcGFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB2ZShlLCB0LnRvLmxpbmUpICYmIFpyKGUsIHQudG8ubGluZSkubWFya2VkU3BhbnM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbiAmJiAhcilyZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0LmZyb20uY2gsIG8gPSB0LnRvLmNoLCBhID0gMCA9PSBfbyh0LmZyb20sIHQudG8pLCBsID0gcnIobiwgaSwgYSksIHMgPSBpcihyLCBvLCBhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAxID09IHQudGV4dC5sZW5ndGgsIHUgPSBJaSh0LnRleHQpLmxlbmd0aCArIChjID8gaSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobClmb3IgKHZhciBmID0gMDsgZiA8IGwubGVuZ3RoOyArK2YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gbFtmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IGgudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGVyKHMsIGgubWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID8gYyAmJiAoaC50byA9IG51bGwgPT0gZC50byA/IG51bGwgOiBkLnRvICsgdSkgOiBoLnRvID0gaVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzKWZvciAodmFyIGYgPSAwOyBmIDwgcy5sZW5ndGg7ICsrZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBzW2ZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gaC50byAmJiAoaC50byArPSB1KSwgbnVsbCA9PSBoLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGVyKGwsIGgubWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkIHx8IChoLmZyb20gPSB1LCBjICYmIChsIHx8IChsID0gW10pKS5wdXNoKGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGguZnJvbSArPSB1LCBjICYmIChsIHx8IChsID0gW10pKS5wdXNoKGgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbCAmJiAobCA9IGFyKGwpKSwgcyAmJiBzICE9IGwgJiYgKHMgPSBhcihzKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gW2xdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtLCBnID0gdC50ZXh0Lmxlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZyA+IDAgJiYgbClmb3IgKHZhciBmID0gMDsgZiA8IGwubGVuZ3RoOyArK2YpbnVsbCA9PSBsW2ZdLnRvICYmIChtIHx8IChtID0gW10pKS5wdXNoKG5ldyBRbihsW2ZdLm1hcmtlciwgbnVsbCwgbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IDA7IGcgPiBmOyArK2YpcC5wdXNoKG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5wdXNoKHMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgZS5sZW5ndGg7ICsrdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlW3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPSBuLmZyb20gJiYgbi5mcm9tID09IG4udG8gJiYgbi5tYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09ICExICYmIGUuc3BsaWNlKHQtLSwgMSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5sZW5ndGggPyBlIDogbnVsbFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGxyKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBtaShlLCB0KSwgciA9IG9yKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW4pcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcilyZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG5baV0sIGEgPSByW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8gJiYgYSllOmZvciAodmFyIGwgPSAwOyBsIDwgYS5sZW5ndGg7ICsrbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSBhW2xdLCBjID0gMDsgYyA8IG8ubGVuZ3RoOyArK2MpaWYgKG9bY10ubWFya2VyID09IHMubWFya2VyKWNvbnRpbnVlIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5wdXNoKHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgYSAmJiAobltpXSA9IGEpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzcihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuaXRlcih0LmxpbmUsIG4ubGluZSArIDEsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUubWFya2VkU3BhbnMpZm9yICh2YXIgdCA9IDA7IHQgPCBlLm1hcmtlZFNwYW5zLmxlbmd0aDsgKyt0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS5tYXJrZWRTcGFuc1t0XS5tYXJrZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFuLnJlYWRPbmx5IHx8IHIgJiYgLTEgIT0gUGkociwgbikgfHwgKHIgfHwgKHIgPSBbXSkpLnB1c2gobilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgIXIpcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBbe2Zyb206IHQsIHRvOiBufV0sIG8gPSAwOyBvIDwgci5sZW5ndGg7ICsrbylmb3IgKHZhciBhID0gcltvXSwgbCA9IGEuZmluZCgwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSAwOyBzIDwgaS5sZW5ndGg7ICsrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBpW3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX28oYy50bywgbC5mcm9tKSA8IDAgfHwgX28oYy5mcm9tLCBsLnRvKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBbcywgMV0sIGYgPSBfbyhjLmZyb20sIGwuZnJvbSksIGggPSBfbyhjLnRvLCBsLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCA+IGYgfHwgIWEuaW5jbHVzaXZlTGVmdCAmJiAhZikgJiYgdS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogYy5mcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogbC5mcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIChoID4gMCB8fCAhYS5pbmNsdXNpdmVSaWdodCAmJiAhaCkgJiYgdS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogbC50byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGMudG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgaS5zcGxpY2UuYXBwbHkoaSwgdSksIHMgKz0gdS5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5tYXJrZWRTcGFucztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7ICsrbil0W25dLm1hcmtlci5kZXRhY2hMaW5lKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5tYXJrZWRTcGFucyA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVyKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7ICsrbil0W25dLm1hcmtlci5hdHRhY2hMaW5lKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5tYXJrZWRTcGFucyA9IHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZyKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuaW5jbHVzaXZlTGVmdCA/IC0xIDogMFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhyKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuaW5jbHVzaXZlUmlnaHQgPyAxIDogMFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRyKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmxpbmVzLmxlbmd0aCAtIHQubGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCAhPSBuKXJldHVybiBuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUuZmluZCgpLCBpID0gdC5maW5kKCksIG8gPSBfbyhyLmZyb20sIGkuZnJvbSkgfHwgZnIoZSkgLSBmcih0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8pcmV0dXJuIC1vO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IF9vKHIudG8sIGkudG8pIHx8IGhyKGUpIC0gaHIodCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhID8gYSA6IHQuaWQgLSBlLmlkXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHIoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiwgciA9IFdvICYmIGUubWFya2VkU3BhbnM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyKWZvciAodmFyIGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSAwOyBvIDwgci5sZW5ndGg7ICsrbylpID0gcltvXSwgaS5tYXJrZXIuY29sbGFwc2VkICYmIG51bGwgPT0gKHQgPyBpLmZyb20gOiBpLnRvKSAmJiAoIW4gfHwgZHIobiwgaS5tYXJrZXIpIDwgMCkgJiYgKG4gPSBpLm1hcmtlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbXIoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHIoZSwgITApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ3IoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHIoZSwgITEpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdnIoZSwgdCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IFpyKGUsIHQpLCBhID0gV28gJiYgby5tYXJrZWRTcGFucztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEpZm9yICh2YXIgbCA9IDA7IGwgPCBhLmxlbmd0aDsgKytsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGFbbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXJrZXIuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBzLm1hcmtlci5maW5kKDApLCB1ID0gX28oYy5mcm9tLCBuKSB8fCBmcihzLm1hcmtlcikgLSBmcihpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IF9vKGMudG8sIHIpIHx8IGhyKHMubWFya2VyKSAtIGhyKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHUgPj0gMCAmJiAwID49IGYgfHwgMCA+PSB1ICYmIGYgPj0gMCkgJiYgKDAgPj0gdSAmJiAocy5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgaS5pbmNsdXNpdmVMZWZ0ID8gX28oYy50bywgbikgPj0gMCA6IF9vKGMudG8sIG4pID4gMCkgfHwgdSA+PSAwICYmIChzLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBpLmluY2x1c2l2ZUxlZnQgPyBfbyhjLmZyb20sIHIpIDw9IDAgOiBfbyhjLmZyb20sIHIpIDwgMCkpKXJldHVybiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24geXIoZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0OyB0ID0gbXIoZSk7KWUgPSB0LmZpbmQoLTEsICEwKS5saW5lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHhyKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCwgbjsgdCA9IGdyKGUpOyllID0gdC5maW5kKDEsICEwKS5saW5lLCAobiB8fCAobiA9IFtdKSkucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBicihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gWnIoZSwgdCksIHIgPSB5cihuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gPT0gciA/IHQgOiB0aShyKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdyKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPiBlLmxhc3RMaW5lKCkpcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuLCByID0gWnIoZSwgdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgha3IoZSwgcikpcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBuID0gZ3Iocik7KXIgPSBuLmZpbmQoMSwgITApLmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aShyKSArIDFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBrcihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gV28gJiYgdC5tYXJrZWRTcGFucztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4pZm9yICh2YXIgciwgaSA9IDA7IGkgPCBuLmxlbmd0aDsgKytpKWlmIChyID0gbltpXSwgci5tYXJrZXIuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PSByLmZyb20pcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyLm1hcmtlci53aWRnZXROb2RlICYmIDAgPT0gci5mcm9tICYmIHIubWFya2VyLmluY2x1c2l2ZUxlZnQgJiYgU3IoZSwgdCwgcikpcmV0dXJuICEwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBTcihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IG4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gbi5tYXJrZXIuZmluZCgxLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3IoZSwgci5saW5lLCBlcihyLmxpbmUubWFya2VkU3BhbnMsIG4ubWFya2VyKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgbi50byA9PSB0LnRleHQubGVuZ3RoKXJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IDA7IG8gPCB0Lm1hcmtlZFNwYW5zLmxlbmd0aDsgKytvKWlmIChpID0gdC5tYXJrZWRTcGFuc1tvXSwgaS5tYXJrZXIuY29sbGFwc2VkICYmICFpLm1hcmtlci53aWRnZXROb2RlICYmIGkuZnJvbSA9PSBuLnRvICYmIChudWxsID09IGkudG8gfHwgaS50byAhPSBuLmZyb20pICYmIChpLm1hcmtlci5pbmNsdXNpdmVMZWZ0IHx8IG4ubWFya2VyLmluY2x1c2l2ZVJpZ2h0KSAmJiBTcihlLCB0LCBpKSlyZXR1cm4gITBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBDcihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpKHQpIDwgKGUuY3VyT3AgJiYgZS5jdXJPcC5zY3JvbGxUb3AgfHwgZS5kb2Muc2Nyb2xsVG9wKSAmJiBXbihlLCBudWxsLCBuKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIExyKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gZS5oZWlnaHQpcmV0dXJuIGUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUuZG9jLmNtO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXQpcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICghVmEoZG9jdW1lbnQuYm9keSwgZS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBcInBvc2l0aW9uOiByZWxhdGl2ZTtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY292ZXJHdXR0ZXIgJiYgKG4gKz0gXCJtYXJnaW4tbGVmdDogLVwiICsgdC5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggKyBcInB4O1wiKSwgZS5ub0hTY3JvbGwgJiYgKG4gKz0gXCJ3aWR0aDogXCIgKyB0LmRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aCArIFwicHg7XCIpLCBxaSh0LmRpc3BsYXkubWVhc3VyZSwgamkoXCJkaXZcIiwgW2Uubm9kZV0sIG51bGwsIG4pKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmhlaWdodCA9IGUubm9kZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFRyKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBuZXcgeGEoZSwgbiwgciksIG8gPSBlLmNtO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbyAmJiBpLm5vSFNjcm9sbCAmJiAoby5kaXNwbGF5LmFsaWduV2lkZ2V0cyA9ICEwKSwgem4oZSwgdCwgXCJ3aWRnZXRcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdC53aWRnZXRzIHx8ICh0LndpZGdldHMgPSBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PSBpLmluc2VydEF0ID8gbi5wdXNoKGkpIDogbi5zcGxpY2UoTWF0aC5taW4obi5sZW5ndGggLSAxLCBNYXRoLm1heCgwLCBpLmluc2VydEF0KSksIDAsIGkpLCBpLmxpbmUgPSB0LCBvICYmICFrcihlLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gcmkodCkgPCBlLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlaSh0LCB0LmhlaWdodCArIExyKGkpKSwgciAmJiBXbihvLCBudWxsLCBpLmhlaWdodCksIG8uY3VyT3AuZm9yY2VVcGRhdGUgPSAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwXG4gICAgICAgICAgICAgICAgICAgIH0pLCBpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTXIoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICBlLnRleHQgPSB0LCBlLnN0YXRlQWZ0ZXIgJiYgKGUuc3RhdGVBZnRlciA9IG51bGwpLCBlLnN0eWxlcyAmJiAoZS5zdHlsZXMgPSBudWxsKSwgbnVsbCAhPSBlLm9yZGVyICYmIChlLm9yZGVyID0gbnVsbCksIGNyKGUpLCB1cihlLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSByID8gcihlKSA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGkgIT0gZS5oZWlnaHQgJiYgZWkoZSwgaSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBOcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucGFyZW50ID0gbnVsbCwgY3IoZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBBcihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKWZvciAoOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUubWF0Y2goLyg/Ol58XFxzKylsaW5lLShiYWNrZ3JvdW5kLSk/KFxcUyspLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW4pYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gZS5zbGljZSgwLCBuLmluZGV4KSArIGUuc2xpY2Uobi5pbmRleCArIG5bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gblsxXSA/IFwiYmdDbGFzc1wiIDogXCJ0ZXh0Q2xhc3NcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgPT0gdFtyXSA/IHRbcl0gPSBuWzJdIDogbmV3IFJlZ0V4cChcIig/Ol58cylcIiArIG5bMl0gKyBcIig/OiR8cylcIikudGVzdCh0W3JdKSB8fCAodFtyXSArPSBcIiBcIiArIG5bMl0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBFcih0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmJsYW5rTGluZSlyZXR1cm4gdC5ibGFua0xpbmUobik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmlubmVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlLmlubmVyTW9kZSh0LCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByLm1vZGUuYmxhbmtMaW5lID8gci5tb2RlLmJsYW5rTGluZShyLnN0YXRlKSA6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gT3IodCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0gMDsgMTAgPiBvOyBvKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgJiYgKGlbMF0gPSBlLmlubmVyTW9kZSh0LCByKS5tb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gdC50b2tlbihuLCByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnBvcyA+IG4uc3RhcnQpcmV0dXJuIGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlIFwiICsgdC5uYW1lICsgXCIgZmFpbGVkIHRvIGFkdmFuY2Ugc3RyZWFtLlwiKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIElyKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaShlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZi5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nOiBmLmN1cnJlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGUgPyBzYShhLm1vZGUsIHUpIDogdVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG8sIGEgPSBlLmRvYywgbCA9IGEubW9kZTtcbiAgICAgICAgICAgICAgICAgICAgdCA9IG1lKGEsIHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcywgYyA9IFpyKGEsIHQubGluZSksIHUgPSBqZShlLCB0LmxpbmUsIG4pLCBmID0gbmV3IG1hKGMudGV4dCwgZS5vcHRpb25zLnRhYlNpemUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHIgJiYgKHMgPSBbXSk7IChyIHx8IGYucG9zIDwgdC5jaCkgJiYgIWYuZW9sKCk7KWYuc3RhcnQgPSBmLnBvcywgbyA9IE9yKGwsIGYsIHUpLCByICYmIHMucHVzaChpKCEwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByID8gcyA6IGkoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFByKGUsIHQsIG4sIHIsIGksIG8sIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBuLmZsYXR0ZW5TcGFucztcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PSBsICYmIChsID0gZS5vcHRpb25zLmZsYXR0ZW5TcGFucyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzLCBjID0gMCwgdSA9IG51bGwsIGYgPSBuZXcgbWEodCwgZS5vcHRpb25zLnRhYlNpemUpLCBoID0gZS5vcHRpb25zLmFkZE1vZGVDbGFzcyAmJiBbbnVsbF07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoXCJcIiA9PSB0ICYmIEFyKEVyKG4sIHIpLCBvKTsgIWYuZW9sKCk7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi5wb3MgPiBlLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoID8gKGwgPSAhMSwgYSAmJiBIcihlLCB0LCByLCBmLnBvcyksIGYucG9zID0gdC5sZW5ndGgsIHMgPSBudWxsKSA6IHMgPSBBcihPcihuLCBmLCByLCBoKSwgbyksIGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGhbMF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkICYmIChzID0gXCJtLVwiICsgKHMgPyBkICsgXCIgXCIgKyBzIDogZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWwgfHwgdSAhPSBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGMgPCBmLnN0YXJ0OyljID0gTWF0aC5taW4oZi5zdGFydCwgYyArIDVlNCksIGkoYywgdSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGYuc3RhcnQgPSBmLnBvc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBjIDwgZi5wb3M7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IE1hdGgubWluKGYucG9zLCBjICsgNWU0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkocCwgdSksIGMgPSBwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBScihlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gW2Uuc3RhdGUubW9kZUdlbl0sIG8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgUHIoZSwgdC50ZXh0LCBlLmRvYy5tb2RlLCBuLCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaS5wdXNoKGUsIHQpXG4gICAgICAgICAgICAgICAgICAgIH0sIG8sIHIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGUuc3RhdGUub3ZlcmxheXMubGVuZ3RoOyArK2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gZS5zdGF0ZS5vdmVybGF5c1thXSwgcyA9IDEsIGMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgUHIoZSwgdC50ZXh0LCBsLm1vZGUsICEwLCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBzOyBlID4gYzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBpW3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID4gZSAmJiBpLnNwbGljZShzLCAxLCBlLCBpW3MgKyAxXSwgciksIHMgKz0gMiwgYyA9IE1hdGgubWluKGUsIHIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0KWlmIChsLm9wYXF1ZSkgaS5zcGxpY2UobiwgcyAtIG4sIGUsIFwiY20tb3ZlcmxheSBcIiArIHQpLCBzID0gbiArIDI7IGVsc2UgZm9yICg7IHMgPiBuOyBuICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBpW24gKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaVtuICsgMV0gPSAobyA/IG8gKyBcIiBcIiA6IFwiXCIpICsgXCJjbS1vdmVybGF5IFwiICsgdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG8pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtzdHlsZXM6IGksIGNsYXNzZXM6IG8uYmdDbGFzcyB8fCBvLnRleHRDbGFzcyA/IG8gOiBudWxsfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIERyKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0LnN0eWxlcyB8fCB0LnN0eWxlc1swXSAhPSBlLnN0YXRlLm1vZGVHZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gamUoZSwgdGkodCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBScihlLCB0LCB0LnRleHQubGVuZ3RoID4gZS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCA/IHNhKGUuZG9jLm1vZGUsIHIpIDogcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnN0YXRlQWZ0ZXIgPSByLCB0LnN0eWxlcyA9IGkuc3R5bGVzLCBpLmNsYXNzZXMgPyB0LnN0eWxlQ2xhc3NlcyA9IGkuY2xhc3NlcyA6IHQuc3R5bGVDbGFzc2VzICYmICh0LnN0eWxlQ2xhc3NlcyA9IG51bGwpLCBuID09PSBlLmRvYy5mcm9udGllciAmJiBlLmRvYy5mcm9udGllcisrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuc3R5bGVzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSHIoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGUuZG9jLm1vZGUsIG8gPSBuZXcgbWEodCwgZS5vcHRpb25zLnRhYlNpemUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG8uc3RhcnQgPSBvLnBvcyA9IHIgfHwgMCwgXCJcIiA9PSB0ICYmIEVyKGksIG4pOyAhby5lb2woKTspT3IoaSwgbywgbiksIG8uc3RhcnQgPSBvLnBvc1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFdyKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlIHx8IC9eXFxzKiQvLnRlc3QoZSkpcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdC5hZGRNb2RlQ2xhc3MgPyBrYSA6IHdhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbltlXSB8fCAobltlXSA9IGUucmVwbGFjZSgvXFxTKy9nLCBcImNtLSQmXCIpKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEJyKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBqaShcInNwYW5cIiwgbnVsbCwgbnVsbCwgd28gPyBcInBhZGRpbmctcmlnaHQ6IC4xcHhcIiA6IG51bGwpLCByID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlOiBqaShcInByZVwiLCBbbl0sIFwiQ29kZU1pcnJvci1saW5lXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRTcGFjZXM6ICh4byB8fCB3bykgJiYgZS5nZXRPcHRpb24oXCJsaW5lV3JhcHBpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdC5tZWFzdXJlID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9ICh0LnJlc3QgPyB0LnJlc3QubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8sIGEgPSBpID8gdC5yZXN0W2kgLSAxXSA6IHQubGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucG9zID0gMCwgci5hZGRUb2tlbiA9IEZyLCBKaShlLmRpc3BsYXkubWVhc3VyZSkgJiYgKG8gPSBpaShhKSkgJiYgKHIuYWRkVG9rZW4gPSBqcihyLmFkZFRva2VuLCBvKSksIHIubWFwID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHQgIT0gZS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgJiYgdGkoYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcihhLCByLCBEcihlLCBhLCBsKSksIGEuc3R5bGVDbGFzc2VzICYmIChhLnN0eWxlQ2xhc3Nlcy5iZ0NsYXNzICYmIChyLmJnQ2xhc3MgPSAkaShhLnN0eWxlQ2xhc3Nlcy5iZ0NsYXNzLCByLmJnQ2xhc3MgfHwgXCJcIikpLCBhLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3MgJiYgKHIudGV4dENsYXNzID0gJGkoYS5zdHlsZUNsYXNzZXMudGV4dENsYXNzLCByLnRleHRDbGFzcyB8fCBcIlwiKSkpLCAwID09IHIubWFwLmxlbmd0aCAmJiByLm1hcC5wdXNoKDAsIDAsIHIuY29udGVudC5hcHBlbmRDaGlsZChaaShlLmRpc3BsYXkubWVhc3VyZSkpKSwgMCA9PSBpID8gKHQubWVhc3VyZS5tYXAgPSByLm1hcCwgdC5tZWFzdXJlLmNhY2hlID0ge30pIDogKCh0Lm1lYXN1cmUubWFwcyB8fCAodC5tZWFzdXJlLm1hcHMgPSBbXSkpLnB1c2goci5tYXApLCAodC5tZWFzdXJlLmNhY2hlcyB8fCAodC5tZWFzdXJlLmNhY2hlcyA9IFtdKSkucHVzaCh7fSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHIuY29udGVudC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAoL1xcYmNtLXRhYlxcYi8udGVzdChzLmNsYXNzTmFtZSkgfHwgcy5xdWVyeVNlbGVjdG9yICYmIHMucXVlcnlTZWxlY3RvcihcIi5jbS10YWJcIikpICYmIChyLmNvbnRlbnQuY2xhc3NOYW1lID0gXCJjbS10YWItd3JhcC1oYWNrXCIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhKGUsIFwicmVuZGVyTGluZVwiLCBlLCB0LmxpbmUsIHIucHJlKSwgci5wcmUuY2xhc3NOYW1lICYmIChyLnRleHRDbGFzcyA9ICRpKHIucHJlLmNsYXNzTmFtZSwgci50ZXh0Q2xhc3MgfHwgXCJcIikpLCByXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gX3IoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGppKFwic3BhblwiLCBcIuKAolwiLCBcImNtLWludmFsaWRjaGFyXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC50aXRsZSA9IFwiXFxcXHVcIiArIGUuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNiksIHQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0LnRpdGxlKSwgdFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEZyKGUsIHQsIG4sIHIsIGksIG8sIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gZS5zcGxpdFNwYWNlcyA/IHQucmVwbGFjZSgvIHszLH0vZywgenIpIDogdCwgcyA9IGUuY20uc3RhdGUuc3BlY2lhbENoYXJzLCBjID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy50ZXN0KHQpKWZvciAodmFyIHUgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIGYgPSAwOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5sYXN0SW5kZXggPSBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gcy5leGVjKHQpLCBkID0gaCA/IGguaW5kZXggLSBmIDogdC5sZW5ndGggLSBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobC5zbGljZShmLCBmICsgZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4byAmJiA5ID4gYm8gPyB1LmFwcGVuZENoaWxkKGppKFwic3BhblwiLCBbcF0pKSA6IHUuYXBwZW5kQ2hpbGQocCksIGUubWFwLnB1c2goZS5wb3MsIGUucG9zICsgZCwgcCksIGUuY29sICs9IGQsIGUucG9zICs9IGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoKWJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmICs9IGQgKyAxLCBcIlx0XCIgPT0gaFswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGUuY20ub3B0aW9ucy50YWJTaXplLCBnID0gbSAtIGUuY29sICUgbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSB1LmFwcGVuZENoaWxkKGppKFwic3BhblwiLCBPaShnKSwgXCJjbS10YWJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIiksIHAuc2V0QXR0cmlidXRlKFwiY20tdGV4dFwiLCBcIlx0XCIpLCBlLmNvbCArPSBnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcIlxcclwiID09IGhbMF0gfHwgXCJcXG5cIiA9PSBoWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gdS5hcHBlbmRDaGlsZChqaShcInNwYW5cIiwgXCJcXHJcIiA9PSBoWzBdID8gXCLikI1cIiA6IFwi4pCkXCIsIFwiY20taW52YWxpZGNoYXJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgaFswXSksIGUuY29sICs9IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGUuY20ub3B0aW9ucy5zcGVjaWFsQ2hhclBsYWNlaG9sZGVyKGhbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgaFswXSksIHhvICYmIDkgPiBibyA/IHUuYXBwZW5kQ2hpbGQoamkoXCJzcGFuXCIsIFtwXSkpIDogdS5hcHBlbmRDaGlsZChwKSwgZS5jb2wgKz0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm1hcC5wdXNoKGUucG9zLCBlLnBvcyArIDEsIHApLCBlLnBvcysrXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY29sICs9IHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5tYXAucHVzaChlLnBvcywgZS5wb3MgKyB0Lmxlbmd0aCwgdSksIHhvICYmIDkgPiBibyAmJiAoYyA9ICEwKSwgZS5wb3MgKz0gdC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuIHx8IHIgfHwgaSB8fCBjIHx8IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IG4gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByICYmICh2ICs9IHIpLCBpICYmICh2ICs9IGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gamkoXCJzcGFuXCIsIFt1XSwgdiwgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8gJiYgKHkudGl0bGUgPSBvKSwgZS5jb250ZW50LmFwcGVuZENoaWxkKHkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmNvbnRlbnQuYXBwZW5kQ2hpbGQodSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHpyKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IFwiIFwiLCBuID0gMDsgbiA8IGUubGVuZ3RoIC0gMjsgKytuKXQgKz0gbiAlIDIgPyBcIiBcIiA6IFwiwqBcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgKz0gXCIgXCJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBqcihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobiwgciwgaSwgbywgYSwgbCwgcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGkgPyBpICsgXCIgY20tZm9yY2UtYm9yZGVyXCIgOiBcImNtLWZvcmNlLWJvcmRlclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IG4ucG9zLCB1ID0gYyArIHIubGVuZ3RoOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCB0Lmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gdFtmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGgudG8gPiBjICYmIGguZnJvbSA8PSBjKWJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoLnRvID49IHUpcmV0dXJuIGUobiwgciwgaSwgbywgYSwgbCwgcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZShuLCByLnNsaWNlKDAsIGgudG8gLSBjKSwgaSwgbywgbnVsbCwgbCwgcyksIG8gPSBudWxsLCByID0gci5zbGljZShoLnRvIC0gYyksIGMgPSBoLnRvXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBVcihlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gIXIgJiYgbi53aWRnZXROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpICYmIGUubWFwLnB1c2goZS5wb3MsIGUucG9zICsgdCwgaSksICFyICYmIGUuY20uZGlzcGxheS5pbnB1dC5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUgJiYgKGkgfHwgKGkgPSBlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpKSwgaS5zZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIiwgbi5pZCkpLCBpICYmIChlLmNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShpKSwgZS5jb250ZW50LmFwcGVuZENoaWxkKGkpKSwgZS5wb3MgKz0gdFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHFyKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlLm1hcmtlZFNwYW5zLCBpID0gZS50ZXh0LCBvID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIpZm9yICh2YXIgYSwgbCwgcywgYywgdSwgZiwgaCwgZCA9IGkubGVuZ3RoLCBwID0gMCwgbSA9IDEsIGcgPSBcIlwiLCB2ID0gMDsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT0gcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBjID0gdSA9IGYgPSBsID0gXCJcIiwgaCA9IG51bGwsIHYgPSAxIC8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5LCB4ID0gW10sIGIgPSAwOyBiIDwgci5sZW5ndGg7ICsrYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHJbYl0sIGsgPSB3Lm1hcmtlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJib29rbWFya1wiID09IGsudHlwZSAmJiB3LmZyb20gPT0gcCAmJiBrLndpZGdldE5vZGUgPyB4LnB1c2goaykgOiB3LmZyb20gPD0gcCAmJiAobnVsbCA9PSB3LnRvIHx8IHcudG8gPiBwIHx8IGsuY29sbGFwc2VkICYmIHcudG8gPT0gcCAmJiB3LmZyb20gPT0gcCkgPyAobnVsbCAhPSB3LnRvICYmIHcudG8gIT0gcCAmJiB2ID4gdy50byAmJiAodiA9IHcudG8sIGMgPSBcIlwiKSwgay5jbGFzc05hbWUgJiYgKHMgKz0gXCIgXCIgKyBrLmNsYXNzTmFtZSksIGsuY3NzICYmIChsID0gKGwgPyBsICsgXCI7XCIgOiBcIlwiKSArIGsuY3NzKSwgay5zdGFydFN0eWxlICYmIHcuZnJvbSA9PSBwICYmICh1ICs9IFwiIFwiICsgay5zdGFydFN0eWxlKSwgay5lbmRTdHlsZSAmJiB3LnRvID09IHYgJiYgKHkgfHwgKHkgPSBbXSkpLnB1c2goay5lbmRTdHlsZSwgdy50byksIGsudGl0bGUgJiYgIWYgJiYgKGYgPSBrLnRpdGxlKSwgay5jb2xsYXBzZWQgJiYgKCFoIHx8IGRyKGgubWFya2VyLCBrKSA8IDApICYmIChoID0gdykpIDogdy5mcm9tID4gcCAmJiB2ID4gdy5mcm9tICYmICh2ID0gdy5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeSlmb3IgKHZhciBiID0gMDsgYiA8IHkubGVuZ3RoOyBiICs9IDIpeVtiICsgMV0gPT0gdiAmJiAoYyArPSBcIiBcIiArIHlbYl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaCB8fCBoLmZyb20gPT0gcClmb3IgKHZhciBiID0gMDsgYiA8IHgubGVuZ3RoOyArK2IpVXIodCwgMCwgeFtiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGggJiYgKGguZnJvbSB8fCAwKSA9PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChVcih0LCAobnVsbCA9PSBoLnRvID8gZCArIDEgOiBoLnRvKSAtIHAsIGgubWFya2VyLCBudWxsID09IGguZnJvbSksIG51bGwgPT0gaC50bylyZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgudG8gPT0gcCAmJiAoaCA9ICExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwID49IGQpYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBTID0gTWF0aC5taW4oZCwgdik7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQyA9IHAgKyBnLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTCA9IEMgPiBTID8gZy5zbGljZSgwLCBTIC0gcCkgOiBnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5hZGRUb2tlbih0LCBMLCBhID8gYSArIHMgOiBzLCB1LCBwICsgTC5sZW5ndGggPT0gdiA/IGMgOiBcIlwiLCBmLCBsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDID49IFMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBnLnNsaWNlKFMgLSBwKSwgcCA9IFM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBDLCB1ID0gXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gaS5zbGljZShvLCBvID0gblttKytdKSwgYSA9IFdyKG5bbSsrXSwgdC5jbS5vcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZm9yICh2YXIgbSA9IDE7IG0gPCBuLmxlbmd0aDsgbSArPSAyKXQuYWRkVG9rZW4odCwgaS5zbGljZShvLCBvID0gblttXSksIFdyKG5bbSArIDFdLCB0LmNtLm9wdGlvbnMpKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEdyKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgPT0gdC5mcm9tLmNoICYmIDAgPT0gdC50by5jaCAmJiBcIlwiID09IElpKHQudGV4dCkgJiYgKCFlLmNtIHx8IGUuY20ub3B0aW9ucy53aG9sZUxpbmVVcGRhdGVCZWZvcmUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gWXIoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuID8gbltlXSA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG8oZSwgbiwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTXIoZSwgbiwgaSwgciksIENpKGUsIFwiY2hhbmdlXCIsIGUsIHQpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBlLCBvID0gW107IHQgPiBuOyArK24pby5wdXNoKG5ldyBiYShjW25dLCBpKG4pLCByKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSB0LmZyb20sIHMgPSB0LnRvLCBjID0gdC50ZXh0LCB1ID0gWnIoZSwgbC5saW5lKSwgZiA9IFpyKGUsIHMubGluZSksIGggPSBJaShjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBpKGMubGVuZ3RoIC0gMSksIHAgPSBzLmxpbmUgLSBsLmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmZ1bGwpIGUuaW5zZXJ0KDAsIGEoMCwgYy5sZW5ndGgpKSwgZS5yZW1vdmUoYy5sZW5ndGgsIGUuc2l6ZSAtIGMubGVuZ3RoKTsgZWxzZSBpZiAoR3IoZSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gYSgwLCBjLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbyhmLCBmLnRleHQsIGQpLCBwICYmIGUucmVtb3ZlKGwubGluZSwgcCksIG0ubGVuZ3RoICYmIGUuaW5zZXJ0KGwubGluZSwgbSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1ID09IGYpaWYgKDEgPT0gYy5sZW5ndGgpIG8odSwgdS50ZXh0LnNsaWNlKDAsIGwuY2gpICsgaCArIHUudGV4dC5zbGljZShzLmNoKSwgZCk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBhKDEsIGMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnB1c2gobmV3IGJhKGggKyB1LnRleHQuc2xpY2Uocy5jaCksIGQsIHIpKSwgbyh1LCB1LnRleHQuc2xpY2UoMCwgbC5jaCkgKyBjWzBdLCBpKDApKSwgZS5pbnNlcnQobC5saW5lICsgMSwgbSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgxID09IGMubGVuZ3RoKSBvKHUsIHUudGV4dC5zbGljZSgwLCBsLmNoKSArIGNbMF0gKyBmLnRleHQuc2xpY2Uocy5jaCksIGkoMCkpLCBlLnJlbW92ZShsLmxpbmUgKyAxLCBwKTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvKHUsIHUudGV4dC5zbGljZSgwLCBsLmNoKSArIGNbMF0sIGkoMCkpLCBvKGYsIGggKyBmLnRleHQuc2xpY2Uocy5jaCksIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBhKDEsIGMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwID4gMSAmJiBlLnJlbW92ZShsLmxpbmUgKyAxLCBwIC0gMSksIGUuaW5zZXJ0KGwubGluZSArIDEsIG0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgQ2koZSwgXCJjaGFuZ2VcIiwgZSwgdClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAkcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZXMgPSBlLCB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAwLCBuID0gMDsgdCA8IGUubGVuZ3RoOyArK3QpZVt0XS5wYXJlbnQgPSB0aGlzLCBuICs9IGVbdF0uaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBWcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMCwgbiA9IDAsIHIgPSAwOyByIDwgZS5sZW5ndGg7ICsrcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlW3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCArPSBpLmNodW5rU2l6ZSgpLCBuICs9IGkuaGVpZ2h0LCBpLnBhcmVudCA9IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSB0LCB0aGlzLmhlaWdodCA9IG4sIHRoaXMucGFyZW50ID0gbnVsbFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEtyKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcihlLCBpLCBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5saW5rZWQpZm9yICh2YXIgYSA9IDA7IGEgPCBlLmxpbmtlZC5sZW5ndGg7ICsrYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gZS5saW5rZWRbYV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwuZG9jICE9IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBvICYmIGwuc2hhcmVkSGlzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiAmJiAhcyB8fCAodChsLmRvYywgcyksIHIobC5kb2MsIGUsIHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHIoZSwgbnVsbCwgITApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gWHIoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodC5jbSl0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGRvY3VtZW50IGlzIGFscmVhZHkgaW4gdXNlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgZS5kb2MgPSB0LCB0LmNtID0gZSwgYShlKSwgbihlKSwgZS5vcHRpb25zLmxpbmVXcmFwcGluZyB8fCBoKGUpLCBlLm9wdGlvbnMubW9kZSA9IHQubW9kZU9wdGlvbiwgRHQoZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBacihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0IC09IGUuZmlyc3QsIDAgPiB0IHx8IHQgPj0gZS5zaXplKXRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGxpbmUgXCIgKyAodCArIGUuZmlyc3QpICsgXCIgaW4gdGhlIGRvY3VtZW50LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IGU7ICFuLmxpbmVzOylmb3IgKHZhciByID0gMDsgOyArK3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gbi5jaGlsZHJlbltyXSwgbyA9IGkuY2h1bmtTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobyA+IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdCAtPSBvXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4ubGluZXNbdF1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBKcihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gW10sIGkgPSB0LmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLml0ZXIodC5saW5lLCBuLmxpbmUgKyAxLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBlLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID09IG4ubGluZSAmJiAobyA9IG8uc2xpY2UoMCwgbi5jaCkpLCBpID09IHQubGluZSAmJiAobyA9IG8uc2xpY2UodC5jaCkpLCByLnB1c2gobyksICsraVxuICAgICAgICAgICAgICAgICAgICB9KSwgclxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFFyKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuaXRlcih0LCBuLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgci5wdXNoKGUudGV4dClcbiAgICAgICAgICAgICAgICAgICAgfSksIHJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBlaShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdCAtIGUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAobilmb3IgKHZhciByID0gZTsgcjsgciA9IHIucGFyZW50KXIuaGVpZ2h0ICs9IG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0aShlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IGUucGFyZW50KXJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gZS5wYXJlbnQsIG4gPSBQaSh0LmxpbmVzLCBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHQucGFyZW50OyByOyB0ID0gciwgciA9IHIucGFyZW50KWZvciAodmFyIGkgPSAwOyByLmNoaWxkcmVuW2ldICE9IHQ7ICsraSluICs9IHIuY2hpbGRyZW5baV0uY2h1bmtTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuICsgdC5maXJzdFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG5pKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmZpcnN0O1xuICAgICAgICAgICAgICAgICAgICBlOmRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgZS5jaGlsZHJlbi5sZW5ndGg7ICsrcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZS5jaGlsZHJlbltyXSwgbyA9IGkuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvID4gdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0IC09IG8sIG4gKz0gaS5jaHVua1NpemUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoIWUubGluZXMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGUubGluZXMubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gZS5saW5lc1tyXSwgbCA9IGEuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwgPiB0KWJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCAtPSBsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gKyByXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmkoZSkge1xuICAgICAgICAgICAgICAgICAgICBlID0geXIoZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAwLCBuID0gZS5wYXJlbnQsIHIgPSAwOyByIDwgbi5saW5lcy5sZW5ndGg7ICsrcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBuLmxpbmVzW3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gZSlicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgKz0gaS5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0gbi5wYXJlbnQ7IG87IG4gPSBvLCBvID0gbi5wYXJlbnQpZm9yICh2YXIgciA9IDA7IHIgPCBvLmNoaWxkcmVuLmxlbmd0aDsgKytyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG8uY2hpbGRyZW5bcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA9PSBuKWJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCArPSBhLmhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaWkoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUub3JkZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsID09IHQgJiYgKHQgPSBlLm9yZGVyID0gbGwoZS50ZXh0KSksIHRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvaShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IFtdLCB0aGlzLnVuZG9uZSA9IFtdLCB0aGlzLnVuZG9EZXB0aCA9IDEgLyAwLCB0aGlzLmxhc3RNb2RUaW1lID0gdGhpcy5sYXN0U2VsVGltZSA9IDAsIHRoaXMubGFzdE9wID0gdGhpcy5sYXN0U2VsT3AgPSBudWxsLCB0aGlzLmxhc3RPcmlnaW4gPSB0aGlzLmxhc3RTZWxPcmlnaW4gPSBudWxsLCB0aGlzLmdlbmVyYXRpb24gPSB0aGlzLm1heEdlbmVyYXRpb24gPSBlIHx8IDFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhaShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0ge2Zyb206ICQodC5mcm9tKSwgdG86IFFvKHQpLCB0ZXh0OiBKcihlLCB0LmZyb20sIHQudG8pfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpKGUsIG4sIHQuZnJvbS5saW5lLCB0LnRvLmxpbmUgKyAxKSwgS3IoZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpKGUsIG4sIHQuZnJvbS5saW5lLCB0LnRvLmxpbmUgKyAxKVxuICAgICAgICAgICAgICAgICAgICB9LCAhMCksIG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsaShlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBlLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gSWkoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXQucmFuZ2VzKWJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wb3AoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2koZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCA/IChsaShlLmRvbmUpLCBJaShlLmRvbmUpKSA6IGUuZG9uZS5sZW5ndGggJiYgIUlpKGUuZG9uZSkucmFuZ2VzID8gSWkoZS5kb25lKSA6IGUuZG9uZS5sZW5ndGggPiAxICYmICFlLmRvbmVbZS5kb25lLmxlbmd0aCAtIDJdLnJhbmdlcyA/IChlLmRvbmUucG9wKCksIElpKGUuZG9uZSkpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2koZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGUuaGlzdG9yeTtcbiAgICAgICAgICAgICAgICAgICAgaS51bmRvbmUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8sIGEgPSArbmV3IERhdGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoaS5sYXN0T3AgPT0gciB8fCBpLmxhc3RPcmlnaW4gPT0gdC5vcmlnaW4gJiYgdC5vcmlnaW4gJiYgKFwiK1wiID09IHQub3JpZ2luLmNoYXJBdCgwKSAmJiBlLmNtICYmIGkubGFzdE1vZFRpbWUgPiBhIC0gZS5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5IHx8IFwiKlwiID09IHQub3JpZ2luLmNoYXJBdCgwKSkpICYmIChvID0gc2koaSwgaS5sYXN0T3AgPT0gcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IElpKG8uY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAwID09IF9vKHQuZnJvbSwgdC50bykgJiYgMCA9PSBfbyh0LmZyb20sIGwudG8pID8gbC50byA9IFFvKHQpIDogby5jaGFuZ2VzLnB1c2goYWkoZSwgdCkpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IElpKGkuZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHMgJiYgcy5yYW5nZXMgfHwgaGkoZS5zZWwsIGkuZG9uZSksIG8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogW2FpKGUsIHQpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uOiBpLmdlbmVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGkuZG9uZS5wdXNoKG8pOyBpLmRvbmUubGVuZ3RoID4gaS51bmRvRGVwdGg7KWkuZG9uZS5zaGlmdCgpLCBpLmRvbmVbMF0ucmFuZ2VzIHx8IGkuZG9uZS5zaGlmdCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaS5kb25lLnB1c2gobiksIGkuZ2VuZXJhdGlvbiA9ICsraS5tYXhHZW5lcmF0aW9uLCBpLmxhc3RNb2RUaW1lID0gaS5sYXN0U2VsVGltZSA9IGEsIGkubGFzdE9wID0gaS5sYXN0U2VsT3AgPSByLCBpLmxhc3RPcmlnaW4gPSBpLmxhc3RTZWxPcmlnaW4gPSB0Lm9yaWdpbiwgbCB8fCBQYShlLCBcImhpc3RvcnlBZGRlZFwiKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVpKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0LmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKlwiID09IGkgfHwgXCIrXCIgPT0gaSAmJiBuLnJhbmdlcy5sZW5ndGggPT0gci5yYW5nZXMubGVuZ3RoICYmIG4uc29tZXRoaW5nU2VsZWN0ZWQoKSA9PSByLnNvbWV0aGluZ1NlbGVjdGVkKCkgJiYgbmV3IERhdGUgLSBlLmhpc3RvcnkubGFzdFNlbFRpbWUgPD0gKGUuY20gPyBlLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXkgOiA1MDApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmkoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGUuaGlzdG9yeSwgbyA9IHIgJiYgci5vcmlnaW47XG4gICAgICAgICAgICAgICAgICAgIG4gPT0gaS5sYXN0U2VsT3AgfHwgbyAmJiBpLmxhc3RTZWxPcmlnaW4gPT0gbyAmJiAoaS5sYXN0TW9kVGltZSA9PSBpLmxhc3RTZWxUaW1lICYmIGkubGFzdE9yaWdpbiA9PSBvIHx8IHVpKGUsIG8sIElpKGkuZG9uZSksIHQpKSA/IGkuZG9uZVtpLmRvbmUubGVuZ3RoIC0gMV0gPSB0IDogaGkodCwgaS5kb25lKSwgaS5sYXN0U2VsVGltZSA9ICtuZXcgRGF0ZSwgaS5sYXN0U2VsT3JpZ2luID0gbywgaS5sYXN0U2VsT3AgPSBuLCByICYmIHIuY2xlYXJSZWRvICE9PSAhMSAmJiBsaShpLnVuZG9uZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoaShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gSWkodCk7XG4gICAgICAgICAgICAgICAgICAgIG4gJiYgbi5yYW5nZXMgJiYgbi5lcXVhbHMoZSkgfHwgdC5wdXNoKGUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGkoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRbXCJzcGFuc19cIiArIGUuaWRdLCBvID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZS5pdGVyKE1hdGgubWF4KGUuZmlyc3QsIG4pLCBNYXRoLm1pbihlLmZpcnN0ICsgZS5zaXplLCByKSwgZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4ubWFya2VkU3BhbnMgJiYgKChpIHx8IChpID0gdFtcInNwYW5zX1wiICsgZS5pZF0gPSB7fSkpW29dID0gbi5tYXJrZWRTcGFucyksICsrb1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHBpKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlKXJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMDsgbiA8IGUubGVuZ3RoOyArK24pZVtuXS5tYXJrZXIuZXhwbGljaXRseUNsZWFyZWQgPyB0IHx8ICh0ID0gZS5zbGljZSgwLCBuKSkgOiB0ICYmIHQucHVzaChlW25dKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPyB0Lmxlbmd0aCA/IHQgOiBudWxsIDogZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1pKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0W1wic3BhbnNfXCIgKyBlLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuKXJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMCwgaSA9IFtdOyByIDwgdC50ZXh0Lmxlbmd0aDsgKytyKWkucHVzaChwaShuW3JdKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2koZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMCwgaSA9IFtdOyByIDwgZS5sZW5ndGg7ICsrcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBlW3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8ucmFuZ2VzKSBpLnB1c2gobiA/IHVlLnByb3RvdHlwZS5kZWVwQ29weS5jYWxsKG8pIDogbyk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gby5jaGFuZ2VzLCBsID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS5wdXNoKHtjaGFuZ2VzOiBsfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBhLmxlbmd0aDsgKytzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjLCB1ID0gYVtzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdS5mcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB1LnRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHUudGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIHQpZm9yICh2YXIgZiBpbiB1KShjID0gZi5tYXRjaCgvXnNwYW5zXyhcXGQrKSQvKSkgJiYgUGkodCwgTnVtYmVyKGNbMV0pKSA+IC0xICYmIChJaShsKVtmXSA9IHVbZl0sIGRlbGV0ZSB1W2ZdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHZpKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgbiA8IGUubGluZSA/IGUubGluZSArPSByIDogdCA8IGUubGluZSAmJiAoZS5saW5lID0gdCwgZS5jaCA9IDApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24geWkoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZVtpXSwgYSA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8ucmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5jb3BpZWQgfHwgKG8gPSBlW2ldID0gby5kZWVwQ29weSgpLCBvLmNvcGllZCA9ICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IG8ucmFuZ2VzLmxlbmd0aDsgbCsrKXZpKG8ucmFuZ2VzW2xdLmFuY2hvciwgdCwgbiwgciksIHZpKG8ucmFuZ2VzW2xdLmhlYWQsIHQsIG4sIHIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgby5jaGFuZ2VzLmxlbmd0aDsgKytsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gby5jaGFuZ2VzW2xdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobiA8IHMuZnJvbS5saW5lKSBzLmZyb20gPSBCbyhzLmZyb20ubGluZSArIHIsIHMuZnJvbS5jaCksIHMudG8gPSBCbyhzLnRvLmxpbmUgKyByLCBzLnRvLmNoKTsgZWxzZSBpZiAodCA8PSBzLnRvLmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSB8fCAoZS5zcGxpY2UoMCwgaSArIDEpLCBpID0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHhpKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0LmZyb20ubGluZSwgciA9IHQudG8ubGluZSwgaSA9IHQudGV4dC5sZW5ndGggLSAociAtIG4pIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgeWkoZS5kb25lLCBuLCByLCBpKSwgeWkoZS51bmRvbmUsIG4sIHIsIGkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYmkoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCAhPSBlLmRlZmF1bHRQcmV2ZW50ZWQgPyBlLmRlZmF1bHRQcmV2ZW50ZWQgOiAwID09IGUucmV0dXJuVmFsdWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB3aShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBraShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS53aGljaDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gdCAmJiAoMSAmIGUuYnV0dG9uID8gdCA9IDEgOiAyICYgZS5idXR0b24gPyB0ID0gMyA6IDQgJiBlLmJ1dHRvbiAmJiAodCA9IDIpKSwgRW8gJiYgZS5jdHJsS2V5ICYmIDEgPT0gdCAmJiAodCA9IDMpLCB0XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU2koZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUuX2hhbmRsZXJzICYmIGUuX2hhbmRsZXJzW3RdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiA/IHIgJiYgci5sZW5ndGggPiAwID8gci5zbGljZSgpIDogT2EgOiByIHx8IE9hXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQ2koZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBuKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5hcHBseShudWxsLCBvKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBTaShlLCB0LCAhMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgR28gPyBpID0gR28uZGVsYXllZENhbGxiYWNrcyA6IFJhID8gaSA9IFJhIDogKGkgPSBSYSA9IFtdLCBzZXRUaW1lb3V0KExpLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHIubGVuZ3RoOyArK2EpaS5wdXNoKG4oclthXSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBMaSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBSYTtcbiAgICAgICAgICAgICAgICAgICAgUmEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGUubGVuZ3RoOyArK3QpZVt0XSgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gVGkoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCAmJiAodCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHQsIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSksIFBhKGUsIG4gfHwgdC50eXBlLCBlLCB0KSwgYmkodCkgfHwgdC5jb2RlbWlycm9ySWdub3JlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTWkoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUuX2hhbmRsZXJzICYmIGUuX2hhbmRsZXJzLmN1cnNvckFjdGl2aXR5O1xuICAgICAgICAgICAgICAgICAgICBpZiAodClmb3IgKHZhciBuID0gZS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzIHx8IChlLmN1ck9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMgPSBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAwOyByIDwgdC5sZW5ndGg7ICsrciktMSA9PSBQaShuLCB0W3JdKSAmJiBuLnB1c2godFtyXSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBOaShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTaShlLCB0KS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQWkoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBFYSh0aGlzLCBlLCB0KVxuICAgICAgICAgICAgICAgICAgICB9LCBlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgSWEodGhpcywgZSwgdClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEVpKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gbnVsbFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE9pKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGphLmxlbmd0aCA8PSBlOylqYS5wdXNoKElpKGphKSArIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGphW2VdXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSWkoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVtlLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUGkoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyArK24paWYgKGVbbl0gPT0gdClyZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUmkoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gW10sIHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKyluW3JdID0gdChlW3JdLCByKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBEaSgpIHtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBIaShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSA/IG4gPSBPYmplY3QuY3JlYXRlKGUpIDogKERpLnByb3RvdHlwZSA9IGUsIG4gPSBuZXcgRGkpLCB0ICYmIFdpKHQsIG4pLCBuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gV2koZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICB0IHx8ICh0ID0ge30pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByIGluIGUpIWUuaGFzT3duUHJvcGVydHkocikgfHwgbiA9PT0gITEgJiYgdC5oYXNPd25Qcm9wZXJ0eShyKSB8fCAodFtyXSA9IGVbcl0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEJpKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuYXBwbHkobnVsbCwgdClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9pKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPyB0LnNvdXJjZS5pbmRleE9mKFwiXFxcXHdcIikgPiAtMSAmJiBZYShlKSA/ICEwIDogdC50ZXN0KGUpIDogWWEoZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBGaShlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgaW4gZSlpZiAoZS5oYXNPd25Qcm9wZXJ0eSh0KSAmJiBlW3RdKXJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gemkoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5jaGFyQ29kZUF0KDApID49IDc2OCAmJiAkYS50ZXN0KGUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gamkoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuICYmIChpLmNsYXNzTmFtZSA9IG4pLCByICYmIChpLnN0eWxlLmNzc1RleHQgPSByKSwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkgaS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0KSk7IGVsc2UgaWYgKHQpZm9yICh2YXIgbyA9IDA7IG8gPCB0Lmxlbmd0aDsgKytvKWkuYXBwZW5kQ2hpbGQodFtvXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gVWkoZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gZS5jaGlsZE5vZGVzLmxlbmd0aDsgdCA+IDA7IC0tdCllLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcWkoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVWkoZSkuYXBwZW5kQ2hpbGQodClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBHaSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7IGUgJiYgZS5yb290ICYmIGUucm9vdC5hY3RpdmVFbGVtZW50OyllID0gZS5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gWWkoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgZSArIFwiKD86JHxcXFxccylcXFxccypcIilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAkaShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBlLnNwbGl0KFwiIFwiKSwgciA9IDA7IHIgPCBuLmxlbmd0aDsgcisrKW5bcl0gJiYgIVlpKG5bcl0pLnRlc3QodCkgJiYgKHQgKz0gXCIgXCIgKyBuW3JdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBWaShlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5ib2R5LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpZm9yICh2YXIgdCA9IGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIkNvZGVNaXJyb3JcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRbbl0uQ29kZU1pcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgJiYgZShyKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gS2koKSB7XG4gICAgICAgICAgICAgICAgICAgIFFhIHx8IChYaSgpLCBRYSA9ICEwKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFhpKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZTtcbiAgICAgICAgICAgICAgICAgICAgRWEod2luZG93LCBcInJlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsID09IGUgJiYgKGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbnVsbCwgVmkocXQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApKVxuICAgICAgICAgICAgICAgICAgICB9KSwgRWEod2luZG93LCBcImJsdXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgVmkoeW4pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gWmkoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PSBLYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBqaShcInNwYW5cIiwgXCLigItcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBxaShlLCBqaShcInNwYW5cIiwgW3QsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKV0pKSwgMCAhPSBlLmZpcnN0Q2hpbGQub2Zmc2V0SGVpZ2h0ICYmIChLYSA9IHQub2Zmc2V0V2lkdGggPD0gMSAmJiB0Lm9mZnNldEhlaWdodCA+IDIgJiYgISh4byAmJiA4ID4gYm8pKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gS2EgPyBqaShcInNwYW5cIiwgXCLigItcIikgOiBqaShcInNwYW5cIiwgXCLCoFwiLCBudWxsLCBcImRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lkdGg6IDFweDsgbWFyZ2luLXJpZ2h0OiAtMXB4XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIFwiXCIpLCBuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSmkoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBYYSlyZXR1cm4gWGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gcWkoZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJB2K5BXCIpKSwgbiA9IHFhKHQsIDAsIDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW4gfHwgbi5sZWZ0ID09IG4ucmlnaHQpcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHFhKHQsIDEsIDIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWGEgPSByLnJpZ2h0IC0gbi5yaWdodCA8IDNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBRaShlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IGlsKXJldHVybiBpbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBxaShlLCBqaShcInNwYW5cIiwgXCJ4XCIpKSwgbiA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gcWEodCwgMCwgMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbCA9IE1hdGguYWJzKG4ubGVmdCAtIHIubGVmdCkgPiAxXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZW8oZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWUpcmV0dXJuIHIodCwgbiwgXCJsdHJcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAhMSwgbyA9IDA7IG8gPCBlLmxlbmd0aDsgKytvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGVbb107XG4gICAgICAgICAgICAgICAgICAgICAgICAoYS5mcm9tIDwgbiAmJiBhLnRvID4gdCB8fCB0ID09IG4gJiYgYS50byA9PSB0KSAmJiAocihNYXRoLm1heChhLmZyb20sIHQpLCBNYXRoLm1pbihhLnRvLCBuKSwgMSA9PSBhLmxldmVsID8gXCJydGxcIiA6IFwibHRyXCIpLCBpID0gITApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSB8fCByKHQsIG4sIFwibHRyXCIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdG8oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5sZXZlbCAlIDIgPyBlLnRvIDogZS5mcm9tXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbm8oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5sZXZlbCAlIDIgPyBlLmZyb20gOiBlLnRvXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcm8oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGlpKGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCA/IHRvKHRbMF0pIDogMFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlvKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBpaShlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPyBubyhJaSh0KSkgOiBlLnRleHQubGVuZ3RoXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb28oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFpyKGUuZG9jLCB0KSwgciA9IHlyKG4pO1xuICAgICAgICAgICAgICAgICAgICByICE9IG4gJiYgKHQgPSB0aShyKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gaWkociksIG8gPSBpID8gaVswXS5sZXZlbCAlIDIgPyBpbyhyKSA6IHJvKHIpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJvKHQsIG8pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYW8oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuLCByID0gWnIoZS5kb2MsIHQpOyBuID0gZ3Iocik7KXIgPSBuLmZpbmQoMSwgITApLmxpbmUsIHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGlpKHIpLCBvID0gaSA/IGlbMF0ubGV2ZWwgJSAyID8gcm8ocikgOiBpbyhyKSA6IHIudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCbyhudWxsID09IHQgPyB0aShyKSA6IHQsIG8pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbG8oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG9vKGUsIHQubGluZSksIHIgPSBacihlLmRvYywgbi5saW5lKSwgaSA9IGlpKHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWkgfHwgMCA9PSBpWzBdLmxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IE1hdGgubWF4KDAsIHIudGV4dC5zZWFyY2goL1xcUy8pKSwgYSA9IHQubGluZSA9PSBuLmxpbmUgJiYgdC5jaCA8PSBvICYmIHQuY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQm8obi5saW5lLCBhID8gMCA6IG8pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzbyhlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZVswXS5sZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPT0gciA/ICEwIDogbiA9PSByID8gITEgOiBuID4gdFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuLCByID0gMDsgciA8IGUubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZVtyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpLmZyb20gPCB0ICYmIGkudG8gPiB0KXJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkuZnJvbSA9PSB0IHx8IGkudG8gPT0gdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IG4pcmV0dXJuIHNvKGUsIGkubGV2ZWwsIGVbbl0ubGV2ZWwpID8gKGkuZnJvbSAhPSBpLnRvICYmIChhbCA9IG4pLCByKSA6IChpLmZyb20gIT0gaS50byAmJiAoYWwgPSByKSwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVvKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyKXJldHVybiB0ICsgbjtcbiAgICAgICAgICAgICAgICAgICAgZG8gdCArPSBuOyB3aGlsZSAodCA+IDAgJiYgemkoZS50ZXh0LmNoYXJBdCh0KSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZvKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBpaShlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpKXJldHVybiBobyhlLCB0LCBuLCByKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbyA9IGNvKGksIHQpLCBhID0gaVtvXSwgbCA9IHVvKGUsIHQsIGEubGV2ZWwgJSAyID8gLW4gOiBuLCByKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwgPiBhLmZyb20gJiYgbCA8IGEudG8pcmV0dXJuIGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobCA9PSBhLmZyb20gfHwgbCA9PSBhLnRvKXJldHVybiBjbyhpLCBsKSA9PSBvID8gbCA6IChhID0gaVtvICs9IG5dLCBuID4gMCA9PSBhLmxldmVsICUgMiA/IGEudG8gOiBhLmZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPSBpW28gKz0gbl0sICFhKXJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IG4gPiAwID09IGEubGV2ZWwgJSAyID8gdW8oZSwgYS50bywgLTEsIHIpIDogdW8oZSwgYS5mcm9tLCAxLCByKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaG8oZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHQgKyBuO1xuICAgICAgICAgICAgICAgICAgICBpZiAocilmb3IgKDsgaSA+IDAgJiYgemkoZS50ZXh0LmNoYXJBdChpKSk7KWkgKz0gbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgPiBpIHx8IGkgPiBlLnRleHQubGVuZ3RoID8gbnVsbCA6IGlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcG8gPSBuYXZpZ2F0b3IudXNlckFnZW50LCBtbyA9IG5hdmlnYXRvci5wbGF0Zm9ybSwgZ28gPSAvZ2Vja29cXC9cXGQvaS50ZXN0KHBvKSxcbiAgICAgICAgICAgICAgICAgICAgdm8gPSAvTVNJRSBcXGQvLnRlc3QocG8pLCB5byA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhwbyksIHhvID0gdm8gfHwgeW8sXG4gICAgICAgICAgICAgICAgICAgIGJvID0geG8gJiYgKHZvID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IDYgOiB5b1sxXSksIHdvID0gL1dlYktpdFxcLy8udGVzdChwbyksXG4gICAgICAgICAgICAgICAgICAgIGtvID0gd28gJiYgL1F0XFwvXFxkK1xcLlxcZCsvLnRlc3QocG8pLCBTbyA9IC9DaHJvbWVcXC8vLnRlc3QocG8pLCBDbyA9IC9PcGVyYVxcLy8udGVzdChwbyksXG4gICAgICAgICAgICAgICAgICAgIExvID0gL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpLCBUbyA9IC9NYWMgT1MgWCAxXFxkXFxEKFs4LTldfFxcZFxcZClcXEQvLnRlc3QocG8pLFxuICAgICAgICAgICAgICAgICAgICBNbyA9IC9QaGFudG9tSlMvLnRlc3QocG8pLCBObyA9IC9BcHBsZVdlYktpdC8udGVzdChwbykgJiYgL01vYmlsZVxcL1xcdysvLnRlc3QocG8pLFxuICAgICAgICAgICAgICAgICAgICBBbyA9IE5vIHx8IC9BbmRyb2lkfHdlYk9TfEJsYWNrQmVycnl8T3BlcmEgTWluaXxPcGVyYSBNb2JpfElFTW9iaWxlL2kudGVzdChwbyksXG4gICAgICAgICAgICAgICAgICAgIEVvID0gTm8gfHwgL01hYy8udGVzdChtbyksIE9vID0gL1xcYkNyT1NcXGIvLnRlc3QocG8pLCBJbyA9IC93aW4vaS50ZXN0KG1vKSxcbiAgICAgICAgICAgICAgICAgICAgUG8gPSBDbyAmJiBwby5tYXRjaCgvVmVyc2lvblxcLyhcXGQqXFwuXFxkKikvKTtcbiAgICAgICAgICAgICAgICBQbyAmJiAoUG8gPSBOdW1iZXIoUG9bMV0pKSwgUG8gJiYgUG8gPj0gMTUgJiYgKENvID0gITEsIHdvID0gITApO1xuICAgICAgICAgICAgICAgIHZhciBSbyA9IEVvICYmIChrbyB8fCBDbyAmJiAobnVsbCA9PSBQbyB8fCAxMi4xMSA+IFBvKSksIERvID0gZ28gfHwgeG8gJiYgYm8gPj0gOSwgSG8gPSAhMSwgV28gPSAhMTtcbiAgICAgICAgICAgICAgICBtLnByb3RvdHlwZSA9IFdpKHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLnNjcm9sbFdpZHRoID4gZS5jbGllbnRXaWR0aCArIDEsIG4gPSBlLnNjcm9sbEhlaWdodCA+IGUuY2xpZW50SGVpZ2h0ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gZS5uYXRpdmVCYXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIHRoaXMudmVydC5zdHlsZS5ib3R0b20gPSB0ID8gciArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZS52aWV3SGVpZ2h0IC0gKHQgPyByIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgZS5zY3JvbGxIZWlnaHQgLSBlLmNsaWVudEhlaWdodCArIGkpICsgXCJweFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcIlwiLCB0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCB0aGlzLmhvcml6LnN0eWxlLnJpZ2h0ID0gbiA/IHIgKyBcInB4XCIgOiBcIjBcIiwgdGhpcy5ob3Jpei5zdHlsZS5sZWZ0ID0gZS5iYXJMZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZS52aWV3V2lkdGggLSBlLmJhckxlZnQgLSAobiA/IHIgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBlLnNjcm9sbFdpZHRoIC0gZS5jbGllbnRXaWR0aCArIG8gKyBcInB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmhvcml6LnN0eWxlLmRpc3BsYXkgPSBcIlwiLCB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5jaGVja2VkWmVyb1dpZHRoICYmIGUuY2xpZW50SGVpZ2h0ID4gMCAmJiAoMCA9PSByICYmIHRoaXMuemVyb1dpZHRoSGFjaygpLCB0aGlzLmNoZWNrZWRaZXJvV2lkdGggPSAhMCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogbiA/IHIgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogdCA/IHIgOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHNldFNjcm9sbExlZnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvcml6LnNjcm9sbExlZnQgIT0gZSAmJiAodGhpcy5ob3Jpei5zY3JvbGxMZWZ0ID0gZSksIHRoaXMuZGlzYWJsZUhvcml6ICYmIHRoaXMuZW5hYmxlWmVyb1dpZHRoQmFyKHRoaXMuaG9yaXosIHRoaXMuZGlzYWJsZUhvcml6KVxuICAgICAgICAgICAgICAgICAgICB9LCBzZXRTY3JvbGxUb3A6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZlcnQuc2Nyb2xsVG9wICE9IGUgJiYgKHRoaXMudmVydC5zY3JvbGxUb3AgPSBlKSwgdGhpcy5kaXNhYmxlVmVydCAmJiB0aGlzLmVuYWJsZVplcm9XaWR0aEJhcih0aGlzLnZlcnQsIHRoaXMuZGlzYWJsZVZlcnQpXG4gICAgICAgICAgICAgICAgICAgIH0sIHplcm9XaWR0aEhhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gRW8gJiYgIVRvID8gXCIxMnB4XCIgOiBcIjE4cHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaG9yaXouc3R5bGUuaGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLndpZHRoID0gZSwgdGhpcy5ob3Jpei5zdHlsZS5wb2ludGVyRXZlbnRzID0gdGhpcy52ZXJ0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIiwgdGhpcy5kaXNhYmxlSG9yaXogPSBuZXcgRWksIHRoaXMuZGlzYWJsZVZlcnQgPSBuZXcgRWlcbiAgICAgICAgICAgICAgICAgICAgfSwgZW5hYmxlWmVyb1dpZHRoQmFyOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGkgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHIubGVmdCArIDEsIHIuYm90dG9tIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSAhPSBlID8gZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIgOiB0LnNldCgxZTMsIG4pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiLCB0LnNldCgxZTMsIG4pXG4gICAgICAgICAgICAgICAgICAgIH0sIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuaG9yaXoucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlQ2hpbGQodGhpcy5ob3JpeiksIGUucmVtb3ZlQ2hpbGQodGhpcy52ZXJ0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgbS5wcm90b3R5cGUpLCBnLnByb3RvdHlwZSA9IFdpKHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2JvdHRvbTogMCwgcmlnaHQ6IDB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHNldFNjcm9sbExlZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgfSwgc2V0U2Nyb2xsVG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIH0sIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBnLnByb3RvdHlwZSksIGUuc2Nyb2xsYmFyTW9kZWwgPSB7XCJuYXRpdmVcIjogbSwgXCJudWxsXCI6IGd9LCBMLnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBOaShlLCB0KSAmJiB0aGlzLmV2ZW50cy5wdXNoKGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICB9LCBMLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5ldmVudHMubGVuZ3RoOyBlKyspUGEuYXBwbHkobnVsbCwgdGhpcy5ldmVudHNbZV0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgQm8gPSBlLlBvcyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgQm8gPyAodGhpcy5saW5lID0gZSwgdm9pZCh0aGlzLmNoID0gdCkpIDogbmV3IEJvKGUsIHQpXG4gICAgICAgICAgICAgICAgfSwgX28gPSBlLmNtcFBvcyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmxpbmUgLSB0LmxpbmUgfHwgZS5jaCAtIHQuY2hcbiAgICAgICAgICAgICAgICB9LCBGbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgbmUucHJvdG90eXBlID0gV2koe1xuICAgICAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFUaShyLCBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5zb21ldGhpbmdTZWxlY3RlZCgpKSBGbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaXNlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHIuZ2V0U2VsZWN0aW9ucygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG4uaW5hY2N1cmF0ZVNlbGVjdGlvbiAmJiAobi5wcmV2SW5wdXQgPSBcIlwiLCBuLmluYWNjdXJhdGVTZWxlY3Rpb24gPSAhMSwgby52YWx1ZSA9IEZvLnRleHQuam9pbihcIlxcblwiKSwgVWEobykpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghci5vcHRpb25zLmxpbmVXaXNlQ29weUN1dClyZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGVlKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpc2U6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHQudGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgXCJjdXRcIiA9PSBlLnR5cGUgPyByLnNldFNlbGVjdGlvbnModC5yYW5nZXMsIG51bGwsIFdhKSA6IChuLnByZXZJbnB1dCA9IFwiXCIsIG8udmFsdWUgPSB0LnRleHQuam9pbihcIlxcblwiKSwgVWEobykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjdXRcIiA9PSBlLnR5cGUgJiYgKHIuc3RhdGUuY3V0SW5jb21pbmcgPSAhMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcywgciA9IHRoaXMuY20sIGkgPSB0aGlzLndyYXBwZXIgPSByZSgpLCBvID0gdGhpcy50ZXh0YXJlYSA9IGkuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUud3JhcHBlci5pbnNlcnRCZWZvcmUoaSwgZS53cmFwcGVyLmZpcnN0Q2hpbGQpLCBObyAmJiAoby5zdHlsZS53aWR0aCA9IFwiMHB4XCIpLCBFYShvLCBcImlucHV0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4byAmJiBibyA+PSA5ICYmIG4uaGFzU2VsZWN0aW9uICYmIChuLmhhc1NlbGVjdGlvbiA9IG51bGwpLCBuLnBvbGwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIEVhKG8sIFwicGFzdGVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaShyLCBlKSB8fCBKKGUsIHIpIHx8IChyLnN0YXRlLnBhc3RlSW5jb21pbmcgPSAhMCwgbi5mYXN0UG9sbCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIEVhKG8sIFwiY3V0XCIsIHQpLCBFYShvLCBcImNvcHlcIiwgdCksIEVhKGUuc2Nyb2xsZXIsIFwicGFzdGVcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHdChlLCB0KSB8fCBUaShyLCB0KSB8fCAoci5zdGF0ZS5wYXN0ZUluY29taW5nID0gITAsIG4uZm9jdXMoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBFYShlLmxpbmVTcGFjZSwgXCJzZWxlY3RzdGFydFwiLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEd0KGUsIHQpIHx8IE1hKHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgRWEobywgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHIuZ2V0Q3Vyc29yKFwiZnJvbVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLmNvbXBvc2luZyAmJiBuLmNvbXBvc2luZy5yYW5nZS5jbGVhcigpLCBuLmNvbXBvc2luZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiByLm1hcmtUZXh0KGUsIHIuZ2V0Q3Vyc29yKFwidG9cIiksIHtjbGFzc05hbWU6IFwiQ29kZU1pcnJvci1jb21wb3NpbmdcIn0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIEVhKG8sIFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uY29tcG9zaW5nICYmIChuLnBvbGwoKSwgbi5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKSwgbi5jb21wb3NpbmcgPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSwgcHJlcGFyZVNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNtLCB0ID0gZS5kaXNwbGF5LCBuID0gZS5kb2MsIHIgPSBEZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLm9wdGlvbnMubW92ZUlucHV0V2l0aEN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZHQoZSwgbi5zZWwucHJpbWFyeSgpLmhlYWQsIFwiZGl2XCIpLCBvID0gdC53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gdC5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIudGVUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0LndyYXBwZXIuY2xpZW50SGVpZ2h0IC0gMTAsIGkudG9wICsgYS50b3AgLSBvLnRvcCkpLCByLnRlTGVmdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHQud3JhcHBlci5jbGllbnRXaWR0aCAtIDEwLCBpLmxlZnQgKyBhLmxlZnQgLSBvLmxlZnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJcbiAgICAgICAgICAgICAgICAgICAgfSwgc2hvd1NlbGVjdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5jbSwgbiA9IHQuZGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFpKG4uY3Vyc29yRGl2LCBlLmN1cnNvcnMpLCBxaShuLnNlbGVjdGlvbkRpdiwgZS5zZWxlY3Rpb24pLCBudWxsICE9IGUudGVUb3AgJiYgKHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSBlLnRlVG9wICsgXCJweFwiLCB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCA9IGUudGVMZWZ0ICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICB9LCByZXNldDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0TWVudVBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCwgbiwgciA9IHRoaXMuY20sIGkgPSByLmRvYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldklucHV0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBpLnNlbC5wcmltYXJ5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBybCAmJiAoby50bygpLmxpbmUgLSBvLmZyb20oKS5saW5lID4gMTAwIHx8IChuID0gci5nZXRTZWxlY3Rpb24oKSkubGVuZ3RoID4gMWUzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0ID8gXCItXCIgOiBuIHx8IHIuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dGFyZWEudmFsdWUgPSBhLCByLnN0YXRlLmZvY3VzZWQgJiYgVWEodGhpcy50ZXh0YXJlYSksIHhvICYmIGJvID49IDkgJiYgKHRoaXMuaGFzU2VsZWN0aW9uID0gYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZSB8fCAodGhpcy5wcmV2SW5wdXQgPSB0aGlzLnRleHRhcmVhLnZhbHVlID0gXCJcIiwgeG8gJiYgYm8gPj0gOSAmJiAodGhpcy5oYXNTZWxlY3Rpb24gPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmFjY3VyYXRlU2VsZWN0aW9uID0gdFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBnZXRGaWVsZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dGFyZWFcbiAgICAgICAgICAgICAgICAgICAgfSwgc3VwcG9ydHNUb3VjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExXG4gICAgICAgICAgICAgICAgICAgIH0sIGZvY3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJub2N1cnNvclwiICE9IHRoaXMuY20ub3B0aW9ucy5yZWFkT25seSAmJiAoIUFvIHx8IEdpKCkgIT0gdGhpcy50ZXh0YXJlYSkpdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRhcmVhLmZvY3VzKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgYmx1cjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0YXJlYS5ibHVyKClcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLnRvcCA9IHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVjZWl2ZWRGb2N1czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zbG93UG9sbCgpXG4gICAgICAgICAgICAgICAgICAgIH0sIHNsb3dQb2xsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnBvbGxpbmdGYXN0IHx8IGUucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucG9sbCgpLCBlLmNtLnN0YXRlLmZvY3VzZWQgJiYgZS5zbG93UG9sbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9LCBmYXN0UG9sbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG4ucG9sbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgfHwgdCA/IChuLnBvbGxpbmdGYXN0ID0gITEsIG4uc2xvd1BvbGwoKSkgOiAodCA9ICEwLCBuLnBvbGxpbmcuc2V0KDYwLCBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSAhMSwgbiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnBvbGxpbmdGYXN0ID0gITAsIG4ucG9sbGluZy5zZXQoMjAsIGUpXG4gICAgICAgICAgICAgICAgICAgIH0sIHBvbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5jbSwgdCA9IHRoaXMudGV4dGFyZWEsIG4gPSB0aGlzLnByZXZJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHRNZW51UGVuZGluZyB8fCAhZS5zdGF0ZS5mb2N1c2VkIHx8IG5sKHQpICYmICFuICYmICF0aGlzLmNvbXBvc2luZyB8fCBlLmlzUmVhZE9ubHkoKSB8fCBlLm9wdGlvbnMuZGlzYWJsZUlucHV0IHx8IGUuc3RhdGUua2V5U2VxKXJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID09IG4gJiYgIWUuc29tZXRoaW5nU2VsZWN0ZWQoKSlyZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeG8gJiYgYm8gPj0gOSAmJiB0aGlzLmhhc1NlbGVjdGlvbiA9PT0gciB8fCBFbyAmJiAvW1xcdWY3MDAtXFx1ZjdmZl0vLnRlc3QocikpcmV0dXJuIGUuZGlzcGxheS5pbnB1dC5yZXNldCgpLCAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRvYy5zZWwgPT0gZS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSByLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDgyMDMgIT0gaSB8fCBuIHx8IChuID0gXCLigItcIiksIDg2NjYgPT0gaSlyZXR1cm4gdGhpcy5yZXNldCgpLCB0aGlzLmNtLmV4ZWNDb21tYW5kKFwidW5kb1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbyA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gTWF0aC5taW4obi5sZW5ndGgsIHIubGVuZ3RoKTsgYSA+IG8gJiYgbi5jaGFyQ29kZUF0KG8pID09IHIuY2hhckNvZGVBdChvKTspKytvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEF0KGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBaKGUsIHIuc2xpY2UobyksIG4ubGVuZ3RoIC0gbywgbnVsbCwgbC5jb21wb3NpbmcgPyBcIipjb21wb3NlXCIgOiBudWxsKSwgci5sZW5ndGggPiAxZTMgfHwgci5pbmRleE9mKFwiXFxuXCIpID4gLTEgPyB0LnZhbHVlID0gbC5wcmV2SW5wdXQgPSBcIlwiIDogbC5wcmV2SW5wdXQgPSByLCBsLmNvbXBvc2luZyAmJiAobC5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKSwgbC5jb21wb3NpbmcucmFuZ2UgPSBlLm1hcmtUZXh0KGwuY29tcG9zaW5nLnN0YXJ0LCBlLmdldEN1cnNvcihcInRvXCIpLCB7Y2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItY29tcG9zaW5nXCJ9KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAhMFxuICAgICAgICAgICAgICAgICAgICB9LCBlbnN1cmVQb2xsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9sbGluZ0Zhc3QgJiYgdGhpcy5wb2xsKCkgJiYgKHRoaXMucG9sbGluZ0Zhc3QgPSAhMSlcbiAgICAgICAgICAgICAgICAgICAgfSwgb25LZXlQcmVzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeG8gJiYgYm8gPj0gOSAmJiAodGhpcy5oYXNTZWxlY3Rpb24gPSBudWxsKSwgdGhpcy5mYXN0UG9sbCgpXG4gICAgICAgICAgICAgICAgICAgIH0sIG9uQ29udGV4dE1lbnU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IGEuc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBpLnNvbWV0aGluZ1NlbGVjdGVkKCksIHQgPSBcIuKAi1wiICsgKGUgPyBhLnZhbHVlIDogXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEudmFsdWUgPSBcIuKHmlwiLCBhLnZhbHVlID0gdCwgci5wcmV2SW5wdXQgPSBlID8gXCJcIiA6IFwi4oCLXCIsIGEuc2VsZWN0aW9uU3RhcnQgPSAxLCBhLnNlbGVjdGlvbkVuZCA9IHQubGVuZ3RoLCBvLnNlbEZvckNvbnRleHRNZW51ID0gaS5kb2Muc2VsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmNvbnRleHRNZW51UGVuZGluZyA9ICExLCByLndyYXBwZXIuc3R5bGUuY3NzVGV4dCA9IGYsIGEuc3R5bGUuY3NzVGV4dCA9IHUsIHhvICYmIDkgPiBibyAmJiBvLnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKG8uc2Nyb2xsZXIuc2Nyb2xsVG9wID0gcyksIG51bGwgIT0gYS5zZWxlY3Rpb25TdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIXhvIHx8IHhvICYmIDkgPiBibykgJiYgdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IDAsIG4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLnNlbEZvckNvbnRleHRNZW51ID09IGkuZG9jLnNlbCAmJiAwID09IGEuc2VsZWN0aW9uU3RhcnQgJiYgYS5zZWxlY3Rpb25FbmQgPiAwICYmIFwi4oCLXCIgPT0gci5wcmV2SW5wdXQgPyBFdChpLCB1YS5zZWxlY3RBbGwpKGkpIDogZSsrIDwgMTAgPyBvLmRldGVjdGluZ1NlbGVjdEFsbCA9IHNldFRpbWVvdXQobiwgNTAwKSA6IG8uaW5wdXQucmVzZXQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLmRldGVjdGluZ1NlbGVjdEFsbCA9IHNldFRpbWVvdXQobiwgMjAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLCBpID0gci5jbSwgbyA9IGkuZGlzcGxheSwgYSA9IHIudGV4dGFyZWEsIGwgPSBZdChpLCBlKSwgcyA9IG8uc2Nyb2xsZXIuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwgJiYgIUNvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBpLm9wdGlvbnMucmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgJiYgLTEgPT0gaS5kb2Muc2VsLmNvbnRhaW5zKGwpICYmIEV0KGksIFRlKShpLmRvYywgZGUobCksIFdhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGEuc3R5bGUuY3NzVGV4dCwgZiA9IHIud3JhcHBlci5zdHlsZS5jc3NUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIud3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IHIud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAzMHB4OyBoZWlnaHQ6IDMwcHg7IHRvcDogXCIgKyAoZS5jbGllbnRZIC0gaC50b3AgLSA1KSArIFwicHg7IGxlZnQ6IFwiICsgKGUuY2xpZW50WCAtIGgubGVmdCAtIDUpICsgXCJweDsgei1pbmRleDogMTAwMDsgYmFja2dyb3VuZDogXCIgKyAoeG8gPyBcInJnYmEoMjU1LCAyNTUsIDI1NSwgLjA1KVwiIDogXCJ0cmFuc3BhcmVudFwiKSArIFwiOyBvdXRsaW5lOiBub25lOyBib3JkZXItd2lkdGg6IDA7IG91dGxpbmU6IG5vbmU7IG92ZXJmbG93OiBoaWRkZW47IG9wYWNpdHk6IC4wNTsgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTUpO1wiLCB3byl2YXIgZCA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmlucHV0LmZvY3VzKCksIHdvICYmIHdpbmRvdy5zY3JvbGxUbyhudWxsLCBkKSwgby5pbnB1dC5yZXNldCgpLCBpLnNvbWV0aGluZ1NlbGVjdGVkKCkgfHwgKGEudmFsdWUgPSByLnByZXZJbnB1dCA9IFwiIFwiKSwgci5jb250ZXh0TWVudVBlbmRpbmcgPSAhMCwgby5zZWxGb3JDb250ZXh0TWVudSA9IGkuZG9jLnNlbCwgY2xlYXJUaW1lb3V0KG8uZGV0ZWN0aW5nU2VsZWN0QWxsKSwgeG8gJiYgYm8gPj0gOSAmJiB0KCksIERvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFhKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElhKHdpbmRvdywgXCJtb3VzZXVwXCIsIHApLCBzZXRUaW1lb3V0KG4sIDIwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFYSh3aW5kb3csIFwibW91c2V1cFwiLCBwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBzZXRUaW1lb3V0KG4sIDUwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCByZWFkT25seUNoYW5nZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlIHx8IHRoaXMucmVzZXQoKVxuICAgICAgICAgICAgICAgICAgICB9LCBzZXRVbmVkaXRhYmxlOiBEaSwgbmVlZHNDb250ZW50QXR0cmlidXRlOiAhMVxuICAgICAgICAgICAgICAgIH0sIG5lLnByb3RvdHlwZSksIGllLnByb3RvdHlwZSA9IFdpKHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHQoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVGkociwgZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuc29tZXRoaW5nU2VsZWN0ZWQoKSkgRm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lzZTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiByLmdldFNlbGVjdGlvbnMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBcImN1dFwiID09IGUudHlwZSAmJiByLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIik7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KXJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZWUocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGbyA9IHtsaW5lV2lzZTogITAsIHRleHQ6IHQudGV4dH0sIFwiY3V0XCIgPT0gZS50eXBlICYmIHIub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnNldFNlbGVjdGlvbnModC5yYW5nZXMsIDAsIFdhKSwgci5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiY3V0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmNsaXBib2FyZERhdGEgJiYgIU5vKSBlLnByZXZlbnREZWZhdWx0KCksIGUuY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKSwgZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIEZvLnRleHQuam9pbihcIlxcblwiKSk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSByZSgpLCBpID0gbi5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUobiwgci5kaXNwbGF5LmxpbmVTcGFjZS5maXJzdENoaWxkKSwgaS52YWx1ZSA9IEZvLnRleHQuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVhKGkpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKG4pLCBvLmZvY3VzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMsIHIgPSBuLmNtLCBpID0gbi5kaXYgPSBlLmxpbmVEaXY7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZShpKSwgRWEoaSwgXCJwYXN0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRpKHIsIGUpIHx8IEooZSwgcilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBFYShpLCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5jb21wb3NpbmcgPSB7c2VsOiByLmRvYy5zZWwsIGRhdGE6IHQsIHN0YXJ0RGF0YTogdH0sIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSByLmRvYy5zZWwucHJpbWFyeSgpLCBvID0gci5nZXRMaW5lKGkuaGVhZC5saW5lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBvLmluZGV4T2YodCwgTWF0aC5tYXgoMCwgaS5oZWFkLmNoIC0gdC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA+IC0xICYmIGEgPD0gaS5oZWFkLmNoICYmIChuLmNvbXBvc2luZy5zZWwgPSBkZShCbyhpLmhlYWQubGluZSwgYSksIEJvKGkuaGVhZC5saW5lLCBhICsgdC5sZW5ndGgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgRWEoaSwgXCJjb21wb3NpdGlvbnVwZGF0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uY29tcG9zaW5nLmRhdGEgPSBlLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBFYShpLCBcImNvbXBvc2l0aW9uZW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuLmNvbXBvc2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICYmIChlLmRhdGEgPT0gdC5zdGFydERhdGEgfHwgL1xcdTIwMGIvLnRlc3QoZS5kYXRhKSB8fCAodC5kYXRhID0gZS5kYXRhKSwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuaGFuZGxlZCB8fCBuLmFwcGx5Q29tcG9zaXRpb24odCksIG4uY29tcG9zaW5nID09IHQgJiYgKG4uY29tcG9zaW5nID0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCA1MCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgRWEoaSwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLmZvcmNlQ29tcG9zaXRpb25FbmQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIEVhKGksIFwiaW5wdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uY29tcG9zaW5nIHx8ICFyLmlzUmVhZE9ubHkoKSAmJiBuLnBvbGxDb250ZW50KCkgfHwgQXQobi5jbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEdChyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgRWEoaSwgXCJjb3B5XCIsIHQpLCBFYShpLCBcImN1dFwiLCB0KVxuICAgICAgICAgICAgICAgICAgICB9LCBwcmVwYXJlU2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IERlKHRoaXMuY20sICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmZvY3VzID0gdGhpcy5jbS5zdGF0ZS5mb2N1c2VkLCBlXG4gICAgICAgICAgICAgICAgICAgIH0sIHNob3dTZWxlY3Rpb246IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlICYmIHRoaXMuY20uZGlzcGxheS52aWV3Lmxlbmd0aCAmJiAoKGUuZm9jdXMgfHwgdCkgJiYgdGhpcy5zaG93UHJpbWFyeVNlbGVjdGlvbigpLCB0aGlzLnNob3dNdWx0aXBsZVNlbGVjdGlvbnMoZSkpXG4gICAgICAgICAgICAgICAgICAgIH0sIHNob3dQcmltYXJ5U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgdCA9IHRoaXMuY20uZG9jLnNlbC5wcmltYXJ5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGxlKHRoaXMuY20sIGUuYW5jaG9yTm9kZSwgZS5hbmNob3JPZmZzZXQpLCByID0gbGUodGhpcy5jbSwgZS5mb2N1c05vZGUsIGUuZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuIHx8IG4uYmFkIHx8ICFyIHx8IHIuYmFkIHx8IDAgIT0gX28oSyhuLCByKSwgdC5mcm9tKCkpIHx8IDAgIT0gX28oVihuLCByKSwgdC50bygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gb2UodGhpcy5jbSwgdC5mcm9tKCkpLCBvID0gb2UodGhpcy5jbSwgdC50bygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSB8fCBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5jbS5kaXNwbGF5LnZpZXcsIGwgPSBlLnJhbmdlQ291bnQgJiYgZS5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBhW2EubGVuZ3RoIC0gMV0ubWVhc3VyZSwgYyA9IHMubWFwcyA/IHMubWFwc1tzLm1hcHMubGVuZ3RoIC0gMV0gOiBzLm1hcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0ge25vZGU6IGNbYy5sZW5ndGggLSAxXSwgb2Zmc2V0OiBjW2MubGVuZ3RoIC0gMl0gLSBjW2MubGVuZ3RoIC0gM119XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpID0ge25vZGU6IGFbMF0ubWVhc3VyZS5tYXBbMl0sIG9mZnNldDogMH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IHFhKGkubm9kZSwgaS5vZmZzZXQsIG8ub2Zmc2V0LCBvLm5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ICYmICghZ28gJiYgdGhpcy5jbS5zdGF0ZS5mb2N1c2VkID8gKGUuY29sbGFwc2UoaS5ub2RlLCBpLm9mZnNldCksIHUuY29sbGFwc2VkIHx8IGUuYWRkUmFuZ2UodSkpIDogKGUucmVtb3ZlQWxsUmFuZ2VzKCksIGUuYWRkUmFuZ2UodSkpLCBsICYmIG51bGwgPT0gZS5hbmNob3JOb2RlID8gZS5hZGRSYW5nZShsKSA6IGdvICYmIHRoaXMuc3RhcnRHcmFjZVBlcmlvZCgpKSwgdGhpcy5yZW1lbWJlclNlbGVjdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBzdGFydEdyYWNlUGVyaW9kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ncmFjZVBlcmlvZCksIHRoaXMuZ3JhY2VQZXJpb2QgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmdyYWNlUGVyaW9kID0gITEsIGUuc2VsZWN0aW9uQ2hhbmdlZCgpICYmIGUuY20ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjApXG4gICAgICAgICAgICAgICAgICAgIH0sIHNob3dNdWx0aXBsZVNlbGVjdGlvbnM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxaSh0aGlzLmNtLmRpc3BsYXkuY3Vyc29yRGl2LCBlLmN1cnNvcnMpLCBxaSh0aGlzLmNtLmRpc3BsYXkuc2VsZWN0aW9uRGl2LCBlLnNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVtZW1iZXJTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IGUuYW5jaG9yTm9kZSwgdGhpcy5sYXN0QW5jaG9yT2Zmc2V0ID0gZS5hbmNob3JPZmZzZXQsIHRoaXMubGFzdEZvY3VzTm9kZSA9IGUuZm9jdXNOb2RlLCB0aGlzLmxhc3RGb2N1c09mZnNldCA9IGUuZm9jdXNPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSwgc2VsZWN0aW9uSW5FZGl0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlLnJhbmdlQ291bnQpcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmEodGhpcy5kaXYsIHQpXG4gICAgICAgICAgICAgICAgICAgIH0sIGZvY3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vY3Vyc29yXCIgIT0gdGhpcy5jbS5vcHRpb25zLnJlYWRPbmx5ICYmIHRoaXMuZGl2LmZvY3VzKClcbiAgICAgICAgICAgICAgICAgICAgfSwgYmx1cjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXYuYmx1cigpXG4gICAgICAgICAgICAgICAgICAgIH0sIGdldEZpZWxkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXZcbiAgICAgICAgICAgICAgICAgICAgfSwgc3VwcG9ydHNUb3VjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlY2VpdmVkRm9jdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5jbS5zdGF0ZS5mb2N1c2VkICYmICh0LnBvbGxTZWxlY3Rpb24oKSwgdC5wb2xsaW5nLnNldCh0LmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25JbkVkaXRvcigpID8gdGhpcy5wb2xsU2VsZWN0aW9uKCkgOiBBdCh0aGlzLmNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gITBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCB0aGlzLnBvbGxpbmcuc2V0KHRoaXMuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIGUpXG4gICAgICAgICAgICAgICAgICAgIH0sIHNlbGVjdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuYW5jaG9yTm9kZSAhPSB0aGlzLmxhc3RBbmNob3JOb2RlIHx8IGUuYW5jaG9yT2Zmc2V0ICE9IHRoaXMubGFzdEFuY2hvck9mZnNldCB8fCBlLmZvY3VzTm9kZSAhPSB0aGlzLmxhc3RGb2N1c05vZGUgfHwgZS5mb2N1c09mZnNldCAhPSB0aGlzLmxhc3RGb2N1c09mZnNldFxuICAgICAgICAgICAgICAgICAgICB9LCBwb2xsU2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29tcG9zaW5nICYmICF0aGlzLmdyYWNlUGVyaW9kICYmIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHQgPSB0aGlzLmNtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGxlKHQsIGUuYW5jaG9yTm9kZSwgZS5hbmNob3JPZmZzZXQpLCByID0gbGUodCwgZS5mb2N1c05vZGUsIGUuZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gJiYgciAmJiBBdCh0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRlKHQuZG9jLCBkZShuLCByKSwgV2EpLCAobi5iYWQgfHwgci5iYWQpICYmICh0LmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSAhMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBwb2xsQ29udGVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNtLCB0ID0gZS5kaXNwbGF5LCBuID0gZS5kb2Muc2VsLnByaW1hcnkoKSwgciA9IG4uZnJvbSgpLCBpID0gbi50bygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIubGluZSA8IHQudmlld0Zyb20gfHwgaS5saW5lID4gdC52aWV3VG8gLSAxKXJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIubGluZSA9PSB0LnZpZXdGcm9tIHx8IDAgPT0gKG8gPSBCdChlLCByLmxpbmUpKSl2YXIgYSA9IHRpKHQudmlld1swXS5saW5lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gdC52aWV3WzBdLm5vZGU7IGVsc2UgdmFyIGEgPSB0aSh0LnZpZXdbb10ubGluZSksIGwgPSB0LnZpZXdbbyAtIDFdLm5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IEJ0KGUsIGkubGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PSB0LnZpZXcubGVuZ3RoIC0gMSl2YXIgYyA9IHQudmlld1RvIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gdC5saW5lRGl2Lmxhc3RDaGlsZDsgZWxzZSB2YXIgYyA9IHRpKHQudmlld1tzICsgMV0ubGluZSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB0LnZpZXdbcyArIDFdLm5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IGUuZG9jLnNwbGl0TGluZXMoY2UoZSwgbCwgdSwgYSwgYykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9IEpyKGUuZG9jLCBCbyhhLCAwKSwgQm8oYywgWnIoZS5kb2MsIGMpLnRleHQubGVuZ3RoKSk7IGYubGVuZ3RoID4gMSAmJiBoLmxlbmd0aCA+IDE7KWlmIChJaShmKSA9PSBJaShoKSkgZi5wb3AoKSwgaC5wb3AoKSwgYy0tOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZlswXSAhPSBoWzBdKWJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYuc2hpZnQoKSwgaC5zaGlmdCgpLCBhKytcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQgPSAwLCBwID0gMCwgbSA9IGZbMF0sIGcgPSBoWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IE1hdGgubWluKG0ubGVuZ3RoLCBnLmxlbmd0aCk7IHYgPiBkICYmIG0uY2hhckNvZGVBdChkKSA9PSBnLmNoYXJDb2RlQXQoZCk7KSsrZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSBJaShmKSwgeCA9IElpKGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IE1hdGgubWluKHkubGVuZ3RoIC0gKDEgPT0gZi5sZW5ndGggPyBkIDogMCksIHgubGVuZ3RoIC0gKDEgPT0gaC5sZW5ndGggPyBkIDogMCkpOyBiID4gcCAmJiB5LmNoYXJDb2RlQXQoeS5sZW5ndGggLSBwIC0gMSkgPT0geC5jaGFyQ29kZUF0KHgubGVuZ3RoIC0gcCAtIDEpOykrK3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBmW2YubGVuZ3RoIC0gMV0gPSB5LnNsaWNlKDAsIHkubGVuZ3RoIC0gcCksIGZbMF0gPSBmWzBdLnNsaWNlKGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBCbyhhLCBkKSwgayA9IEJvKGMsIGgubGVuZ3RoID8gSWkoaCkubGVuZ3RoIC0gcCA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYubGVuZ3RoID4gMSB8fCBmWzBdIHx8IF9vKHcsIGspID8gKEluKGUuZG9jLCBmLCB3LCBrLCBcIitpbnB1dFwiKSwgITApIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH0sIGVuc3VyZVBvbGxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZUNvbXBvc2l0aW9uRW5kKClcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpXG4gICAgICAgICAgICAgICAgICAgIH0sIGZvcmNlQ29tcG9zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nICYmICF0aGlzLmNvbXBvc2luZy5oYW5kbGVkICYmICh0aGlzLmFwcGx5Q29tcG9zaXRpb24odGhpcy5jb21wb3NpbmcpLCB0aGlzLmNvbXBvc2luZy5oYW5kbGVkID0gITAsIHRoaXMuZGl2LmJsdXIoKSwgdGhpcy5kaXYuZm9jdXMoKSlcbiAgICAgICAgICAgICAgICAgICAgfSwgYXBwbHlDb21wb3NpdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY20uaXNSZWFkT25seSgpID8gRXQodGhpcy5jbSwgRHQpKHRoaXMuY20pIDogZS5kYXRhICYmIGUuZGF0YSAhPSBlLnN0YXJ0RGF0YSAmJiBFdCh0aGlzLmNtLCBaKSh0aGlzLmNtLCBlLmRhdGEsIDAsIGUuc2VsKVxuICAgICAgICAgICAgICAgICAgICB9LCBzZXRVbmVkaXRhYmxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgfSwgb25LZXlQcmVzczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5jbS5pc1JlYWRPbmx5KCkgfHwgRXQodGhpcy5jbSwgWikodGhpcy5jbSwgU3RyaW5nLmZyb21DaGFyQ29kZShudWxsID09IGUuY2hhckNvZGUgPyBlLmtleUNvZGUgOiBlLmNoYXJDb2RlKSwgMClcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVhZE9ubHlDaGFuZ2VkOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXYuY29udGVudEVkaXRhYmxlID0gU3RyaW5nKFwibm9jdXJzb3JcIiAhPSBlKVxuICAgICAgICAgICAgICAgICAgICB9LCBvbkNvbnRleHRNZW51OiBEaSwgcmVzZXRQb3NpdGlvbjogRGksIG5lZWRzQ29udGVudEF0dHJpYnV0ZTogITBcbiAgICAgICAgICAgICAgICB9LCBpZS5wcm90b3R5cGUpLCBlLmlucHV0U3R5bGVzID0ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYTogbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZTogaWVcbiAgICAgICAgICAgICAgICB9LCB1ZS5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1t0aGlzLnByaW1JbmRleF1cbiAgICAgICAgICAgICAgICAgICAgfSwgZXF1YWxzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT0gdGhpcylyZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5wcmltSW5kZXggIT0gdGhpcy5wcmltSW5kZXggfHwgZS5yYW5nZXMubGVuZ3RoICE9IHRoaXMucmFuZ2VzLmxlbmd0aClyZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLnJhbmdlc1t0XSwgciA9IGUucmFuZ2VzW3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwICE9IF9vKG4uYW5jaG9yLCByLmFuY2hvcikgfHwgMCAhPSBfbyhuLmhlYWQsIHIuaGVhZCkpcmV0dXJuICExXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITBcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVlcENvcHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAwOyB0IDwgdGhpcy5yYW5nZXMubGVuZ3RoOyB0KyspZVt0XSA9IG5ldyBmZSgkKHRoaXMucmFuZ2VzW3RdLmFuY2hvciksICQodGhpcy5yYW5nZXNbdF0uaGVhZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB1ZShlLCB0aGlzLnByaW1JbmRleClcbiAgICAgICAgICAgICAgICAgICAgfSwgc29tZXRoaW5nU2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBlKyspaWYgKCF0aGlzLnJhbmdlc1tlXS5lbXB0eSgpKXJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMVxuICAgICAgICAgICAgICAgICAgICB9LCBjb250YWluczogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgfHwgKHQgPSBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMucmFuZ2VzW25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbyh0LCByLmZyb20oKSkgPj0gMCAmJiBfbyhlLCByLnRvKCkpIDw9IDApcmV0dXJuIG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZmUucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSyh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKVxuICAgICAgICAgICAgICAgICAgICB9LCB0bzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFYodGhpcy5hbmNob3IsIHRoaXMuaGVhZClcbiAgICAgICAgICAgICAgICAgICAgfSwgZW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWQubGluZSA9PSB0aGlzLmFuY2hvci5saW5lICYmIHRoaXMuaGVhZC5jaCA9PSB0aGlzLmFuY2hvci5jaFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgem8sIGpvLCBVbywgcW8gPSB7bGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwfSwgR28gPSBudWxsLCBZbyA9IDAsICRvID0gMCwgVm8gPSAwLFxuICAgICAgICAgICAgICAgICAgICBLbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgeG8gPyBLbyA9IC0uNTMgOiBnbyA/IEtvID0gMTUgOiBTbyA/IEtvID0gLS43IDogTG8gJiYgKEtvID0gLTEgLyAzKTtcbiAgICAgICAgICAgICAgICB2YXIgWG8gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUud2hlZWxEZWx0YVgsIG4gPSBlLndoZWVsRGVsdGFZO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCA9PSB0ICYmIGUuZGV0YWlsICYmIGUuYXhpcyA9PSBlLkhPUklaT05UQUxfQVhJUyAmJiAodCA9IGUuZGV0YWlsKSwgbnVsbCA9PSBuICYmIGUuZGV0YWlsICYmIGUuYXhpcyA9PSBlLlZFUlRJQ0FMX0FYSVMgPyBuID0gZS5kZXRhaWwgOiBudWxsID09IG4gJiYgKG4gPSBlLndoZWVsRGVsdGEpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBlLndoZWVsRXZlbnRQaXhlbHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IFhvKGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC54ICo9IEtvLCB0LnkgKj0gS28sIHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBabyA9IG5ldyBFaSwgSm8gPSBudWxsLCBRbyA9IGUuY2hhbmdlRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudGV4dCA/IEJvKGUuZnJvbS5saW5lICsgZS50ZXh0Lmxlbmd0aCAtIDEsIElpKGUudGV4dCkubGVuZ3RoICsgKDEgPT0gZS50ZXh0Lmxlbmd0aCA/IGUuZnJvbS5jaCA6IDApKSA6IGUudG9cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGUucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogZSxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5mb2N1cygpLCB0aGlzLmRpc3BsYXkuaW5wdXQuZm9jdXMoKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb246IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMub3B0aW9ucywgciA9IG5bZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBuW2VdID09IHQgJiYgXCJtb2RlXCIgIT0gZSB8fCAobltlXSA9IHQsIHRhLmhhc093blByb3BlcnR5KGUpICYmIEV0KHRoaXMsIHRhW2VdKSh0aGlzLCB0LCByKSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0T3B0aW9uOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tlXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXREb2M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvY1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhZGRLZXlNYXA6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmtleU1hcHNbdCA/IFwicHVzaFwiIDogXCJ1bnNoaWZ0XCJdKCRuKGUpKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVLZXlNYXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gdGhpcy5zdGF0ZS5rZXlNYXBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgKytuKWlmICh0W25dID09IGUgfHwgdFtuXS5uYW1lID09IGUpcmV0dXJuIHQuc3BsaWNlKG4sIDEpLCAhMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhZGRPdmVybGF5OiBPdChmdW5jdGlvbiAodCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0LnRva2VuID8gdCA6IGUuZ2V0TW9kZSh0aGlzLm9wdGlvbnMsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuc3RhcnRTdGF0ZSl0aHJvdyBuZXcgRXJyb3IoXCJPdmVybGF5cyBtYXkgbm90IGJlIHN0YXRlZnVsLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUub3ZlcmxheXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlU3BlYzogdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFxdWU6IG4gJiYgbi5vcGFxdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCB0aGlzLnN0YXRlLm1vZGVHZW4rKywgRHQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU92ZXJsYXk6IE90KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gdGhpcy5zdGF0ZS5vdmVybGF5cywgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgKytuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0W25dLm1vZGVTcGVjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID09IGUgfHwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiByLm5hbWUgPT0gZSlyZXR1cm4gdC5zcGxpY2UobiwgMSksIHRoaXMuc3RhdGUubW9kZUdlbisrLCB2b2lkIER0KHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRMaW5lOiBPdChmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPSB0eXBlb2YgdCAmJiBcIm51bWJlclwiICE9IHR5cGVvZiB0ICYmICh0ID0gbnVsbCA9PSB0ID8gdGhpcy5vcHRpb25zLnNtYXJ0SW5kZW50ID8gXCJzbWFydFwiIDogXCJwcmV2XCIgOiB0ID8gXCJhZGRcIiA6IFwic3VidHJhY3RcIiksIHZlKHRoaXMuZG9jLCBlKSAmJiBGbih0aGlzLCBlLCB0LCBuKVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50U2VsZWN0aW9uOiBPdChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IHRoaXMuZG9jLnNlbC5yYW5nZXMsIG4gPSAtMSwgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0W3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpLmVtcHR5KCkpIGkuaGVhZC5saW5lID4gbiAmJiAoRm4odGhpcywgaS5oZWFkLmxpbmUsIGUsICEwKSwgbiA9IGkuaGVhZC5saW5lLCByID09IHRoaXMuZG9jLnNlbC5wcmltSW5kZXggJiYgQm4odGhpcykpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBpLmZyb20oKSwgYSA9IGkudG8oKSwgbCA9IE1hdGgubWF4KG4sIG8ubGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBNYXRoLm1pbih0aGlzLmxhc3RMaW5lKCksIGEubGluZSAtIChhLmNoID8gMCA6IDEpKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSBsOyBuID4gczsgKytzKUZuKHRoaXMsIHMsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuZG9jLnNlbC5yYW5nZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgPT0gby5jaCAmJiB0Lmxlbmd0aCA9PSBjLmxlbmd0aCAmJiBjW3JdLmZyb20oKS5jaCA+IDAgJiYga2UodGhpcy5kb2MsIHIsIG5ldyBmZShvLCBjW3JdLnRvKCkpLCBXYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBnZXRUb2tlbkF0OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElyKHRoaXMsIGUsIHQpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldExpbmVUb2tlbnM6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSXIodGhpcywgQm8oZSksIHQsICEwKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRUb2tlblR5cGVBdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBtZSh0aGlzLmRvYywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCwgbiA9IERyKHRoaXMsIFpyKHRoaXMuZG9jLCBlLmxpbmUpKSwgciA9IDAsIGkgPSAobi5sZW5ndGggLSAxKSAvIDIsIG8gPSBlLmNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT0gbykgdCA9IG5bMl07IGVsc2UgZm9yICg7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHIgKyBpID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChhID8gblsyICogYSAtIDFdIDogMCkgPj0gbykgaSA9IGE7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShuWzIgKiBhICsgMV0gPCBvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG5bMiAqIGEgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IGEgKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSB0ID8gdC5pbmRleE9mKFwiY20tb3ZlcmxheSBcIikgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwID4gbCA/IHQgOiAwID09IGwgPyBudWxsIDogdC5zbGljZSgwLCBsIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0TW9kZUF0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmRvYy5tb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uaW5uZXJNb2RlID8gZS5pbm5lck1vZGUobiwgdGhpcy5nZXRUb2tlbkF0KHQpLnN0YXRlKS5tb2RlIDogblxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRIZWxwZXI6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWxwZXJzKGUsIHQpWzBdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldEhlbHBlcnM6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsYS5oYXNPd25Qcm9wZXJ0eSh0KSlyZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gbGFbdF0sIGkgPSB0aGlzLmdldE1vZGVBdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBpW3RdKSByW2lbdF1dICYmIG4ucHVzaChyW2lbdF1dKTsgZWxzZSBpZiAoaVt0XSlmb3IgKHZhciBvID0gMDsgbyA8IGlbdF0ubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHJbaVt0XVtvXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSAmJiBuLnB1c2goYSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpLmhlbHBlclR5cGUgJiYgcltpLmhlbHBlclR5cGVdID8gbi5wdXNoKHJbaS5oZWxwZXJUeXBlXSkgOiByW2kubmFtZV0gJiYgbi5wdXNoKHJbaS5uYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IHIuX2dsb2JhbC5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gci5fZ2xvYmFsW29dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwucHJlZChpLCB0aGlzKSAmJiAtMSA9PSBQaShuLCBsLnZhbCkgJiYgbi5wdXNoKGwudmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0U3RhdGVBZnRlcjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5kb2M7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA9IHBlKG4sIG51bGwgPT0gZSA/IG4uZmlyc3QgKyBuLnNpemUgLSAxIDogZSksIGplKHRoaXMsIGUgKyAxLCB0KVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjdXJzb3JDb29yZHM6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiwgciA9IHRoaXMuZG9jLnNlbC5wcmltYXJ5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiA9IG51bGwgPT0gZSA/IHIuaGVhZCA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgPyBtZSh0aGlzLmRvYywgZSkgOiBlID8gci5mcm9tKCkgOiByLnRvKCksIGR0KHRoaXMsIG4sIHQgfHwgXCJwYWdlXCIpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb29yZHM6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHQodGhpcywgbWUodGhpcy5kb2MsIGUpLCB0IHx8IFwicGFnZVwiKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb29yZHNDaGFyOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPSBmdCh0aGlzLCBlLCB0IHx8IFwicGFnZVwiKSwgZ3QodGhpcywgZS5sZWZ0LCBlLnRvcClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGluZUF0SGVpZ2h0OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPSBmdCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHQgfHwgXCJwYWdlXCIpLnRvcCwgbmkodGhpcy5kb2MsIGUgKyB0aGlzLmRpc3BsYXkudmlld09mZnNldClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0QXRMaW5lOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4sIHIgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmRvYy5maXJzdCArIHRoaXMuZG9jLnNpemUgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPCB0aGlzLmRvYy5maXJzdCA/IGUgPSB0aGlzLmRvYy5maXJzdCA6IGUgPiBpICYmIChlID0gaSwgciA9ICEwKSwgbiA9IFpyKHRoaXMuZG9jLCBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIG4gPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0KHRoaXMsIG4sIHt0b3A6IDAsIGxlZnQ6IDB9LCB0IHx8IFwicGFnZVwiKS50b3AgKyAociA/IHRoaXMuZG9jLmhlaWdodCAtIHJpKG4pIDogMClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFRleHRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5dCh0aGlzLmRpc3BsYXkpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDaGFyV2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4dCh0aGlzLmRpc3BsYXkpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldEd1dHRlck1hcmtlcjogT3QoZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB6bih0aGlzLmRvYywgZSwgXCJndXR0ZXJcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUuZ3V0dGVyTWFya2VycyB8fCAoZS5ndXR0ZXJNYXJrZXJzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByW3RdID0gbiwgIW4gJiYgRmkocikgJiYgKGUuZ3V0dGVyTWFya2VycyA9IG51bGwpLCAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyR3V0dGVyOiBPdChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLCBuID0gdC5kb2MsIHIgPSBuLmZpcnN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5pdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5ndXR0ZXJNYXJrZXJzICYmIG4uZ3V0dGVyTWFya2Vyc1tlXSAmJiAobi5ndXR0ZXJNYXJrZXJzW2VdID0gbnVsbCwgSHQodCwgciwgXCJndXR0ZXJcIiksIEZpKG4uZ3V0dGVyTWFya2VycykgJiYgKG4uZ3V0dGVyTWFya2VycyA9IG51bGwpKSwgKytyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbGluZUluZm86IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmUodGhpcy5kb2MsIGUpKXJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSA9IFpyKHRoaXMuZG9jLCBlKSwgIWUpcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PSB0KXJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGUudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBndXR0ZXJNYXJrZXJzOiBlLmd1dHRlck1hcmtlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENsYXNzOiBlLnRleHRDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ0NsYXNzOiBlLmJnQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcENsYXNzOiBlLndyYXBDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXRzOiBlLndpZGdldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Vmlld3BvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7ZnJvbTogdGhpcy5kaXNwbGF5LnZpZXdGcm9tLCB0bzogdGhpcy5kaXNwbGF5LnZpZXdUb31cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWRkV2lkZ2V0OiBmdW5jdGlvbiAoZSwgdCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gZHQodGhpcywgbWUodGhpcy5kb2MsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gZS5ib3R0b20sIGwgPSBlLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgdC5zZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIsIFwidHJ1ZVwiKSwgdGhpcy5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUodCksIG8uc2l6ZXIuYXBwZW5kQ2hpbGQodCksIFwib3ZlclwiID09IHIpIGEgPSBlLnRvcDsgZWxzZSBpZiAoXCJhYm92ZVwiID09IHIgfHwgXCJuZWFyXCIgPT0gcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gTWF0aC5tYXgoby53cmFwcGVyLmNsaWVudEhlaWdodCwgdGhpcy5kb2MuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IE1hdGgubWF4KG8uc2l6ZXIuY2xpZW50V2lkdGgsIG8ubGluZVNwYWNlLmNsaWVudFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJhYm92ZVwiID09IHIgfHwgZS5ib3R0b20gKyB0Lm9mZnNldEhlaWdodCA+IHMpICYmIGUudG9wID4gdC5vZmZzZXRIZWlnaHQgPyBhID0gZS50b3AgLSB0Lm9mZnNldEhlaWdodCA6IGUuYm90dG9tICsgdC5vZmZzZXRIZWlnaHQgPD0gcyAmJiAoYSA9IGUuYm90dG9tKSwgbCArIHQub2Zmc2V0V2lkdGggPiBjICYmIChsID0gYyAtIHQub2Zmc2V0V2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnN0eWxlLnRvcCA9IGEgKyBcInB4XCIsIHQuc3R5bGUubGVmdCA9IHQuc3R5bGUucmlnaHQgPSBcIlwiLCBcInJpZ2h0XCIgPT0gaSA/IChsID0gby5zaXplci5jbGllbnRXaWR0aCAtIHQub2Zmc2V0V2lkdGgsIHQuc3R5bGUucmlnaHQgPSBcIjBweFwiKSA6IChcImxlZnRcIiA9PSBpID8gbCA9IDAgOiBcIm1pZGRsZVwiID09IGkgJiYgKGwgPSAoby5zaXplci5jbGllbnRXaWR0aCAtIHQub2Zmc2V0V2lkdGgpIC8gMiksIHQuc3R5bGUubGVmdCA9IGwgKyBcInB4XCIpLCBuICYmIERuKHRoaXMsIGwsIGEsIGwgKyB0Lm9mZnNldFdpZHRoLCBhICsgdC5vZmZzZXRIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJPbktleURvd246IE90KGhuKSxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck9uS2V5UHJlc3M6IE90KG1uKSxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck9uS2V5VXA6IHBuLFxuICAgICAgICAgICAgICAgICAgICBleGVjQ29tbWFuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1YS5oYXNPd25Qcm9wZXJ0eShlKSA/IHVhW2VdLmNhbGwobnVsbCwgdGhpcykgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckVsZWN0cmljOiBPdChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUSh0aGlzLCBlKVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgZmluZFBvc0g6IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAwID4gdCAmJiAoaSA9IC0xLCB0ID0gLXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbyA9IDAsIGEgPSBtZSh0aGlzLmRvYywgZSk7IHQgPiBvICYmIChhID0gVW4odGhpcy5kb2MsIGEsIGksIG4sIHIpLCAhYS5oaXRTaWRlKTsgKytvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1vdmVIOiBPdChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5kaXNwbGF5LnNoaWZ0IHx8IG4uZG9jLmV4dGVuZCB8fCByLmVtcHR5KCkgPyBVbihuLmRvYywgci5oZWFkLCBlLCB0LCBuLm9wdGlvbnMucnRsTW92ZVZpc3VhbGx5KSA6IDAgPiBlID8gci5mcm9tKCkgOiByLnRvKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9hKVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlSDogT3QoZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5kb2Muc2VsLCByID0gdGhpcy5kb2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnNvbWV0aGluZ1NlbGVjdGVkKCkgPyByLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCIrZGVsZXRlXCIpIDogam4odGhpcywgZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IFVuKHIsIG4uaGVhZCwgZSwgdCwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwID4gZSA/IHtmcm9tOiBpLCB0bzogbi5oZWFkfSA6IHtmcm9tOiBuLmhlYWQsIHRvOiBpfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGZpbmRQb3NWOiBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAxLCBvID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIDAgPiB0ICYmIChpID0gLTEsIHQgPSAtdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMCwgbCA9IG1lKHRoaXMuZG9jLCBlKTsgdCA+IGE7ICsrYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gZHQodGhpcywgbCwgXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gbyA/IG8gPSBzLmxlZnQgOiBzLmxlZnQgPSBvLCBsID0gcW4odGhpcywgcywgaSwgbiksIGwuaGl0U2lkZSlicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbW92ZVY6IE90KGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMsIHIgPSB0aGlzLmRvYywgaSA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSAhbi5kaXNwbGF5LnNoaWZ0ICYmICFyLmV4dGVuZCAmJiByLnNlbC5zb21ldGhpbmdTZWxlY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvKXJldHVybiAwID4gZSA/IGEuZnJvbSgpIDogYS50bygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGR0KG4sIGEuaGVhZCwgXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT0gYS5nb2FsQ29sdW1uICYmIChsLmxlZnQgPSBhLmdvYWxDb2x1bW4pLCBpLnB1c2gobC5sZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBxbihuLCBsLCBlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicGFnZVwiID09IHQgJiYgYSA9PSByLnNlbC5wcmltYXJ5KCkgJiYgV24obiwgbnVsbCwgaHQobiwgcywgXCJkaXZcIikudG9wIC0gbC50b3ApLCBzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2EpLCBpLmxlbmd0aClmb3IgKHZhciBhID0gMDsgYSA8IHIuc2VsLnJhbmdlcy5sZW5ndGg7IGErKylyLnNlbC5yYW5nZXNbYV0uZ29hbENvbHVtbiA9IGlbYV1cbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGZpbmRXb3JkQXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuZG9jLCBuID0gWnIodCwgZS5saW5lKS50ZXh0LCByID0gZS5jaCwgaSA9IGUuY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gdGhpcy5nZXRIZWxwZXIoZSwgXCJ3b3JkQ2hhcnNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUueFJlbCA8IDAgfHwgaSA9PSBuLmxlbmd0aCkgJiYgciA/IC0tciA6ICsraTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gbi5jaGFyQXQociksIGwgPSBfaShhLCBvKSA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfaShlLCBvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiAvXFxzLy50ZXN0KGEpID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9cXHMvLnRlc3QoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEvXFxzLy50ZXN0KGUpICYmICFfaShlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07IHIgPiAwICYmIGwobi5jaGFyQXQociAtIDEpKTspLS1yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbi5sZW5ndGggJiYgbChuLmNoYXJBdChpKSk7KSsraVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBmZShCbyhlLmxpbmUsIHIpLCBCbyhlLmxpbmUsIGkpKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVPdmVyd3JpdGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9IGUgJiYgZSA9PSB0aGlzLnN0YXRlLm92ZXJ3cml0ZSB8fCAoKHRoaXMuc3RhdGUub3ZlcndyaXRlID0gIXRoaXMuc3RhdGUub3ZlcndyaXRlKSA/IEphKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsIFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcIikgOiBaYSh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LCBcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXCIpLCBQYSh0aGlzLCBcIm92ZXJ3cml0ZVRvZ2dsZVwiLCB0aGlzLCB0aGlzLnN0YXRlLm92ZXJ3cml0ZSkpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhhc0ZvY3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkgPT0gR2koKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpc1JlYWRPbmx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISghdGhpcy5vcHRpb25zLnJlYWRPbmx5ICYmICF0aGlzLmRvYy5jYW50RWRpdClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG86IE90KGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsID09IGUgJiYgbnVsbCA9PSB0IHx8IF9uKHRoaXMpLCBudWxsICE9IGUgJiYgKHRoaXMuY3VyT3Auc2Nyb2xsTGVmdCA9IGUpLCBudWxsICE9IHQgJiYgKHRoaXMuY3VyT3Auc2Nyb2xsVG9wID0gdClcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGdldFNjcm9sbEluZm86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5kaXNwbGF5LnNjcm9sbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBlLnNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBlLnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGUuc2Nyb2xsSGVpZ2h0IC0gWWUodGhpcykgLSB0aGlzLmRpc3BsYXkuYmFySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBlLnNjcm9sbFdpZHRoIC0gWWUodGhpcykgLSB0aGlzLmRpc3BsYXkuYmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBWZSh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRXaWR0aDogJGUodGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IE90KGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PSBlID8gKGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHRoaXMuZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBudWxsID09IHQgJiYgKHQgPSB0aGlzLm9wdGlvbnMuY3Vyc29yU2Nyb2xsTWFyZ2luKSkgOiBcIm51bWJlclwiID09IHR5cGVvZiBlID8gZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogQm8oZSwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IG51bGwgPT0gZS5mcm9tICYmIChlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBlLnRvIHx8IChlLnRvID0gZS5mcm9tKSwgZS5tYXJnaW4gPSB0IHx8IDAsIG51bGwgIT0gZS5mcm9tLmxpbmUpIF9uKHRoaXMpLCB0aGlzLmN1ck9wLnNjcm9sbFRvUG9zID0gZTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBIbih0aGlzLCBNYXRoLm1pbihlLmZyb20ubGVmdCwgZS50by5sZWZ0KSwgTWF0aC5taW4oZS5mcm9tLnRvcCwgZS50by50b3ApIC0gZS5tYXJnaW4sIE1hdGgubWF4KGUuZnJvbS5yaWdodCwgZS50by5yaWdodCksIE1hdGgubWF4KGUuZnJvbS5ib3R0b20sIGUudG8uYm90dG9tKSArIGUubWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvKG4uc2Nyb2xsTGVmdCwgbi5zY3JvbGxUb3ApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzZXRTaXplOiBPdChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCIgPT0gdHlwZW9mIGUgfHwgL15cXGQrJC8udGVzdChTdHJpbmcoZSkpID8gZSArIFwicHhcIiA6IGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPSBlICYmIChyLmRpc3BsYXkud3JhcHBlci5zdHlsZS53aWR0aCA9IG4oZSkpLCBudWxsICE9IHQgJiYgKHIuZGlzcGxheS53cmFwcGVyLnN0eWxlLmhlaWdodCA9IG4odCkpLCByLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIGF0KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSByLmRpc3BsYXkudmlld0Zyb207XG4gICAgICAgICAgICAgICAgICAgICAgICByLmRvYy5pdGVyKGksIHIuZGlzcGxheS52aWV3VG8sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUud2lkZ2V0cylmb3IgKHZhciB0ID0gMDsgdCA8IGUud2lkZ2V0cy5sZW5ndGg7IHQrKylpZiAoZS53aWRnZXRzW3RdLm5vSFNjcm9sbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIdChyLCBpLCBcIndpZGdldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgci5jdXJPcC5mb3JjZVVwZGF0ZSA9ICEwLCBQYShyLCBcInJlZnJlc2hcIiwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBdCh0aGlzLCBlKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoOiBPdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgRHQodGhpcyksIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSAhMCwgbHQodGhpcyksIHRoaXMuc2Nyb2xsVG8odGhpcy5kb2Muc2Nyb2xsTGVmdCwgdGhpcy5kb2Muc2Nyb2xsVG9wKSwgdSh0aGlzKSwgKG51bGwgPT0gZSB8fCBNYXRoLmFicyhlIC0geXQodGhpcy5kaXNwbGF5KSkgPiAuNSkgJiYgYSh0aGlzKSwgUGEodGhpcywgXCJyZWZyZXNoXCIsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzd2FwRG9jOiBPdChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmRvYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmNtID0gbnVsbCwgWHIodGhpcywgZSksIGx0KHRoaXMpLCB0aGlzLmRpc3BsYXkuaW5wdXQucmVzZXQoKSwgdGhpcy5zY3JvbGxUbyhlLnNjcm9sbExlZnQsIGUuc2Nyb2xsVG9wKSwgdGhpcy5jdXJPcC5mb3JjZVNjcm9sbCA9ICEwLCBDaSh0aGlzLCBcInN3YXBEb2NcIiwgdGhpcywgdCksIHRcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGdldElucHV0RmllbGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRXcmFwcGVyRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheS53cmFwcGVyXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldFNjcm9sbGVyRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheS5zY3JvbGxlclxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRHdXR0ZXJFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5Lmd1dHRlcnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIEFpKGUpO1xuICAgICAgICAgICAgICAgIHZhciBlYSA9IGUuZGVmYXVsdHMgPSB7fSwgdGEgPSBlLm9wdGlvbkhhbmRsZXJzID0ge30sIG5hID0gZS5Jbml0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQ29kZU1pcnJvci5Jbml0XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgR24oXCJ2YWx1ZVwiLCBcIlwiLCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBlLnNldFZhbHVlKHQpXG4gICAgICAgICAgICAgICAgfSwgITApLCBHbihcIm1vZGVcIiwgbnVsbCwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kb2MubW9kZU9wdGlvbiA9IHQsIG4oZSlcbiAgICAgICAgICAgICAgICB9LCAhMCksIEduKFwiaW5kZW50VW5pdFwiLCAyLCBuLCAhMCksIEduKFwiaW5kZW50V2l0aFRhYnNcIiwgITEpLCBHbihcInNtYXJ0SW5kZW50XCIsICEwKSwgR24oXCJ0YWJTaXplXCIsIDQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHIoZSksIGx0KGUpLCBEdChlKVxuICAgICAgICAgICAgICAgIH0sICEwKSwgR24oXCJsaW5lU2VwYXJhdG9yXCIsIG51bGwsIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRvYy5saW5lU2VwID0gdCwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBbXSwgciA9IGUuZG9jLmZpcnN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5kb2MuaXRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZS50ZXh0LmluZGV4T2YodCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PSBvKWJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbyArIHQubGVuZ3RoLCBuLnB1c2goQm8ociwgbykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIrK1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSlJbihlLmRvYywgdCwgbltpXSwgQm8obltpXS5saW5lLCBuW2ldLmNoICsgdC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksIEduKFwic3BlY2lhbENoYXJzXCIsIC9bXFx1MDAwMC1cXHUwMDFmXFx1MDA3ZlxcdTAwYWRcXHUyMDBiLVxcdTIwMGZcXHUyMDI4XFx1MjAyOVxcdWZlZmZdL2csIGZ1bmN0aW9uICh0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHQuc3RhdGUuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChuLnNvdXJjZSArIChuLnRlc3QoXCJcdFwiKSA/IFwiXCIgOiBcInxcdFwiKSwgXCJnXCIpLCByICE9IGUuSW5pdCAmJiB0LnJlZnJlc2goKVxuICAgICAgICAgICAgICAgIH0pLCBHbihcInNwZWNpYWxDaGFyUGxhY2Vob2xkZXJcIiwgX3IsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucmVmcmVzaCgpXG4gICAgICAgICAgICAgICAgfSwgITApLCBHbihcImVsZWN0cmljQ2hhcnNcIiwgITApLCBHbihcImlucHV0U3R5bGVcIiwgQW8gPyBcImNvbnRlbnRlZGl0YWJsZVwiIDogXCJ0ZXh0YXJlYVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0U3R5bGUgY2FuIG5vdCAoeWV0KSBiZSBjaGFuZ2VkIGluIGEgcnVubmluZyBlZGl0b3JcIilcbiAgICAgICAgICAgICAgICB9LCAhMCksIEduKFwicnRsTW92ZVZpc3VhbGx5XCIsICFJbyksIEduKFwid2hvbGVMaW5lVXBkYXRlQmVmb3JlXCIsICEwKSwgR24oXCJ0aGVtZVwiLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbChlKSwgcyhlKVxuICAgICAgICAgICAgICAgIH0sICEwKSwgR24oXCJrZXlNYXBcIiwgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uICh0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gJG4obiksIG8gPSByICE9IGUuSW5pdCAmJiAkbihyKTtcbiAgICAgICAgICAgICAgICAgICAgbyAmJiBvLmRldGFjaCAmJiBvLmRldGFjaCh0LCBpKSwgaS5hdHRhY2ggJiYgaS5hdHRhY2godCwgbyB8fCBudWxsKVxuICAgICAgICAgICAgICAgIH0pLCBHbihcImV4dHJhS2V5c1wiLCBudWxsKSwgR24oXCJsaW5lV3JhcHBpbmdcIiwgITEsIGksICEwKSwgR24oXCJndXR0ZXJzXCIsIFtdLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBkKGUub3B0aW9ucyksIHMoZSlcbiAgICAgICAgICAgICAgICB9LCAhMCksIEduKFwiZml4ZWRHdXR0ZXJcIiwgITAsIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGUuZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmxlZnQgPSB0ID8gQyhlLmRpc3BsYXkpICsgXCJweFwiIDogXCIwXCIsIGUucmVmcmVzaCgpXG4gICAgICAgICAgICAgICAgfSwgITApLCBHbihcImNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyXCIsICExLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB5KGUpXG4gICAgICAgICAgICAgICAgfSwgITApLCBHbihcInNjcm9sbGJhclN0eWxlXCIsIFwibmF0aXZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHYoZSksIHkoZSksIGUuZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChlLmRvYy5zY3JvbGxUb3ApLCBlLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KGUuZG9jLnNjcm9sbExlZnQpXG4gICAgICAgICAgICAgICAgfSwgITApLCBHbihcImxpbmVOdW1iZXJzXCIsICExLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBkKGUub3B0aW9ucyksIHMoZSlcbiAgICAgICAgICAgICAgICB9LCAhMCksIEduKFwiZmlyc3RMaW5lTnVtYmVyXCIsIDEsIHMsICEwKSwgR24oXCJsaW5lTnVtYmVyRm9ybWF0dGVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlXG4gICAgICAgICAgICAgICAgfSwgcywgITApLCBHbihcInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nXCIsICExLCBSZSwgITApLCBHbihcInJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVwiLCAhMCksIEduKFwibGluZVdpc2VDb3B5Q3V0XCIsICEwKSwgR24oXCJyZWFkT25seVwiLCAhMSwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgXCJub2N1cnNvclwiID09IHQgPyAoeW4oZSksIGUuZGlzcGxheS5pbnB1dC5ibHVyKCksIGUuZGlzcGxheS5kaXNhYmxlZCA9ICEwKSA6IGUuZGlzcGxheS5kaXNhYmxlZCA9ICExLCBlLmRpc3BsYXkuaW5wdXQucmVhZE9ubHlDaGFuZ2VkKHQpXG4gICAgICAgICAgICAgICAgfSksIEduKFwiZGlzYWJsZUlucHV0XCIsICExLCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB0IHx8IGUuZGlzcGxheS5pbnB1dC5yZXNldCgpXG4gICAgICAgICAgICAgICAgfSwgITApLCBHbihcImRyYWdEcm9wXCIsICEwLCBVdCksIEduKFwiYWxsb3dEcm9wRmlsZVR5cGVzXCIsIG51bGwpLCBHbihcImN1cnNvckJsaW5rUmF0ZVwiLCA1MzApLCBHbihcImN1cnNvclNjcm9sbE1hcmdpblwiLCAwKSwgR24oXCJjdXJzb3JIZWlnaHRcIiwgMSwgUmUsICEwKSwgR24oXCJzaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lXCIsICEwLCBSZSwgITApLCBHbihcIndvcmtUaW1lXCIsIDEwMCksIEduKFwid29ya0RlbGF5XCIsIDEwMCksIEduKFwiZmxhdHRlblNwYW5zXCIsICEwLCByLCAhMCksIEduKFwiYWRkTW9kZUNsYXNzXCIsICExLCByLCAhMCksIEduKFwicG9sbEludGVydmFsXCIsIDEwMCksIEduKFwidW5kb0RlcHRoXCIsIDIwMCwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kb2MuaGlzdG9yeS51bmRvRGVwdGggPSB0XG4gICAgICAgICAgICAgICAgfSksIEduKFwiaGlzdG9yeUV2ZW50RGVsYXlcIiwgMTI1MCksIEduKFwidmlld3BvcnRNYXJnaW5cIiwgMTAsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucmVmcmVzaCgpXG4gICAgICAgICAgICAgICAgfSwgITApLCBHbihcIm1heEhpZ2hsaWdodExlbmd0aFwiLCAxZTQsIHIsICEwKSwgR24oXCJtb3ZlSW5wdXRXaXRoQ3Vyc29yXCIsICEwLCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB0IHx8IGUuZGlzcGxheS5pbnB1dC5yZXNldFBvc2l0aW9uKClcbiAgICAgICAgICAgICAgICB9KSwgR24oXCJ0YWJpbmRleFwiLCBudWxsLCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBlLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKS50YWJJbmRleCA9IHQgfHwgXCJcIlxuICAgICAgICAgICAgICAgIH0pLCBHbihcImF1dG9mb2N1c1wiLCBudWxsKTtcbiAgICAgICAgICAgICAgICB2YXIgcmEgPSBlLm1vZGVzID0ge30sIGlhID0gZS5taW1lTW9kZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBlLmRlZmluZU1vZGUgPSBmdW5jdGlvbiAodCwgbikge1xuICAgICAgICAgICAgICAgICAgICBlLmRlZmF1bHRzLm1vZGUgfHwgXCJudWxsXCIgPT0gdCB8fCAoZS5kZWZhdWx0cy5tb2RlID0gdCksIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIChuLmRlcGVuZGVuY2llcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpLCByYVt0XSA9IG5cbiAgICAgICAgICAgICAgICB9LCBlLmRlZmluZU1JTUUgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpYVtlXSA9IHRcbiAgICAgICAgICAgICAgICB9LCBlLnJlc29sdmVNb2RlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgaWEuaGFzT3duUHJvcGVydHkodCkpIHQgPSBpYVt0XTsgZWxzZSBpZiAodCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB0Lm5hbWUgJiYgaWEuaGFzT3duUHJvcGVydHkodC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBpYVt0Lm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgbiAmJiAobiA9IHtuYW1lOiBufSksIHQgPSBIaShuLCB0KSwgdC5uYW1lID0gbi5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCAmJiAvXltcXHdcXC1dK1xcL1tcXHdcXC1dK1xcK3htbCQvLnRlc3QodCkpcmV0dXJuIGUucmVzb2x2ZU1vZGUoXCJhcHBsaWNhdGlvbi94bWxcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8ge25hbWU6IHR9IDogdCB8fCB7bmFtZTogXCJudWxsXCJ9XG4gICAgICAgICAgICAgICAgfSwgZS5nZXRNb2RlID0gZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLnJlc29sdmVNb2RlKG4pLCByID0gcmFbbi5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyKXJldHVybiBlLmdldE1vZGUodCwgXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHIodCwgbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYS5oYXNPd25Qcm9wZXJ0eShuLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG9hW24ubmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhIGluIG8pby5oYXNPd25Qcm9wZXJ0eShhKSAmJiAoaS5oYXNPd25Qcm9wZXJ0eShhKSAmJiAoaVtcIl9cIiArIGFdID0gaVthXSksIGlbYV0gPSBvW2FdKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpLm5hbWUgPSBuLm5hbWUsIG4uaGVscGVyVHlwZSAmJiAoaS5oZWxwZXJUeXBlID0gbi5oZWxwZXJUeXBlKSwgbi5tb2RlUHJvcHMpZm9yICh2YXIgYSBpbiBuLm1vZGVQcm9wcylpW2FdID0gbi5tb2RlUHJvcHNbYV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICAgICAgfSwgZS5kZWZpbmVNb2RlKFwibnVsbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnNraXBUb0VuZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgZS5kZWZpbmVNSU1FKFwidGV4dC9wbGFpblwiLCBcIm51bGxcIik7XG4gICAgICAgICAgICAgICAgdmFyIG9hID0gZS5tb2RlRXh0ZW5zaW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIGUuZXh0ZW5kTW9kZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gb2EuaGFzT3duUHJvcGVydHkoZSkgPyBvYVtlXSA6IG9hW2VdID0ge307XG4gICAgICAgICAgICAgICAgICAgIFdpKHQsIG4pXG4gICAgICAgICAgICAgICAgfSwgZS5kZWZpbmVFeHRlbnNpb24gPSBmdW5jdGlvbiAodCwgbikge1xuICAgICAgICAgICAgICAgICAgICBlLnByb3RvdHlwZVt0XSA9IG5cbiAgICAgICAgICAgICAgICB9LCBlLmRlZmluZURvY0V4dGVuc2lvbiA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIENhLnByb3RvdHlwZVtlXSA9IHRcbiAgICAgICAgICAgICAgICB9LCBlLmRlZmluZU9wdGlvbiA9IEduO1xuICAgICAgICAgICAgICAgIHZhciBhYSA9IFtdO1xuICAgICAgICAgICAgICAgIGUuZGVmaW5lSW5pdEhvb2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBhYS5wdXNoKGUpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgbGEgPSBlLmhlbHBlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICBlLnJlZ2lzdGVySGVscGVyID0gZnVuY3Rpb24gKHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGEuaGFzT3duUHJvcGVydHkodCkgfHwgKGxhW3RdID0gZVt0XSA9IHtfZ2xvYmFsOiBbXX0pLCBsYVt0XVtuXSA9IHJcbiAgICAgICAgICAgICAgICB9LCBlLnJlZ2lzdGVyR2xvYmFsSGVscGVyID0gZnVuY3Rpb24gKHQsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5yZWdpc3RlckhlbHBlcih0LCBuLCBpKSwgbGFbdF0uX2dsb2JhbC5wdXNoKHtwcmVkOiByLCB2YWw6IGl9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHNhID0gZS5jb3B5U3RhdGUgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodCA9PT0gITApcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNvcHlTdGF0ZSlyZXR1cm4gZS5jb3B5U3RhdGUodCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgaW4gdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0W3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSBpbnN0YW5jZW9mIEFycmF5ICYmIChpID0gaS5jb25jYXQoW10pKSwgbltyXSA9IGlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gblxuICAgICAgICAgICAgICAgIH0sIGNhID0gZS5zdGFydFN0YXRlID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RhcnRTdGF0ZSA/IGUuc3RhcnRTdGF0ZSh0LCBuKSA6ICEwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBlLmlubmVyTW9kZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBlLmlubmVyTW9kZTspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS5pbm5lck1vZGUodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW4gfHwgbi5tb2RlID09IGUpYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gbi5zdGF0ZSwgZSA9IG4ubW9kZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuIHx8IHttb2RlOiBlLCBzdGF0ZTogdH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciB1YSA9IGUuY29tbWFuZHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdEFsbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0U2VsZWN0aW9uKEJvKGUuZmlyc3RMaW5lKCksIDApLCBCbyhlLmxhc3RMaW5lKCkpLCBXYSlcbiAgICAgICAgICAgICAgICAgICAgfSwgc2luZ2xlU2VsZWN0aW9uOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXRTZWxlY3Rpb24oZS5nZXRDdXJzb3IoXCJhbmNob3JcIiksIGUuZ2V0Q3Vyc29yKFwiaGVhZFwiKSwgV2EpXG4gICAgICAgICAgICAgICAgICAgIH0sIGtpbGxMaW5lOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgam4oZSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5lbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gWnIoZS5kb2MsIHQuaGVhZC5saW5lKS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuaGVhZC5jaCA9PSBuICYmIHQuaGVhZC5saW5lIDwgZS5sYXN0TGluZSgpID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdC5oZWFkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IEJvKHQuaGVhZC5saW5lICsgMSwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHtmcm9tOiB0LmhlYWQsIHRvOiBCbyh0LmhlYWQubGluZSwgbil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7ZnJvbTogdC5mcm9tKCksIHRvOiB0LnRvKCl9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9LCBkZWxldGVMaW5lOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgam4oZSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2Zyb206IEJvKHQuZnJvbSgpLmxpbmUsIDApLCB0bzogbWUoZS5kb2MsIEJvKHQudG8oKS5saW5lICsgMSwgMCkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsTGluZUxlZnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqbihlLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7ZnJvbTogQm8oZS5mcm9tKCkubGluZSwgMCksIHRvOiBlLmZyb20oKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0sIGRlbFdyYXBwZWRMaW5lTGVmdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpuKGUsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmNoYXJDb29yZHModC5oZWFkLCBcImRpdlwiKS50b3AgKyA1LCByID0gZS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IG59LCBcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2Zyb206IHIsIHRvOiB0LmZyb20oKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0sIGRlbFdyYXBwZWRMaW5lUmlnaHQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqbihlLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS5jaGFyQ29vcmRzKHQuaGVhZCwgXCJkaXZcIikudG9wICsgNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IGUuY29vcmRzQ2hhcih7bGVmdDogZS5kaXNwbGF5LmxpbmVEaXYub2Zmc2V0V2lkdGggKyAxMDAsIHRvcDogbn0sIFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7ZnJvbTogdC5mcm9tKCksIHRvOiByfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSwgdW5kbzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUudW5kbygpXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlZG86IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnJlZG8oKVxuICAgICAgICAgICAgICAgICAgICB9LCB1bmRvU2VsZWN0aW9uOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS51bmRvU2VsZWN0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVkb1NlbGVjdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucmVkb1NlbGVjdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIH0sIGdvRG9jU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmV4dGVuZFNlbGVjdGlvbihCbyhlLmZpcnN0TGluZSgpLCAwKSlcbiAgICAgICAgICAgICAgICAgICAgfSwgZ29Eb2NFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmV4dGVuZFNlbGVjdGlvbihCbyhlLmxhc3RMaW5lKCkpKVxuICAgICAgICAgICAgICAgICAgICB9LCBnb0xpbmVTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9vKGUsIHQuaGVhZC5saW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge29yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAxfSlcbiAgICAgICAgICAgICAgICAgICAgfSwgZ29MaW5lU3RhcnRTbWFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvKGUsIHQuaGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtvcmlnaW46IFwiK21vdmVcIiwgYmlhczogMX0pXG4gICAgICAgICAgICAgICAgICAgIH0sIGdvTGluZUVuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFvKGUsIHQuaGVhZC5saW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge29yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAtMX0pXG4gICAgICAgICAgICAgICAgICAgIH0sIGdvTGluZVJpZ2h0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUuY2hhckNvb3Jkcyh0LmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuY29vcmRzQ2hhcih7bGVmdDogZS5kaXNwbGF5LmxpbmVEaXYub2Zmc2V0V2lkdGggKyAxMDAsIHRvcDogbn0sIFwiZGl2XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBfYSlcbiAgICAgICAgICAgICAgICAgICAgfSwgZ29MaW5lTGVmdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmNoYXJDb29yZHModC5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmNvb3Jkc0NoYXIoe2xlZnQ6IDAsIHRvcDogbn0sIFwiZGl2XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBfYSlcbiAgICAgICAgICAgICAgICAgICAgfSwgZ29MaW5lTGVmdFNtYXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUuY2hhckNvb3Jkcyh0LmhlYWQsIFwiZGl2XCIpLnRvcCArIDUsIHIgPSBlLmNvb3Jkc0NoYXIoe2xlZnQ6IDAsIHRvcDogbn0sIFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByLmNoIDwgZS5nZXRMaW5lKHIubGluZSkuc2VhcmNoKC9cXFMvKSA/IGxvKGUsIHQuaGVhZCkgOiByXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBfYSlcbiAgICAgICAgICAgICAgICAgICAgfSwgZ29MaW5lVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLm1vdmVWKC0xLCBcImxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgfSwgZ29MaW5lRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubW92ZVYoMSwgXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgIH0sIGdvUGFnZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5tb3ZlVigtMSwgXCJwYWdlXCIpXG4gICAgICAgICAgICAgICAgICAgIH0sIGdvUGFnZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLm1vdmVWKDEsIFwicGFnZVwiKVxuICAgICAgICAgICAgICAgICAgICB9LCBnb0NoYXJMZWZ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5tb3ZlSCgtMSwgXCJjaGFyXCIpXG4gICAgICAgICAgICAgICAgICAgIH0sIGdvQ2hhclJpZ2h0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5tb3ZlSCgxLCBcImNoYXJcIilcbiAgICAgICAgICAgICAgICAgICAgfSwgZ29Db2x1bW5MZWZ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5tb3ZlSCgtMSwgXCJjb2x1bW5cIilcbiAgICAgICAgICAgICAgICAgICAgfSwgZ29Db2x1bW5SaWdodDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubW92ZUgoMSwgXCJjb2x1bW5cIilcbiAgICAgICAgICAgICAgICAgICAgfSwgZ29Xb3JkTGVmdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubW92ZUgoLTEsIFwid29yZFwiKVxuICAgICAgICAgICAgICAgICAgICB9LCBnb0dyb3VwUmlnaHQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLm1vdmVIKDEsIFwiZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAgICAgfSwgZ29Hcm91cExlZnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLm1vdmVIKC0xLCBcImdyb3VwXCIpXG4gICAgICAgICAgICAgICAgICAgIH0sIGdvV29yZFJpZ2h0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5tb3ZlSCgxLCBcIndvcmRcIilcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsQ2hhckJlZm9yZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGVsZXRlSCgtMSwgXCJjaGFyXCIpXG4gICAgICAgICAgICAgICAgICAgIH0sIGRlbENoYXJBZnRlcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGVsZXRlSCgxLCBcImNoYXJcIilcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsV29yZEJlZm9yZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGVsZXRlSCgtMSwgXCJ3b3JkXCIpXG4gICAgICAgICAgICAgICAgICAgIH0sIGRlbFdvcmRBZnRlcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGVsZXRlSCgxLCBcIndvcmRcIilcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsR3JvdXBCZWZvcmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRlbGV0ZUgoLTEsIFwiZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsR3JvdXBBZnRlcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGVsZXRlSCgxLCBcImdyb3VwXCIpXG4gICAgICAgICAgICAgICAgICAgIH0sIGluZGVudEF1dG86IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmluZGVudFNlbGVjdGlvbihcInNtYXJ0XCIpXG4gICAgICAgICAgICAgICAgICAgIH0sIGluZGVudE1vcmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmluZGVudFNlbGVjdGlvbihcImFkZFwiKVxuICAgICAgICAgICAgICAgICAgICB9LCBpbmRlbnRMZXNzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5pbmRlbnRTZWxlY3Rpb24oXCJzdWJ0cmFjdFwiKVxuICAgICAgICAgICAgICAgICAgICB9LCBpbnNlcnRUYWI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnJlcGxhY2VTZWxlY3Rpb24oXCJcdFwiKVxuICAgICAgICAgICAgICAgICAgICB9LCBpbnNlcnRTb2Z0VGFiOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IFtdLCBuID0gZS5saXN0U2VsZWN0aW9ucygpLCByID0gZS5vcHRpb25zLnRhYlNpemUsIGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gbltpXS5mcm9tKCksIGEgPSBGYShlLmdldExpbmUoby5saW5lKSwgby5jaCwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5wdXNoKE9pKHIgLSBhICUgcikpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnJlcGxhY2VTZWxlY3Rpb25zKHQpXG4gICAgICAgICAgICAgICAgICAgIH0sIGRlZmF1bHRUYWI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNvbWV0aGluZ1NlbGVjdGVkKCkgPyBlLmluZGVudFNlbGVjdGlvbihcImFkZFwiKSA6IGUuZXhlY0NvbW1hbmQoXCJpbnNlcnRUYWJcIilcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJhbnNwb3NlQ2hhcnM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBdChlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IGUubGlzdFNlbGVjdGlvbnMoKSwgbiA9IFtdLCByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0W3JdLmhlYWQsIG8gPSBacihlLmRvYywgaS5saW5lKS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobylpZiAoaS5jaCA9PSBvLmxlbmd0aCAmJiAoaSA9IG5ldyBCbyhpLmxpbmUsIGkuY2ggLSAxKSksIGkuY2ggPiAwKSBpID0gbmV3IEJvKGkubGluZSwgaS5jaCArIDEpLCBlLnJlcGxhY2VSYW5nZShvLmNoYXJBdChpLmNoIC0gMSkgKyBvLmNoYXJBdChpLmNoIC0gMiksIEJvKGkubGluZSwgaS5jaCAtIDIpLCBpLCBcIit0cmFuc3Bvc2VcIik7IGVsc2UgaWYgKGkubGluZSA+IGUuZG9jLmZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFpyKGUuZG9jLCBpLmxpbmUgLSAxKS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSAmJiBlLnJlcGxhY2VSYW5nZShvLmNoYXJBdCgwKSArIGUuZG9jLmxpbmVTZXBhcmF0b3IoKSArIGEuY2hhckF0KGEubGVuZ3RoIC0gMSksIEJvKGkubGluZSAtIDEsIGEubGVuZ3RoIC0gMSksIEJvKGkubGluZSwgMSksIFwiK3RyYW5zcG9zZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4ucHVzaChuZXcgZmUoaSwgaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0U2VsZWN0aW9ucyhuKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSwgbmV3bGluZUFuZEluZGVudDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEF0KGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gZS5saXN0U2VsZWN0aW9ucygpLmxlbmd0aCwgbiA9IDA7IHQgPiBuOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlLmxpc3RTZWxlY3Rpb25zKClbbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucmVwbGFjZVJhbmdlKGUuZG9jLmxpbmVTZXBhcmF0b3IoKSwgci5hbmNob3IsIHIuaGVhZCwgXCIraW5wdXRcIiksIGUuaW5kZW50TGluZShyLmZyb20oKS5saW5lICsgMSwgbnVsbCwgITApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJuKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9LCBvcGVuTGluZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucmVwbGFjZVNlbGVjdGlvbihcIlxcblwiLCBcInN0YXJ0XCIpXG4gICAgICAgICAgICAgICAgICAgIH0sIHRvZ2dsZU92ZXJ3cml0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUudG9nZ2xlT3ZlcndyaXRlKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZhID0gZS5rZXlNYXAgPSB7fTtcbiAgICAgICAgICAgICAgICBmYS5iYXNpYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgTGVmdDogXCJnb0NoYXJMZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFJpZ2h0OiBcImdvQ2hhclJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFVwOiBcImdvTGluZVVwXCIsXG4gICAgICAgICAgICAgICAgICAgIERvd246IFwiZ29MaW5lRG93blwiLFxuICAgICAgICAgICAgICAgICAgICBFbmQ6IFwiZ29MaW5lRW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIEhvbWU6IFwiZ29MaW5lU3RhcnRTbWFydFwiLFxuICAgICAgICAgICAgICAgICAgICBQYWdlVXA6IFwiZ29QYWdlVXBcIixcbiAgICAgICAgICAgICAgICAgICAgUGFnZURvd246IFwiZ29QYWdlRG93blwiLFxuICAgICAgICAgICAgICAgICAgICBEZWxldGU6IFwiZGVsQ2hhckFmdGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIEJhY2tzcGFjZTogXCJkZWxDaGFyQmVmb3JlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiU2hpZnQtQmFja3NwYWNlXCI6IFwiZGVsQ2hhckJlZm9yZVwiLFxuICAgICAgICAgICAgICAgICAgICBUYWI6IFwiZGVmYXVsdFRhYlwiLFxuICAgICAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudEF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgRW50ZXI6IFwibmV3bGluZUFuZEluZGVudFwiLFxuICAgICAgICAgICAgICAgICAgICBJbnNlcnQ6IFwidG9nZ2xlT3ZlcndyaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIEVzYzogXCJzaW5nbGVTZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgIH0sIGZhLnBjRGVmYXVsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLUFcIjogXCJzZWxlY3RBbGxcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLURcIjogXCJkZWxldGVMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ3RybC1aXCI6IFwidW5kb1wiLFxuICAgICAgICAgICAgICAgICAgICBcIlNoaWZ0LUN0cmwtWlwiOiBcInJlZG9cIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLVlcIjogXCJyZWRvXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ3RybC1Ib21lXCI6IFwiZ29Eb2NTdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkN0cmwtRW5kXCI6IFwiZ29Eb2NFbmRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLVVwXCI6IFwiZ29MaW5lVXBcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLURvd25cIjogXCJnb0xpbmVEb3duXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ3RybC1MZWZ0XCI6IFwiZ29Hcm91cExlZnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLVJpZ2h0XCI6IFwiZ29Hcm91cFJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQWx0LUxlZnRcIjogXCJnb0xpbmVTdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkFsdC1SaWdodFwiOiBcImdvTGluZUVuZFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkN0cmwtQmFja3NwYWNlXCI6IFwiZGVsR3JvdXBCZWZvcmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLURlbGV0ZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLVNcIjogXCJzYXZlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ3RybC1GXCI6IFwiZmluZFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkN0cmwtR1wiOiBcImZpbmROZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiU2hpZnQtQ3RybC1HXCI6IFwiZmluZFByZXZcIixcbiAgICAgICAgICAgICAgICAgICAgXCJTaGlmdC1DdHJsLUZcIjogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiU2hpZnQtQ3RybC1SXCI6IFwicmVwbGFjZUFsbFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkN0cmwtW1wiOiBcImluZGVudExlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLV1cIjogXCJpbmRlbnRNb3JlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ3RybC1VXCI6IFwidW5kb1NlbGVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcIlNoaWZ0LUN0cmwtVVwiOiBcInJlZG9TZWxlY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJBbHQtVVwiOiBcInJlZG9TZWxlY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgZmFsbHRocm91Z2g6IFwiYmFzaWNcIlxuICAgICAgICAgICAgICAgIH0sIGZhLmVtYWNzeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLUZcIjogXCJnb0NoYXJSaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkN0cmwtQlwiOiBcImdvQ2hhckxlZnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLVBcIjogXCJnb0xpbmVVcFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkN0cmwtTlwiOiBcImdvTGluZURvd25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJBbHQtRlwiOiBcImdvV29yZFJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQWx0LUJcIjogXCJnb1dvcmRMZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ3RybC1BXCI6IFwiZ29MaW5lU3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLUVcIjogXCJnb0xpbmVFbmRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLVZcIjogXCJnb1BhZ2VEb3duXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiU2hpZnQtQ3RybC1WXCI6IFwiZ29QYWdlVXBcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLURcIjogXCJkZWxDaGFyQWZ0ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLUhcIjogXCJkZWxDaGFyQmVmb3JlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQWx0LURcIjogXCJkZWxXb3JkQWZ0ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJBbHQtQmFja3NwYWNlXCI6IFwiZGVsV29yZEJlZm9yZVwiLFxuICAgICAgICAgICAgICAgICAgICBcIkN0cmwtS1wiOiBcImtpbGxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ3RybC1UXCI6IFwidHJhbnNwb3NlQ2hhcnNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDdHJsLU9cIjogXCJvcGVuTGluZVwiXG4gICAgICAgICAgICAgICAgfSwgZmEubWFjRGVmYXVsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDbWQtQVwiOiBcInNlbGVjdEFsbFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNtZC1EXCI6IFwiZGVsZXRlTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNtZC1aXCI6IFwidW5kb1wiLFxuICAgICAgICAgICAgICAgICAgICBcIlNoaWZ0LUNtZC1aXCI6IFwicmVkb1wiLFxuICAgICAgICAgICAgICAgICAgICBcIkNtZC1ZXCI6IFwicmVkb1wiLFxuICAgICAgICAgICAgICAgICAgICBcIkNtZC1Ib21lXCI6IFwiZ29Eb2NTdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNtZC1VcFwiOiBcImdvRG9jU3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDbWQtRW5kXCI6IFwiZ29Eb2NFbmRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDbWQtRG93blwiOiBcImdvRG9jRW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQWx0LUxlZnRcIjogXCJnb0dyb3VwTGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkFsdC1SaWdodFwiOiBcImdvR3JvdXBSaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNtZC1MZWZ0XCI6IFwiZ29MaW5lTGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNtZC1SaWdodFwiOiBcImdvTGluZVJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQWx0LUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQmVmb3JlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6IFwiZGVsR3JvdXBBZnRlclwiLFxuICAgICAgICAgICAgICAgICAgICBcIkFsdC1EZWxldGVcIjogXCJkZWxHcm91cEFmdGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ21kLVNcIjogXCJzYXZlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ21kLUZcIjogXCJmaW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ21kLUdcIjogXCJmaW5kTmV4dFwiLFxuICAgICAgICAgICAgICAgICAgICBcIlNoaWZ0LUNtZC1HXCI6IFwiZmluZFByZXZcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDbWQtQWx0LUZcIjogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiU2hpZnQtQ21kLUFsdC1GXCI6IFwicmVwbGFjZUFsbFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNtZC1bXCI6IFwiaW5kZW50TGVzc1wiLFxuICAgICAgICAgICAgICAgICAgICBcIkNtZC1dXCI6IFwiaW5kZW50TW9yZVwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNtZC1CYWNrc3BhY2VcIjogXCJkZWxXcmFwcGVkTGluZUxlZnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDbWQtRGVsZXRlXCI6IFwiZGVsV3JhcHBlZExpbmVSaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNtZC1VXCI6IFwidW5kb1NlbGVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcIlNoaWZ0LUNtZC1VXCI6IFwicmVkb1NlbGVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcIkN0cmwtVXBcIjogXCJnb0RvY1N0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ3RybC1Eb3duXCI6IFwiZ29Eb2NFbmRcIixcbiAgICAgICAgICAgICAgICAgICAgZmFsbHRocm91Z2g6IFtcImJhc2ljXCIsIFwiZW1hY3N5XCJdXG4gICAgICAgICAgICAgICAgfSwgZmFbXCJkZWZhdWx0XCJdID0gRW8gPyBmYS5tYWNEZWZhdWx0IDogZmEucGNEZWZhdWx0LCBlLm5vcm1hbGl6ZUtleU1hcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gaW4gZSlpZiAoZS5oYXNPd25Qcm9wZXJ0eShuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlW25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9eKG5hbWV8ZmFsbHRocm91Z2h8KGRlfGF0KXRhY2gpJC8udGVzdChuKSljb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIi4uLlwiID09IHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZVtuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IFJpKG4uc3BsaXQoXCIgXCIpLCBZbiksIG8gPSAwOyBvIDwgaS5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhLCBsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPT0gaS5sZW5ndGggLSAxID8gKGwgPSBpLmpvaW4oXCIgXCIpLCBhID0gcikgOiAobCA9IGkuc2xpY2UoMCwgbyArIDEpLmpvaW4oXCIgXCIpLCBhID0gXCIuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0W2xdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzICE9IGEpdGhyb3cgbmV3IEVycm9yKFwiSW5jb25zaXN0ZW50IGJpbmRpbmdzIGZvciBcIiArIGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHRbbF0gPSBhXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZVtuXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgaW4gdCllW2NdID0gdFtjXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBoYSA9IGUubG9va3VwS2V5ID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9ICRuKHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHQuY2FsbCA/IHQuY2FsbChlLCByKSA6IHRbZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAhMSlyZXR1cm4gXCJub3RoaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIi4uLlwiID09PSBpKXJldHVybiBcIm11bHRpXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IGkgJiYgbihpKSlyZXR1cm4gXCJoYW5kbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmZhbGx0aHJvdWdoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJbb2JqZWN0IEFycmF5XVwiICE9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LmZhbGx0aHJvdWdoKSlyZXR1cm4gaGEoZSwgdC5mYWxsdGhyb3VnaCwgbiwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IHQuZmFsbHRocm91Z2gubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGhhKGUsIHQuZmFsbHRocm91Z2hbb10sIG4sIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhKXJldHVybiBhXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBkYSA9IGUuaXNNb2RpZmllcktleSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IGUgOiBvbFtlLmtleUNvZGVdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJDdHJsXCIgPT0gdCB8fCBcIkFsdFwiID09IHQgfHwgXCJTaGlmdFwiID09IHQgfHwgXCJNb2RcIiA9PSB0XG4gICAgICAgICAgICAgICAgfSwgcGEgPSBlLmtleU5hbWUgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ28gJiYgMzQgPT0gZS5rZXlDb2RlICYmIGVbXCJjaGFyXCJdKXJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBvbFtlLmtleUNvZGVdLCByID0gbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gciB8fCBlLmFsdEdyYXBoS2V5ID8gITEgOiAoZS5hbHRLZXkgJiYgXCJBbHRcIiAhPSBuICYmIChyID0gXCJBbHQtXCIgKyByKSwgKFJvID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSAmJiBcIkN0cmxcIiAhPSBuICYmIChyID0gXCJDdHJsLVwiICsgciksIChSbyA/IGUuY3RybEtleSA6IGUubWV0YUtleSkgJiYgXCJDbWRcIiAhPSBuICYmIChyID0gXCJDbWQtXCIgKyByKSwgIXQgJiYgZS5zaGlmdEtleSAmJiBcIlNoaWZ0XCIgIT0gbiAmJiAociA9IFwiU2hpZnQtXCIgKyByKSwgcilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGUuZnJvbVRleHRBcmVhID0gZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQudmFsdWUgPSBjLmdldFZhbHVlKClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuID0gbiA/IFdpKG4pIDoge30sIG4udmFsdWUgPSB0LnZhbHVlLCAhbi50YWJpbmRleCAmJiB0LnRhYkluZGV4ICYmIChuLnRhYmluZGV4ID0gdC50YWJJbmRleCksICFuLnBsYWNlaG9sZGVyICYmIHQucGxhY2Vob2xkZXIgJiYgKG4ucGxhY2Vob2xkZXIgPSB0LnBsYWNlaG9sZGVyKSwgbnVsbCA9PSBuLmF1dG9mb2N1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBHaSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5hdXRvZm9jdXMgPSBpID09IHQgfHwgbnVsbCAhPSB0LmdldEF0dHJpYnV0ZShcImF1dG9mb2N1c1wiKSAmJiBpID09IGRvY3VtZW50LmJvZHlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodC5mb3JtICYmIChFYSh0LmZvcm0sIFwic3VibWl0XCIsIHIpLCAhbi5sZWF2ZVN1Ym1pdE1ldGhvZEFsb25lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0LmZvcm0sIGEgPSBvLnN1Ym1pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBvLnN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcigpLCBvLnN1Ym1pdCA9IGEsIG8uc3VibWl0KCksIG8uc3VibWl0ID0gbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuLmZpbmlzaEluaXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zYXZlID0gciwgZS5nZXRUZXh0QXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZS50b1RleHRBcmVhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUudG9UZXh0QXJlYSA9IGlzTmFOLCByKCksIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlLmdldFdyYXBwZXJFbGVtZW50KCkpLCB0LnN0eWxlLmRpc3BsYXkgPSBcIlwiLCB0LmZvcm0gJiYgKElhKHQuZm9ybSwgXCJzdWJtaXRcIiwgciksIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdC5mb3JtLnN1Ym1pdCAmJiAodC5mb3JtLnN1Ym1pdCA9IGEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBlKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsIHQubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgIH0sIG4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIG1hID0gZS5TdHJpbmdTdHJlYW0gPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSAwLCB0aGlzLnN0cmluZyA9IGUsIHRoaXMudGFiU2l6ZSA9IHQgfHwgOCwgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSAwLCB0aGlzLmxpbmVTdGFydCA9IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1hLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZW9sOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5zdHJpbmcubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH0sIHNvbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zID09IHRoaXMubGluZVN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIH0sIHBlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICB9LCBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3MgPCB0aGlzLnN0cmluZy5sZW5ndGggPyB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MrKykgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgfSwgZWF0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpdmFyIG4gPSB0ID09IGU7IGVsc2UgdmFyIG4gPSB0ICYmIChlLnRlc3QgPyBlLnRlc3QodCkgOiBlKHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuID8gKCsrdGhpcy5wb3MsIHQpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH0sIGVhdFdoaWxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IHRoaXMucG9zOyB0aGlzLmVhdChlKTspO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gdFxuICAgICAgICAgICAgICAgICAgICB9LCBlYXRTcGFjZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMucG9zOyAvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpOykrK3RoaXMucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gZVxuICAgICAgICAgICAgICAgICAgICB9LCBza2lwVG9FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH0sIHNraXBUbzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5zdHJpbmcuaW5kZXhPZihlLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCA+IC0xID8gKHRoaXMucG9zID0gdCwgITApIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH0sIGJhY2tVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zIC09IGVcbiAgICAgICAgICAgICAgICAgICAgfSwgY29sdW1uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCAmJiAodGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBGYSh0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKSwgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5zdGFydCksIHRoaXMubGFzdENvbHVtblZhbHVlIC0gKHRoaXMubGluZVN0YXJ0ID8gRmEodGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMClcbiAgICAgICAgICAgICAgICAgICAgfSwgaW5kZW50YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBGYSh0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKSAtICh0aGlzLmxpbmVTdGFydCA/IEZhKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApXG4gICAgICAgICAgICAgICAgICAgIH0sIG1hdGNoOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gciAmJiByLmluZGV4ID4gMCA/IG51bGwgOiAociAmJiB0ICE9PSAhMSAmJiAodGhpcy5wb3MgKz0gclswXS5sZW5ndGgpLCByKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuID8gZS50b0xvd2VyQ2FzZSgpIDogZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgbyA9IHRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcywgZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkobykgPT0gaShlKSA/ICh0ICE9PSAhMSAmJiAodGhpcy5wb3MgKz0gZS5sZW5ndGgpLCAhMCkgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgfSwgY3VycmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKVxuICAgICAgICAgICAgICAgICAgICB9LCBoaWRlRmlyc3RDaGFyczogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ICs9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgLT0gZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZ2EgPSAwLCB2YSA9IGUuVGV4dE1hcmtlciA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZXMgPSBbXSwgdGhpcy50eXBlID0gdCwgdGhpcy5kb2MgPSBlLCB0aGlzLmlkID0gKytnYVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQWkodmEpLCB2YS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmRvYy5jbSwgdCA9IGUgJiYgIWUuY3VyT3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBidChlKSwgTmkodGhpcywgXCJjbGVhclwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5maW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiAmJiBDaSh0aGlzLCBcImNsZWFyXCIsIG4uZnJvbSwgbi50bylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSBudWxsLCBpID0gbnVsbCwgbyA9IDA7IG8gPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmxpbmVzW29dLCBsID0gZXIoYS5tYXJrZWRTcGFucywgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSAmJiAhdGhpcy5jb2xsYXBzZWQgPyBIdChlLCB0aShhKSwgXCJ0ZXh0XCIpIDogZSAmJiAobnVsbCAhPSBsLnRvICYmIChpID0gdGkoYSkpLCBudWxsICE9IGwuZnJvbSAmJiAociA9IHRpKGEpKSksIGEubWFya2VkU3BhbnMgPSB0cihhLm1hcmtlZFNwYW5zLCBsKSwgbnVsbCA9PSBsLmZyb20gJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWtyKHRoaXMuZG9jLCBhKSAmJiBlICYmIGVpKGEsIHl0KGUuZGlzcGxheSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhZS5vcHRpb25zLmxpbmVXcmFwcGluZylmb3IgKHZhciBvID0gMDsgbyA8IHRoaXMubGluZXMubGVuZ3RoOyArK28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHlyKHRoaXMubGluZXNbb10pLCBjID0gZihzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID4gZS5kaXNwbGF5Lm1heExpbmVMZW5ndGggJiYgKGUuZGlzcGxheS5tYXhMaW5lID0gcywgZS5kaXNwbGF5Lm1heExpbmVMZW5ndGggPSBjLCBlLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSAhMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT0gciAmJiBlICYmIHRoaXMuY29sbGFwc2VkICYmIER0KGUsIHIsIGkgKyAxKSwgdGhpcy5saW5lcy5sZW5ndGggPSAwLCB0aGlzLmV4cGxpY2l0bHlDbGVhcmVkID0gITAsIHRoaXMuYXRvbWljICYmIHRoaXMuZG9jLmNhbnRFZGl0ICYmICh0aGlzLmRvYy5jYW50RWRpdCA9ICExLCBlICYmIEFlKGUuZG9jKSksIGUgJiYgQ2koZSwgXCJtYXJrZXJDbGVhcmVkXCIsIGUsIHRoaXMpLCB0ICYmIGt0KGUpLCB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5jbGVhcigpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB2YS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT0gZSAmJiBcImJvb2ttYXJrXCIgPT0gdGhpcy50eXBlICYmIChlID0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4sIHIsIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLmxpbmVzW2ldLCBhID0gZXIoby5tYXJrZWRTcGFucywgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBhLmZyb20gJiYgKG4gPSBCbyh0ID8gbyA6IHRpKG8pLCBhLmZyb20pLCAtMSA9PSBlKSlyZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IGEudG8gJiYgKHIgPSBCbyh0ID8gbyA6IHRpKG8pLCBhLnRvKSwgMSA9PSBlKSlyZXR1cm4gclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuICYmIHtmcm9tOiBuLCB0bzogcn1cbiAgICAgICAgICAgICAgICB9LCB2YS5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmZpbmQoLTEsICEwKSwgdCA9IHRoaXMsIG4gPSB0aGlzLmRvYy5jbTtcbiAgICAgICAgICAgICAgICAgICAgZSAmJiBuICYmIEF0KG4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5saW5lLCBpID0gdGkoZS5saW5lKSwgbyA9IFFlKG4sIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8gJiYgKG90KG8pLCBuLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSBuLmN1ck9wLmZvcmNlVXBkYXRlID0gITApLCBuLmN1ck9wLnVwZGF0ZU1heExpbmUgPSAhMCwgIWtyKHQuZG9jLCByKSAmJiBudWxsICE9IHQuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmhlaWdodCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBMcih0KSAtIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCAmJiBlaShyLCByLmhlaWdodCArIGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSwgdmEucHJvdG90eXBlLmF0dGFjaExpbmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGluZXMubGVuZ3RoICYmIHRoaXMuZG9jLmNtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuZG9jLmNtLmN1ck9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5tYXliZUhpZGRlbk1hcmtlcnMgJiYgLTEgIT0gUGkodC5tYXliZUhpZGRlbk1hcmtlcnMsIHRoaXMpIHx8ICh0Lm1heWJlVW5oaWRkZW5NYXJrZXJzIHx8ICh0Lm1heWJlVW5oaWRkZW5NYXJrZXJzID0gW10pKS5wdXNoKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lcy5wdXNoKGUpXG4gICAgICAgICAgICAgICAgfSwgdmEucHJvdG90eXBlLmRldGFjaExpbmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5lcy5zcGxpY2UoUGkodGhpcy5saW5lcywgZSksIDEpLCAhdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5kb2MuY20uY3VyT3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAodC5tYXliZUhpZGRlbk1hcmtlcnMgfHwgKHQubWF5YmVIaWRkZW5NYXJrZXJzID0gW10pKS5wdXNoKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBnYSA9IDAsIHlhID0gZS5TaGFyZWRUZXh0TWFya2VyID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gZSwgdGhpcy5wcmltYXJ5ID0gdDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBlLmxlbmd0aDsgKytuKWVbbl0ucGFyZW50ID0gdGhpc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQWkoeWEpLCB5YS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyArK2UpdGhpcy5tYXJrZXJzW2VdLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBDaSh0aGlzLCBcImNsZWFyXCIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB5YS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByaW1hcnkuZmluZChlLCB0KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHhhID0gZS5MaW5lV2lkZ2V0ID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4pZm9yICh2YXIgciBpbiBuKW4uaGFzT3duUHJvcGVydHkocikgJiYgKHRoaXNbcl0gPSBuW3JdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2MgPSBlLCB0aGlzLm5vZGUgPSB0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBBaSh4YSksIHhhLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmRvYy5jbSwgdCA9IHRoaXMubGluZS53aWRnZXRzLCBuID0gdGhpcy5saW5lLCByID0gdGkobik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9IHIgJiYgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgKytpKXRbaV0gPT0gdGhpcyAmJiB0LnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5sZW5ndGggfHwgKG4ud2lkZ2V0cyA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBMcih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVpKG4sIE1hdGgubWF4KDAsIG4uaGVpZ2h0IC0gbykpLCBlICYmIEF0KGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDcihlLCBuLCAtbyksIEh0KGUsIHIsIFwid2lkZ2V0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgeGEucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5oZWlnaHQsIHQgPSB0aGlzLmRvYy5jbSwgbiA9IHRoaXMubGluZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IExyKHRoaXMpIC0gZTtcbiAgICAgICAgICAgICAgICAgICAgciAmJiAoZWkobiwgbi5oZWlnaHQgKyByKSwgdCAmJiBBdCh0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LmN1ck9wLmZvcmNlVXBkYXRlID0gITAsIENyKHQsIG4sIHIpXG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGJhID0gZS5MaW5lID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gZSwgdXIodGhpcywgdCksIHRoaXMuaGVpZ2h0ID0gbiA/IG4odGhpcykgOiAxXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBBaShiYSksIGJhLnByb3RvdHlwZS5saW5lTm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aSh0aGlzKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHdhID0ge30sIGthID0ge307XG4gICAgICAgICAgICAgICAgJHIucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgICAgICAgICBjaHVua1NpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9LCByZW1vdmVJbm5lcjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBlLCByID0gZSArIHQ7IHIgPiBuOyArK24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMubGluZXNbbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgLT0gaS5oZWlnaHQsIE5yKGkpLCBDaShpLCBcImRlbGV0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lcy5zcGxpY2UoZSwgdClcbiAgICAgICAgICAgICAgICAgICAgfSwgY29sbGFwc2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnB1c2guYXBwbHkoZSwgdGhpcy5saW5lcylcbiAgICAgICAgICAgICAgICAgICAgfSwgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCArPSBuLCB0aGlzLmxpbmVzID0gdGhpcy5saW5lcy5zbGljZSgwLCBlKS5jb25jYXQodCkuY29uY2F0KHRoaXMubGluZXMuc2xpY2UoZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgKytyKXRbcl0ucGFyZW50ID0gdGhpc1xuICAgICAgICAgICAgICAgICAgICB9LCBpdGVyTjogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSBlICsgdDsgciA+IGU7ICsrZSlpZiAobih0aGlzLmxpbmVzW2VdKSlyZXR1cm4gITBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFZyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlbW92ZUlubmVyOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplIC09IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY2hpbGRyZW5bbl0sIGkgPSByLmNodW5rU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IE1hdGgubWluKHQsIGkgLSBlKSwgYSA9IHIuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5yZW1vdmVJbm5lcihlLCBvKSwgdGhpcy5oZWlnaHQgLT0gYSAtIHIuaGVpZ2h0LCBpID09IG8gJiYgKHRoaXMuY2hpbGRyZW4uc3BsaWNlKG4tLSwgMSksIHIucGFyZW50ID0gbnVsbCksIDAgPT0gKHQgLT0gbykpYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGUgLT0gaVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2l6ZSAtIHQgPCAyNSAmJiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAxIHx8ICEodGhpcy5jaGlsZHJlblswXSBpbnN0YW5jZW9mICRyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UobCksIHRoaXMuY2hpbGRyZW4gPSBbbmV3ICRyKGwpXSwgdGhpcy5jaGlsZHJlblswXS5wYXJlbnQgPSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGNvbGxhcHNlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKyt0KXRoaXMuY2hpbGRyZW5bdF0uY29sbGFwc2UoZSlcbiAgICAgICAgICAgICAgICAgICAgfSwgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgKz0gdC5sZW5ndGgsIHRoaXMuaGVpZ2h0ICs9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMuY2hpbGRyZW5bcl0sIG8gPSBpLmNodW5rU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvID49IGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkuaW5zZXJ0SW5uZXIoZSwgdCwgbiksIGkubGluZXMgJiYgaS5saW5lcy5sZW5ndGggPiA1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IGkubGluZXMubGVuZ3RoICUgMjUgKyAyNSwgbCA9IGE7IGwgPCBpLmxpbmVzLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG5ldyAkcihpLmxpbmVzLnNsaWNlKGwsIGwgKz0gMjUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLmhlaWdodCAtPSBzLmhlaWdodCwgdGhpcy5jaGlsZHJlbi5zcGxpY2UoKytyLCAwLCBzKSwgcy5wYXJlbnQgPSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLmxpbmVzID0gaS5saW5lcy5zbGljZSgwLCBhKSwgdGhpcy5tYXliZVNwaWxsKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlIC09IG9cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgbWF5YmVTcGlsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gMTApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLmNoaWxkcmVuLnNwbGljZShlLmNoaWxkcmVuLmxlbmd0aCAtIDUsIDUpLCBuID0gbmV3IFZyKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc2l6ZSAtPSBuLnNpemUsIGUuaGVpZ2h0IC09IG4uaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBQaShlLnBhcmVudC5jaGlsZHJlbiwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UociArIDEsIDAsIG4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IG5ldyBWcihlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkucGFyZW50ID0gZSwgZS5jaGlsZHJlbiA9IFtpLCBuXSwgZSA9IGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLnBhcmVudCA9IGUucGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoZS5jaGlsZHJlbi5sZW5ndGggPiAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wYXJlbnQubWF5YmVTcGlsbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGl0ZXJOOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmNoaWxkcmVuW3JdLCBvID0gaS5jaHVua1NpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobyA+IGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBNYXRoLm1pbih0LCBvIC0gZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpLml0ZXJOKGUsIGEsIG4pKXJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT0gKHQgLT0gYSkpYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGUgLT0gb1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgU2EgPSAwLCBDYSA9IGUuRG9jID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENhKSlyZXR1cm4gbmV3IENhKGUsIHQsIG4sIHIpO1xuICAgICAgICAgICAgICAgICAgICBudWxsID09IG4gJiYgKG4gPSAwKSwgVnIuY2FsbCh0aGlzLCBbbmV3ICRyKFtuZXcgYmEoXCJcIiwgbnVsbCldKV0pLCB0aGlzLmZpcnN0ID0gbiwgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbExlZnQgPSAwLCB0aGlzLmNhbnRFZGl0ID0gITEsIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gMSwgdGhpcy5mcm9udGllciA9IG47XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gQm8obiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsID0gZGUoaSksIHRoaXMuaGlzdG9yeSA9IG5ldyBvaShudWxsKSwgdGhpcy5pZCA9ICsrU2EsIHRoaXMubW9kZU9wdGlvbiA9IHQsIHRoaXMubGluZVNlcCA9IHIsIHRoaXMuZXh0ZW5kID0gITEsIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgKGUgPSB0aGlzLnNwbGl0TGluZXMoZSkpLCBZcih0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IGksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBlXG4gICAgICAgICAgICAgICAgICAgIH0pLCBUZSh0aGlzLCBkZShpKSwgV2EpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDYS5wcm90b3R5cGUgPSBIaShWci5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IENhLCBpdGVyOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA/IHRoaXMuaXRlck4oZSAtIHRoaXMuZmlyc3QsIHQgLSBlLCBuKSA6IHRoaXMuaXRlck4odGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSwgZSlcbiAgICAgICAgICAgICAgICAgICAgfSwgaW5zZXJ0OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDAsIHIgPSAwOyByIDwgdC5sZW5ndGg7ICsrciluICs9IHRbcl0uaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRJbm5lcihlIC0gdGhpcy5maXJzdCwgdCwgbilcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJbm5lcihlIC0gdGhpcy5maXJzdCwgdClcbiAgICAgICAgICAgICAgICAgICAgfSwgZ2V0VmFsdWU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IFFyKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPT09ICExID8gdCA6IHQuam9pbihlIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKVxuICAgICAgICAgICAgICAgICAgICB9LCBzZXRWYWx1ZTogSXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gQm8odGhpcy5maXJzdCwgMCksIG4gPSB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRuKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBCbyhuLCBacih0aGlzLCBuKS50ZXh0Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5zcGxpdExpbmVzKGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJzZXRWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGw6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAhMCksIFRlKHRoaXMsIGRlKHQpKVxuICAgICAgICAgICAgICAgICAgICB9KSwgcmVwbGFjZVJhbmdlOiBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG1lKHRoaXMsIHQpLCBuID0gbiA/IG1lKHRoaXMsIG4pIDogdCwgSW4odGhpcywgZSwgdCwgbiwgcilcbiAgICAgICAgICAgICAgICAgICAgfSwgZ2V0UmFuZ2U6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IEpyKHRoaXMsIG1lKHRoaXMsIGUpLCBtZSh0aGlzLCB0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiA9PT0gITEgPyByIDogci5qb2luKG4gfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpXG4gICAgICAgICAgICAgICAgICAgIH0sIGdldExpbmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0TGluZUhhbmRsZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ICYmIHQudGV4dFxuICAgICAgICAgICAgICAgICAgICB9LCBnZXRMaW5lSGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlKHRoaXMsIGUpID8gWnIodGhpcywgZSkgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgfSwgZ2V0TGluZU51bWJlcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aShlKVxuICAgICAgICAgICAgICAgICAgICB9LCBnZXRMaW5lSGFuZGxlVmlzdWFsU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIiA9PSB0eXBlb2YgZSAmJiAoZSA9IFpyKHRoaXMsIGUpKSwgeXIoZSlcbiAgICAgICAgICAgICAgICAgICAgfSwgbGluZUNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplXG4gICAgICAgICAgICAgICAgICAgIH0sIGZpcnN0TGluZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgfSwgbGFzdExpbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMVxuICAgICAgICAgICAgICAgICAgICB9LCBjbGlwUG9zOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lKHRoaXMsIGUpXG4gICAgICAgICAgICAgICAgICAgIH0sIGdldEN1cnNvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0LCBuID0gdGhpcy5zZWwucHJpbWFyeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPSBudWxsID09IGUgfHwgXCJoZWFkXCIgPT0gZSA/IG4uaGVhZCA6IFwiYW5jaG9yXCIgPT0gZSA/IG4uYW5jaG9yIDogXCJlbmRcIiA9PSBlIHx8IFwidG9cIiA9PSBlIHx8IGUgPT09ICExID8gbi50bygpIDogbi5mcm9tKClcbiAgICAgICAgICAgICAgICAgICAgfSwgbGlzdFNlbGVjdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbC5yYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgfSwgc29tZXRoaW5nU2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbC5zb21ldGhpbmdTZWxlY3RlZCgpXG4gICAgICAgICAgICAgICAgICAgIH0sIHNldEN1cnNvcjogSXQoZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNlKHRoaXMsIG1lKHRoaXMsIFwibnVtYmVyXCIgPT0gdHlwZW9mIGUgPyBCbyhlLCB0IHx8IDApIDogZSksIG51bGwsIG4pXG4gICAgICAgICAgICAgICAgICAgIH0pLCBzZXRTZWxlY3Rpb246IEl0KGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTZSh0aGlzLCBtZSh0aGlzLCBlKSwgbWUodGhpcywgdCB8fCBlKSwgbilcbiAgICAgICAgICAgICAgICAgICAgfSksIGV4dGVuZFNlbGVjdGlvbjogSXQoZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlKHRoaXMsIG1lKHRoaXMsIGUpLCB0ICYmIG1lKHRoaXMsIHQpLCBuKVxuICAgICAgICAgICAgICAgICAgICB9KSwgZXh0ZW5kU2VsZWN0aW9uczogSXQoZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlKHRoaXMsIHllKHRoaXMsIGUpLCB0KVxuICAgICAgICAgICAgICAgICAgICB9KSwgZXh0ZW5kU2VsZWN0aW9uc0J5OiBJdChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBSaSh0aGlzLnNlbC5yYW5nZXMsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2UodGhpcywgeWUodGhpcywgbiksIHQpXG4gICAgICAgICAgICAgICAgICAgIH0pLCBzZXRTZWxlY3Rpb25zOiBJdChmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IFtdOyByIDwgZS5sZW5ndGg7IHIrKylpW3JdID0gbmV3IGZlKG1lKHRoaXMsIGVbcl0uYW5jaG9yKSwgbWUodGhpcywgZVtyXS5oZWFkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA9PSB0ICYmICh0ID0gTWF0aC5taW4oZS5sZW5ndGggLSAxLCB0aGlzLnNlbC5wcmltSW5kZXgpKSwgVGUodGhpcywgaGUoaSwgdCksIG4pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLCBhZGRTZWxlY3Rpb246IEl0KGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuc2VsLnJhbmdlcy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucHVzaChuZXcgZmUobWUodGhpcywgZSksIG1lKHRoaXMsIHQgfHwgZSkpKSwgVGUodGhpcywgaGUociwgci5sZW5ndGggLSAxKSwgbilcbiAgICAgICAgICAgICAgICAgICAgfSksIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQsIG4gPSB0aGlzLnNlbC5yYW5nZXMsIHIgPSAwOyByIDwgbi5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gSnIodGhpcywgbltyXS5mcm9tKCksIG5bcl0udG8oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHQgPyB0LmNvbmNhdChpKSA6IGlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlID09PSAhMSA/IHQgOiB0LmpvaW4oZSB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSlcbiAgICAgICAgICAgICAgICAgICAgfSwgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSBbXSwgbiA9IHRoaXMuc2VsLnJhbmdlcywgciA9IDA7IHIgPCBuLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBKcih0aGlzLCBuW3JdLmZyb20oKSwgbltyXS50bygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlICE9PSAhMSAmJiAoaSA9IGkuam9pbihlIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKSksIHRbcl0gPSBpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdFxuICAgICAgICAgICAgICAgICAgICB9LCByZXBsYWNlU2VsZWN0aW9uOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IFtdLCBpID0gMDsgaSA8IHRoaXMuc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylyW2ldID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbnMociwgdCwgbiB8fCBcIitpbnB1dFwiKVxuICAgICAgICAgICAgICAgICAgICB9LCByZXBsYWNlU2VsZWN0aW9uczogSXQoZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSBbXSwgaSA9IHRoaXMuc2VsLCBvID0gMDsgbyA8IGkucmFuZ2VzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpLnJhbmdlc1tvXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByW29dID0ge2Zyb206IGEuZnJvbSgpLCB0bzogYS50bygpLCB0ZXh0OiB0aGlzLnNwbGl0TGluZXMoZVtvXSksIG9yaWdpbjogbn1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSB0ICYmIFwiZW5kXCIgIT0gdCAmJiBDbih0aGlzLCByLCB0KSwgbyA9IHIubGVuZ3RoIC0gMTsgbyA+PSAwOyBvLS0pVG4odGhpcywgcltvXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsID8gTGUodGhpcywgbCkgOiB0aGlzLmNtICYmIEJuKHRoaXMuY20pXG4gICAgICAgICAgICAgICAgICAgIH0pLCB1bmRvOiBJdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBObih0aGlzLCBcInVuZG9cIilcbiAgICAgICAgICAgICAgICAgICAgfSksIHJlZG86IEl0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE5uKHRoaXMsIFwicmVkb1wiKVxuICAgICAgICAgICAgICAgICAgICB9KSwgdW5kb1NlbGVjdGlvbjogSXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTm4odGhpcywgXCJ1bmRvXCIsICEwKVxuICAgICAgICAgICAgICAgICAgICB9KSwgcmVkb1NlbGVjdGlvbjogSXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTm4odGhpcywgXCJyZWRvXCIsICEwKVxuICAgICAgICAgICAgICAgICAgICB9KSwgc2V0RXh0ZW5kaW5nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRlbmQgPSBlXG4gICAgICAgICAgICAgICAgICAgIH0sIGdldEV4dGVuZGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kXG4gICAgICAgICAgICAgICAgICAgIH0sIGhpc3RvcnlTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gdGhpcy5oaXN0b3J5LCB0ID0gMCwgbiA9IDAsIHIgPSAwOyByIDwgZS5kb25lLmxlbmd0aDsgcisrKWUuZG9uZVtyXS5yYW5nZXMgfHwgKyt0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBlLnVuZG9uZS5sZW5ndGg7IHIrKyllLnVuZG9uZVtyXS5yYW5nZXMgfHwgKytuO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt1bmRvOiB0LCByZWRvOiBufVxuICAgICAgICAgICAgICAgICAgICB9LCBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBvaSh0aGlzLmhpc3RvcnkubWF4R2VuZXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgfSwgbWFya0NsZWFuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuR2VuZXJhdGlvbiA9IHRoaXMuY2hhbmdlR2VuZXJhdGlvbighMClcbiAgICAgICAgICAgICAgICAgICAgfSwgY2hhbmdlR2VuZXJhdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmICh0aGlzLmhpc3RvcnkubGFzdE9wID0gdGhpcy5oaXN0b3J5Lmxhc3RTZWxPcCA9IHRoaXMuaGlzdG9yeS5sYXN0T3JpZ2luID0gbnVsbCksIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0sIGlzQ2xlYW46IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb24gPT0gKGUgfHwgdGhpcy5jbGVhbkdlbmVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIH0sIGdldEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7ZG9uZTogZ2kodGhpcy5oaXN0b3J5LmRvbmUpLCB1bmRvbmU6IGdpKHRoaXMuaGlzdG9yeS51bmRvbmUpfVxuICAgICAgICAgICAgICAgICAgICB9LCBzZXRIaXN0b3J5OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmhpc3RvcnkgPSBuZXcgb2kodGhpcy5oaXN0b3J5Lm1heEdlbmVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5kb25lID0gZ2koZS5kb25lLnNsaWNlKDApLCBudWxsLCAhMCksIHQudW5kb25lID0gZ2koZS51bmRvbmUuc2xpY2UoMCksIG51bGwsICEwKVxuICAgICAgICAgICAgICAgICAgICB9LCBhZGRMaW5lQ2xhc3M6IEl0KGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gem4odGhpcywgZSwgXCJndXR0ZXJcIiA9PSB0ID8gXCJndXR0ZXJcIiA6IFwiY2xhc3NcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IFwidGV4dFwiID09IHQgPyBcInRleHRDbGFzc1wiIDogXCJiYWNrZ3JvdW5kXCIgPT0gdCA/IFwiYmdDbGFzc1wiIDogXCJndXR0ZXJcIiA9PSB0ID8gXCJndXR0ZXJDbGFzc1wiIDogXCJ3cmFwQ2xhc3NcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoWWkobikudGVzdChlW3JdKSlyZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVbcl0gKz0gXCIgXCIgKyBuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGVbcl0gPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSksIHJlbW92ZUxpbmVDbGFzczogSXQoZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB6bih0aGlzLCBlLCBcImd1dHRlclwiID09IHQgPyBcImd1dHRlclwiIDogXCJjbGFzc1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gXCJ0ZXh0XCIgPT0gdCA/IFwidGV4dENsYXNzXCIgOiBcImJhY2tncm91bmRcIiA9PSB0ID8gXCJiZ0NsYXNzXCIgOiBcImd1dHRlclwiID09IHQgPyBcImd1dHRlckNsYXNzXCIgOiBcIndyYXBDbGFzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gZVtyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWkpcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IG4pIGVbcl0gPSBudWxsOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBpLm1hdGNoKFlpKG4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvKXJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBvLmluZGV4ICsgb1swXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVbcl0gPSBpLnNsaWNlKDAsIG8uaW5kZXgpICsgKG8uaW5kZXggJiYgYSAhPSBpLmxlbmd0aCA/IFwiIFwiIDogXCJcIikgKyBpLnNsaWNlKGEpIHx8IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KSwgYWRkTGluZVdpZGdldDogSXQoZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUcih0aGlzLCBlLCB0LCBuKVxuICAgICAgICAgICAgICAgICAgICB9KSwgcmVtb3ZlTGluZVdpZGdldDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY2xlYXIoKVxuICAgICAgICAgICAgICAgICAgICB9LCBtYXJrVGV4dDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBWbih0aGlzLCBtZSh0aGlzLCBlKSwgbWUodGhpcywgdCksIG4sIG4gJiYgbi50eXBlIHx8IFwicmFuZ2VcIilcbiAgICAgICAgICAgICAgICAgICAgfSwgc2V0Qm9va21hcms6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlZFdpdGg6IHQgJiYgKG51bGwgPT0gdC5ub2RlVHlwZSA/IHQud2lkZ2V0IDogdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TGVmdDogdCAmJiB0Lmluc2VydExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJXaGVuRW1wdHk6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZDogdCAmJiB0LnNoYXJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVNb3VzZUV2ZW50czogdCAmJiB0LmhhbmRsZU1vdXNlRXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPSBtZSh0aGlzLCBlKSwgVm4odGhpcywgZSwgZSwgbiwgXCJib29rbWFya1wiKVxuICAgICAgICAgICAgICAgICAgICB9LCBmaW5kTWFya3NBdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBtZSh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gW10sIG4gPSBacih0aGlzLCBlLmxpbmUpLm1hcmtlZFNwYW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4pZm9yICh2YXIgciA9IDA7IHIgPCBuLmxlbmd0aDsgKytyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBuW3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChudWxsID09IGkuZnJvbSB8fCBpLmZyb20gPD0gZS5jaCkgJiYgKG51bGwgPT0gaS50byB8fCBpLnRvID49IGUuY2gpICYmIHQucHVzaChpLm1hcmtlci5wYXJlbnQgfHwgaS5tYXJrZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdFxuICAgICAgICAgICAgICAgICAgICB9LCBmaW5kTWFya3M6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gbWUodGhpcywgZSksIHQgPSBtZSh0aGlzLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gW10sIGkgPSBlLmxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyKGUubGluZSwgdC5saW5lICsgMSwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG8ubWFya2VkU3BhbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEpZm9yICh2YXIgbCA9IDA7IGwgPCBhLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gYVtsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPSBzLnRvICYmIGkgPT0gZS5saW5lICYmIGUuY2ggPj0gcy50byB8fCBudWxsID09IHMuZnJvbSAmJiBpICE9IGUubGluZSB8fCBudWxsICE9IHMuZnJvbSAmJiBpID09IHQubGluZSAmJiBzLmZyb20gPj0gdC5jaCB8fCBuICYmICFuKHMubWFya2VyKSB8fCByLnB1c2gocy5tYXJrZXIucGFyZW50IHx8IHMubWFya2VyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2lcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCByXG4gICAgICAgICAgICAgICAgICAgIH0sIGdldEFsbE1hcmtzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdC5tYXJrZWRTcGFucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobilmb3IgKHZhciByID0gMDsgciA8IG4ubGVuZ3RoOyArK3IpbnVsbCAhPSBuW3JdLmZyb20gJiYgZS5wdXNoKG5bcl0ubWFya2VyKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIGVcbiAgICAgICAgICAgICAgICAgICAgfSwgcG9zRnJvbUluZGV4OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQsIG4gPSB0aGlzLmZpcnN0LCByID0gdGhpcy5saW5lU2VwYXJhdG9yKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gaS50ZXh0Lmxlbmd0aCArIHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8gPiBlID8gKHQgPSBlLCAhMCkgOiAoZSAtPSBvLCB2b2lkKytuKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIG1lKHRoaXMsIEJvKG4sIHQpKVxuICAgICAgICAgICAgICAgICAgICB9LCBpbmRleEZyb21Qb3M6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gbWUodGhpcywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUuY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5saW5lIDwgdGhpcy5maXJzdCB8fCBlLmNoIDwgMClyZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5saW5lU2VwYXJhdG9yKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcih0aGlzLmZpcnN0LCBlLmxpbmUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCArPSBlLnRleHQubGVuZ3RoICsgblxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIHRcbiAgICAgICAgICAgICAgICAgICAgfSwgY29weTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IENhKFFyKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpLCB0aGlzLm1vZGVPcHRpb24sIHRoaXMuZmlyc3QsIHRoaXMubGluZVNlcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcCwgdC5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0LCB0LnNlbCA9IHRoaXMuc2VsLCB0LmV4dGVuZCA9ICExLCBlICYmICh0Lmhpc3RvcnkudW5kb0RlcHRoID0gdGhpcy5oaXN0b3J5LnVuZG9EZXB0aCwgdC5zZXRIaXN0b3J5KHRoaXMuZ2V0SGlzdG9yeSgpKSksIHRcbiAgICAgICAgICAgICAgICAgICAgfSwgbGlua2VkRG9jOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSB8fCAoZSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5maXJzdCwgbiA9IHRoaXMuZmlyc3QgKyB0aGlzLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9IGUuZnJvbSAmJiBlLmZyb20gPiB0ICYmICh0ID0gZS5mcm9tKSwgbnVsbCAhPSBlLnRvICYmIGUudG8gPCBuICYmIChuID0gZS50byk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBDYShRcih0aGlzLCB0LCBuKSwgZS5tb2RlIHx8IHRoaXMubW9kZU9wdGlvbiwgdCwgdGhpcy5saW5lU2VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnNoYXJlZEhpc3QgJiYgKHIuaGlzdG9yeSA9IHRoaXMuaGlzdG9yeSksICh0aGlzLmxpbmtlZCB8fCAodGhpcy5saW5rZWQgPSBbXSkpLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYzogcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRIaXN0OiBlLnNoYXJlZEhpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCByLmxpbmtlZCA9IFt7ZG9jOiB0aGlzLCBpc1BhcmVudDogITAsIHNoYXJlZEhpc3Q6IGUuc2hhcmVkSGlzdH1dLCBabihyLCBYbih0aGlzKSksIHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdW5saW5rRG9jOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBlICYmICh0ID0gdC5kb2MpLCB0aGlzLmxpbmtlZClmb3IgKHZhciBuID0gMDsgbiA8IHRoaXMubGlua2VkLmxlbmd0aDsgKytuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmxpbmtlZFtuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5kb2MgPT0gdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtlZC5zcGxpY2UobiwgMSksIHQudW5saW5rRG9jKHRoaXMpLCBKbihYbih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuaGlzdG9yeSA9PSB0aGlzLmhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IFt0LmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBLcih0LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLnB1c2goZS5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAhMCksIHQuaGlzdG9yeSA9IG5ldyBvaShudWxsKSwgdC5oaXN0b3J5LmRvbmUgPSBnaSh0aGlzLmhpc3RvcnkuZG9uZSwgaSksIHQuaGlzdG9yeS51bmRvbmUgPSBnaSh0aGlzLmhpc3RvcnkudW5kb25lLCBpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBpdGVyTGlua2VkRG9jczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtyKHRoaXMsIGUpXG4gICAgICAgICAgICAgICAgICAgIH0sIGdldE1vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVcbiAgICAgICAgICAgICAgICAgICAgfSwgZ2V0RWRpdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbVxuICAgICAgICAgICAgICAgICAgICB9LCBzcGxpdExpbmVzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZVNlcCA/IGUuc3BsaXQodGhpcy5saW5lU2VwKSA6IHRsKGUpXG4gICAgICAgICAgICAgICAgICAgIH0sIGxpbmVTZXBhcmF0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVTZXAgfHwgXCJcXG5cIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksIENhLnByb3RvdHlwZS5lYWNoTGluZSA9IENhLnByb3RvdHlwZS5pdGVyO1xuICAgICAgICAgICAgICAgIHZhciBMYSA9IFwiaXRlciBpbnNlcnQgcmVtb3ZlIGNvcHkgZ2V0RWRpdG9yIGNvbnN0cnVjdG9yXCIuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIFRhIGluIENhLnByb3RvdHlwZSlDYS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoVGEpICYmIFBpKExhLCBUYSkgPCAwICYmIChlLnByb3RvdHlwZVtUYV0gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuYXBwbHkodGhpcy5kb2MsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0oQ2EucHJvdG90eXBlW1RhXSkpO1xuICAgICAgICAgICAgICAgIEFpKENhKTtcbiAgICAgICAgICAgICAgICB2YXIgTWEgPSBlLmVfcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogZS5yZXR1cm5WYWx1ZSA9ICExXG4gICAgICAgICAgICAgICAgfSwgTmEgPSBlLmVfc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24gPyBlLnN0b3BQcm9wYWdhdGlvbigpIDogZS5jYW5jZWxCdWJibGUgPSAhMFxuICAgICAgICAgICAgICAgIH0sIEFhID0gZS5lX3N0b3AgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBNYShlKSwgTmEoZSlcbiAgICAgICAgICAgICAgICB9LCBFYSA9IGUub24gPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5hZGRFdmVudExpc3RlbmVyKSBlLmFkZEV2ZW50TGlzdGVuZXIodCwgbiwgITEpOyBlbHNlIGlmIChlLmF0dGFjaEV2ZW50KSBlLmF0dGFjaEV2ZW50KFwib25cIiArIHQsIG4pOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5faGFuZGxlcnMgfHwgKGUuX2hhbmRsZXJzID0ge30pLCBpID0gclt0XSB8fCAoclt0XSA9IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkucHVzaChuKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgT2EgPSBbXSwgSWEgPSBlLm9mZiA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnJlbW92ZUV2ZW50TGlzdGVuZXIpIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBuLCAhMSk7IGVsc2UgaWYgKGUuZGV0YWNoRXZlbnQpIGUuZGV0YWNoRXZlbnQoXCJvblwiICsgdCwgbik7IGVsc2UgZm9yICh2YXIgciA9IFNpKGUsIHQsICExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7IGkgPCByLmxlbmd0aDsgKytpKWlmIChyW2ldID09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFBhID0gZS5zaWduYWwgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFNpKGUsIHQsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4ubGVuZ3RoKWZvciAodmFyIHIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7IGkgPCBuLmxlbmd0aDsgKytpKW5baV0uYXBwbHkobnVsbCwgcilcbiAgICAgICAgICAgICAgICB9LCBSYSA9IG51bGwsIERhID0gMzAsIEhhID0gZS5QYXNzID0ge1xuICAgICAgICAgICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQ29kZU1pcnJvci5QYXNzXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFdhID0ge3Njcm9sbDogITF9LCBCYSA9IHtvcmlnaW46IFwiKm1vdXNlXCJ9LCBfYSA9IHtvcmlnaW46IFwiK21vdmVcIn07XG4gICAgICAgICAgICAgICAgRWkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkKSwgdGhpcy5pZCA9IHNldFRpbWVvdXQodCwgZSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBGYSA9IGUuY291bnRDb2x1bW4gPSBmdW5jdGlvbiAoZSwgdCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICBudWxsID09IHQgJiYgKHQgPSBlLnNlYXJjaCgvW15cXHNcXHUwMGEwXS8pLCAtMSA9PSB0ICYmICh0ID0gZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbyA9IHIgfHwgMCwgYSA9IGkgfHwgMDsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBlLmluZGV4T2YoXCJcdFwiLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID4gbCB8fCBsID49IHQpcmV0dXJuIGEgKyAodCAtIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBsIC0gbywgYSArPSBuIC0gYSAlIG4sIG8gPSBsICsgMVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgemEgPSBlLmZpbmRDb2x1bW4gPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMCwgaSA9IDA7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZS5pbmRleE9mKFwiXHRcIiwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAtMSA9PSBvICYmIChvID0gZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBvIC0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvID09IGUubGVuZ3RoIHx8IGkgKyBhID49IHQpcmV0dXJuIHIgKyBNYXRoLm1pbihhLCB0IC0gaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSArPSBvIC0gciwgaSArPSBuIC0gaSAlIG4sIHIgPSBvICsgMSwgaSA+PSB0KXJldHVybiByXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBqYSA9IFtcIlwiXSwgVWEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnNlbGVjdCgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBObyA/IFVhID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZWxlY3Rpb25TdGFydCA9IDAsIGUuc2VsZWN0aW9uRW5kID0gZS52YWx1ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICB9IDogeG8gJiYgKFVhID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zZWxlY3QoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcWEsXG4gICAgICAgICAgICAgICAgICAgIEdhID0gL1tcXHUwMGRmXFx1MDU4N1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTMwNDAtXFx1MzA5ZlxcdTMwYTAtXFx1MzBmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWFjMDAtXFx1ZDdhZl0vLFxuICAgICAgICAgICAgICAgICAgICBZYSA9IGUuaXNXb3JkQ2hhciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gL1xcdy8udGVzdChlKSB8fCBlID4gXCLCgFwiICYmIChlLnRvVXBwZXJDYXNlKCkgIT0gZS50b0xvd2VyQ2FzZSgpIHx8IEdhLnRlc3QoZSkpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICRhID0gL1tcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NWVcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZS1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdlYi1cXHUwN2YzXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDkwMC1cXHUwOTAyXFx1MDkzY1xcdTA5NDEtXFx1MDk0OFxcdTA5NGRcXHUwOTUxLVxcdTA5NTVcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOWJjXFx1MDliZVxcdTA5YzEtXFx1MDljNFxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwYTAxXFx1MGEwMlxcdTBhM2NcXHUwYTQxXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNzBcXHUwYTcxXFx1MGE3NVxcdTBhODFcXHUwYTgyXFx1MGFiY1xcdTBhYzEtXFx1MGFjNVxcdTBhYzdcXHUwYWM4XFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGIwMVxcdTBiM2NcXHUwYjNlXFx1MGIzZlxcdTBiNDEtXFx1MGI0NFxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI4MlxcdTBiYmVcXHUwYmMwXFx1MGJjZFxcdTBiZDdcXHUwYzNlLVxcdTBjNDBcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGNiY1xcdTBjYmZcXHUwY2MyXFx1MGNjNlxcdTBjY2NcXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBkM2VcXHUwZDQxLVxcdTBkNDRcXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGRjYVxcdTBkY2ZcXHUwZGQyLVxcdTBkZDRcXHUwZGQ2XFx1MGRkZlxcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZWIxXFx1MGViNC1cXHUwZWI5XFx1MGViYlxcdTBlYmNcXHUwZWM4LVxcdTBlY2RcXHUwZjE4XFx1MGYxOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNzEtXFx1MGY3ZVxcdTBmODAtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY5MC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNhXFx1MTAzZFxcdTEwM2VcXHUxMDU4XFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOGRcXHUxMDlkXFx1MTM1ZlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I3LVxcdTE3YmRcXHUxN2M2XFx1MTdjOS1cXHUxN2QzXFx1MTdkZFxcdTE4MGItXFx1MTgwZFxcdTE4YTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M2JcXHUxYTE3XFx1MWExOFxcdTFhNTZcXHUxYTU4LVxcdTFhNWVcXHUxYTYwXFx1MWE2MlxcdTFhNjUtXFx1MWE2Y1xcdTFhNzMtXFx1MWE3Y1xcdTFhN2ZcXHUxYjAwLVxcdTFiMDNcXHUxYjM0XFx1MWIzNi1cXHUxYjNhXFx1MWIzY1xcdTFiNDJcXHUxYjZiLVxcdTFiNzNcXHUxYjgwXFx1MWI4MVxcdTFiYTItXFx1MWJhNVxcdTFiYThcXHUxYmE5XFx1MWMyYy1cXHUxYzMzXFx1MWMzNlxcdTFjMzdcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZTBcXHUxY2UyLVxcdTFjZThcXHUxY2VkXFx1MWRjMC1cXHUxZGU2XFx1MWRmZC1cXHUxZGZmXFx1MjAwY1xcdTIwMGRcXHUyMGQwLVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2NmYtXFx1YTY3MlxcdWE2N2NcXHVhNjdkXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODI1XFx1YTgyNlxcdWE4YzRcXHVhOGUwLVxcdWE4ZjFcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTFcXHVhOTgwLVxcdWE5ODJcXHVhOWIzXFx1YTliNi1cXHVhOWI5XFx1YTliY1xcdWFhMjktXFx1YWEyZVxcdWFhMzFcXHVhYTMyXFx1YWEzNVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFiZTVcXHVhYmU4XFx1YWJlZFxcdWRjMDAtXFx1ZGZmZlxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZjllXFx1ZmY5Zl0vO1xuICAgICAgICAgICAgICAgIHFhID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UgPyBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpLnNldEVuZChyIHx8IGUsIG4pLCBpLnNldFN0YXJ0KGUsIHQpLCBpXG4gICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZG9jdW1lbnQuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIubW92ZVRvRWxlbWVudFRleHQoZS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByLmNvbGxhcHNlKCEwKSwgci5tb3ZlRW5kKFwiY2hhcmFjdGVyXCIsIG4pLCByLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCB0KSwgclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIFZhID0gZS5jb250YWlucyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgzID09IHQubm9kZVR5cGUgJiYgKHQgPSB0LnBhcmVudE5vZGUpLCBlLmNvbnRhaW5zKXJldHVybiBlLmNvbnRhaW5zKHQpO1xuICAgICAgICAgICAgICAgICAgICBkbyBpZiAoMTEgPT0gdC5ub2RlVHlwZSAmJiAodCA9IHQuaG9zdCksIHQgPT0gZSlyZXR1cm4gITA7IHdoaWxlICh0ID0gdC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgeG8gJiYgMTEgPiBibyAmJiAoR2kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIEthLCBYYSwgWmEgPSBlLnJtQ2xhc3MgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUuY2xhc3NOYW1lLCByID0gWWkodCkuZXhlYyhuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gbi5zbGljZShyLmluZGV4ICsgclswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5jbGFzc05hbWUgPSBuLnNsaWNlKDAsIHIuaW5kZXgpICsgKGkgPyByWzFdICsgaSA6IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBKYSA9IGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICBZaSh0KS50ZXN0KG4pIHx8IChlLmNsYXNzTmFtZSArPSAobiA/IFwiIFwiIDogXCJcIikgKyB0KVxuICAgICAgICAgICAgICAgIH0sIFFhID0gITEsIGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeG8gJiYgOSA+IGJvKXJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBqaShcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZHJhZ2dhYmxlXCIgaW4gZSB8fCBcImRyYWdEcm9wXCIgaW4gZVxuICAgICAgICAgICAgICAgIH0oKSwgdGwgPSBlLnNwbGl0TGluZXMgPSAzICE9IFwiXFxuXFxuYlwiLnNwbGl0KC9cXG4vKS5sZW5ndGggPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMCwgbiA9IFtdLCByID0gZS5sZW5ndGg7IHIgPj0gdDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZS5pbmRleE9mKFwiXFxuXCIsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLTEgPT0gaSAmJiAoaSA9IGUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZS5zbGljZSh0LCBcIlxcclwiID09IGUuY2hhckF0KGkgLSAxKSA/IGkgLSAxIDogaSksIGEgPSBvLmluZGV4T2YoXCJcXHJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAtMSAhPSBhID8gKG4ucHVzaChvLnNsaWNlKDAsIGEpKSwgdCArPSBhICsgMSkgOiAobi5wdXNoKG8pLCB0ID0gaSArIDEpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuc3BsaXQoL1xcclxcbj98XFxuLylcbiAgICAgICAgICAgICAgICB9LCBubCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuc2VsZWN0aW9uU3RhcnQgIT0gZS5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5vd25lckRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCAmJiB0LnBhcmVudEVsZW1lbnQoKSA9PSBlID8gMCAhPSB0LmNvbXBhcmVFbmRQb2ludHMoXCJTdGFydFRvRW5kXCIsIHQpIDogITFcbiAgICAgICAgICAgICAgICB9LCBybCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBqaShcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib25jb3B5XCIgaW4gZSA/ICEwIDogKGUuc2V0QXR0cmlidXRlKFwib25jb3B5XCIsIFwicmV0dXJuO1wiKSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlLm9uY29weSlcbiAgICAgICAgICAgICAgICB9KCksIGlsID0gbnVsbCwgb2wgPSBlLmtleU5hbWVzID0ge1xuICAgICAgICAgICAgICAgICAgICAzOiBcIkVudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIDg6IFwiQmFja3NwYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIDk6IFwiVGFiXCIsXG4gICAgICAgICAgICAgICAgICAgIDEzOiBcIkVudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIDE2OiBcIlNoaWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgIDE3OiBcIkN0cmxcIixcbiAgICAgICAgICAgICAgICAgICAgMTg6IFwiQWx0XCIsXG4gICAgICAgICAgICAgICAgICAgIDE5OiBcIlBhdXNlXCIsXG4gICAgICAgICAgICAgICAgICAgIDIwOiBcIkNhcHNMb2NrXCIsXG4gICAgICAgICAgICAgICAgICAgIDI3OiBcIkVzY1wiLFxuICAgICAgICAgICAgICAgICAgICAzMjogXCJTcGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAzMzogXCJQYWdlVXBcIixcbiAgICAgICAgICAgICAgICAgICAgMzQ6IFwiUGFnZURvd25cIixcbiAgICAgICAgICAgICAgICAgICAgMzU6IFwiRW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIDM2OiBcIkhvbWVcIixcbiAgICAgICAgICAgICAgICAgICAgMzc6IFwiTGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICAzODogXCJVcFwiLFxuICAgICAgICAgICAgICAgICAgICAzOTogXCJSaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICA0MDogXCJEb3duXCIsXG4gICAgICAgICAgICAgICAgICAgIDQ0OiBcIlByaW50U2NyblwiLFxuICAgICAgICAgICAgICAgICAgICA0NTogXCJJbnNlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgNDY6IFwiRGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIDU5OiBcIjtcIixcbiAgICAgICAgICAgICAgICAgICAgNjE6IFwiPVwiLFxuICAgICAgICAgICAgICAgICAgICA5MTogXCJNb2RcIixcbiAgICAgICAgICAgICAgICAgICAgOTI6IFwiTW9kXCIsXG4gICAgICAgICAgICAgICAgICAgIDkzOiBcIk1vZFwiLFxuICAgICAgICAgICAgICAgICAgICAxMDY6IFwiKlwiLFxuICAgICAgICAgICAgICAgICAgICAxMDc6IFwiPVwiLFxuICAgICAgICAgICAgICAgICAgICAxMDk6IFwiLVwiLFxuICAgICAgICAgICAgICAgICAgICAxMTA6IFwiLlwiLFxuICAgICAgICAgICAgICAgICAgICAxMTE6IFwiL1wiLFxuICAgICAgICAgICAgICAgICAgICAxMjc6IFwiRGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIDE3MzogXCItXCIsXG4gICAgICAgICAgICAgICAgICAgIDE4NjogXCI7XCIsXG4gICAgICAgICAgICAgICAgICAgIDE4NzogXCI9XCIsXG4gICAgICAgICAgICAgICAgICAgIDE4ODogXCIsXCIsXG4gICAgICAgICAgICAgICAgICAgIDE4OTogXCItXCIsXG4gICAgICAgICAgICAgICAgICAgIDE5MDogXCIuXCIsXG4gICAgICAgICAgICAgICAgICAgIDE5MTogXCIvXCIsXG4gICAgICAgICAgICAgICAgICAgIDE5MjogXCJgXCIsXG4gICAgICAgICAgICAgICAgICAgIDIxOTogXCJbXCIsXG4gICAgICAgICAgICAgICAgICAgIDIyMDogXCJcXFxcXCIsXG4gICAgICAgICAgICAgICAgICAgIDIyMTogXCJdXCIsXG4gICAgICAgICAgICAgICAgICAgIDIyMjogXCInXCIsXG4gICAgICAgICAgICAgICAgICAgIDYzMjMyOiBcIlVwXCIsXG4gICAgICAgICAgICAgICAgICAgIDYzMjMzOiBcIkRvd25cIixcbiAgICAgICAgICAgICAgICAgICAgNjMyMzQ6IFwiTGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICA2MzIzNTogXCJSaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICA2MzI3MjogXCJEZWxldGVcIixcbiAgICAgICAgICAgICAgICAgICAgNjMyNzM6IFwiSG9tZVwiLFxuICAgICAgICAgICAgICAgICAgICA2MzI3NTogXCJFbmRcIixcbiAgICAgICAgICAgICAgICAgICAgNjMyNzY6IFwiUGFnZVVwXCIsXG4gICAgICAgICAgICAgICAgICAgIDYzMjc3OiBcIlBhZ2VEb3duXCIsXG4gICAgICAgICAgICAgICAgICAgIDYzMzAyOiBcIkluc2VydFwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAhZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMDsgMTAgPiBlOyBlKyspb2xbZSArIDQ4XSA9IG9sW2UgKyA5Nl0gPSBTdHJpbmcoZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSA2NTsgOTAgPj0gZTsgZSsrKW9sW2VdID0gU3RyaW5nLmZyb21DaGFyQ29kZShlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDE7IDEyID49IGU7IGUrKylvbFtlICsgMTExXSA9IG9sW2UgKyA2MzIzNV0gPSBcIkZcIiArIGVcbiAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgdmFyIGFsLCBsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjQ3ID49IGUgPyBuLmNoYXJBdChlKSA6IGUgPj0gMTQyNCAmJiAxNTI0ID49IGUgPyBcIlJcIiA6IGUgPj0gMTUzNiAmJiAxNzczID49IGUgPyByLmNoYXJBdChlIC0gMTUzNikgOiBlID49IDE3NzQgJiYgMjIyMCA+PSBlID8gXCJyXCIgOiBlID49IDgxOTIgJiYgODIwMyA+PSBlID8gXCJ3XCIgOiA4MjA0ID09IGUgPyBcImJcIiA6IFwiTFwiXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0KGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGV2ZWwgPSBlLCB0aGlzLmZyb20gPSB0LCB0aGlzLnRvID0gblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBcImJiYmJiYmJiYnRzdHdzYmJiYmJiYmJiYmJiYmJzc3N0d05OJSUlTk5OTk5OLE4sTjExMTExMTExMTFOTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5iYmJiYmJzYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmIsTiUlJSVOTk5OTE5OTk5OJSUxMU5MTk5OMUxOTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTkxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExOXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gXCJycnJycnJycnJycnIsck5ObW1tbW1tcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbW1tbW1tbXJycnJycnJubm5ubm5ubm5uJW5ucnJybXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW1tbW1tbW1tbW1tbU5tbW1tXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLywgbyA9IC9bc3R3Tl0vLCBhID0gL1tMUnJdLywgbCA9IC9bTGIxbl0vLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IC9bMW5dLywgYyA9IFwiTFwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaS50ZXN0KG4pKXJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIsIHUgPSBuLmxlbmd0aCwgZiA9IFtdLCBoID0gMDsgdSA+IGg7ICsraClmLnB1c2gociA9IGUobi5jaGFyQ29kZUF0KGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBoID0gMCwgZCA9IGM7IHUgPiBoOyArK2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGZbaF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtXCIgPT0gciA/IGZbaF0gPSBkIDogZCA9IHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGggPSAwLCBwID0gYzsgdSA+IGg7ICsraCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZltoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjFcIiA9PSByICYmIFwiclwiID09IHAgPyBmW2hdID0gXCJuXCIgOiBhLnRlc3QocikgJiYgKHAgPSByLCBcInJcIiA9PSByICYmIChmW2hdID0gXCJSXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaCA9IDEsIGQgPSBmWzBdOyB1IC0gMSA+IGg7ICsraCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZltoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIitcIiA9PSByICYmIFwiMVwiID09IGQgJiYgXCIxXCIgPT0gZltoICsgMV0gPyBmW2hdID0gXCIxXCIgOiBcIixcIiAhPSByIHx8IGQgIT0gZltoICsgMV0gfHwgXCIxXCIgIT0gZCAmJiBcIm5cIiAhPSBkIHx8IChmW2hdID0gZCksIGQgPSByXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBoID0gMDsgdSA+IGg7ICsraCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZltoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCIsXCIgPT0gcikgZltoXSA9IFwiTlwiOyBlbHNlIGlmIChcIiVcIiA9PSByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSBoICsgMTsgdSA+IG0gJiYgXCIlXCIgPT0gZlttXTsgKyttKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZyA9IGggJiYgXCIhXCIgPT0gZltoIC0gMV0gfHwgdSA+IG0gJiYgXCIxXCIgPT0gZlttXSA/IFwiMVwiIDogXCJOXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBoOyBtID4gdjsgKyt2KWZbdl0gPSBnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0gbSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBoID0gMCwgcCA9IGM7IHUgPiBoOyArK2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGZbaF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJMXCIgPT0gcCAmJiBcIjFcIiA9PSByID8gZltoXSA9IFwiTFwiIDogYS50ZXN0KHIpICYmIChwID0gcilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGggPSAwOyB1ID4gaDsgKytoKWlmIChvLnRlc3QoZltoXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gaCArIDE7IHUgPiBtICYmIG8udGVzdChmW21dKTsgKyttKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gXCJMXCIgPT0gKGggPyBmW2ggLSAxXSA6IGMpLCB4ID0gXCJMXCIgPT0gKHUgPiBtID8gZlttXSA6IGMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSB5IHx8IHggPyBcIkxcIiA6IFwiUlwiLCB2ID0gaDsgbSA+IHY7ICsrdilmW3ZdID0gZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0gbSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGIsIHcgPSBbXSwgaCA9IDA7IHUgPiBoOylpZiAobC50ZXN0KGZbaF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoKytoOyB1ID4gaCAmJiBsLnRlc3QoZltoXSk7ICsraCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdy5wdXNoKG5ldyB0KDAsIGssIGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgUyA9IGgsIEMgPSB3Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCsraDsgdSA+IGggJiYgXCJMXCIgIT0gZltoXTsgKytoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB2ID0gUzsgaCA+IHY7KWlmIChzLnRlc3QoZlt2XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA+IFMgJiYgdy5zcGxpY2UoQywgMCwgbmV3IHQoMSwgUywgdikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTCA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoKyt2OyBoID4gdiAmJiBzLnRlc3QoZlt2XSk7ICsrdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcuc3BsaWNlKEMsIDAsIG5ldyB0KDIsIEwsIHYpKSwgUyA9IHZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UrK3Y7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA+IFMgJiYgdy5zcGxpY2UoQywgMCwgbmV3IHQoMSwgUywgaCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSA9PSB3WzBdLmxldmVsICYmIChiID0gbi5tYXRjaCgvXlxccysvKSkgJiYgKHdbMF0uZnJvbSA9IGJbMF0ubGVuZ3RoLCB3LnVuc2hpZnQobmV3IHQoMCwgMCwgYlswXS5sZW5ndGgpKSksIDEgPT0gSWkodykubGV2ZWwgJiYgKGIgPSBuLm1hdGNoKC9cXHMrJC8pKSAmJiAoSWkodykudG8gLT0gYlswXS5sZW5ndGgsIHcucHVzaChuZXcgdCgwLCB1IC0gYlswXS5sZW5ndGgsIHUpKSksIDIgPT0gd1swXS5sZXZlbCAmJiB3LnVuc2hpZnQobmV3IHQoMSwgd1swXS50bywgd1swXS50bykpLCB3WzBdLmxldmVsICE9IElpKHcpLmxldmVsICYmIHcucHVzaChuZXcgdCh3WzBdLmxldmVsLCB1LCB1KSksIHdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS52ZXJzaW9uID0gXCI1LjE1LjJcIiwgZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwge31dLFxuICAgICAgICAxMTogW2Z1bmN0aW9uICh0LCBuLCByKSB7XG4gICAgICAgICAgICAhZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09IHR5cGVvZiByICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG4gPyBpKHQoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSwgdChcIi4uL21hcmtkb3duL21hcmtkb3duXCIpLCB0KFwiLi4vLi4vYWRkb24vbW9kZS9vdmVybGF5XCIpKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSAmJiBlLmFtZCA/IGUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiwgXCIuLi9tYXJrZG93bi9tYXJrZG93blwiLCBcIi4uLy4uL2FkZG9uL21vZGUvb3ZlcmxheVwiXSwgaSkgOiBpKENvZGVNaXJyb3IpXG4gICAgICAgICAgICB9KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSAvXigoPzooPzphYWFzP3xhYm91dHxhY2FwfGFkaXVteHRyYXxhZltwc118YWltfGFwdHxhdHRhY2htZW50fGF3fGJlc2hhcmV8Yml0Y29pbnxib2xvfGNhbGx0b3xjYXB8Y2hyb21lKD86LWV4dGVuc2lvbik/fGNpZHxjb2FwfGNvbS1ldmVudGJyaXRlLWF0dGVuZGVlfGNvbnRlbnR8Y3JpZHxjdnN8ZGF0YXxkYXZ8ZGljdHxkbG5hLSg/OnBsYXljb250YWluZXJ8cGxheXNpbmdsZSl8ZG5zfGRvaXxkdG58ZHZifGVkMmt8ZmFjZXRpbWV8ZmVlZHxmaWxlfGZpbmdlcnxmaXNofGZ0cHxnZW98Z2d8Z2l0fGdpem1vcHJvamVjdHxnb3xnb3BoZXJ8Z3RhbGt8aDMyM3xoY3B8aHR0cHM/fGlheHxpY2FwfGljb258aW18aW1hcHxpbmZvfGlwbnxpcHB8aXJjWzZzXT98aXJpcyg/OlxcLmJlZXB8XFwubHd6fFxcLnhwY3xcXC54cGNzKT98aXRtc3xqYXJ8amF2YXNjcmlwdHxqbXN8a2V5cGFyY3xsYXN0Zm18bGRhcHM/fG1hZ25ldHxtYWlsdG98bWFwc3xtYXJrZXR8bWVzc2FnZXxtaWR8bW1zfG1zLWhlbHB8bXNuaW18bXNycHM/fG10cXB8bXVtYmxlfG11cGRhdGV8bXZufG5ld3N8bmZzfG5paD98bm50cHxub3Rlc3xvaWR8b3BhcXVlbG9ja3Rva2VufHBhbG18cGFwYXJhenppfHBsYXRmb3JtfHBvcHxwcmVzfHByb3h5fHBzeWN8cXVlcnl8cmVzKD86b3VyY2UpP3xybWl8cnN5bmN8cnRtcHxydHNwfHNlY29uZGxpZmV8c2VydmljZXxzZXNzaW9ufHNmdHB8c2dufHNodHRwfHNpZXZlfHNpcHM/fHNreXBlfHNtW2JzXXxzbm1wfHNvYXBcXC5iZWVwcz98c29sZGF0fHNwb3RpZnl8c3NofHN0ZWFtfHN2bnx0YWd8dGVhbXNwZWFrfHRlbCg/Om5ldCk/fHRmdHB8dGhpbmdzfHRoaXNtZXNzYWdlfHRpcHx0bjMyNzB8dHZ8dWRwfHVucmVhbHx1cm58dXQyMDA0fHZlbW1pfHZlbnRyaWxvfHZpZXctc291cmNlfHdlYmNhbHx3c3M/fHd0YWl8d3ljaXd5Z3x4Y29uKD86LXVzZXJpZCk/fHhmaXJlfHhtbHJwY1xcLmJlZXBzP3x4bXBwfHhyaXx5bXNncnx6MzlcXC41MFtyc10/KTooPzpcXC97MSwzfXxbYS16MC05JV0pfHd3d1xcZHswLDN9Wy5dfFthLXowLTkuXFwtXStbLl1bYS16XXsyLDR9XFwvKSg/OlteXFxzKCk8Pl18XFwoW15cXHMoKTw+XSpcXCkpKyg/OlxcKFteXFxzKCk8Pl0qXFwpfFteXFxzYCohKClcXFtcXF17fTs6J1wiLiw8Pj/Cq8K74oCc4oCd4oCY4oCZXSkpL2k7XG4gICAgICAgICAgICAgICAgZS5kZWZpbmVNb2RlKFwiZ2ZtXCIsIGZ1bmN0aW9uIChuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuY29kZSA9ICExLCBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IDAsIGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2RlOiAhMSwgY29kZUJsb2NrOiAhMSwgYXRlU3BhY2U6ICExfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29weVN0YXRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29kZTogZS5jb2RlLCBjb2RlQmxvY2s6IGUuY29kZUJsb2NrLCBhdGVTcGFjZTogZS5hdGVTcGFjZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRva2VuOiBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLmNvbWJpbmVUb2tlbnMgPSBudWxsLCBuLmNvZGVCbG9jaylyZXR1cm4gZS5tYXRjaCgvXmBgYCsvKSA/IChuLmNvZGVCbG9jayA9ICExLCBudWxsKSA6IChlLnNraXBUb0VuZCgpLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5zb2woKSAmJiAobi5jb2RlID0gITEpLCBlLnNvbCgpICYmIGUubWF0Y2goL15gYGArLykpcmV0dXJuIGUuc2tpcFRvRW5kKCksIG4uY29kZUJsb2NrID0gITAsIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiYFwiID09PSBlLnBlZWsoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5lYXRXaGlsZShcImBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gMSArIGUucG9zIC0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uY29kZSA/IGEgPT09IG8gJiYgKG4uY29kZSA9ICExKSA6IChvID0gYSwgbi5jb2RlID0gITApLCBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLmNvZGUpcmV0dXJuIGUubmV4dCgpLCBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmVhdFNwYWNlKCkpcmV0dXJuIG4uYXRlU3BhY2UgPSAhMCwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGUuc29sKCkgfHwgbi5hdGVTcGFjZSkgJiYgKG4uYXRlU3BhY2UgPSAhMSwgci5naXRIdWJTcGljZSAhPT0gITEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLm1hdGNoKC9eKD86W2EtekEtWjAtOVxcLV9dK1xcLyk/KD86W2EtekEtWjAtOVxcLV9dK0ApPyg/OlthLWYwLTldezcsNDB9XFxiKS8pKXJldHVybiBuLmNvbWJpbmVUb2tlbnMgPSAhMCwgXCJsaW5rXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLm1hdGNoKC9eKD86W2EtekEtWjAtOVxcLV9dK1xcLyk/KD86W2EtekEtWjAtOVxcLV9dKyk/I1swLTldK1xcYi8pKXJldHVybiBuLmNvbWJpbmVUb2tlbnMgPSAhMCwgXCJsaW5rXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubWF0Y2godCkgJiYgXCJdKFwiICE9IGUuc3RyaW5nLnNsaWNlKGUuc3RhcnQgLSAyLCBlLnN0YXJ0KSAmJiAoMCA9PSBlLnN0YXJ0IHx8IC9cXFcvLnRlc3QoZS5zdHJpbmcuY2hhckF0KGUuc3RhcnQgLSAxKSkpID8gKG4uY29tYmluZVRva2VucyA9ICEwLCBcImxpbmtcIikgOiAoZS5uZXh0KCksIG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBibGFua0xpbmU6IGlcbiAgICAgICAgICAgICAgICAgICAgfSwgbCA9IHt1bmRlcnNjb3Jlc0JyZWFrV29yZHM6ICExLCB0YXNrTGlzdHM6ICEwLCBmZW5jZWRDb2RlQmxvY2tzOiBcImBgYFwiLCBzdHJpa2V0aHJvdWdoOiAhMH07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgaW4gcilsW3NdID0gcltzXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwubmFtZSA9IFwibWFya2Rvd25cIiwgZS5vdmVybGF5TW9kZShlLmdldE1vZGUobiwgbCksIGEpXG4gICAgICAgICAgICAgICAgfSwgXCJtYXJrZG93blwiKSwgZS5kZWZpbmVNSU1FKFwidGV4dC94LWdmbVwiLCBcImdmbVwiKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwge1wiLi4vLi4vYWRkb24vbW9kZS9vdmVybGF5XCI6IDgsIFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIjogMTAsIFwiLi4vbWFya2Rvd24vbWFya2Rvd25cIjogMTJ9XSxcbiAgICAgICAgMTI6IFtmdW5jdGlvbiAodCwgbiwgcikge1xuICAgICAgICAgICAgIWZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PSB0eXBlb2YgciAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBuID8gaSh0KFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHQoXCIuLi94bWwveG1sXCIpLCB0KFwiLi4vbWV0YVwiKSkgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgJiYgZS5hbWQgPyBlKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4veG1sL3htbFwiLCBcIi4uL21ldGFcIl0sIGkpIDogaShDb2RlTWlycm9yKVxuICAgICAgICAgICAgfShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgICAgIGUuZGVmaW5lTW9kZShcIm1hcmtkb3duXCIsIGZ1bmN0aW9uICh0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHIobikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZmluZE1vZGVCeU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUuZmluZE1vZGVCeU5hbWUobik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciAmJiAobiA9IHIubWltZSB8fCByLm1pbWVzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlLmdldE1vZGUodCwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJudWxsXCIgPT0gaS5uYW1lID8gbnVsbCA6IGlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuZiA9IHQuaW5saW5lID0gbiwgbihlLCB0KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbyhlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5mID0gdC5ibG9jayA9IG4sIG4oZSwgdClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGEoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFlIHx8ICEvXFxTLy50ZXN0KGUuc3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5saW5rVGl0bGUgPSAhMSwgZS5lbSA9ICExLCBlLnN0cm9uZyA9ICExLCBlLnN0cmlrZXRocm91Z2ggPSAhMSwgZS5xdW90ZSA9IDAsIGUuaW5kZW50ZWRDb2RlID0gITEsIGsgJiYgZS5mID09IGMgJiYgKGUuZiA9IHAsIGUuYmxvY2sgPSBzKSwgZS50cmFpbGluZ1NwYWNlID0gMCwgZS50cmFpbGluZ1NwYWNlTmV3TGluZSA9ICExLCBlLnByZXZMaW5lID0gZS50aGlzTGluZSwgZS50aGlzTGluZSA9IG51bGwsIG51bGxcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHModCwgbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSB0LnNvbCgpLCBzID0gby5saXN0ICE9PSAhMSwgYyA9IG8uaW5kZW50ZWRDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5pbmRlbnRlZENvZGUgPSAhMSwgcyAmJiAoby5pbmRlbnRhdGlvbkRpZmYgPj0gMCA/IChvLmluZGVudGF0aW9uRGlmZiA8IDQgJiYgKG8uaW5kZW50YXRpb24gLT0gby5pbmRlbnRhdGlvbkRpZmYpLCBvLmxpc3QgPSBudWxsKSA6IG8uaW5kZW50YXRpb24gPiAwID8gby5saXN0ID0gbnVsbCA6IG8ubGlzdCA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmluZGVudGF0aW9uRGlmZiA+PSA0KXJldHVybiB0LnNraXBUb0VuZCgpLCBjIHx8IGEoby5wcmV2TGluZSkgPyAoby5pbmRlbnRhdGlvbiAtPSA0LCBvLmluZGVudGVkQ29kZSA9ICEwLCBTLmNvZGUpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LmVhdFNwYWNlKCkpcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGYgPSB0Lm1hdGNoKEEpKSAmJiBmWzFdLmxlbmd0aCA8PSA2KXJldHVybiBvLmhlYWRlciA9IGZbMV0ubGVuZ3RoLCBuLmhpZ2hsaWdodEZvcm1hdHRpbmcgJiYgKG8uZm9ybWF0dGluZyA9IFwiaGVhZGVyXCIpLCBvLmYgPSBvLmlubGluZSwgaChvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGEoby5wcmV2TGluZSkgfHwgby5xdW90ZSB8fCBzIHx8IGMpICYmIChmID0gdC5tYXRjaChFKSkpcmV0dXJuIG8uaGVhZGVyID0gXCI9XCIgPT0gZlswXS5jaGFyQXQoMCkgPyAxIDogMiwgbi5oaWdobGlnaHRGb3JtYXR0aW5nICYmIChvLmZvcm1hdHRpbmcgPSBcImhlYWRlclwiKSwgby5mID0gby5pbmxpbmUsIGgobyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5lYXQoXCI+XCIpKXJldHVybiBvLnF1b3RlID0gbCA/IDEgOiBvLnF1b3RlICsgMSwgbi5oaWdobGlnaHRGb3JtYXR0aW5nICYmIChvLmZvcm1hdHRpbmcgPSBcInF1b3RlXCIpLCB0LmVhdFNwYWNlKCksIGgobyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJbXCIgPT09IHQucGVlaygpKXJldHVybiBpKHQsIG8sIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQubWF0Y2goTCwgITApKXJldHVybiBvLmhyID0gITAsIFMuaHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGEoby5wcmV2TGluZSkgfHwgcykgJiYgKHQubWF0Y2goVCwgITEpIHx8IHQubWF0Y2goTSwgITEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHQubWF0Y2goVCwgITApID8gZCA9IFwidWxcIiA6ICh0Lm1hdGNoKE0sICEwKSwgZCA9IFwib2xcIiksIG8uaW5kZW50YXRpb24gPSB0LmNvbHVtbigpICsgdC5jdXJyZW50KCkubGVuZ3RoLCBvLmxpc3QgPSAhMDsgby5saXN0U3RhY2sgJiYgdC5jb2x1bW4oKSA8IG8ubGlzdFN0YWNrW28ubGlzdFN0YWNrLmxlbmd0aCAtIDFdOylvLmxpc3RTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gby5saXN0U3RhY2sucHVzaChvLmluZGVudGF0aW9uKSwgbi50YXNrTGlzdHMgJiYgdC5tYXRjaChOLCAhMSkgJiYgKG8udGFza0xpc3QgPSAhMCksIG8uZiA9IG8uaW5saW5lLCBuLmhpZ2hsaWdodEZvcm1hdHRpbmcgJiYgKG8uZm9ybWF0dGluZyA9IFtcImxpc3RcIiwgXCJsaXN0LVwiICsgZF0pLCBoKG8pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5mZW5jZWRDb2RlQmxvY2tzICYmIChmID0gdC5tYXRjaChJLCAhMCkpID8gKG8uZmVuY2VkQ2hhcnMgPSBmWzFdLCBvLmxvY2FsTW9kZSA9IHIoZlsyXSksIG8ubG9jYWxNb2RlICYmIChvLmxvY2FsU3RhdGUgPSBlLnN0YXJ0U3RhdGUoby5sb2NhbE1vZGUpKSwgby5mID0gby5ibG9jayA9IHUsIG4uaGlnaGxpZ2h0Rm9ybWF0dGluZyAmJiAoby5mb3JtYXR0aW5nID0gXCJjb2RlLWJsb2NrXCIpLCBvLmNvZGUgPSAtMSwgaChvKSkgOiBpKHQsIG8sIG8uaW5saW5lKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYyh0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHcudG9rZW4odCwgbi5odG1sU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlLmlubmVyTW9kZSh3LCBuLmh0bWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwieG1sXCIgPT0gaS5tb2RlLm5hbWUgJiYgbnVsbCA9PT0gaS5zdGF0ZS50YWdTdGFydCAmJiAhaS5zdGF0ZS5jb250ZXh0ICYmIGkuc3RhdGUudG9rZW5pemUuaXNJblRleHQgfHwgbi5tZF9pbnNpZGUgJiYgdC5jdXJyZW50KCkuaW5kZXhPZihcIj5cIikgPiAtMSkgJiYgKG4uZiA9IHAsIG4uYmxvY2sgPSBzLCBuLmh0bWxTdGF0ZSA9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gclxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5mZW5jZWRDaGFycyAmJiBlLm1hdGNoKHQuZmVuY2VkQ2hhcnMsICExKSA/ICh0LmxvY2FsTW9kZSA9IHQubG9jYWxTdGF0ZSA9IG51bGwsIHQuZiA9IHQuYmxvY2sgPSBmLCBudWxsKSA6IHQubG9jYWxNb2RlID8gdC5sb2NhbE1vZGUudG9rZW4oZSwgdC5sb2NhbFN0YXRlKSA6IChlLnNraXBUb0VuZCgpLCBTLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubWF0Y2godC5mZW5jZWRDaGFycyksIHQuYmxvY2sgPSBzLCB0LmYgPSBwLCB0LmZlbmNlZENoYXJzID0gbnVsbCwgbi5oaWdobGlnaHRGb3JtYXR0aW5nICYmICh0LmZvcm1hdHRpbmcgPSBcImNvZGUtYmxvY2tcIiksIHQuY29kZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGgodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5jb2RlID0gMCwgclxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZm9ybWF0dGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQucHVzaChTLmZvcm1hdHRpbmcpLCBcInN0cmluZ1wiID09IHR5cGVvZiBlLmZvcm1hdHRpbmcgJiYgKGUuZm9ybWF0dGluZyA9IFtlLmZvcm1hdHRpbmddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGUuZm9ybWF0dGluZy5sZW5ndGg7IHIrKyl0LnB1c2goUy5mb3JtYXR0aW5nICsgXCItXCIgKyBlLmZvcm1hdHRpbmdbcl0pLCBcImhlYWRlclwiID09PSBlLmZvcm1hdHRpbmdbcl0gJiYgdC5wdXNoKFMuZm9ybWF0dGluZyArIFwiLVwiICsgZS5mb3JtYXR0aW5nW3JdICsgXCItXCIgKyBlLmhlYWRlciksIFwicXVvdGVcIiA9PT0gZS5mb3JtYXR0aW5nW3JdICYmICghbi5tYXhCbG9ja3F1b3RlRGVwdGggfHwgbi5tYXhCbG9ja3F1b3RlRGVwdGggPj0gZS5xdW90ZSA/IHQucHVzaChTLmZvcm1hdHRpbmcgKyBcIi1cIiArIGUuZm9ybWF0dGluZ1tyXSArIFwiLVwiICsgZS5xdW90ZSkgOiB0LnB1c2goXCJlcnJvclwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnRhc2tPcGVuKXJldHVybiB0LnB1c2goXCJtZXRhXCIpLCB0Lmxlbmd0aCA/IHQuam9pbihcIiBcIikgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUudGFza0Nsb3NlZClyZXR1cm4gdC5wdXNoKFwicHJvcGVydHlcIiksIHQubGVuZ3RoID8gdC5qb2luKFwiIFwiKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5saW5rSHJlZiA/IHQucHVzaChTLmxpbmtIcmVmLCBcInVybFwiKSA6IChlLnN0cm9uZyAmJiB0LnB1c2goUy5zdHJvbmcpLCBlLmVtICYmIHQucHVzaChTLmVtKSwgZS5zdHJpa2V0aHJvdWdoICYmIHQucHVzaChTLnN0cmlrZXRocm91Z2gpLCBlLmxpbmtUZXh0ICYmIHQucHVzaChTLmxpbmtUZXh0KSwgZS5jb2RlICYmIHQucHVzaChTLmNvZGUpKSwgZS5oZWFkZXIgJiYgdC5wdXNoKFMuaGVhZGVyLCBTLmhlYWRlciArIFwiLVwiICsgZS5oZWFkZXIpLCBlLnF1b3RlICYmICh0LnB1c2goUy5xdW90ZSksICFuLm1heEJsb2NrcXVvdGVEZXB0aCB8fCBuLm1heEJsb2NrcXVvdGVEZXB0aCA+PSBlLnF1b3RlID8gdC5wdXNoKFMucXVvdGUgKyBcIi1cIiArIGUucXVvdGUpIDogdC5wdXNoKFMucXVvdGUgKyBcIi1cIiArIG4ubWF4QmxvY2txdW90ZURlcHRoKSksIGUubGlzdCAhPT0gITEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IChlLmxpc3RTdGFjay5sZW5ndGggLSAxKSAlIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA/IDEgPT09IGkgPyB0LnB1c2goUy5saXN0MikgOiB0LnB1c2goUy5saXN0MykgOiB0LnB1c2goUy5saXN0MSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnRyYWlsaW5nU3BhY2VOZXdMaW5lID8gdC5wdXNoKFwidHJhaWxpbmctc3BhY2UtbmV3LWxpbmVcIikgOiBlLnRyYWlsaW5nU3BhY2UgJiYgdC5wdXNoKFwidHJhaWxpbmctc3BhY2UtXCIgKyAoZS50cmFpbGluZ1NwYWNlICUgMiA/IFwiYVwiIDogXCJiXCIpKSwgdC5sZW5ndGggPyB0LmpvaW4oXCIgXCIpIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5tYXRjaChPLCAhMCkgPyBoKHQpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBwKHQsIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gci50ZXh0KHQsIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGkpcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5saXN0KXJldHVybiByLmxpc3QgPSBudWxsLCBoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIudGFza0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFwieFwiICE9PSB0Lm1hdGNoKE4sICEwKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA/IHIudGFza09wZW4gPSAhMCA6IHIudGFza0Nsb3NlZCA9ICEwLCBuLmhpZ2hsaWdodEZvcm1hdHRpbmcgJiYgKHIuZm9ybWF0dGluZyA9IFwidGFza1wiKSwgci50YXNrTGlzdCA9ICExLCBoKHIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci50YXNrT3BlbiA9ICExLCByLnRhc2tDbG9zZWQgPSAhMSwgci5oZWFkZXIgJiYgdC5tYXRjaCgvXiMrJC8sICEwKSlyZXR1cm4gbi5oaWdobGlnaHRGb3JtYXR0aW5nICYmIChyLmZvcm1hdHRpbmcgPSBcImhlYWRlclwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSB0LnNvbCgpLCBzID0gdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5saW5rVGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmxpbmtUaXRsZSA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIiA9PT0gcyAmJiAodSA9IFwiKVwiKSwgdSA9ICh1ICsgXCJcIikucmVwbGFjZSgvKFsuPyorXiRbXFxdXFxcXCgpe318LV0pL2csIFwiXFxcXCQxXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gXCJeXFxcXHMqKD86W15cIiArIHUgKyBcIlxcXFxcXFxcXSt8XFxcXFxcXFxcXFxcXFxcXHxcXFxcXFxcXC4pXCIgKyB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0Lm1hdGNoKG5ldyBSZWdFeHAoZiksICEwKSlyZXR1cm4gUy5saW5rSHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiYFwiID09PSBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSByLmZvcm1hdHRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5oaWdobGlnaHRGb3JtYXR0aW5nICYmIChyLmZvcm1hdHRpbmcgPSBcImNvZGVcIiksIHQuZWF0V2hpbGUoXCJgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gdC5jdXJyZW50KCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09IHIuY29kZSlyZXR1cm4gci5jb2RlID0gcCwgaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocCA9PSByLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gci5jb2RlID0gMCwgdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gci5mb3JtYXR0aW5nID0gZCwgaChyKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuY29kZSlyZXR1cm4gaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIlxcXFxcIiA9PT0gcyAmJiAodC5uZXh0KCksIG4uaGlnaGxpZ2h0Rm9ybWF0dGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGgociksIHggPSBTLmZvcm1hdHRpbmcgKyBcIi1lc2NhcGVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geSA/IHkgKyBcIiBcIiArIHggOiB4XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCIhXCIgPT09IHMgJiYgdC5tYXRjaCgvXFxbW15cXF1dKlxcXSA/KD86XFwofFxcWykvLCAhMSkpcmV0dXJuIHQubWF0Y2goL1xcW1teXFxdXSpcXF0vKSwgci5pbmxpbmUgPSByLmYgPSBnLCBTLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiW1wiID09PSBzICYmIHQubWF0Y2goL1teXFxdXSpcXF0oXFwoLipcXCl8ID9cXFsuKj9cXF0pLywgITEpKXJldHVybiByLmxpbmtUZXh0ID0gITAsIG4uaGlnaGxpZ2h0Rm9ybWF0dGluZyAmJiAoci5mb3JtYXR0aW5nID0gXCJsaW5rXCIpLCBoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiXVwiID09PSBzICYmIHIubGlua1RleHQgJiYgdC5tYXRjaCgvXFwoLio/XFwpfCA/XFxbLio/XFxdLywgITEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5oaWdobGlnaHRGb3JtYXR0aW5nICYmIChyLmZvcm1hdHRpbmcgPSBcImxpbmtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByLmxpbmtUZXh0ID0gITEsIHIuaW5saW5lID0gci5mID0gZywgeVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiPFwiID09PSBzICYmIHQubWF0Y2goL14oaHR0cHM/fGZ0cHM/KTpcXC9cXC8oPzpbXlxcXFw+XXxcXFxcLikrPi8sICExKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIuZiA9IHIuaW5saW5lID0gbSwgbi5oaWdobGlnaHRGb3JtYXR0aW5nICYmIChyLmZvcm1hdHRpbmcgPSBcImxpbmtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5ID8geSArPSBcIiBcIiA6IHkgPSBcIlwiLCB5ICsgUy5saW5rSW5saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCI8XCIgPT09IHMgJiYgdC5tYXRjaCgvXltePiBcXFxcXStAKD86W15cXFxcPl18XFxcXC4pKz4vLCAhMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmYgPSByLmlubGluZSA9IG0sIG4uaGlnaGxpZ2h0Rm9ybWF0dGluZyAmJiAoci5mb3JtYXR0aW5nID0gXCJsaW5rXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geSA/IHkgKz0gXCIgXCIgOiB5ID0gXCJcIiwgeSArIFMubGlua0VtYWlsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCI8XCIgPT09IHMgJiYgdC5tYXRjaCgvXighLS18XFx3KS8sICExKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gdC5zdHJpbmcuaW5kZXhPZihcIj5cIiwgdC5wb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPSBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gdC5zdHJpbmcuc3Vic3RyaW5nKHQuc3RhcnQsIGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvbWFya2Rvd25cXHMqPVxccyooJ3xcIil7MCwxfTEoJ3xcIil7MCwxfS8udGVzdChrKSAmJiAoci5tZF9pbnNpZGUgPSAhMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuYmFja1VwKDEpLCByLmh0bWxTdGF0ZSA9IGUuc3RhcnRTdGF0ZSh3KSwgbyh0LCByLCBjKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiPFwiID09PSBzICYmIHQubWF0Y2goL15cXC9cXHcqPz4vKSlyZXR1cm4gci5tZF9pbnNpZGUgPSAhMSwgXCJ0YWdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW4udW5kZXJzY29yZXNCcmVha1dvcmRzICYmIFwiX1wiID09PSBzICYmIFwiX1wiICE9PSB0LnBlZWsoKSAmJiB0Lm1hdGNoKC8oXFx3KS8sICExKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBMID0gdC5wb3MgLSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFQgPSB0LnN0cmluZy5jaGFyQXQoTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiX1wiICE9PSBUICYmIFQubWF0Y2goLyhcXHcpLywgITEpICYmIChDID0gITApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiKlwiID09PSBzIHx8IFwiX1wiID09PSBzICYmICFDKWlmIChsICYmIFwiIFwiID09PSB0LnBlZWsoKSk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLnN0cm9uZyA9PT0gcyAmJiB0LmVhdChzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLmhpZ2hsaWdodEZvcm1hdHRpbmcgJiYgKHIuZm9ybWF0dGluZyA9IFwic3Ryb25nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGgocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByLnN0cm9uZyA9ICExLCB2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghci5zdHJvbmcgJiYgdC5lYXQocykpcmV0dXJuIHIuc3Ryb25nID0gcywgbi5oaWdobGlnaHRGb3JtYXR0aW5nICYmIChyLmZvcm1hdHRpbmcgPSBcInN0cm9uZ1wiKSwgaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5lbSA9PT0gcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLmhpZ2hsaWdodEZvcm1hdHRpbmcgJiYgKHIuZm9ybWF0dGluZyA9IFwiZW1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIuZW0gPSAhMSwgdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXIuZW0pcmV0dXJuIHIuZW0gPSBzLCBuLmhpZ2hsaWdodEZvcm1hdHRpbmcgJiYgKHIuZm9ybWF0dGluZyA9IFwiZW1cIiksIGgocilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIgXCIgPT09IHMgJiYgKHQuZWF0KFwiKlwiKSB8fCB0LmVhdChcIl9cIikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiIFwiID09PSB0LnBlZWsoKSlyZXR1cm4gaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmJhY2tVcCgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4uc3RyaWtldGhyb3VnaClpZiAoXCJ+XCIgPT09IHMgJiYgdC5lYXRXaGlsZShzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLnN0cmlrZXRocm91Z2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5oaWdobGlnaHRGb3JtYXR0aW5nICYmIChyLmZvcm1hdHRpbmcgPSBcInN0cmlrZXRocm91Z2hcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIuc3RyaWtldGhyb3VnaCA9ICExLCB2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0Lm1hdGNoKC9eW15cXHNdLywgITEpKXJldHVybiByLnN0cmlrZXRocm91Z2ggPSAhMCwgbi5oaWdobGlnaHRGb3JtYXR0aW5nICYmIChyLmZvcm1hdHRpbmcgPSBcInN0cmlrZXRocm91Z2hcIiksIGgocilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIgXCIgPT09IHMgJiYgdC5tYXRjaCgvXn5+LywgITApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiIFwiID09PSB0LnBlZWsoKSlyZXR1cm4gaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmJhY2tVcCgyKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiIFwiID09PSBzICYmICh0Lm1hdGNoKC8gKyQvLCAhMSkgPyByLnRyYWlsaW5nU3BhY2UrKyA6IHIudHJhaWxpbmdTcGFjZSAmJiAoci50cmFpbGluZ1NwYWNlTmV3TGluZSA9ICEwKSksIGgocilcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG0oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIj5cIiA9PT0gcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuZiA9IHQuaW5saW5lID0gcCwgbi5oaWdobGlnaHRGb3JtYXR0aW5nICYmICh0LmZvcm1hdHRpbmcgPSBcImxpbmtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBoKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpID8gaSArPSBcIiBcIiA6IGkgPSBcIlwiLCBpICsgUy5saW5rSW5saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5tYXRjaCgvXltePl0rLywgITApLCBTLmxpbmtJbmxpbmVcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGcoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZWF0U3BhY2UoKSlyZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIoXCIgPT09IHIgfHwgXCJbXCIgPT09IHIgPyAodC5mID0gdC5pbmxpbmUgPSB2KFwiKFwiID09PSByID8gXCIpXCIgOiBcIl1cIiwgMCksIG4uaGlnaGxpZ2h0Rm9ybWF0dGluZyAmJiAodC5mb3JtYXR0aW5nID0gXCJsaW5rLXN0cmluZ1wiKSwgdC5saW5rSHJlZiA9ICEwLCBoKHQpKSA6IFwiZXJyb3JcIlxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIuZiA9IHIuaW5saW5lID0gcCwgbi5oaWdobGlnaHRGb3JtYXR0aW5nICYmIChyLmZvcm1hdHRpbmcgPSBcImxpbmstc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGgocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByLmxpbmtIcmVmID0gITEsIG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQubWF0Y2goUFtlXSksIHIubGlua0hyZWYgPSAhMCwgaChyKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24geShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5tYXRjaCgvXihbXlxcXVxcXFxdfFxcXFwuKSpcXF06LywgITEpID8gKHQuZiA9IHgsIGUubmV4dCgpLCBuLmhpZ2hsaWdodEZvcm1hdHRpbmcgJiYgKHQuZm9ybWF0dGluZyA9IFwibGlua1wiKSwgdC5saW5rVGV4dCA9ICEwLCBoKHQpKSA6IGkoZSwgdCwgcClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHgoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUubWF0Y2goL15cXF06LywgITApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5mID0gdC5pbmxpbmUgPSBiLCBuLmhpZ2hsaWdodEZvcm1hdHRpbmcgJiYgKHQuZm9ybWF0dGluZyA9IFwibGlua1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGgodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQubGlua1RleHQgPSAhMSwgclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubWF0Y2goL14oW15cXF1cXFxcXXxcXFxcLikrLywgITApLCBTLmxpbmtUZXh0XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBiKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmVhdFNwYWNlKCkgPyBudWxsIDogKGUubWF0Y2goL15bXlxcc10rLywgITApLCB2b2lkIDAgPT09IGUucGVlaygpID8gdC5saW5rVGl0bGUgPSAhMCA6IGUubWF0Y2goL14oPzpcXHMrKD86XCIoPzpbXlwiXFxcXF18XFxcXFxcXFx8XFxcXC4pK1wifCcoPzpbXidcXFxcXXxcXFxcXFxcXHxcXFxcLikrJ3xcXCgoPzpbXilcXFxcXXxcXFxcXFxcXHxcXFxcLikrXFwpKSk/LywgITApLCB0LmYgPSB0LmlubGluZSA9IHAsIFMubGlua0hyZWYgKyBcIiB1cmxcIilcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gZS5nZXRNb2RlKHQsIFwidGV4dC9odG1sXCIpLCBrID0gXCJudWxsXCIgPT0gdy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG4uaGlnaGxpZ2h0Rm9ybWF0dGluZyAmJiAobi5oaWdobGlnaHRGb3JtYXR0aW5nID0gITEpLCB2b2lkIDAgPT09IG4ubWF4QmxvY2txdW90ZURlcHRoICYmIChuLm1heEJsb2NrcXVvdGVEZXB0aCA9IDApLCB2b2lkIDAgPT09IG4udW5kZXJzY29yZXNCcmVha1dvcmRzICYmIChuLnVuZGVyc2NvcmVzQnJlYWtXb3JkcyA9ICEwKSwgdm9pZCAwID09PSBuLnRhc2tMaXN0cyAmJiAobi50YXNrTGlzdHMgPSAhMSksIHZvaWQgMCA9PT0gbi5zdHJpa2V0aHJvdWdoICYmIChuLnN0cmlrZXRocm91Z2ggPSAhMSksIHZvaWQgMCA9PT0gbi50b2tlblR5cGVPdmVycmlkZXMgJiYgKG4udG9rZW5UeXBlT3ZlcnJpZGVzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgUyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiY29tbWVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGU6IFwicXVvdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QxOiBcInZhcmlhYmxlLTJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QyOiBcInZhcmlhYmxlLTNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QzOiBcImtleXdvcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyOiBcImhyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogXCJ0YWdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IFwiZm9ybWF0dGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua0lubGluZTogXCJsaW5rXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rRW1haWw6IFwibGlua1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua1RleHQ6IFwibGlua1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua0hyZWY6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbTogXCJlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb25nOiBcInN0cm9uZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWtldGhyb3VnaDogXCJzdHJpa2V0aHJvdWdoXCJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgQyBpbiBTKVMuaGFzT3duUHJvcGVydHkoQykgJiYgbi50b2tlblR5cGVPdmVycmlkZXNbQ10gJiYgKFNbQ10gPSBuLnRva2VuVHlwZU92ZXJyaWRlc1tDXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBMID0gL14oWypcXC1fXSkoPzpcXHMqXFwxKXsyLH1cXHMqJC8sIFQgPSAvXlsqXFwtK11cXHMrLywgTSA9IC9eWzAtOV0rKFsuKV0pXFxzKy8sXG4gICAgICAgICAgICAgICAgICAgICAgICBOID0gL15cXFsoeHwgKVxcXSg/PVxccykvLCBBID0gbi5hbGxvd0F0eEhlYWRlcldpdGhvdXRTcGFjZSA/IC9eKCMrKS8gOiAvXigjKykoPzogfCQpLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIEUgPSAvXiAqKD86XFw9ezEsfXwtezEsfSlcXHMqJC8sIE8gPSAvXlteIyFcXFtcXF0qX1xcXFw8PmAgXCInKH5dKy8sXG4gICAgICAgICAgICAgICAgICAgICAgICBJID0gbmV3IFJlZ0V4cChcIl4oXCIgKyAobi5mZW5jZWRDb2RlQmxvY2tzID09PSAhMCA/IFwifn5+K3xgYGArXCIgOiBuLmZlbmNlZENvZGVCbG9ja3MpICsgXCIpWyBcXFxcdF0qKFtcXFxcdysjLV0qKVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIpXCI6IC9eKD86W15cXFxcXFwoXFwpXXxcXFxcLnxcXCgoPzpbXlxcXFxcXChcXCldfFxcXFwuKSpcXCkpKj8oPz1cXCkpLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIl1cIjogL14oPzpbXlxcXFxcXFtcXF1dfFxcXFwufFxcWyg/OlteXFxcXFxcW1xcXFxdXXxcXFxcLikqXFxdKSo/KD89XFxdKS9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZjogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZMaW5lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0xpbmU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jazogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxTdGF0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudGF0aW9uOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5saW5lOiBwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua1RleHQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua0hyZWY6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua1RpdGxlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJvbmc6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHI6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFza0xpc3Q6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0U3RhY2s6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1NwYWNlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdTcGFjZU5ld0xpbmU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWtldGhyb3VnaDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZW5jZWRDaGFyczogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29weVN0YXRlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZjogdC5mLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldkxpbmU6IHQucHJldkxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzTGluZTogdC50aGlzTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrOiB0LmJsb2NrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbFN0YXRlOiB0Lmh0bWxTdGF0ZSAmJiBlLmNvcHlTdGF0ZSh3LCB0Lmh0bWxTdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnRhdGlvbjogdC5pbmRlbnRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsTW9kZTogdC5sb2NhbE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlOiB0LmxvY2FsTW9kZSA/IGUuY29weVN0YXRlKHQubG9jYWxNb2RlLCB0LmxvY2FsU3RhdGUpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubGluZTogdC5pbmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0LnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtUaXRsZTogdC5saW5rVGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiB0LmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbTogdC5lbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9uZzogdC5zdHJvbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpa2V0aHJvdWdoOiB0LnN0cmlrZXRocm91Z2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IHQuaGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHI6IHQuaHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrTGlzdDogdC50YXNrTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Q6IHQubGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RTdGFjazogdC5saXN0U3RhY2suc2xpY2UoMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90ZTogdC5xdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudGVkQ29kZTogdC5pbmRlbnRlZENvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1NwYWNlOiB0LnRyYWlsaW5nU3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1NwYWNlTmV3TGluZTogdC50cmFpbGluZ1NwYWNlTmV3TGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1kX2luc2lkZTogdC5tZF9pbnNpZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZW5jZWRDaGFyczogdC5mZW5jZWRDaGFyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdG9rZW46IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LmZvcm1hdHRpbmcgPSAhMSwgZSAhPSB0LnRoaXNMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHQuaGVhZGVyIHx8IHQuaHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5oZWFkZXIgPSAwLCB0LmhyID0gITEsIGUubWF0Y2goL15cXHMqJC8sICEwKSB8fCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwodCksICFuKXJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQucHJldkxpbmUgPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnByZXZMaW5lID0gdC50aGlzTGluZSwgdC50aGlzTGluZSA9IGUsIHQudGFza0xpc3QgPSAhMSwgdC50cmFpbGluZ1NwYWNlID0gMCwgdC50cmFpbGluZ1NwYWNlTmV3TGluZSA9ICExLCB0LmYgPSB0LmJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlLm1hdGNoKC9eXFxzKi8sICEwKVswXS5yZXBsYWNlKC9cXHQvZywgXCIgICAgXCIpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LmluZGVudGF0aW9uRGlmZiA9IE1hdGgubWluKHIgLSB0LmluZGVudGF0aW9uLCA0KSwgdC5pbmRlbnRhdGlvbiA9IHQuaW5kZW50YXRpb24gKyB0LmluZGVudGF0aW9uRGlmZiwgciA+IDApcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5mKGUsIHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgaW5uZXJNb2RlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5ibG9jayA9PSBjID8ge3N0YXRlOiBlLmh0bWxTdGF0ZSwgbW9kZTogd30gOiBlLmxvY2FsU3RhdGUgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogZS5sb2NhbFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogZS5sb2NhbE1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHtzdGF0ZTogZSwgbW9kZTogUn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBibGFua0xpbmU6IGwsIGdldFR5cGU6IGgsIGZvbGQ6IFwibWFya2Rvd25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJcbiAgICAgICAgICAgICAgICB9LCBcInhtbFwiKSwgZS5kZWZpbmVNSU1FKFwidGV4dC94LW1hcmtkb3duXCIsIFwibWFya2Rvd25cIilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIHtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCI6IDEwLCBcIi4uL21ldGFcIjogMTMsIFwiLi4veG1sL3htbFwiOiAxNH1dLFxuICAgICAgICAxMzogW2Z1bmN0aW9uICh0LCBuLCByKSB7XG4gICAgICAgICAgICAhZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09IHR5cGVvZiByICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG4gPyBpKHQoXCIuLi9saWIvY29kZW1pcnJvclwiKSkgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgJiYgZS5hbWQgPyBlKFtcIi4uL2xpYi9jb2RlbWlycm9yXCJdLCBpKSA6IGkoQ29kZU1pcnJvcilcbiAgICAgICAgICAgIH0oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgICAgICBlLm1vZGVJbmZvID0gW3tuYW1lOiBcIkFQTFwiLCBtaW1lOiBcInRleHQvYXBsXCIsIG1vZGU6IFwiYXBsXCIsIGV4dDogW1wiZHlhbG9nXCIsIFwiYXBsXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlBHUFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lczogW1wiYXBwbGljYXRpb24vcGdwXCIsIFwiYXBwbGljYXRpb24vcGdwLWtleXNcIiwgXCJhcHBsaWNhdGlvbi9wZ3Atc2lnbmF0dXJlXCJdLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImFzY2lpYXJtb3JcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJwZ3BcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJBU04uMVwiLCBtaW1lOiBcInRleHQveC10dGNuLWFzblwiLCBtb2RlOiBcImFzbi4xXCIsIGV4dDogW1wiYXNuXCIsIFwiYXNuMVwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJBc3Rlcmlza1wiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1hc3Rlcmlza1wiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImFzdGVyaXNrXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IC9eZXh0ZW5zaW9uc1xcLmNvbmYkL2lcbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJCcmFpbmZ1Y2tcIiwgbWltZTogXCJ0ZXh0L3gtYnJhaW5mdWNrXCIsIG1vZGU6IFwiYnJhaW5mdWNrXCIsIGV4dDogW1wiYlwiLCBcImJmXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtY3NyY1wiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNsaWtlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiY1wiLCBcImhcIl1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQysrXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LWMrK3NyY1wiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNsaWtlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiY3BwXCIsIFwiYysrXCIsIFwiY2NcIiwgXCJjeHhcIiwgXCJocHBcIiwgXCJoKytcIiwgXCJoaFwiLCBcImh4eFwiXSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFtcImNwcFwiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIkNvYm9sXCIsIG1pbWU6IFwidGV4dC94LWNvYm9sXCIsIG1vZGU6IFwiY29ib2xcIiwgZXh0OiBbXCJjb2JcIiwgXCJjcHlcIl19LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQyNcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtY3NoYXJwXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiY2xpa2VcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJjc1wiXSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFtcImNzaGFycFwiXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJDbG9qdXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LWNsb2p1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJjbG9qdXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiY2xqXCIsIFwiY2xqY1wiLCBcImNsanhcIl1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQ2xvanVyZVNjcmlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1jbG9qdXJlc2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiY2xvanVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcImNsanNcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJDbG9zdXJlIFN0eWxlc2hlZXRzIChHU1MpXCIsIG1pbWU6IFwidGV4dC94LWdzc1wiLCBtb2RlOiBcImNzc1wiLCBleHQ6IFtcImdzc1wiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJDTWFrZVwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1jbWFrZVwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNtYWtlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiY21ha2VcIiwgXCJjbWFrZS5pblwiXSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogL15DTWFrZUxpc3RzLnR4dCQvXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvZmZlZVNjcmlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1jb2ZmZWVzY3JpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJjb2ZmZWVzY3JpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJjb2ZmZWVcIl0sXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzOiBbXCJjb2ZmZWVcIiwgXCJjb2ZmZWUtc2NyaXB0XCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbW1vbiBMaXNwXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LWNvbW1vbi1saXNwXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiY29tbW9ubGlzcFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcImNsXCIsIFwibGlzcFwiLCBcImVsXCJdLFxuICAgICAgICAgICAgICAgICAgICBhbGlhczogW1wibGlzcFwiXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJDeXBoZXJcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJhcHBsaWNhdGlvbi94LWN5cGhlci1xdWVyeVwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImN5cGhlclwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcImN5cFwiLCBcImN5cGhlclwiXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJDeXRob25cIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtY3l0aG9uXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwicHl0aG9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wicHl4XCIsIFwicHhkXCIsIFwicHhpXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiQ3J5c3RhbFwiLCBtaW1lOiBcInRleHQveC1jcnlzdGFsXCIsIG1vZGU6IFwiY3J5c3RhbFwiLCBleHQ6IFtcImNyXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNTU1wiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQvY3NzXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiY3NzXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiY3NzXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiQ1FMXCIsIG1pbWU6IFwidGV4dC94LWNhc3NhbmRyYVwiLCBtb2RlOiBcInNxbFwiLCBleHQ6IFtcImNxbFwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJEXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LWRcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJkXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiZFwiXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJEYXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWVzOiBbXCJhcHBsaWNhdGlvbi9kYXJ0XCIsIFwidGV4dC94LWRhcnRcIl0sXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiZGFydFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcImRhcnRcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJkaWZmXCIsIG1pbWU6IFwidGV4dC94LWRpZmZcIiwgbW9kZTogXCJkaWZmXCIsIGV4dDogW1wiZGlmZlwiLCBcInBhdGNoXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkRqYW5nb1wiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1kamFuZ29cIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJkamFuZ29cIlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJEb2NrZXJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LWRvY2tlcmZpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJkb2NrZXJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IC9eRG9ja2VyZmlsZSQvXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiRFREXCIsIG1pbWU6IFwiYXBwbGljYXRpb24veG1sLWR0ZFwiLCBtb2RlOiBcImR0ZFwiLCBleHQ6IFtcImR0ZFwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJEeWxhblwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1keWxhblwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImR5bGFuXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiZHlsYW5cIiwgXCJkeWxcIiwgXCJpbnRyXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiRUJORlwiLCBtaW1lOiBcInRleHQveC1lYm5mXCIsIG1vZGU6IFwiZWJuZlwifSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkVDTFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1lY2xcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJlY2xcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJlY2xcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJlZG5cIiwgbWltZTogXCJhcHBsaWNhdGlvbi9lZG5cIiwgbW9kZTogXCJjbG9qdXJlXCIsIGV4dDogW1wiZWRuXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkVpZmZlbFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1laWZmZWxcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJlaWZmZWxcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJlXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiRWxtXCIsIG1pbWU6IFwidGV4dC94LWVsbVwiLCBtb2RlOiBcImVsbVwiLCBleHQ6IFtcImVsbVwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJFbWJlZGRlZCBKYXZhc2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwiYXBwbGljYXRpb24veC1lanNcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJodG1sZW1iZWRkZWRcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJlanNcIl1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiRW1iZWRkZWQgUnVieVwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcImFwcGxpY2F0aW9uL3gtZXJiXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiaHRtbGVtYmVkZGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiZXJiXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiRXJsYW5nXCIsIG1pbWU6IFwidGV4dC94LWVybGFuZ1wiLCBtb2RlOiBcImVybGFuZ1wiLCBleHQ6IFtcImVybFwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJGYWN0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtZmFjdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiZmFjdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiZmFjdG9yXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiRkNMXCIsIG1pbWU6IFwidGV4dC94LWZjbFwiLCBtb2RlOiBcImZjbFwifSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkZvcnRoXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LWZvcnRoXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiZm9ydGhcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJmb3J0aFwiLCBcImZ0aFwiLCBcIjR0aFwiXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJGb3J0cmFuXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LWZvcnRyYW5cIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJmb3J0cmFuXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiZlwiLCBcImZvclwiLCBcImY3N1wiLCBcImY5MFwiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIkYjXCIsIG1pbWU6IFwidGV4dC94LWZzaGFycFwiLCBtb2RlOiBcIm1sbGlrZVwiLCBleHQ6IFtcImZzXCJdLCBhbGlhczogW1wiZnNoYXJwXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkdhc1wiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1nYXNcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJnYXNcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJzXCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkdoZXJraW5cIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtZmVhdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImdoZXJraW5cIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJmZWF0dXJlXCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkdpdEh1YiBGbGF2b3JlZCBNYXJrZG93blwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1nZm1cIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJnZm1cIixcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogL14ocmVhZG1lfGNvbnRyaWJ1dGluZ3xoaXN0b3J5KS5tZCQvaVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIkdvXCIsIG1pbWU6IFwidGV4dC94LWdvXCIsIG1vZGU6IFwiZ29cIiwgZXh0OiBbXCJnb1wiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJHcm9vdnlcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtZ3Jvb3Z5XCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiZ3Jvb3Z5XCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiZ3Jvb3Z5XCIsIFwiZ3JhZGxlXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiSEFNTFwiLCBtaW1lOiBcInRleHQveC1oYW1sXCIsIG1vZGU6IFwiaGFtbFwiLCBleHQ6IFtcImhhbWxcIl19LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiSGFza2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1oYXNrZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiaGFza2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcImhzXCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkhhc2tlbGwgKExpdGVyYXRlKVwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1saXRlcmF0ZS1oYXNrZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiaGFza2VsbC1saXRlcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcImxoc1wiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIkhheGVcIiwgbWltZTogXCJ0ZXh0L3gtaGF4ZVwiLCBtb2RlOiBcImhheGVcIiwgZXh0OiBbXCJoeFwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJIWE1MXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LWh4bWxcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJoYXhlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiaHhtbFwiXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJBU1AuTkVUXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwiYXBwbGljYXRpb24veC1hc3B4XCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiaHRtbGVtYmVkZGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiYXNweFwiXSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFtcImFzcFwiLCBcImFzcHhcIl1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiSFRNTFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQvaHRtbFwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImh0bWxtaXhlZFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcImh0bWxcIiwgXCJodG1cIl0sXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzOiBbXCJ4aHRtbFwiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIkhUVFBcIiwgbWltZTogXCJtZXNzYWdlL2h0dHBcIiwgbW9kZTogXCJodHRwXCJ9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiSURMXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LWlkbFwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImlkbFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInByb1wiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIkphZGVcIiwgbWltZTogXCJ0ZXh0L3gtamFkZVwiLCBtb2RlOiBcImphZGVcIiwgZXh0OiBbXCJqYWRlXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkphdmFcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtamF2YVwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNsaWtlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiamF2YVwiXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJKYXZhIFNlcnZlciBQYWdlc1wiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcImFwcGxpY2F0aW9uL3gtanNwXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiaHRtbGVtYmVkZGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wianNwXCJdLFxuICAgICAgICAgICAgICAgICAgICBhbGlhczogW1wianNwXCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkphdmFTY3JpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZXM6IFtcInRleHQvamF2YXNjcmlwdFwiLCBcInRleHQvZWNtYXNjcmlwdFwiLCBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiwgXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcIiwgXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCJdLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImphdmFzY3JpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJqc1wiXSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFtcImVjbWFzY3JpcHRcIiwgXCJqc1wiLCBcIm5vZGVcIl1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiSlNPTlwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lczogW1wiYXBwbGljYXRpb24vanNvblwiLCBcImFwcGxpY2F0aW9uL3gtanNvblwiXSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJqYXZhc2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wianNvblwiLCBcIm1hcFwiXSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFtcImpzb241XCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkpTT04tTERcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJhcHBsaWNhdGlvbi9sZCtqc29uXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiamF2YXNjcmlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcImpzb25sZFwiXSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFtcImpzb25sZFwiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIkpTWFwiLCBtaW1lOiBcInRleHQvanN4XCIsIG1vZGU6IFwianN4XCIsIGV4dDogW1wianN4XCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkppbmphMlwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcIm51bGxcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJqaW5qYTJcIlxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIkp1bGlhXCIsIG1pbWU6IFwidGV4dC94LWp1bGlhXCIsIG1vZGU6IFwianVsaWFcIiwgZXh0OiBbXCJqbFwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJLb3RsaW5cIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gta290bGluXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiY2xpa2VcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJrdFwiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIkxFU1NcIiwgbWltZTogXCJ0ZXh0L3gtbGVzc1wiLCBtb2RlOiBcImNzc1wiLCBleHQ6IFtcImxlc3NcIl19LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiTGl2ZVNjcmlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1saXZlc2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwibGl2ZXNjcmlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcImxzXCJdLFxuICAgICAgICAgICAgICAgICAgICBhbGlhczogW1wibHNcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJMdWFcIiwgbWltZTogXCJ0ZXh0L3gtbHVhXCIsIG1vZGU6IFwibHVhXCIsIGV4dDogW1wibHVhXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk1hcmtkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LW1hcmtkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwibWFya2Rvd25cIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJtYXJrZG93blwiLCBcIm1kXCIsIFwibWtkXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwibUlSQ1wiLCBtaW1lOiBcInRleHQvbWlyY1wiLCBtb2RlOiBcIm1pcmNcIn0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJNYXJpYURCIFNRTFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1tYXJpYWRiXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwic3FsXCJcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiTWF0aGVtYXRpY2FcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtbWF0aGVtYXRpY2FcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJtYXRoZW1hdGljYVwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcIm1cIiwgXCJuYlwiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIk1vZGVsaWNhXCIsIG1pbWU6IFwidGV4dC94LW1vZGVsaWNhXCIsIG1vZGU6IFwibW9kZWxpY2FcIiwgZXh0OiBbXCJtb1wiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJNVU1QU1wiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1tdW1wc1wiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcIm11bXBzXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wibXBzXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiTVMgU1FMXCIsIG1pbWU6IFwidGV4dC94LW1zc3FsXCIsIG1vZGU6IFwic3FsXCJ9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwibWJveFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcImFwcGxpY2F0aW9uL21ib3hcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJtYm94XCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wibWJveFwiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIk15U1FMXCIsIG1pbWU6IFwidGV4dC94LW15c3FsXCIsIG1vZGU6IFwic3FsXCJ9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiTmdpbnhcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtbmdpbngtY29uZlwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcIm5naW54XCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IC9uZ2lueC4qXFwuY29uZiQvaVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIk5TSVNcIiwgbWltZTogXCJ0ZXh0L3gtbnNpc1wiLCBtb2RlOiBcIm5zaXNcIiwgZXh0OiBbXCJuc2hcIiwgXCJuc2lcIl19LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiTlRyaXBsZXNcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L24tdHJpcGxlc1wiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcIm50cmlwbGVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wibnRcIl1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiT2JqZWN0aXZlIENcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtb2JqZWN0aXZlY1wiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNsaWtlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wibVwiLCBcIm1tXCJdLFxuICAgICAgICAgICAgICAgICAgICBhbGlhczogW1wib2JqZWN0aXZlLWNcIiwgXCJvYmpjXCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9DYW1sXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LW9jYW1sXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwibWxsaWtlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wibWxcIiwgXCJtbGlcIiwgXCJtbGxcIiwgXCJtbHlcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJPY3RhdmVcIiwgbWltZTogXCJ0ZXh0L3gtb2N0YXZlXCIsIG1vZGU6IFwib2N0YXZlXCIsIGV4dDogW1wibVwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPelwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1velwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcIm96XCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wib3pcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJQYXNjYWxcIiwgbWltZTogXCJ0ZXh0L3gtcGFzY2FsXCIsIG1vZGU6IFwicGFzY2FsXCIsIGV4dDogW1wicFwiLCBcInBhc1wiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQRUcuanNcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJudWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwicGVnanNcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJqc29ubGRcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJQZXJsXCIsIG1pbWU6IFwidGV4dC94LXBlcmxcIiwgbW9kZTogXCJwZXJsXCIsIGV4dDogW1wicGxcIiwgXCJwbVwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQSFBcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJhcHBsaWNhdGlvbi94LWh0dHBkLXBocFwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInBocFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInBocFwiLCBcInBocDNcIiwgXCJwaHA0XCIsIFwicGhwNVwiLCBcInBodG1sXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiUGlnXCIsIG1pbWU6IFwidGV4dC94LXBpZ1wiLCBtb2RlOiBcInBpZ1wiLCBleHQ6IFtcInBpZ1wiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQbGFpbiBUZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC9wbGFpblwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcIm51bGxcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJ0eHRcIiwgXCJ0ZXh0XCIsIFwiY29uZlwiLCBcImRlZlwiLCBcImxpc3RcIiwgXCJsb2dcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJQTFNRTFwiLCBtaW1lOiBcInRleHQveC1wbHNxbFwiLCBtb2RlOiBcInNxbFwiLCBleHQ6IFtcInBsc1wiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQb3dlclNoZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwiYXBwbGljYXRpb24veC1wb3dlcnNoZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwicG93ZXJzaGVsbFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInBzMVwiLCBcInBzZDFcIiwgXCJwc20xXCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlByb3BlcnRpZXMgZmlsZXNcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtcHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJwcm9wZXJ0aWVzXCIsIFwiaW5pXCIsIFwiaW5cIl0sXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzOiBbXCJpbmlcIiwgXCJwcm9wZXJ0aWVzXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiUHJvdG9CdWZcIiwgbWltZTogXCJ0ZXh0L3gtcHJvdG9idWZcIiwgbW9kZTogXCJwcm90b2J1ZlwiLCBleHQ6IFtcInByb3RvXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlB5dGhvblwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1weXRob25cIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJweXRob25cIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJCVUlMRFwiLCBcImJ6bFwiLCBcInB5XCIsIFwicHl3XCJdLFxuICAgICAgICAgICAgICAgICAgICBmaWxlOiAvXihCVUNLfEJVSUxEKSQvXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiUHVwcGV0XCIsIG1pbWU6IFwidGV4dC94LXB1cHBldFwiLCBtb2RlOiBcInB1cHBldFwiLCBleHQ6IFtcInBwXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlFcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtcVwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInFcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJxXCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlJcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtcnNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInJcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJyXCJdLFxuICAgICAgICAgICAgICAgICAgICBhbGlhczogW1wicnNjcmlwdFwiXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJyZVN0cnVjdHVyZWRUZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LXJzdFwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInJzdFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInJzdFwiXSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFtcInJzdFwiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIlJQTSBDaGFuZ2VzXCIsIG1pbWU6IFwidGV4dC94LXJwbS1jaGFuZ2VzXCIsIG1vZGU6IFwicnBtXCJ9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUlBNIFNwZWNcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtcnBtLXNwZWNcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJycG1cIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJzcGVjXCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlJ1YnlcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtcnVieVwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInJ1YnlcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJyYlwiXSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFtcImpydWJ5XCIsIFwibWFjcnVieVwiLCBcInJha2VcIiwgXCJyYlwiLCBcInJieFwiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIlJ1c3RcIiwgbWltZTogXCJ0ZXh0L3gtcnVzdHNyY1wiLCBtb2RlOiBcInJ1c3RcIiwgZXh0OiBbXCJyc1wiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTQVNcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtc2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwic2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wic2FzXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiU2Fzc1wiLCBtaW1lOiBcInRleHQveC1zYXNzXCIsIG1vZGU6IFwic2Fzc1wiLCBleHQ6IFtcInNhc3NcIl19LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU2NhbGFcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtc2NhbGFcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJjbGlrZVwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInNjYWxhXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiU2NoZW1lXCIsIG1pbWU6IFwidGV4dC94LXNjaGVtZVwiLCBtb2RlOiBcInNjaGVtZVwiLCBleHQ6IFtcInNjbVwiLCBcInNzXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNDU1NcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtc2Nzc1wiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNzc1wiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInNjc3NcIl1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU2hlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtc2hcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJzaGVsbFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInNoXCIsIFwia3NoXCIsIFwiYmFzaFwiXSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFtcImJhc2hcIiwgXCJzaFwiLCBcInpzaFwiXSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogL15QS0dCVUlMRCQvXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiU2lldmVcIiwgbWltZTogXCJhcHBsaWNhdGlvbi9zaWV2ZVwiLCBtb2RlOiBcInNpZXZlXCIsIGV4dDogW1wic2l2XCIsIFwic2lldmVcIl19LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU2xpbVwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lczogW1widGV4dC94LXNsaW1cIiwgXCJhcHBsaWNhdGlvbi94LXNsaW1cIl0sXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwic2xpbVwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInNsaW1cIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJTbWFsbHRhbGtcIiwgbWltZTogXCJ0ZXh0L3gtc3RzcmNcIiwgbW9kZTogXCJzbWFsbHRhbGtcIiwgZXh0OiBbXCJzdFwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTbWFydHlcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtc21hcnR5XCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwic21hcnR5XCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1widHBsXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiU29sclwiLCBtaW1lOiBcInRleHQveC1zb2xyXCIsIG1vZGU6IFwic29sclwifSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNveVwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1zb3lcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJzb3lcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJzb3lcIl0sXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzOiBbXCJjbG9zdXJlIHRlbXBsYXRlXCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNQQVJRTFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcImFwcGxpY2F0aW9uL3NwYXJxbC1xdWVyeVwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInNwYXJxbFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInJxXCIsIFwic3BhcnFsXCJdLFxuICAgICAgICAgICAgICAgICAgICBhbGlhczogW1wic3BhcnVsXCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNwcmVhZHNoZWV0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LXNwcmVhZHNoZWV0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwic3ByZWFkc2hlZXRcIixcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFtcImV4Y2VsXCIsIFwiZm9ybXVsYVwiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIlNRTFwiLCBtaW1lOiBcInRleHQveC1zcWxcIiwgbW9kZTogXCJzcWxcIiwgZXh0OiBbXCJzcWxcIl19LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3F1aXJyZWxcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtc3F1aXJyZWxcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJjbGlrZVwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcIm51dFwiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIlN3aWZ0XCIsIG1pbWU6IFwidGV4dC94LXN3aWZ0XCIsIG1vZGU6IFwic3dpZnRcIiwgZXh0OiBbXCJzd2lmdFwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzVGVYXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC94LXN0ZXhcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJzdGV4XCJcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiTGFUZVhcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtbGF0ZXhcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJzdGV4XCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1widGV4dFwiLCBcImx0eFwiXSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFtcInRleFwiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcIlN5c3RlbVZlcmlsb2dcIiwgbWltZTogXCJ0ZXh0L3gtc3lzdGVtdmVyaWxvZ1wiLCBtb2RlOiBcInZlcmlsb2dcIiwgZXh0OiBbXCJ2XCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlRjbFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC10Y2xcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJ0Y2xcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJ0Y2xcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJUZXh0aWxlXCIsIG1pbWU6IFwidGV4dC94LXRleHRpbGVcIiwgbW9kZTogXCJ0ZXh0aWxlXCIsIGV4dDogW1widGV4dGlsZVwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJUaWRkbHlXaWtpIFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC10aWRkbHl3aWtpXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwidGlkZGx5d2lraVwiXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiVGlraSB3aWtpXCIsIG1pbWU6IFwidGV4dC90aWtpXCIsIG1vZGU6IFwidGlraVwifSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlRPTUxcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtdG9tbFwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInRvbWxcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJ0b21sXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiVG9ybmFkb1wiLCBtaW1lOiBcInRleHQveC10b3JuYWRvXCIsIG1vZGU6IFwidG9ybmFkb1wifSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInRyb2ZmXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC90cm9mZlwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInRyb2ZmXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlRUQ05cIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJ0ZXh0L3gtdHRjblwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInR0Y25cIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJ0dGNuXCIsIFwidHRjbjNcIiwgXCJ0dGNucHBcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJUVENOX0NGR1wiLCBtaW1lOiBcInRleHQveC10dGNuLWNmZ1wiLCBtb2RlOiBcInR0Y24tY2ZnXCIsIGV4dDogW1wiY2ZnXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlR1cnRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQvdHVydGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwidHVydGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1widHRsXCJdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlR5cGVTY3JpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZTogXCJhcHBsaWNhdGlvbi90eXBlc2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiamF2YXNjcmlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInRzXCJdLFxuICAgICAgICAgICAgICAgICAgICBhbGlhczogW1widHNcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJUd2lnXCIsIG1pbWU6IFwidGV4dC94LXR3aWdcIiwgbW9kZTogXCJ0d2lnXCJ9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiV2ViIElETFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC13ZWJpZGxcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJ3ZWJpZGxcIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJ3ZWJpZGxcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJWQi5ORVRcIiwgbWltZTogXCJ0ZXh0L3gtdmJcIiwgbW9kZTogXCJ2YlwiLCBleHQ6IFtcInZiXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlZCU2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IFwidGV4dC92YnNjcmlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInZic2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1widmJzXCJdXG4gICAgICAgICAgICAgICAgfSwge25hbWU6IFwiVmVsb2NpdHlcIiwgbWltZTogXCJ0ZXh0L3ZlbG9jaXR5XCIsIG1vZGU6IFwidmVsb2NpdHlcIiwgZXh0OiBbXCJ2dGxcIl19LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiVmVyaWxvZ1wiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC12ZXJpbG9nXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwidmVyaWxvZ1wiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInZcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJWSERMXCIsIG1pbWU6IFwidGV4dC94LXZoZGxcIiwgbW9kZTogXCJ2aGRsXCIsIGV4dDogW1widmhkXCIsIFwidmhkbFwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJYTUxcIixcbiAgICAgICAgICAgICAgICAgICAgbWltZXM6IFtcImFwcGxpY2F0aW9uL3htbFwiLCBcInRleHQveG1sXCJdLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInhtbFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInhtbFwiLCBcInhzbFwiLCBcInhzZFwiXSxcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFtcInJzc1wiLCBcIndzZGxcIiwgXCJ4c2RcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJYUXVlcnlcIiwgbWltZTogXCJhcHBsaWNhdGlvbi94cXVlcnlcIiwgbW9kZTogXCJ4cXVlcnlcIiwgZXh0OiBbXCJ4eVwiLCBcInhxdWVyeVwiXX0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJZYWNhc1wiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC15YWNhc1wiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInlhY2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wieXNcIl1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiWUFNTFwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC15YW1sXCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwieWFtbFwiLFxuICAgICAgICAgICAgICAgICAgICBleHQ6IFtcInlhbWxcIiwgXCJ5bWxcIl0sXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzOiBbXCJ5bWxcIl1cbiAgICAgICAgICAgICAgICB9LCB7bmFtZTogXCJaODBcIiwgbWltZTogXCJ0ZXh0L3gtejgwXCIsIG1vZGU6IFwiejgwXCIsIGV4dDogW1wiejgwXCJdfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm1zY2dlblwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1tc2NnZW5cIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJtc2NnZW5cIixcbiAgICAgICAgICAgICAgICAgICAgZXh0OiBbXCJtc2NnZW5cIiwgXCJtc2NpblwiLCBcIm1zY1wiXVxuICAgICAgICAgICAgICAgIH0sIHtuYW1lOiBcInh1XCIsIG1pbWU6IFwidGV4dC94LXh1XCIsIG1vZGU6IFwibXNjZ2VuXCIsIGV4dDogW1wieHVcIl19LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwibXNnZW5ueVwiLFxuICAgICAgICAgICAgICAgICAgICBtaW1lOiBcInRleHQveC1tc2dlbm55XCIsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IFwibXNjZ2VuXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dDogW1wibXNnZW5ueVwiXVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgZS5tb2RlSW5mby5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUubW9kZUluZm9bdF07XG4gICAgICAgICAgICAgICAgICAgIG4ubWltZXMgJiYgKG4ubWltZSA9IG4ubWltZXNbMF0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUuZmluZE1vZGVCeU1JTUUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubW9kZUluZm8ubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5tb2RlSW5mb1tuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLm1pbWUgPT0gdClyZXR1cm4gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLm1pbWVzKWZvciAodmFyIGkgPSAwOyBpIDwgci5taW1lcy5sZW5ndGg7IGkrKylpZiAoci5taW1lc1tpXSA9PSB0KXJldHVybiByXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBlLmZpbmRNb2RlQnlFeHRlbnNpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubW9kZUluZm8ubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5tb2RlSW5mb1tuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmV4dClmb3IgKHZhciBpID0gMDsgaSA8IHIuZXh0Lmxlbmd0aDsgaSsrKWlmIChyLmV4dFtpXSA9PSB0KXJldHVybiByXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBlLmZpbmRNb2RlQnlGaWxlTmFtZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZS5tb2RlSW5mby5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlLm1vZGVJbmZvW25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuZmlsZSAmJiByLmZpbGUudGVzdCh0KSlyZXR1cm4gclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gdC5sYXN0SW5kZXhPZihcIi5cIiksIG8gPSBpID4gLTEgJiYgdC5zdWJzdHJpbmcoaSArIDEsIHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8gPyBlLmZpbmRNb2RlQnlFeHRlbnNpb24obykgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICB9LCBlLmZpbmRNb2RlQnlOYW1lID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBlLm1vZGVJbmZvLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUubW9kZUluZm9bbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5uYW1lLnRvTG93ZXJDYXNlKCkgPT0gdClyZXR1cm4gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmFsaWFzKWZvciAodmFyIGkgPSAwOyBpIDwgci5hbGlhcy5sZW5ndGg7IGkrKylpZiAoci5hbGlhc1tpXS50b0xvd2VyQ2FzZSgpID09IHQpcmV0dXJuIHJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIHtcIi4uL2xpYi9jb2RlbWlycm9yXCI6IDEwfV0sXG4gICAgICAgIDE0OiBbZnVuY3Rpb24gKHQsIG4sIHIpIHtcbiAgICAgICAgICAgICFmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT0gdHlwZW9mIHIgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgbiA/IGkodChcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSAmJiBlLmFtZCA/IGUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIGkpIDogaShDb2RlTWlycm9yKVxuICAgICAgICAgICAgfShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgICAgIHZhciB0ID0ge1xuICAgICAgICAgICAgICAgICAgICBhdXRvU2VsZkNsb3NlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWE6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBicjogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWJlZDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBocjogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWc6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5Z2VuOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbms6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2s6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2JyOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbnVpdGVtOiAhMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbXBsaWNpdGx5Q2xvc2VkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRncm91cDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBycDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBydDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0Ym9keTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0Zm9vdDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cjogITBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dEdyYWJiZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZDoge2RkOiAhMCwgZHQ6ICEwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR0OiB7ZGQ6ICEwLCBkdDogITB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGk6IHtsaTogITB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiB7b3B0aW9uOiAhMCwgb3B0Z3JvdXA6ICEwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwOiB7b3B0Z3JvdXA6ICEwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnRpY2xlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc2lkZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2txdW90ZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXY6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRsOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHNldDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoMTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDI6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgzOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoNDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg2OiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXI6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhncm91cDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHI6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbnU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdjogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2w6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHA6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbjogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVsOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJwOiB7cnA6ICEwLCBydDogITB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcnQ6IHtycDogITAsIHJ0OiAhMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0Ym9keToge3Rib2R5OiAhMCwgdGZvb3Q6ICEwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRkOiB7dGQ6ICEwLCB0aDogITB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGZvb3Q6IHt0Ym9keTogITB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGg6IHt0ZDogITAsIHRoOiAhMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVhZDoge3Rib2R5OiAhMCwgdGZvb3Q6ICEwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyOiB7dHI6ICEwfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkb05vdEluZGVudDoge3ByZTogITB9LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd1VucXVvdGVkOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dNaXNzaW5nOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgY2FzZUZvbGQ6ICEwXG4gICAgICAgICAgICAgICAgfSwgbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1NlbGZDbG9zZXJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgaW1wbGljaXRseUNsb3NlZDoge30sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRHcmFiYmVyczoge30sXG4gICAgICAgICAgICAgICAgICAgIGRvTm90SW5kZW50OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dVbnF1b3RlZDogITEsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93TWlzc2luZzogITEsXG4gICAgICAgICAgICAgICAgICAgIGNhc2VGb2xkOiAhMVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZS5kZWZpbmVNb2RlKFwieG1sXCIsIGZ1bmN0aW9uIChyLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG8oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbihuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQudG9rZW5pemUgPSBuLCBuKGUsIHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZS5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCI8XCIgPT0gcilyZXR1cm4gZS5lYXQoXCIhXCIpID8gZS5lYXQoXCJbXCIpID8gZS5tYXRjaChcIkNEQVRBW1wiKSA/IG4ocyhcImF0b21cIiwgXCJdXT5cIikpIDogbnVsbCA6IGUubWF0Y2goXCItLVwiKSA/IG4ocyhcImNvbW1lbnRcIiwgXCItLT5cIikpIDogZS5tYXRjaChcIkRPQ1RZUEVcIiwgITAsICEwKSA/IChlLmVhdFdoaWxlKC9bXFx3XFwuX1xcLV0vKSwgbihjKDEpKSkgOiBudWxsIDogZS5lYXQoXCI/XCIpID8gKGUuZWF0V2hpbGUoL1tcXHdcXC5fXFwtXS8pLCB0LnRva2VuaXplID0gcyhcIm1ldGFcIiwgXCI/PlwiKSwgXCJtZXRhXCIpIDogKFQgPSBlLmVhdChcIi9cIikgPyBcImNsb3NlVGFnXCIgOiBcIm9wZW5UYWdcIiwgdC50b2tlbml6ZSA9IGEsIFwidGFnIGJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCImXCIgPT0gcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpID0gZS5lYXQoXCIjXCIpID8gZS5lYXQoXCJ4XCIpID8gZS5lYXRXaGlsZSgvW2EtZkEtRlxcZF0vKSAmJiBlLmVhdChcIjtcIikgOiBlLmVhdFdoaWxlKC9bXFxkXS8pICYmIGUuZWF0KFwiO1wiKSA6IGUuZWF0V2hpbGUoL1tcXHdcXC5cXC06XS8pICYmIGUuZWF0KFwiO1wiKSwgaSA/IFwiYXRvbVwiIDogXCJlcnJvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5lYXRXaGlsZSgvW14mPF0vKSwgbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiPlwiID09IG4gfHwgXCIvXCIgPT0gbiAmJiBlLmVhdChcIj5cIikpcmV0dXJuIHQudG9rZW5pemUgPSBvLCBUID0gXCI+XCIgPT0gbiA/IFwiZW5kVGFnXCIgOiBcInNlbGZjbG9zZVRhZ1wiLCBcInRhZyBicmFja2V0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCI9XCIgPT0gbilyZXR1cm4gVCA9IFwiZXF1YWxzXCIsIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCI8XCIgPT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQudG9rZW5pemUgPSBvLCB0LnN0YXRlID0gZCwgdC50YWdOYW1lID0gdC50YWdTdGFydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0LnRva2VuaXplKGUsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByID8gciArIFwiIHRhZyBlcnJvclwiIDogXCJ0YWcgZXJyb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9bXFwnXFxcIl0vLnRlc3QobikgPyAodC50b2tlbml6ZSA9IGwobiksIHQuc3RyaW5nU3RhcnRDb2wgPSBlLmNvbHVtbigpLCB0LnRva2VuaXplKGUsIHQpKSA6IChlLm1hdGNoKC9eW15cXHNcXHUwMGEwPTw+XFxcIlxcJ10qW15cXHNcXHUwMGEwPTw+XFxcIlxcJ1xcL10vKSwgXCJ3b3JkXCIpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBsKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgIXQuZW9sKCk7KWlmICh0Lm5leHQoKSA9PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4udG9rZW5pemUgPSBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlzSW5BdHRyaWJ1dGUgPSAhMCwgdFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcyhlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgIW4uZW9sKCk7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLm1hdGNoKHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnRva2VuaXplID0gbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5uZXh0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcjsgbnVsbCAhPSAociA9IHQubmV4dCgpKTspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiPFwiID09IHIpcmV0dXJuIG4udG9rZW5pemUgPSBjKGUgKyAxKSwgbi50b2tlbml6ZSh0LCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiPlwiID09IHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgxID09IGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLnRva2VuaXplID0gbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4udG9rZW5pemUgPSBjKGUgLSAxKSwgbi50b2tlbml6ZSh0LCBuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1ldGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdShlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXYgPSBlLmNvbnRleHQsIHRoaXMudGFnTmFtZSA9IHQsIHRoaXMuaW5kZW50ID0gZS5pbmRlbnRlZCwgdGhpcy5zdGFydE9mTGluZSA9IG4sIChTLmRvTm90SW5kZW50Lmhhc093blByb3BlcnR5KHQpIHx8IGUuY29udGV4dCAmJiBlLmNvbnRleHQubm9JbmRlbnQpICYmICh0aGlzLm5vSW5kZW50ID0gITApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY29udGV4dCAmJiAoZS5jb250ZXh0ID0gZS5jb250ZXh0LnByZXYpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBoKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG47IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUuY29udGV4dClyZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPSBlLmNvbnRleHQudGFnTmFtZSwgIVMuY29udGV4dEdyYWJiZXJzLmhhc093blByb3BlcnR5KG4pIHx8ICFTLmNvbnRleHRHcmFiYmVyc1tuXS5oYXNPd25Qcm9wZXJ0eSh0KSlyZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZihlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvcGVuVGFnXCIgPT0gZSA/IChuLnRhZ1N0YXJ0ID0gdC5jb2x1bW4oKSwgcCkgOiBcImNsb3NlVGFnXCIgPT0gZSA/IG0gOiBkXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBwKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIndvcmRcIiA9PSBlID8gKG4udGFnTmFtZSA9IHQuY3VycmVudCgpLCBNID0gXCJ0YWdcIiwgeSkgOiAoTSA9IFwiZXJyb3JcIiwgcClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG0oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwid29yZFwiID09IGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHQuY3VycmVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuLmNvbnRleHQgJiYgbi5jb250ZXh0LnRhZ05hbWUgIT0gciAmJiBTLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkobi5jb250ZXh0LnRhZ05hbWUpICYmIGYobiksIG4uY29udGV4dCAmJiBuLmNvbnRleHQudGFnTmFtZSA9PSByIHx8IFMubWF0Y2hDbG9zaW5nID09PSAhMSA/IChNID0gXCJ0YWdcIiwgZykgOiAoTSA9IFwidGFnIGVycm9yXCIsIHYpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTSA9IFwiZXJyb3JcIiwgdlxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZyhlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlbmRUYWdcIiAhPSBlID8gKE0gPSBcImVycm9yXCIsIGcpIDogKGYobiksIGQpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB2KGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNID0gXCJlcnJvclwiLCBnKGUsIHQsIG4pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB5KGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIndvcmRcIiA9PSBlKXJldHVybiBNID0gXCJhdHRyaWJ1dGVcIiwgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImVuZFRhZ1wiID09IGUgfHwgXCJzZWxmY2xvc2VUYWdcIiA9PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBuLnRhZ05hbWUsIGkgPSBuLnRhZ1N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuLnRhZ05hbWUgPSBuLnRhZ1N0YXJ0ID0gbnVsbCwgXCJzZWxmY2xvc2VUYWdcIiA9PSBlIHx8IFMuYXV0b1NlbGZDbG9zZXJzLmhhc093blByb3BlcnR5KHIpID8gaChuLCByKSA6IChoKG4sIHIpLCBuLmNvbnRleHQgPSBuZXcgdShuLCByLCBpID09IG4uaW5kZW50ZWQpKSwgZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE0gPSBcImVycm9yXCIsIHlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHgoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZXF1YWxzXCIgPT0gZSA/IGIgOiAoUy5hbGxvd01pc3NpbmcgfHwgKE0gPSBcImVycm9yXCIpLCB5KGUsIHQsIG4pKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSBlID8gdyA6IFwid29yZFwiID09IGUgJiYgUy5hbGxvd1VucXVvdGVkID8gKE0gPSBcInN0cmluZ1wiLCB5KSA6IChNID0gXCJlcnJvclwiLCB5KGUsIHQsIG4pKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdyhlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSBlID8gdyA6IHkoZSwgdCwgbilcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gci5pbmRlbnRVbml0LCBTID0ge30sIEMgPSBpLmh0bWxNb2RlID8gdCA6IG47XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIEwgaW4gQylTW0xdID0gQ1tMXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgTCBpbiBpKVNbTF0gPSBpW0xdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgVCwgTTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uaXNJblRleHQgPSAhMCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5pemU6IG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnRlZDogZSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdTdGFydDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgIT0gZSAmJiAodC5iYXNlSW5kZW50ID0gZSksIHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXQudGFnTmFtZSAmJiBlLnNvbCgpICYmICh0LmluZGVudGVkID0gZS5pbmRlbnRhdGlvbigpKSwgZS5lYXRTcGFjZSgpKXJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdC50b2tlbml6ZShlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG4gfHwgVCkgJiYgXCJjb21tZW50XCIgIT0gbiAmJiAoTSA9IG51bGwsIHQuc3RhdGUgPSB0LnN0YXRlKFQgfHwgbiwgZSwgdCksIE0gJiYgKG4gPSBcImVycm9yXCIgPT0gTSA/IG4gKyBcIiBlcnJvclwiIDogTSkpLCBuXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiBmdW5jdGlvbiAodCwgbiwgcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gdC5jb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LnRva2VuaXplLmlzSW5BdHRyaWJ1dGUpcmV0dXJuIHQudGFnU3RhcnQgPT0gdC5pbmRlbnRlZCA/IHQuc3RyaW5nU3RhcnRDb2wgKyAxIDogdC5pbmRlbnRlZCArIGs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgJiYgaS5ub0luZGVudClyZXR1cm4gZS5QYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LnRva2VuaXplICE9IGEgJiYgdC50b2tlbml6ZSAhPSBvKXJldHVybiByID8gci5tYXRjaCgvXihcXHMqKS8pWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQudGFnTmFtZSlyZXR1cm4gUy5tdWx0aWxpbmVUYWdJbmRlbnRQYXN0VGFnICE9PSAhMSA/IHQudGFnU3RhcnQgKyB0LnRhZ05hbWUubGVuZ3RoICsgMiA6IHQudGFnU3RhcnQgKyBrICogKFMubXVsdGlsaW5lVGFnSW5kZW50RmFjdG9yIHx8IDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTLmFsaWduQ0RBVEEgJiYgLzwhXFxbQ0RBVEFcXFsvLnRlc3QobikpcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBuICYmIC9ePChcXC8pPyhbXFx3XzpcXC4tXSopLy5leGVjKG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsICYmIGxbMV0pZm9yICg7IGk7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpLnRhZ05hbWUgPT0gbFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGkucHJldjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFTLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoaS50YWdOYW1lKSlicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGkucHJldlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobClmb3IgKDsgaTspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBTLmNvbnRleHRHcmFiYmVyc1tpLnRhZ05hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXMgfHwgIXMuaGFzT3duUHJvcGVydHkobFsyXSkpYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpLnByZXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgJiYgaS5wcmV2ICYmICFpLnN0YXJ0T2ZMaW5lOylpID0gaS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpID8gaS5pbmRlbnQgKyBrIDogdC5iYXNlSW5kZW50IHx8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVjdHJpY0lucHV0OiAvPFxcL1tcXHNcXHc6XSs+JC8sXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0NvbW1lbnRTdGFydDogXCI8IS0tXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0NvbW1lbnRFbmQ6IFwiLS0+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uOiBTLmh0bWxNb2RlID8gXCJodG1sXCIgOiBcInhtbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyVHlwZTogUy5odG1sTW9kZSA/IFwiaHRtbFwiIDogXCJ4bWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBBdHRyaWJ1dGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdGF0ZSA9PSBiICYmIChlLnN0YXRlID0geSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCBlLmRlZmluZU1JTUUoXCJ0ZXh0L3htbFwiLCBcInhtbFwiKSwgZS5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24veG1sXCIsIFwieG1sXCIpLCBlLm1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShcInRleHQvaHRtbFwiKSB8fCBlLmRlZmluZU1JTUUoXCJ0ZXh0L2h0bWxcIiwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInhtbFwiLFxuICAgICAgICAgICAgICAgICAgICBodG1sTW9kZTogITBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwge1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIjogMTB9XSxcbiAgICAgICAgMTU6IFtmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgbi5yZWFkID0gZnVuY3Rpb24gKGUsIHQsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbywgYSwgbCA9IDggKiBpIC0gciAtIDEsIHMgPSAoMSA8PCBsKSAtIDEsIGMgPSBzID4+IDEsIHUgPSAtNywgZiA9IG4gPyBpIC0gMSA6IDAsIGggPSBuID8gLTEgOiAxLFxuICAgICAgICAgICAgICAgICAgICBkID0gZVt0ICsgZl07XG4gICAgICAgICAgICAgICAgZm9yIChmICs9IGgsIG8gPSBkICYgKDEgPDwgLXUpIC0gMSwgZCA+Pj0gLXUsIHUgKz0gbDsgdSA+IDA7IG8gPSAyNTYgKiBvICsgZVt0ICsgZl0sIGYgKz0gaCwgdSAtPSA4KTtcbiAgICAgICAgICAgICAgICBmb3IgKGEgPSBvICYgKDEgPDwgLXUpIC0gMSwgbyA+Pj0gLXUsIHUgKz0gcjsgdSA+IDA7IGEgPSAyNTYgKiBhICsgZVt0ICsgZl0sIGYgKz0gaCwgdSAtPSA4KTtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbykgbyA9IDEgLSBjOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPT09IHMpcmV0dXJuIGEgPyBOYU4gOiAoZCA/IC0xIDogMSkgKiAoMSAvIDApO1xuICAgICAgICAgICAgICAgICAgICBhICs9IE1hdGgucG93KDIsIHIpLCBvIC09IGNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkID8gLTEgOiAxKSAqIGEgKiBNYXRoLnBvdygyLCBvIC0gcilcbiAgICAgICAgICAgIH0sIG4ud3JpdGUgPSBmdW5jdGlvbiAoZSwgdCwgbiwgciwgaSwgbykge1xuICAgICAgICAgICAgICAgIHZhciBhLCBsLCBzLCBjID0gOCAqIG8gLSBpIC0gMSwgdSA9ICgxIDw8IGMpIC0gMSwgZiA9IHUgPj4gMSxcbiAgICAgICAgICAgICAgICAgICAgaCA9IDIzID09PSBpID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwLCBkID0gciA/IDAgOiBvIC0gMSwgcCA9IHIgPyAxIDogLTEsXG4gICAgICAgICAgICAgICAgICAgIG0gPSAwID4gdCB8fCAwID09PSB0ICYmIDAgPiAxIC8gdCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIGZvciAodCA9IE1hdGguYWJzKHQpLCBpc05hTih0KSB8fCB0ID09PSAxIC8gMCA/IChsID0gaXNOYU4odCkgPyAxIDogMCwgYSA9IHUpIDogKGEgPSBNYXRoLmZsb29yKE1hdGgubG9nKHQpIC8gTWF0aC5MTjIpLCB0ICogKHMgPSBNYXRoLnBvdygyLCAtYSkpIDwgMSAmJiAoYS0tLCBzICo9IDIpLCB0ICs9IGEgKyBmID49IDEgPyBoIC8gcyA6IGggKiBNYXRoLnBvdygyLCAxIC0gZiksIHQgKiBzID49IDIgJiYgKGErKywgcyAvPSAyKSwgYSArIGYgPj0gdSA/IChsID0gMCwgYSA9IHUpIDogYSArIGYgPj0gMSA/IChsID0gKHQgKiBzIC0gMSkgKiBNYXRoLnBvdygyLCBpKSwgYSArPSBmKSA6IChsID0gdCAqIE1hdGgucG93KDIsIGYgLSAxKSAqIE1hdGgucG93KDIsIGkpLCBhID0gMCkpOyBpID49IDg7IGVbbiArIGRdID0gMjU1ICYgbCwgZCArPSBwLCBsIC89IDI1NiwgaSAtPSA4KTtcbiAgICAgICAgICAgICAgICBmb3IgKGEgPSBhIDw8IGkgfCBsLCBjICs9IGk7IGMgPiAwOyBlW24gKyBkXSA9IDI1NSAmIGEsIGQgKz0gcCwgYSAvPSAyNTYsIGMgLT0gOCk7XG4gICAgICAgICAgICAgICAgZVtuICsgZCAtIHBdIHw9IDEyOCAqIG1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge31dLFxuICAgICAgICAxNjogW2Z1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICB2YXIgciA9IHt9LnRvU3RyaW5nO1xuICAgICAgICAgICAgdC5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IEFycmF5XVwiID09IHIuY2FsbChlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSwge31dLFxuICAgICAgICAxNzogW2Z1bmN0aW9uICh0LCBuLCByKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zID0gW10sIHRoaXMudG9rZW5zLmxpbmtzID0ge30sIHRoaXMub3B0aW9ucyA9IGUgfHwgaC5kZWZhdWx0cywgdGhpcy5ydWxlcyA9IGQubm9ybWFsLCB0aGlzLm9wdGlvbnMuZ2ZtICYmICh0aGlzLm9wdGlvbnMudGFibGVzID8gdGhpcy5ydWxlcyA9IGQudGFibGVzIDogdGhpcy5ydWxlcyA9IGQuZ2ZtKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zID0gdCB8fCBoLmRlZmF1bHRzLCB0aGlzLmxpbmtzID0gZSwgdGhpcy5ydWxlcyA9IHAubm9ybWFsLCB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBvLCB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsICF0aGlzLmxpbmtzKXRocm93IG5ldyBFcnJvcihcIlRva2VucyBhcnJheSByZXF1aXJlcyBhIGBsaW5rc2AgcHJvcGVydHkuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmdmbSA/IHRoaXMub3B0aW9ucy5icmVha3MgPyB0aGlzLnJ1bGVzID0gcC5icmVha3MgOiB0aGlzLnJ1bGVzID0gcC5nZm0gOiB0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgKHRoaXMucnVsZXMgPSBwLnBlZGFudGljKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbyhlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBlIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zID0gW10sIHRoaXMudG9rZW4gPSBudWxsLCB0aGlzLm9wdGlvbnMgPSBlIHx8IGguZGVmYXVsdHMsIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgbywgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciwgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBsKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnJlcGxhY2UodCA/IC8mL2cgOiAvJig/ISM/XFx3KzspL2csIFwiJmFtcDtcIikucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIikucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikucmVwbGFjZSgvJy9nLCBcIiYjMzk7XCIpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnJlcGxhY2UoLyYoWyNcXHddKyk7L2csIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPSB0LnRvTG93ZXJDYXNlKCksIFwiY29sb25cIiA9PT0gdCA/IFwiOlwiIDogXCIjXCIgPT09IHQuY2hhckF0KDApID8gXCJ4XCIgPT09IHQuY2hhckF0KDEpID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh0LnN1YnN0cmluZygyKSwgMTYpKSA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK3Quc3Vic3RyaW5nKDEpKSA6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlID0gZS5zb3VyY2UsIHQgPSB0IHx8IFwiXCIsIGZ1bmN0aW9uIG4ociwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByID8gKGkgPSBpLnNvdXJjZSB8fCBpLCBpID0gaS5yZXBsYWNlKC8oXnxbXlxcW10pXFxeL2csIFwiJDFcIiksIGUgPSBlLnJlcGxhY2UociwgaSksIG4pIDogbmV3IFJlZ0V4cChlLCB0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdSgpIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCwgbiwgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gYXJndW1lbnRzW3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCBuKSAmJiAoZVtuXSA9IHRbbl0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaChlLCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByIHx8IChyID0gbiwgbiA9IG51bGwpLCBuID0gZih7fSwgaC5kZWZhdWx0cywgbiB8fCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8sIHMgPSBuLmhpZ2hsaWdodCwgYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHQubGV4KGUsIG4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcih1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gaS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSlyZXR1cm4gbi5oaWdobGlnaHQgPSBzLCByKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBhLnBhcnNlKGksIG4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uaGlnaGxpZ2h0ID0gcywgZSA/IHIoZSkgOiByKG51bGwsIHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXMgfHwgcy5sZW5ndGggPCAzKXJldHVybiBkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZSBuLmhpZ2hsaWdodCwgIW8pcmV0dXJuIGQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgYyA8IGkubGVuZ3RoOyBjKyspIWZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvZGVcIiAhPT0gZS50eXBlID8gLS1vIHx8IGQoKSA6IHMoZS50ZXh0LCBlLmxhbmcsIGZ1bmN0aW9uICh0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCA/IGQodCkgOiBudWxsID09IG4gfHwgbiA9PT0gZS50ZXh0ID8gLS1vIHx8IGQoKSA6IChlLnRleHQgPSBuLCBlLmVzY2FwZWQgPSAhMCwgdm9pZCgtLW8gfHwgZCgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGlbY10pXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiAmJiAobiA9IGYoe30sIGguZGVmYXVsdHMsIG4pKSwgYS5wYXJzZSh0LmxleChlLCBuKSwgbilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodS5tZXNzYWdlICs9IFwiXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZC5cIiwgKG4gfHwgaC5kZWZhdWx0cykuc2lsZW50KXJldHVybiBcIjxwPkFuIGVycm9yIG9jY3VyZWQ6PC9wPjxwcmU+XCIgKyBsKHUubWVzc2FnZSArIFwiXCIsICEwKSArIFwiPC9wcmU+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdsaW5lOiAvXlxcbisvLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogL14oIHs0fVteXFxuXStcXG4qKSsvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmVuY2VzOiB1LFxuICAgICAgICAgICAgICAgICAgICAgICAgaHI6IC9eKCAqWy0qX10pezMsfSAqKD86XFxuK3wkKS8sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKihbXlxcbl0rPykgKiMqICooPzpcXG4rfCQpLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5wdGFibGU6IHUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaGVhZGluZzogL14oW15cXG5dKylcXG4gKig9fC0pezIsfSAqKD86XFxuK3wkKS8sXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3F1b3RlOiAvXiggKj5bXlxcbl0rKFxcbig/IWRlZilbXlxcbl0rKSpcXG4qKSsvLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdDogL14oICopKGJ1bGwpIFtcXHNcXFNdKz8oPzpocnxkZWZ8XFxuezIsfSg/ISApKD8hXFwxYnVsbCApXFxuKnxcXHMqJCkvLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDogL14gKig/OmNvbW1lbnQgKig/OlxcbnxcXHMqJCl8Y2xvc2VkICooPzpcXG57Mix9fFxccyokKXxjbG9zaW5nICooPzpcXG57Mix9fFxccyokKSkvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogK1tcIihdKFteXFxuXSspW1wiKV0pPyAqKD86XFxuK3wkKS8sXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZTogdSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaDogL14oKD86W15cXG5dK1xcbj8oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8dGFnfGRlZikpKylcXG4qLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IC9eW15cXG5dKy9cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZC5idWxsZXQgPSAvKD86WyorLV18XFxkK1xcLikvLCBkLml0ZW0gPSAvXiggKikoYnVsbCkgW15cXG5dKig/Olxcbig/IVxcMWJ1bGwgKVteXFxuXSopKi8sIGQuaXRlbSA9IGMoZC5pdGVtLCBcImdtXCIpKC9idWxsL2csIGQuYnVsbGV0KSgpLCBkLmxpc3QgPSBjKGQubGlzdCkoL2J1bGwvZywgZC5idWxsZXQpKFwiaHJcIiwgXCJcXFxcbisoPz1cXFxcMT8oPzpbLSpfXSAqKXszLH0oPzpcXFxcbit8JCkpXCIpKFwiZGVmXCIsIFwiXFxcXG4rKD89XCIgKyBkLmRlZi5zb3VyY2UgKyBcIilcIikoKSwgZC5ibG9ja3F1b3RlID0gYyhkLmJsb2NrcXVvdGUpKFwiZGVmXCIsIGQuZGVmKSgpLCBkLl90YWcgPSBcIig/ISg/OmF8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWJ8c3VwfGl8Ynx1fG1hcmt8cnVieXxydHxycHxiZGl8YmRvfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKVxcXFxiKVxcXFx3Kyg/ITovfFteXFxcXHdcXFxcc0BdKkApXFxcXGJcIiwgZC5odG1sID0gYyhkLmh0bWwpKFwiY29tbWVudFwiLCAvPCEtLVtcXHNcXFNdKj8tLT4vKShcImNsb3NlZFwiLCAvPCh0YWcpW1xcc1xcU10rPzxcXC9cXDE+LykoXCJjbG9zaW5nXCIsIC88dGFnKD86XCJbXlwiXSpcInwnW14nXSonfFteJ1wiPl0pKj8+LykoL3RhZy9nLCBkLl90YWcpKCksIGQucGFyYWdyYXBoID0gYyhkLnBhcmFncmFwaCkoXCJoclwiLCBkLmhyKShcImhlYWRpbmdcIiwgZC5oZWFkaW5nKShcImxoZWFkaW5nXCIsIGQubGhlYWRpbmcpKFwiYmxvY2txdW90ZVwiLCBkLmJsb2NrcXVvdGUpKFwidGFnXCIsIFwiPFwiICsgZC5fdGFnKShcImRlZlwiLCBkLmRlZikoKSwgZC5ub3JtYWwgPSBmKHt9LCBkKSwgZC5nZm0gPSBmKHt9LCBkLm5vcm1hbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVuY2VzOiAvXiAqKGB7Myx9fH57Myx9KVsgXFwuXSooXFxTKyk/ICpcXG4oW1xcc1xcU10qPylcXHMqXFwxICooPzpcXG4rfCQpLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaDogL14vLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGluZzogL14gKigjezEsNn0pICsoW15cXG5dKz8pICojKiAqKD86XFxuK3wkKS9cbiAgICAgICAgICAgICAgICAgICAgfSksIGQuZ2ZtLnBhcmFncmFwaCA9IGMoZC5wYXJhZ3JhcGgpKFwiKD8hXCIsIFwiKD8hXCIgKyBkLmdmbS5mZW5jZXMuc291cmNlLnJlcGxhY2UoXCJcXFxcMVwiLCBcIlxcXFwyXCIpICsgXCJ8XCIgKyBkLmxpc3Quc291cmNlLnJlcGxhY2UoXCJcXFxcMVwiLCBcIlxcXFwzXCIpICsgXCJ8XCIpKCksIGQudGFibGVzID0gZih7fSwgZC5nZm0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5wdGFibGU6IC9eICooXFxTLipcXHwuKilcXG4gKihbLTpdKyAqXFx8Wy18IDpdKilcXG4oKD86LipcXHwuKig/OlxcbnwkKSkqKVxcbiovLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGU6IC9eICpcXHwoLispXFxuICpcXHwoICpbLTpdK1stfCA6XSopXFxuKCg/OiAqXFx8LiooPzpcXG58JCkpKilcXG4qL1xuICAgICAgICAgICAgICAgICAgICB9KSwgdC5ydWxlcyA9IGQsIHQubGV4ID0gZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gbmV3IHQobik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gci5sZXgoZSlcbiAgICAgICAgICAgICAgICAgICAgfSwgdC5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlID0gZS5yZXBsYWNlKC9cXHJcXG58XFxyL2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcdC9nLCBcIiAgICBcIikucmVwbGFjZSgvXFx1MDBhMC9nLCBcIiBcIikucmVwbGFjZSgvXFx1MjQyNC9nLCBcIlxcblwiKSwgdGhpcy50b2tlbihlLCAhMClcbiAgICAgICAgICAgICAgICAgICAgfSwgdC5wcm90b3R5cGUudG9rZW4gPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciwgaSwgbywgYSwgbCwgcywgYywgdSwgZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlLnJlcGxhY2UoL14gKyQvZ20sIFwiXCIpOyBlOylpZiAoKG8gPSB0aGlzLnJ1bGVzLm5ld2xpbmUuZXhlYyhlKSkgJiYgKGUgPSBlLnN1YnN0cmluZyhvWzBdLmxlbmd0aCksIG9bMF0ubGVuZ3RoID4gMSAmJiB0aGlzLnRva2Vucy5wdXNoKHt0eXBlOiBcInNwYWNlXCJ9KSksIG8gPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhlKSkgZSA9IGUuc3Vic3RyaW5nKG9bMF0ubGVuZ3RoKSwgbyA9IG9bMF0ucmVwbGFjZSgvXiB7NH0vZ20sIFwiXCIpLCB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMucGVkYW50aWMgPyBvIDogby5yZXBsYWNlKC9cXG4rJC8sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTsgZWxzZSBpZiAobyA9IHRoaXMucnVsZXMuZmVuY2VzLmV4ZWMoZSkpIGUgPSBlLnN1YnN0cmluZyhvWzBdLmxlbmd0aCksIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29kZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmc6IG9bMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogb1szXSB8fCBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTsgZWxzZSBpZiAobyA9IHRoaXMucnVsZXMuaGVhZGluZy5leGVjKGUpKSBlID0gZS5zdWJzdHJpbmcob1swXS5sZW5ndGgpLCB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aDogb1sxXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogb1syXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7IGVsc2UgaWYgKHQgJiYgKG8gPSB0aGlzLnJ1bGVzLm5wdGFibGUuZXhlYyhlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGUgPSBlLnN1YnN0cmluZyhvWzBdLmxlbmd0aCksIHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBvWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCBcIlwiKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbjogb1syXS5yZXBsYWNlKC9eICp8XFx8ICokL2csIFwiXCIpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzOiBvWzNdLnJlcGxhY2UoL1xcbiQvLCBcIlwiKS5zcGxpdChcIlxcblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHUgPSAwOyB1IDwgcy5hbGlnbi5sZW5ndGg7IHUrKykvXiAqLSs6ICokLy50ZXN0KHMuYWxpZ25bdV0pID8gcy5hbGlnblt1XSA9IFwicmlnaHRcIiA6IC9eICo6LSs6ICokLy50ZXN0KHMuYWxpZ25bdV0pID8gcy5hbGlnblt1XSA9IFwiY2VudGVyXCIgOiAvXiAqOi0rICokLy50ZXN0KHMuYWxpZ25bdV0pID8gcy5hbGlnblt1XSA9IFwibGVmdFwiIDogcy5hbGlnblt1XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh1ID0gMDsgdSA8IHMuY2VsbHMubGVuZ3RoOyB1Kyspcy5jZWxsc1t1XSA9IHMuY2VsbHNbdV0uc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG8gPSB0aGlzLnJ1bGVzLmxoZWFkaW5nLmV4ZWMoZSkpIGUgPSBlLnN1YnN0cmluZyhvWzBdLmxlbmd0aCksIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoOiBcIj1cIiA9PT0gb1syXSA/IDEgOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG9bMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyBlbHNlIGlmIChvID0gdGhpcy5ydWxlcy5oci5leGVjKGUpKSBlID0gZS5zdWJzdHJpbmcob1swXS5sZW5ndGgpLCB0aGlzLnRva2Vucy5wdXNoKHt0eXBlOiBcImhyXCJ9KTsgZWxzZSBpZiAobyA9IHRoaXMucnVsZXMuYmxvY2txdW90ZS5leGVjKGUpKSBlID0gZS5zdWJzdHJpbmcob1swXS5sZW5ndGgpLCB0aGlzLnRva2Vucy5wdXNoKHt0eXBlOiBcImJsb2NrcXVvdGVfc3RhcnRcIn0pLCBvID0gb1swXS5yZXBsYWNlKC9eICo+ID8vZ20sIFwiXCIpLCB0aGlzLnRva2VuKG8sIHQsICEwKSwgdGhpcy50b2tlbnMucHVzaCh7dHlwZTogXCJibG9ja3F1b3RlX2VuZFwifSk7IGVsc2UgaWYgKG8gPSB0aGlzLnJ1bGVzLmxpc3QuZXhlYyhlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoZSA9IGUuc3Vic3RyaW5nKG9bMF0ubGVuZ3RoKSwgYSA9IG9bMl0sIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImxpc3Rfc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZDogYS5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIG8gPSBvWzBdLm1hdGNoKHRoaXMucnVsZXMuaXRlbSksIHIgPSAhMSwgZiA9IG8ubGVuZ3RoLCB1ID0gMDsgZiA+IHU7IHUrKylzID0gb1t1XSwgYyA9IHMubGVuZ3RoLCBzID0gcy5yZXBsYWNlKC9eICooWyorLV18XFxkK1xcLikgKy8sIFwiXCIpLCB+cy5pbmRleE9mKFwiXFxuIFwiKSAmJiAoYyAtPSBzLmxlbmd0aCwgcyA9IHRoaXMub3B0aW9ucy5wZWRhbnRpYyA/IHMucmVwbGFjZSgvXiB7MSw0fS9nbSwgXCJcIikgOiBzLnJlcGxhY2UobmV3IFJlZ0V4cChcIl4gezEsXCIgKyBjICsgXCJ9XCIsIFwiZ21cIiksIFwiXCIpKSwgdGhpcy5vcHRpb25zLnNtYXJ0TGlzdHMgJiYgdSAhPT0gZiAtIDEgJiYgKGwgPSBkLmJ1bGxldC5leGVjKG9bdSArIDFdKVswXSwgYSA9PT0gbCB8fCBhLmxlbmd0aCA+IDEgJiYgbC5sZW5ndGggPiAxIHx8IChlID0gby5zbGljZSh1ICsgMSkuam9pbihcIlxcblwiKSArIGUsIHUgPSBmIC0gMSkpLCBpID0gciB8fCAvXFxuXFxuKD8hXFxzKiQpLy50ZXN0KHMpLCB1ICE9PSBmIC0gMSAmJiAociA9IFwiXFxuXCIgPT09IHMuY2hhckF0KHMubGVuZ3RoIC0gMSksIGkgfHwgKGkgPSByKSksIHRoaXMudG9rZW5zLnB1c2goe3R5cGU6IGkgPyBcImxvb3NlX2l0ZW1fc3RhcnRcIiA6IFwibGlzdF9pdGVtX3N0YXJ0XCJ9KSwgdGhpcy50b2tlbihzLCAhMSwgbiksIHRoaXMudG9rZW5zLnB1c2goe3R5cGU6IFwibGlzdF9pdGVtX2VuZFwifSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7dHlwZTogXCJsaXN0X2VuZFwifSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobyA9IHRoaXMucnVsZXMuaHRtbC5leGVjKGUpKSBlID0gZS5zdWJzdHJpbmcob1swXS5sZW5ndGgpLCB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyBcInBhcmFncmFwaFwiIDogXCJodG1sXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplciAmJiAoXCJwcmVcIiA9PT0gb1sxXSB8fCBcInNjcmlwdFwiID09PSBvWzFdIHx8IFwic3R5bGVcIiA9PT0gb1sxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogb1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7IGVsc2UgaWYgKCFuICYmIHQgJiYgKG8gPSB0aGlzLnJ1bGVzLmRlZi5leGVjKGUpKSkgZSA9IGUuc3Vic3RyaW5nKG9bMF0ubGVuZ3RoKSwgdGhpcy50b2tlbnMubGlua3Nbb1sxXS50b0xvd2VyQ2FzZSgpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiBvWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBvWzNdXG4gICAgICAgICAgICAgICAgICAgICAgICB9OyBlbHNlIGlmICh0ICYmIChvID0gdGhpcy5ydWxlcy50YWJsZS5leGVjKGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoZSA9IGUuc3Vic3RyaW5nKG9bMF0ubGVuZ3RoKSwgcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IG9bMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csIFwiXCIpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduOiBvWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgXCJcIikuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbHM6IG9bM10ucmVwbGFjZSgvKD86ICpcXHwgKik/XFxuJC8sIFwiXCIpLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdSA9IDA7IHUgPCBzLmFsaWduLmxlbmd0aDsgdSsrKS9eICotKzogKiQvLnRlc3Qocy5hbGlnblt1XSkgPyBzLmFsaWduW3VdID0gXCJyaWdodFwiIDogL14gKjotKzogKiQvLnRlc3Qocy5hbGlnblt1XSkgPyBzLmFsaWduW3VdID0gXCJjZW50ZXJcIiA6IC9eICo6LSsgKiQvLnRlc3Qocy5hbGlnblt1XSkgPyBzLmFsaWduW3VdID0gXCJsZWZ0XCIgOiBzLmFsaWduW3VdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHUgPSAwOyB1IDwgcy5jZWxscy5sZW5ndGg7IHUrKylzLmNlbGxzW3VdID0gcy5jZWxsc1t1XS5yZXBsYWNlKC9eICpcXHwgKnwgKlxcfCAqJC9nLCBcIlwiKS5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2gocylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodCAmJiAobyA9IHRoaXMucnVsZXMucGFyYWdyYXBoLmV4ZWMoZSkpKSBlID0gZS5zdWJzdHJpbmcob1swXS5sZW5ndGgpLCB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFwiXFxuXCIgPT09IG9bMV0uY2hhckF0KG9bMV0ubGVuZ3RoIC0gMSkgPyBvWzFdLnNsaWNlKDAsIC0xKSA6IG9bMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyBlbHNlIGlmIChvID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoZSkpIGUgPSBlLnN1YnN0cmluZyhvWzBdLmxlbmd0aCksIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG9bMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyBlbHNlIGlmIChlKXRocm93IG5ldyBFcnJvcihcIkluZmluaXRlIGxvb3Agb24gYnl0ZTogXCIgKyBlLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlOiAvXlxcXFwoW1xcXFxgKnt9XFxbXFxdKCkjK1xcLS4hXz5dKS8sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvbGluazogL148KFteID5dKyhAfDpcXC8pW14gPl0rKT4vLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAvXjwhLS1bXFxzXFxTXSo/LS0+fF48XFwvP1xcdysoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluazogL14hP1xcWyhpbnNpZGUpXFxdXFwoaHJlZlxcKS8sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXHMqXFxbKFteXFxdXSopXFxdLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vbGluazogL14hP1xcWygoPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXSkqKVxcXS8sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJvbmc6IC9eX18oW1xcc1xcU10rPylfXyg/IV8pfF5cXCpcXCooW1xcc1xcU10rPylcXCpcXCooPyFcXCopLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtOiAvXlxcYl8oKD86W15fXXxfXykrPylfXFxifF5cXCooKD86XFwqXFwqfFtcXHNcXFNdKSs/KVxcKig/IVxcKikvLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogL14oYCspXFxzKihbXFxzXFxTXSo/W15gXSlcXHMqXFwxKD8hYCkvLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnI6IC9eIHsyLH1cXG4oPyFcXHMqJCkvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsOiB1LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogL15bXFxzXFxTXSs/KD89W1xcXFw8IVxcW18qYF18IHsyLH1cXG58JCkvXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHAuX2luc2lkZSA9IC8oPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXXxcXF0oPz1bXlxcW10qXFxdKSkqLywgcC5faHJlZiA9IC9cXHMqPD8oW1xcc1xcU10qPyk+Pyg/OlxccytbJ1wiXShbXFxzXFxTXSo/KVsnXCJdKT9cXHMqLywgcC5saW5rID0gYyhwLmxpbmspKFwiaW5zaWRlXCIsIHAuX2luc2lkZSkoXCJocmVmXCIsIHAuX2hyZWYpKCksIHAucmVmbGluayA9IGMocC5yZWZsaW5rKShcImluc2lkZVwiLCBwLl9pbnNpZGUpKCksIHAubm9ybWFsID0gZih7fSwgcCksIHAucGVkYW50aWMgPSBmKHt9LCBwLm5vcm1hbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb25nOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtOiAvXl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pfF5cXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKS9cbiAgICAgICAgICAgICAgICAgICAgfSksIHAuZ2ZtID0gZih7fSwgcC5ub3JtYWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZTogYyhwLmVzY2FwZSkoXCJdKVwiLCBcIn58XSlcIikoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogL14oaHR0cHM/OlxcL1xcL1teXFxzPF0rW148Liw6O1wiJylcXF1cXHNdKS8sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWw6IC9efn4oPz1cXFMpKFtcXHNcXFNdKj9cXFMpfn4vLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogYyhwLnRleHQpKFwiXXxcIiwgXCJ+XXxcIikoXCJ8XCIsIFwifGh0dHBzPzovL3xcIikoKVxuICAgICAgICAgICAgICAgICAgICB9KSwgcC5icmVha3MgPSBmKHt9LCBwLmdmbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnI6IGMocC5icikoXCJ7Mix9XCIsIFwiKlwiKSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogYyhwLmdmbS50ZXh0KShcInsyLH1cIiwgXCIqXCIpKClcbiAgICAgICAgICAgICAgICAgICAgfSksIGkucnVsZXMgPSBwLCBpLm91dHB1dCA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBpKHQsIG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIub3V0cHV0KGUpXG4gICAgICAgICAgICAgICAgICAgIH0sIGkucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0LCBuLCByLCBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IFwiXCI7IGU7KWlmIChpID0gdGhpcy5ydWxlcy5lc2NhcGUuZXhlYyhlKSkgZSA9IGUuc3Vic3RyaW5nKGlbMF0ubGVuZ3RoKSwgbyArPSBpWzFdOyBlbHNlIGlmIChpID0gdGhpcy5ydWxlcy5hdXRvbGluay5leGVjKGUpKSBlID0gZS5zdWJzdHJpbmcoaVswXS5sZW5ndGgpLCBcIkBcIiA9PT0gaVsyXSA/IChuID0gXCI6XCIgPT09IGlbMV0uY2hhckF0KDYpID8gdGhpcy5tYW5nbGUoaVsxXS5zdWJzdHJpbmcoNykpIDogdGhpcy5tYW5nbGUoaVsxXSksIHIgPSB0aGlzLm1hbmdsZShcIm1haWx0bzpcIikgKyBuKSA6IChuID0gbChpWzFdKSwgciA9IG4pLCBvICs9IHRoaXMucmVuZGVyZXIubGluayhyLCBudWxsLCBuKTsgZWxzZSBpZiAodGhpcy5pbkxpbmsgfHwgIShpID0gdGhpcy5ydWxlcy51cmwuZXhlYyhlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9IHRoaXMucnVsZXMudGFnLmV4ZWMoZSkpICF0aGlzLmluTGluayAmJiAvXjxhIC9pLnRlc3QoaVswXSkgPyB0aGlzLmluTGluayA9ICEwIDogdGhpcy5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGlbMF0pICYmICh0aGlzLmluTGluayA9ICExKSwgZSA9IGUuc3Vic3RyaW5nKGlbMF0ubGVuZ3RoKSwgbyArPSB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihpWzBdKSA6IGwoaVswXSkgOiBpWzBdOyBlbHNlIGlmIChpID0gdGhpcy5ydWxlcy5saW5rLmV4ZWMoZSkpIGUgPSBlLnN1YnN0cmluZyhpWzBdLmxlbmd0aCksIHRoaXMuaW5MaW5rID0gITAsIG8gKz0gdGhpcy5vdXRwdXRMaW5rKGksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogaVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGlbM11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgdGhpcy5pbkxpbmsgPSAhMTsgZWxzZSBpZiAoKGkgPSB0aGlzLnJ1bGVzLnJlZmxpbmsuZXhlYyhlKSkgfHwgKGkgPSB0aGlzLnJ1bGVzLm5vbGluay5leGVjKGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSA9IGUuc3Vic3RyaW5nKGlbMF0ubGVuZ3RoKSwgdCA9IChpWzJdIHx8IGlbMV0pLnJlcGxhY2UoL1xccysvZywgXCIgXCIpLCB0ID0gdGhpcy5saW5rc1t0LnRvTG93ZXJDYXNlKCldLCAhdCB8fCAhdC5ocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvICs9IGlbMF0uY2hhckF0KDApLCBlID0gaVswXS5zdWJzdHJpbmcoMSkgKyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluTGluayA9ICEwLCBvICs9IHRoaXMub3V0cHV0TGluayhpLCB0KSwgdGhpcy5pbkxpbmsgPSAhMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9IHRoaXMucnVsZXMuc3Ryb25nLmV4ZWMoZSkpIGUgPSBlLnN1YnN0cmluZyhpWzBdLmxlbmd0aCksIG8gKz0gdGhpcy5yZW5kZXJlci5zdHJvbmcodGhpcy5vdXRwdXQoaVsyXSB8fCBpWzFdKSk7IGVsc2UgaWYgKGkgPSB0aGlzLnJ1bGVzLmVtLmV4ZWMoZSkpIGUgPSBlLnN1YnN0cmluZyhpWzBdLmxlbmd0aCksIG8gKz0gdGhpcy5yZW5kZXJlci5lbSh0aGlzLm91dHB1dChpWzJdIHx8IGlbMV0pKTsgZWxzZSBpZiAoaSA9IHRoaXMucnVsZXMuY29kZS5leGVjKGUpKSBlID0gZS5zdWJzdHJpbmcoaVswXS5sZW5ndGgpLCBvICs9IHRoaXMucmVuZGVyZXIuY29kZXNwYW4obChpWzJdLCAhMCkpOyBlbHNlIGlmIChpID0gdGhpcy5ydWxlcy5ici5leGVjKGUpKSBlID0gZS5zdWJzdHJpbmcoaVswXS5sZW5ndGgpLCBvICs9IHRoaXMucmVuZGVyZXIuYnIoKTsgZWxzZSBpZiAoaSA9IHRoaXMucnVsZXMuZGVsLmV4ZWMoZSkpIGUgPSBlLnN1YnN0cmluZyhpWzBdLmxlbmd0aCksIG8gKz0gdGhpcy5yZW5kZXJlci5kZWwodGhpcy5vdXRwdXQoaVsxXSkpOyBlbHNlIGlmIChpID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoZSkpIGUgPSBlLnN1YnN0cmluZyhpWzBdLmxlbmd0aCksIG8gKz0gdGhpcy5yZW5kZXJlci50ZXh0KGwodGhpcy5zbWFydHlwYW50cyhpWzBdKSkpOyBlbHNlIGlmIChlKXRocm93IG5ldyBFcnJvcihcIkluZmluaXRlIGxvb3Agb24gYnl0ZTogXCIgKyBlLmNoYXJDb2RlQXQoMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZSA9IGUuc3Vic3RyaW5nKGlbMF0ubGVuZ3RoKSwgbiA9IGwoaVsxXSksIHIgPSBuLCBvICs9IHRoaXMucmVuZGVyZXIubGluayhyLCBudWxsLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvXG4gICAgICAgICAgICAgICAgICAgIH0sIGkucHJvdG90eXBlLm91dHB1dExpbmsgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBsKHQuaHJlZiksIHIgPSB0LnRpdGxlID8gbCh0LnRpdGxlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIhXCIgIT09IGVbMF0uY2hhckF0KDApID8gdGhpcy5yZW5kZXJlci5saW5rKG4sIHIsIHRoaXMub3V0cHV0KGVbMV0pKSA6IHRoaXMucmVuZGVyZXIuaW1hZ2UobiwgciwgbChlWzFdKSlcbiAgICAgICAgICAgICAgICAgICAgfSwgaS5wcm90b3R5cGUuc21hcnR5cGFudHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zbWFydHlwYW50cyA/IGUucmVwbGFjZSgvLS0tL2csIFwi4oCUXCIpLnJlcGxhY2UoLy0tL2csIFwi4oCTXCIpLnJlcGxhY2UoLyhefFstXFx1MjAxNFxcLyhcXFt7XCJcXHNdKScvZywgXCIkMeKAmFwiKS5yZXBsYWNlKC8nL2csIFwi4oCZXCIpLnJlcGxhY2UoLyhefFstXFx1MjAxNFxcLyhcXFt7XFx1MjAxOFxcc10pXCIvZywgXCIkMeKAnFwiKS5yZXBsYWNlKC9cIi9nLCBcIuKAnVwiKS5yZXBsYWNlKC9cXC57M30vZywgXCLigKZcIikgOiBlXG4gICAgICAgICAgICAgICAgICAgIH0sIGkucHJvdG90eXBlLm1hbmdsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5tYW5nbGUpcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0LCBuID0gXCJcIiwgciA9IGUubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7IHIgPiBpOyBpKyspdCA9IGUuY2hhckNvZGVBdChpKSwgTWF0aC5yYW5kb20oKSA+IC41ICYmICh0ID0gXCJ4XCIgKyB0LnRvU3RyaW5nKDE2KSksIG4gKz0gXCImI1wiICsgdCArIFwiO1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgICAgICAgfSwgby5wcm90b3R5cGUuY29kZSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5vcHRpb25zLmhpZ2hsaWdodChlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9IHIgJiYgciAhPT0gZSAmJiAobiA9ICEwLCBlID0gcilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ID8gJzxwcmU+PGNvZGUgY2xhc3M9XCInICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXggKyBsKHQsICEwKSArICdcIj4nICsgKG4gPyBlIDogbChlLCAhMCkpICsgXCJcXG48L2NvZGU+PC9wcmU+XFxuXCIgOiBcIjxwcmU+PGNvZGU+XCIgKyAobiA/IGUgOiBsKGUsICEwKSkgKyBcIlxcbjwvY29kZT48L3ByZT5cIlxuICAgICAgICAgICAgICAgICAgICB9LCBvLnByb3RvdHlwZS5ibG9ja3F1b3RlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjxibG9ja3F1b3RlPlxcblwiICsgZSArIFwiPC9ibG9ja3F1b3RlPlxcblwiXG4gICAgICAgICAgICAgICAgICAgIH0sIG8ucHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAgICAgICAgICAgfSwgby5wcm90b3R5cGUuaGVhZGluZyA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI8aFwiICsgdCArICcgaWQ9XCInICsgdGhpcy5vcHRpb25zLmhlYWRlclByZWZpeCArIG4udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXlxcd10rL2csIFwiLVwiKSArICdcIj4nICsgZSArIFwiPC9oXCIgKyB0ICsgXCI+XFxuXCJcbiAgICAgICAgICAgICAgICAgICAgfSwgby5wcm90b3R5cGUuaHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gXCI8aHIvPlxcblwiIDogXCI8aHI+XFxuXCJcbiAgICAgICAgICAgICAgICAgICAgfSwgby5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHQgPyBcIm9sXCIgOiBcInVsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI8XCIgKyBuICsgXCI+XFxuXCIgKyBlICsgXCI8L1wiICsgbiArIFwiPlxcblwiXG4gICAgICAgICAgICAgICAgICAgIH0sIG8ucHJvdG90eXBlLmxpc3RpdGVtID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjxsaT5cIiArIGUgKyBcIjwvbGk+XFxuXCJcbiAgICAgICAgICAgICAgICAgICAgfSwgby5wcm90b3R5cGUucGFyYWdyYXBoID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjxwPlwiICsgZSArIFwiPC9wPlxcblwiXG4gICAgICAgICAgICAgICAgICAgIH0sIG8ucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjx0YWJsZT5cXG48dGhlYWQ+XFxuXCIgKyBlICsgXCI8L3RoZWFkPlxcbjx0Ym9keT5cXG5cIiArIHQgKyBcIjwvdGJvZHk+XFxuPC90YWJsZT5cXG5cIlxuICAgICAgICAgICAgICAgICAgICB9LCBvLnByb3RvdHlwZS50YWJsZXJvdyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI8dHI+XFxuXCIgKyBlICsgXCI8L3RyPlxcblwiXG4gICAgICAgICAgICAgICAgICAgIH0sIG8ucHJvdG90eXBlLnRhYmxlY2VsbCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHQuaGVhZGVyID8gXCJ0aFwiIDogXCJ0ZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB0LmFsaWduID8gXCI8XCIgKyBuICsgJyBzdHlsZT1cInRleHQtYWxpZ246JyArIHQuYWxpZ24gKyAnXCI+JyA6IFwiPFwiICsgbiArIFwiPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgKyBlICsgXCI8L1wiICsgbiArIFwiPlxcblwiXG4gICAgICAgICAgICAgICAgICAgIH0sIG8ucHJvdG90eXBlLnN0cm9uZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI8c3Ryb25nPlwiICsgZSArIFwiPC9zdHJvbmc+XCJcbiAgICAgICAgICAgICAgICAgICAgfSwgby5wcm90b3R5cGUuZW0gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiPGVtPlwiICsgZSArIFwiPC9lbT5cIlxuICAgICAgICAgICAgICAgICAgICB9LCBvLnByb3RvdHlwZS5jb2Rlc3BhbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI8Y29kZT5cIiArIGUgKyBcIjwvY29kZT5cIlxuICAgICAgICAgICAgICAgICAgICB9LCBvLnByb3RvdHlwZS5iciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyBcIjxici8+XCIgOiBcIjxicj5cIlxuICAgICAgICAgICAgICAgICAgICB9LCBvLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiPGRlbD5cIiArIGUgKyBcIjwvZGVsPlwiXG4gICAgICAgICAgICAgICAgICAgIH0sIG8ucHJvdG90eXBlLmxpbmsgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZGVjb2RlVVJJQ29tcG9uZW50KHMoZSkpLnJlcGxhY2UoL1teXFx3Ol0vZywgXCJcIikudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IHIuaW5kZXhPZihcImphdmFzY3JpcHQ6XCIpIHx8IDAgPT09IHIuaW5kZXhPZihcInZic2NyaXB0OlwiKSlyZXR1cm4gXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSAnPGEgaHJlZj1cIicgKyBlICsgJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ICYmIChvICs9ICcgdGl0bGU9XCInICsgdCArICdcIicpLCBvICs9IFwiPlwiICsgbiArIFwiPC9hPlwiXG4gICAgICAgICAgICAgICAgICAgIH0sIG8ucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gJzxpbWcgc3JjPVwiJyArIGUgKyAnXCIgYWx0PVwiJyArIG4gKyAnXCInO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgJiYgKHIgKz0gJyB0aXRsZT1cIicgKyB0ICsgJ1wiJyksIHIgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gXCIvPlwiIDogXCI+XCJcbiAgICAgICAgICAgICAgICAgICAgfSwgby5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICAgICAgICB9LCBhLnBhcnNlID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gbmV3IGEodCwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gci5wYXJzZShlKVxuICAgICAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZSA9IG5ldyBpKGUubGlua3MsIHRoaXMub3B0aW9ucywgdGhpcy5yZW5kZXJlciksIHRoaXMudG9rZW5zID0gZS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gXCJcIjsgdGhpcy5uZXh0KCk7KXQgKz0gdGhpcy50b2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0XG4gICAgICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbiA9IHRoaXMudG9rZW5zLnBvcCgpXG4gICAgICAgICAgICAgICAgICAgIH0sIGEucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gfHwgMFxuICAgICAgICAgICAgICAgICAgICB9LCBhLnByb3RvdHlwZS5wYXJzZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gdGhpcy50b2tlbi50ZXh0OyBcInRleHRcIiA9PT0gdGhpcy5wZWVrKCkudHlwZTspZSArPSBcIlxcblwiICsgdGhpcy5uZXh0KCkudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlubGluZS5vdXRwdXQoZSlcbiAgICAgICAgICAgICAgICAgICAgfSwgYS5wcm90b3R5cGUudG9rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJzcGFjZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJoclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ocigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcImhlYWRpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaGVhZGluZyh0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KSwgdGhpcy50b2tlbi5kZXB0aCwgdGhpcy50b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJjb2RlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmNvZGUodGhpcy50b2tlbi50ZXh0LCB0aGlzLnRva2VuLmxhbmcsIHRoaXMudG9rZW4uZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwidGFibGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUsIHQsIG4sIHIsIGksIG8gPSBcIlwiLCBhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChuID0gXCJcIiwgZSA9IDA7IGUgPCB0aGlzLnRva2VuLmhlYWRlci5sZW5ndGg7IGUrKylyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2VdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG4gKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwodGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4uaGVhZGVyW2VdKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2VdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG8gKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhuKSwgZSA9IDA7IGUgPCB0aGlzLnRva2VuLmNlbGxzLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHQgPSB0aGlzLnRva2VuLmNlbGxzW2VdLCBuID0gXCJcIiwgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKW4gKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwodGhpcy5pbmxpbmUub3V0cHV0KHRbaV0pLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3cobilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci50YWJsZShvLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJibG9ja3F1b3RlX3N0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSBcIlwiOyBcImJsb2NrcXVvdGVfZW5kXCIgIT09IHRoaXMubmV4dCgpLnR5cGU7KWEgKz0gdGhpcy50b2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJsaXN0X3N0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gdGhpcy50b2tlbi5vcmRlcmVkOyBcImxpc3RfZW5kXCIgIT09IHRoaXMubmV4dCgpLnR5cGU7KWEgKz0gdGhpcy50b2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdChhLCBsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlXCJsaXN0X2l0ZW1fc3RhcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IFwiXCI7IFwibGlzdF9pdGVtX2VuZFwiICE9PSB0aGlzLm5leHQoKS50eXBlOylhICs9IFwidGV4dFwiID09PSB0aGlzLnRva2VuLnR5cGUgPyB0aGlzLnBhcnNlVGV4dCgpIDogdGhpcy50b2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwibG9vc2VfaXRlbV9zdGFydFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gXCJcIjsgXCJsaXN0X2l0ZW1fZW5kXCIgIT09IHRoaXMubmV4dCgpLnR5cGU7KWEgKz0gdGhpcy50b2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVwiaHRtbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMudG9rZW4ucHJlIHx8IHRoaXMub3B0aW9ucy5wZWRhbnRpYyA/IHRoaXMudG9rZW4udGV4dCA6IHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5odG1sKHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcInBhcmFncmFwaFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VcInRleHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VUZXh0KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHUuZXhlYyA9IHUsIGgub3B0aW9ucyA9IGguc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZihoLmRlZmF1bHRzLCBlKSwgaFxuICAgICAgICAgICAgICAgICAgICB9LCBoLmRlZmF1bHRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2ZtOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlczogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha3M6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVkYW50aWM6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FuaXRpemU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FuaXRpemVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFuZ2xlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtYXJ0TGlzdHM6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lsZW50OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmdQcmVmaXg6IFwibGFuZy1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtYXJ0eXBhbnRzOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlclByZWZpeDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBuZXcgbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhodG1sOiAhMVxuICAgICAgICAgICAgICAgICAgICB9LCBoLlBhcnNlciA9IGEsIGgucGFyc2VyID0gYS5wYXJzZSwgaC5SZW5kZXJlciA9IG8sIGguTGV4ZXIgPSB0LCBoLmxleGVyID0gdC5sZXgsIGguSW5saW5lTGV4ZXIgPSBpLCBoLmlubGluZUxleGVyID0gaS5vdXRwdXQsIGgucGFyc2UgPSBoLCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBuICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHIgPyBuLmV4cG9ydHMgPSBoIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBlICYmIGUuYW1kID8gZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaFxuICAgICAgICAgICAgICAgICAgICB9KSA6IHRoaXMubWFya2VkID0gaFxuICAgICAgICAgICAgICAgIH0pLmNhbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcyB8fCAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDogdClcbiAgICAgICAgICAgICAgICB9KCkpXG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMsIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGdsb2JhbCA/IGdsb2JhbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgPyBzZWxmIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDoge30pXG4gICAgICAgIH0sIHt9XSxcbiAgICAgICAgMTg6IFtmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChuLCByKSB7XG4gICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBmdW5jdGlvbiAoZSwgdCwgbiwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9IGkgfHwge30sIHRoaXMuZGljdGlvbmFyeSA9IG51bGwsIHRoaXMucnVsZXMgPSB7fSwgdGhpcy5kaWN0aW9uYXJ5VGFibGUgPSB7fSwgdGhpcy5jb21wb3VuZFJ1bGVzID0gW10sIHRoaXMuY29tcG91bmRSdWxlQ29kZXMgPSB7fSwgdGhpcy5yZXBsYWNlbWVudFRhYmxlID0gW10sIHRoaXMuZmxhZ3MgPSBpLmZsYWdzIHx8IHt9LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kaWN0aW9uYXJ5ID0gZSwgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ICYmIFwiY2hyb21lXCIgaW4gd2luZG93ICYmIFwiZXh0ZW5zaW9uXCIgaW4gd2luZG93LmNocm9tZSAmJiBcImdldFVSTFwiIGluIHdpbmRvdy5jaHJvbWUuZXh0ZW5zaW9uKSB0IHx8ICh0ID0gdGhpcy5fcmVhZEZpbGUoY2hyb21lLmV4dGVuc2lvbi5nZXRVUkwoXCJsaWIvdHlwby9kaWN0aW9uYXJpZXMvXCIgKyBlICsgXCIvXCIgKyBlICsgXCIuYWZmXCIpKSksIG4gfHwgKG4gPSB0aGlzLl9yZWFkRmlsZShjaHJvbWUuZXh0ZW5zaW9uLmdldFVSTChcImxpYi90eXBvL2RpY3Rpb25hcmllcy9cIiArIGUgKyBcIi9cIiArIGUgKyBcIi5kaWNcIikpKTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkuZGljdGlvbmFyeVBhdGgpdmFyIG8gPSBpLmRpY3Rpb25hcnlQYXRoOyBlbHNlIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiByKXZhciBvID0gciArIFwiL2RpY3Rpb25hcmllc1wiOyBlbHNlIHZhciBvID0gXCIuL2RpY3Rpb25hcmllc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgfHwgKHQgPSB0aGlzLl9yZWFkRmlsZShvICsgXCIvXCIgKyBlICsgXCIvXCIgKyBlICsgXCIuYWZmXCIpKSwgbiB8fCAobiA9IHRoaXMuX3JlYWRGaWxlKG8gKyBcIi9cIiArIGUgKyBcIi9cIiArIGUgKyBcIi5kaWNcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bGVzID0gdGhpcy5fcGFyc2VBRkYodCksIHRoaXMuY29tcG91bmRSdWxlQ29kZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSAwLCBsID0gdGhpcy5jb21wb3VuZFJ1bGVzLmxlbmd0aDsgbCA+IGE7IGErKylmb3IgKHZhciBzID0gdGhpcy5jb21wb3VuZFJ1bGVzW2FdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBzLmxlbmd0aDsgdSA+IGM7IGMrKyl0aGlzLmNvbXBvdW5kUnVsZUNvZGVzW3NbY11dID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBcIk9OTFlJTkNPTVBPVU5EXCIgaW4gdGhpcy5mbGFncyAmJiAodGhpcy5jb21wb3VuZFJ1bGVDb2Rlc1t0aGlzLmZsYWdzLk9OTFlJTkNPTVBPVU5EXSA9IFtdKSwgdGhpcy5kaWN0aW9uYXJ5VGFibGUgPSB0aGlzLl9wYXJzZURJQyhuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgaW4gdGhpcy5jb21wb3VuZFJ1bGVDb2RlcykwID09IHRoaXMuY29tcG91bmRSdWxlQ29kZXNbYV0ubGVuZ3RoICYmIGRlbGV0ZSB0aGlzLmNvbXBvdW5kUnVsZUNvZGVzW2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDAsIGwgPSB0aGlzLmNvbXBvdW5kUnVsZXMubGVuZ3RoOyBsID4gYTsgYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IHRoaXMuY29tcG91bmRSdWxlc1thXSwgaCA9IFwiXCIsIGMgPSAwLCB1ID0gZi5sZW5ndGg7IHUgPiBjOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBmW2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoICs9IGQgaW4gdGhpcy5jb21wb3VuZFJ1bGVDb2RlcyA/IFwiKFwiICsgdGhpcy5jb21wb3VuZFJ1bGVDb2Rlc1tkXS5qb2luKFwifFwiKSArIFwiKVwiIDogZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvdW5kUnVsZXNbYV0gPSBuZXcgUmVnRXhwKGgsIFwiaVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgaW4gZSl0aGlzW3RdID0gZVt0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0sIF9yZWFkRmlsZTogZnVuY3Rpb24gKHQsIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyIHx8IChyID0gXCJ1dGY4XCIpLCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpLm9wZW4oXCJHRVRcIiwgdCwgITEpLCBpLm92ZXJyaWRlTWltZVR5cGUgJiYgaS5vdmVycmlkZU1pbWVUeXBlKFwidGV4dC9wbGFpbjsgY2hhcnNldD1cIiArIHIpLCBpLnNlbmQobnVsbCksIGkucmVzcG9uc2VUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZShcImZzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmV4aXN0c1N5bmModCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gby5zdGF0U3luYyh0KSwgbCA9IG8ub3BlblN5bmModCwgXCJyXCIpLCBzID0gbmV3IG4oYS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvLnJlYWRTeW5jKGwsIHMsIDAsIHMubGVuZ3RoLCBudWxsKSwgcy50b1N0cmluZyhyLCAwLCBzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBhdGggXCIgKyB0ICsgXCIgZG9lcyBub3QgZXhpc3QuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2coYyksIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9wYXJzZUFGRjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5fcmVtb3ZlQWZmaXhDb21tZW50cyhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBlLnNwbGl0KFwiXFxuXCIpLCByID0gMCwgaSA9IG4ubGVuZ3RoOyBpID4gcjsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBuW3JdLCBhID0gby5zcGxpdCgvXFxzKy8pLCBsID0gYVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJQRlhcIiA9PSBsIHx8IFwiU0ZYXCIgPT0gbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gYVsxXSwgYyA9IGFbMl0sIHUgPSBwYXJzZUludChhWzNdLCAxMCksIGYgPSBbXSwgaCA9IHIgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gciArIDEgKyB1OyBkID4gaDsgaCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG5baF0sIHAgPSBvLnNwbGl0KC9cXHMrLyksIG0gPSBwWzJdLCBnID0gcFszXS5zcGxpdChcIi9cIiksIHYgPSBnWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIwXCIgPT09IHYgJiYgKHYgPSBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5wYXJzZVJ1bGVDb2RlcyhnWzFdKSwgeCA9IHBbNF0sIGIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYWRkID0gdiwgeS5sZW5ndGggPiAwICYmIChiLmNvbnRpbnVhdGlvbkNsYXNzZXMgPSB5KSwgXCIuXCIgIT09IHggJiYgKFwiU0ZYXCIgPT09IGwgPyBiLm1hdGNoID0gbmV3IFJlZ0V4cCh4ICsgXCIkXCIpIDogYi5tYXRjaCA9IG5ldyBSZWdFeHAoXCJeXCIgKyB4KSksIFwiMFwiICE9IG0gJiYgKFwiU0ZYXCIgPT09IGwgPyBiLnJlbW92ZSA9IG5ldyBSZWdFeHAobSArIFwiJFwiKSA6IGIucmVtb3ZlID0gbSksIGYucHVzaChiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRbc10gPSB7dHlwZTogbCwgY29tYmluZWFibGU6IFwiWVwiID09IGMsIGVudHJpZXM6IGZ9LCByICs9IHVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiQ09NUE9VTkRSVUxFXCIgPT09IGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdSA9IHBhcnNlSW50KGFbMV0sIDEwKSwgaCA9IHIgKyAxLCBkID0gciArIDEgKyB1OyBkID4gaDsgaCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG5baF0sIHAgPSBvLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvdW5kUnVsZXMucHVzaChwWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gdVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJSRVBcIiA9PT0gbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG8uc3BsaXQoL1xccysvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyA9PT0gcC5sZW5ndGggJiYgdGhpcy5yZXBsYWNlbWVudFRhYmxlLnB1c2goW3BbMV0sIHBbMl1dKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmZsYWdzW2xdID0gYVsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgICAgICAgICAgICAgfSwgX3JlbW92ZUFmZml4Q29tbWVudHM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA9IGUucmVwbGFjZSgvIy4qJC9nbSwgXCJcIiksIGUgPSBlLnJlcGxhY2UoL15cXHNcXHMqL20sIFwiXCIpLnJlcGxhY2UoL1xcc1xccyokL20sIFwiXCIpLCBlID0gZS5yZXBsYWNlKC9cXG57Mix9L2csIFwiXFxuXCIpLCBlID0gZS5yZXBsYWNlKC9eXFxzXFxzKi8sIFwiXCIpLnJlcGxhY2UoL1xcc1xccyokLywgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgfSwgX3BhcnNlRElDOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSBpbiByICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHJbZV0gfHwgKHJbZV0gPSBbXSksIHJbZV0ucHVzaCh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5fcmVtb3ZlRGljQ29tbWVudHMoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gZS5zcGxpdChcIlxcblwiKSwgciA9IHt9LCBpID0gMSwgbyA9IG4ubGVuZ3RoOyBvID4gaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBuW2ldLCBsID0gYS5zcGxpdChcIi9cIiwgMiksIHMgPSBsWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLnBhcnNlUnVsZUNvZGVzKGxbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk5FRURBRkZJWFwiIGluIHRoaXMuZmxhZ3MgJiYgLTEgIT0gYy5pbmRleE9mKHRoaXMuZmxhZ3MuTkVFREFGRklYKSB8fCB0KHMsIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB1ID0gMCwgZiA9IGMubGVuZ3RoOyBmID4gdTsgdSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGNbdV0sIGQgPSB0aGlzLnJ1bGVzW2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQpZm9yICh2YXIgcCA9IHRoaXMuX2FwcGx5UnVsZShzLCBkKSwgbSA9IDAsIGcgPSBwLmxlbmd0aDsgZyA+IG07IG0rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gcFttXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodCh2LCBbXSksIGQuY29tYmluZWFibGUpZm9yICh2YXIgeSA9IHUgKyAxOyBmID4geTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gY1t5XSwgYiA9IHRoaXMucnVsZXNbeF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiICYmIGIuY29tYmluZWFibGUgJiYgZC50eXBlICE9IGIudHlwZSlmb3IgKHZhciB3ID0gdGhpcy5fYXBwbHlSdWxlKHYsIGIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTID0gdy5sZW5ndGg7IFMgPiBrOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDID0gd1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQoQywgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoIGluIHRoaXMuY29tcG91bmRSdWxlQ29kZXMgJiYgdGhpcy5jb21wb3VuZFJ1bGVDb2Rlc1toXS5wdXNoKHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdChzLnRyaW0oKSwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gclxuICAgICAgICAgICAgICAgICAgICB9LCBfcmVtb3ZlRGljQ29tbWVudHM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSA9IGUucmVwbGFjZSgvXlxcdC4qJC9nbSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgfSwgcGFyc2VSdWxlQ29kZXM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUpcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoXCJGTEFHXCIgaW4gdGhpcy5mbGFncykpcmV0dXJuIGUuc3BsaXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJsb25nXCIgPT09IHRoaXMuZmxhZ3MuRkxBRykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSBbXSwgbiA9IDAsIHIgPSBlLmxlbmd0aDsgciA+IG47IG4gKz0gMil0LnB1c2goZS5zdWJzdHIobiwgMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJudW1cIiA9PT0gdGhpcy5mbGFncy5GTEFHID8gdGV4dENvZGUuc3BsaXQoXCIsXCIpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH0sIF9hcHBseVJ1bGU6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gdC5lbnRyaWVzLCByID0gW10sIGkgPSAwLCBvID0gbi5sZW5ndGg7IG8gPiBpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG5baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhLm1hdGNoIHx8IGUubWF0Y2goYS5tYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5yZW1vdmUgJiYgKGwgPSBsLnJlcGxhY2UoYS5yZW1vdmUsIFwiXCIpKSwgXCJTRlhcIiA9PT0gdC50eXBlID8gbCArPSBhLmFkZCA6IGwgPSBhLmFkZCArIGwsIHIucHVzaChsKSwgXCJjb250aW51YXRpb25DbGFzc2VzXCIgaW4gYSlmb3IgKHZhciBzID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGEuY29udGludWF0aW9uQ2xhc3Nlcy5sZW5ndGg7IGMgPiBzOyBzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gdGhpcy5ydWxlc1thLmNvbnRpbnVhdGlvbkNsYXNzZXNbc11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSAmJiAociA9IHIuY29uY2F0KHRoaXMuX2FwcGx5UnVsZShsLCB1KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gclxuICAgICAgICAgICAgICAgICAgICB9LCBjaGVjazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5yZXBsYWNlKC9eXFxzXFxzKi8sIFwiXCIpLnJlcGxhY2UoL1xcc1xccyokLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0V4YWN0KHQpKXJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LnRvVXBwZXJDYXNlKCkgPT09IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRbMF0gKyB0LnN1YnN0cmluZygxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsYWcobiwgXCJLRUVQQ0FTRVwiKSlyZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tFeGFjdChuKSlyZXR1cm4gITBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgIT09IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNGbGFnKHIsIFwiS0VFUENBU0VcIikpcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrRXhhY3QocikpcmV0dXJuICEwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITFcbiAgICAgICAgICAgICAgICAgICAgfSwgY2hlY2tFeGFjdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5kaWN0aW9uYXJ5VGFibGVbZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIkNPTVBPVU5ETUlOXCIgaW4gdGhpcy5mbGFncyAmJiBlLmxlbmd0aCA+PSB0aGlzLmZsYWdzLkNPTVBPVU5ETUlOKWZvciAodmFyIG4gPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gdGhpcy5jb21wb3VuZFJ1bGVzLmxlbmd0aDsgciA+IG47IG4rKylpZiAoZS5tYXRjaCh0aGlzLmNvbXBvdW5kUnVsZXNbbl0pKXJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHQubGVuZ3RoOyByID4gbjsgbisrKWlmICghdGhpcy5oYXNGbGFnKGUsIFwiT05MWUlOQ09NUE9VTkRcIiwgdFtuXSkpcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBoYXNGbGFnOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgaW4gdGhpcy5mbGFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBuKXZhciBuID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdGhpcy5kaWN0aW9uYXJ5VGFibGVbZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICYmIC0xICE9PSBuLmluZGV4T2YodGhpcy5mbGFnc1t0XSkpcmV0dXJuICEwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITFcbiAgICAgICAgICAgICAgICAgICAgfSwgYWxwaGFiZXQ6IFwiXCIsIHN1Z2dlc3Q6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBuKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gW10sIG4gPSAwLCByID0gZS5sZW5ndGg7IHIgPiBuOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGVbbl0sIG8gPSBbXSwgYSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBpLmxlbmd0aCArIDE7IGwgPiBhOyBhKyspby5wdXNoKFtpLnN1YnN0cmluZygwLCBhKSwgaS5zdWJzdHJpbmcoYSwgaS5sZW5ndGgpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSBbXSwgYSA9IDAsIGwgPSBvLmxlbmd0aDsgbCA+IGE7IGErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBvW2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdVsxXSAmJiBzLnB1c2godVswXSArIHVbMV0uc3Vic3RyaW5nKDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGYgPSBbXSwgYSA9IDAsIGwgPSBvLmxlbmd0aDsgbCA+IGE7IGErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBvW2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdVsxXS5sZW5ndGggPiAxICYmIGYucHVzaCh1WzBdICsgdVsxXVsxXSArIHVbMV1bMF0gKyB1WzFdLnN1YnN0cmluZygyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBoID0gW10sIGEgPSAwLCBsID0gby5sZW5ndGg7IGwgPiBhOyBhKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gb1thXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1WzFdKWZvciAodmFyIGQgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGMuYWxwaGFiZXQubGVuZ3RoOyBwID4gZDsgZCsrKWgucHVzaCh1WzBdICsgYy5hbHBoYWJldFtkXSArIHVbMV0uc3Vic3RyaW5nKDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSBbXSwgYSA9IDAsIGwgPSBvLmxlbmd0aDsgbCA+IGE7IGErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBvW2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVbMV0pZm9yICh2YXIgZCA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gYy5hbHBoYWJldC5sZW5ndGg7IHAgPiBkOyBkKyspaC5wdXNoKHVbMF0gKyBjLmFscGhhYmV0W2RdICsgdVsxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gdC5jb25jYXQocyksIHQgPSB0LmNvbmNhdChmKSwgdCA9IHQuY29uY2F0KGgpLCB0ID0gdC5jb25jYXQobSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IFtdLCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspYy5jaGVjayhlW25dKSAmJiB0LnB1c2goZVtuXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaShlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlWzFdIDwgdFsxXSA/IC0xIDogMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG8gPSBuKFtlXSksIGEgPSBuKG8pLCBsID0gcihvKS5jb25jYXQocihhKSksIHMgPSB7fSwgdSA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGwubGVuZ3RoOyBmID4gdTsgdSsrKWxbdV0gaW4gcyA/IHNbbFt1XV0gKz0gMSA6IHNbbFt1XV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdSBpbiBzKWgucHVzaChbdSwgc1t1XV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGguc29ydChpKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IFtdLCB1ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gTWF0aC5taW4odCwgaC5sZW5ndGgpOyBmID4gdTsgdSsrKWMuaGFzRmxhZyhoW3VdWzBdLCBcIk5PU1VHR0VTVFwiKSB8fCBkLnB1c2goaFt1XVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgfHwgKHQgPSA1KSwgdGhpcy5jaGVjayhlKSlyZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0gMCwgYSA9IHRoaXMucmVwbGFjZW1lbnRUYWJsZS5sZW5ndGg7IGEgPiBvOyBvKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHRoaXMucmVwbGFjZW1lbnRUYWJsZVtvXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLTEgIT09IGUuaW5kZXhPZihsWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGUucmVwbGFjZShsWzBdLCBsWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2socykpcmV0dXJuIFtzXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLmFscGhhYmV0ID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLCBpKGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB0ICYmICh0LmV4cG9ydHMgPSBpKVxuICAgICAgICAgICAgfSkuY2FsbCh0aGlzLCBlKFwiYnVmZmVyXCIpLkJ1ZmZlciwgXCIvbm9kZV9tb2R1bGVzL3R5cG8tanNcIilcbiAgICAgICAgfSwge2J1ZmZlcjogMywgZnM6IDJ9XSxcbiAgICAgICAgMTk6IFtmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgdmFyIHIgPSBlKFwiY29kZW1pcnJvclwiKTtcbiAgICAgICAgICAgIHIuY29tbWFuZHMudGFiQW5kSW5kZW50TWFya2Rvd25MaXN0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUubGlzdFNlbGVjdGlvbnMoKSwgbiA9IHRbMF0uaGVhZCwgciA9IGUuZ2V0U3RhdGVBZnRlcihuLmxpbmUpLCBpID0gci5saXN0ICE9PSAhMTtcbiAgICAgICAgICAgICAgICBpZiAoaSlyZXR1cm4gdm9pZCBlLmV4ZWNDb21tYW5kKFwiaW5kZW50TW9yZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5vcHRpb25zLmluZGVudFdpdGhUYWJzKSBlLmV4ZWNDb21tYW5kKFwiaW5zZXJ0VGFiXCIpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBBcnJheShlLm9wdGlvbnMudGFiU2l6ZSArIDEpLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICBlLnJlcGxhY2VTZWxlY3Rpb24obylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByLmNvbW1hbmRzLnNoaWZ0VGFiQW5kVW5pbmRlbnRNYXJrZG93bkxpc3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZS5saXN0U2VsZWN0aW9ucygpLCBuID0gdFswXS5oZWFkLCByID0gZS5nZXRTdGF0ZUFmdGVyKG4ubGluZSksIGkgPSByLmxpc3QgIT09ICExO1xuICAgICAgICAgICAgICAgIGlmIChpKXJldHVybiB2b2lkIGUuZXhlY0NvbW1hbmQoXCJpbmRlbnRMZXNzXCIpO1xuICAgICAgICAgICAgICAgIGlmIChlLm9wdGlvbnMuaW5kZW50V2l0aFRhYnMpIGUuZXhlY0NvbW1hbmQoXCJpbnNlcnRUYWJcIik7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IEFycmF5KGUub3B0aW9ucy50YWJTaXplICsgMSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgIGUucmVwbGFjZVNlbGVjdGlvbihvKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge2NvZGVtaXJyb3I6IDEwfV0sXG4gICAgICAgIDIwOiBbZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZnVuY3Rpb24gcihlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgPSBVID8gZS5yZXBsYWNlKFwiQ3RybFwiLCBcIkNtZFwiKSA6IGUucmVwbGFjZShcIkNtZFwiLCBcIkN0cmxcIilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaShlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgZSA9IGUgfHwge307XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdCA9IHZvaWQgMCA9PSB0ID8gITAgOiB0LCBlLnRpdGxlICYmIHQgJiYgKHIudGl0bGUgPSBhKGUudGl0bGUsIGUuYWN0aW9uLCBuKSwgVSAmJiAoci50aXRsZSA9IHIudGl0bGUucmVwbGFjZShcIkN0cmxcIiwgXCLijJhcIiksIHIudGl0bGUgPSByLnRpdGxlLnJlcGxhY2UoXCJBbHRcIiwgXCLijKVcIikpKSwgci50YWJJbmRleCA9IC0xLCByLmNsYXNzTmFtZSA9IGUuY2xhc3NOYW1lLCByXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG8oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5jbGFzc05hbWUgPSBcInNlcGFyYXRvclwiLCBlLmlubmVySFRNTCA9IFwifFwiLCBlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGEoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgIHZhciBpLCBvID0gZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdCAmJiAoaSA9IFkodCksIG5baV0gJiYgKG8gKz0gXCIgKFwiICsgcihuW2ldKSArIFwiKVwiKSksIG9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbChlLCB0KSB7XG4gICAgICAgICAgICAgICAgdCA9IHQgfHwgZS5nZXRDdXJzb3IoXCJzdGFydFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGUuZ2V0VG9rZW5BdCh0KTtcbiAgICAgICAgICAgICAgICBpZiAoIW4udHlwZSlyZXR1cm4ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgciwgaSwgbyA9IG4udHlwZS5zcGxpdChcIiBcIiksIGEgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBsID0gMDsgbCA8IG8ubGVuZ3RoOyBsKyspciA9IG9bbF0sIFwic3Ryb25nXCIgPT09IHIgPyBhLmJvbGQgPSAhMCA6IFwidmFyaWFibGUtMlwiID09PSByID8gKGkgPSBlLmdldExpbmUodC5saW5lKSwgL15cXHMqXFxkK1xcLlxccy8udGVzdChpKSA/IGFbXCJvcmRlcmVkLWxpc3RcIl0gPSAhMCA6IGFbXCJ1bm9yZGVyZWQtbGlzdFwiXSA9ICEwKSA6IFwiYXRvbVwiID09PSByID8gYS5xdW90ZSA9ICEwIDogXCJlbVwiID09PSByID8gYS5pdGFsaWMgPSAhMCA6IFwicXVvdGVcIiA9PT0gciA/IGEucXVvdGUgPSAhMCA6IFwic3RyaWtldGhyb3VnaFwiID09PSByID8gYS5zdHJpa2V0aHJvdWdoID0gITAgOiBcImNvbW1lbnRcIiA9PT0gciA/IGEuY29kZSA9ICEwIDogXCJsaW5rXCIgPT09IHIgPyBhLmxpbmsgPSAhMCA6IFwidGFnXCIgPT09IHIgPyBhLmltYWdlID0gITAgOiByLm1hdGNoKC9eaGVhZGVyKFxcLVsxLTZdKT8kLykgJiYgKGFbci5yZXBsYWNlKFwiaGVhZGVyXCIsIFwiaGVhZGluZ1wiKV0gPSAhMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcyhlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBlLmNvZGVtaXJyb3I7XG4gICAgICAgICAgICAgICAgdC5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICF0LmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpLCB0LmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikgPyAoViA9IGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3csIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiKSA6IGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBWO1xuICAgICAgICAgICAgICAgIHZhciBuID0gdC5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIC9mdWxsc2NyZWVuLy50ZXN0KG4ucHJldmlvdXNTaWJsaW5nLmNsYXNzTmFtZSkgPyBuLnByZXZpb3VzU2libGluZy5jbGFzc05hbWUgPSBuLnByZXZpb3VzU2libGluZy5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmZ1bGxzY3JlZW5cXGIvLCBcIlwiKSA6IG4ucHJldmlvdXNTaWJsaW5nLmNsYXNzTmFtZSArPSBcIiBmdWxsc2NyZWVuXCI7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBlLnRvb2xiYXJFbGVtZW50cy5mdWxsc2NyZWVuO1xuICAgICAgICAgICAgICAgIC9hY3RpdmUvLnRlc3Qoci5jbGFzc05hbWUpID8gci5jbGFzc05hbWUgPSByLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqYWN0aXZlXFxzKi9nLCBcIlwiKSA6IHIuY2xhc3NOYW1lICs9IFwiIGFjdGl2ZVwiO1xuICAgICAgICAgICAgICAgIHZhciBpID0gdC5nZXRXcmFwcGVyRWxlbWVudCgpLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIC9lZGl0b3ItcHJldmlldy1hY3RpdmUtc2lkZS8udGVzdChpLmNsYXNzTmFtZSkgJiYgTihlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjKGUpIHtcbiAgICAgICAgICAgICAgICBQKGUsIFwiYm9sZFwiLCBlLm9wdGlvbnMuYmxvY2tTdHlsZXMuYm9sZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdShlKSB7XG4gICAgICAgICAgICAgICAgUChlLCBcIml0YWxpY1wiLCBlLm9wdGlvbnMuYmxvY2tTdHlsZXMuaXRhbGljKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBmKGUpIHtcbiAgICAgICAgICAgICAgICBQKGUsIFwic3RyaWtldGhyb3VnaFwiLCBcIn5+XCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGgoZSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHQoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgZSl0aHJvd1wiZmVuY2luZ19saW5lKCkgdGFrZXMgYSAnbGluZScgb2JqZWN0IChub3QgYSBsaW5lIG51bWJlciwgb3IgbGluZSB0ZXh0KS4gIEdvdDogXCIgKyB0eXBlb2YgZSArIFwiOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnN0eWxlcyAmJiBlLnN0eWxlc1syXSAmJiAtMSAhPT0gZS5zdHlsZXNbMl0uaW5kZXhPZihcImZvcm1hdHRpbmctY29kZS1ibG9ja1wiKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG4oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5zdGF0ZS5iYXNlLmJhc2UgfHwgZS5zdGF0ZS5iYXNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcihlLCByLCBpLCBvLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBpIHx8IGUuZ2V0TGluZUhhbmRsZShyKSwgbyA9IG8gfHwgZS5nZXRUb2tlbkF0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiByLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgYSA9IGEgfHwgISFpLnRleHQgJiYgZS5nZXRUb2tlbkF0KHtsaW5lOiByLCBjaDogaS50ZXh0Lmxlbmd0aCAtIDF9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBvLnR5cGUgPyBvLnR5cGUuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhICYmIG4oYSkuaW5kZW50ZWRDb2RlID8gXCJpbmRlbnRlZFwiIDogLTEgPT09IGwuaW5kZXhPZihcImNvbW1lbnRcIikgPyAhMSA6IG4obykuZmVuY2VkQ2hhcnMgfHwgbihhKS5mZW5jZWRDaGFycyB8fCB0KGkpID8gXCJmZW5jZWRcIiA6IFwic2luZ2xlXCJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0LmxpbmUgKyAxLCBvID0gbi5saW5lICsgMSwgYSA9IHQubGluZSAhPT0gbi5saW5lLCBsID0gciArIFwiXFxuXCIsIHMgPSBcIlxcblwiICsgcjtcbiAgICAgICAgICAgICAgICAgICAgYSAmJiBvKyssIGEgJiYgMCA9PT0gbi5jaCAmJiAocyA9IHIgKyBcIlxcblwiLCBvLS0pLCBFKGUsICExLCBbbCwgc10pLCBlLnNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2g6IDBcbiAgICAgICAgICAgICAgICAgICAgfSwge2xpbmU6IG8sIGNoOiAwfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbywgYSwgbCwgcyA9IGUub3B0aW9ucy5ibG9ja1N0eWxlcy5jb2RlLCBjID0gZS5jb2RlbWlycm9yLCB1ID0gYy5nZXRDdXJzb3IoXCJzdGFydFwiKSxcbiAgICAgICAgICAgICAgICAgICAgZiA9IGMuZ2V0Q3Vyc29yKFwiZW5kXCIpLCBoID0gYy5nZXRUb2tlbkF0KHtsaW5lOiB1LmxpbmUsIGNoOiB1LmNoIHx8IDF9KSxcbiAgICAgICAgICAgICAgICAgICAgZCA9IGMuZ2V0TGluZUhhbmRsZSh1LmxpbmUpLCBwID0gcihjLCB1LmxpbmUsIGQsIGgpO1xuICAgICAgICAgICAgICAgIGlmIChcInNpbmdsZVwiID09PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gZC50ZXh0LnNsaWNlKDAsIHUuY2gpLnJlcGxhY2UoXCJgXCIsIFwiXCIpLCBnID0gZC50ZXh0LnNsaWNlKHUuY2gpLnJlcGxhY2UoXCJgXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBjLnJlcGxhY2VSYW5nZShtICsgZywge2xpbmU6IHUubGluZSwgY2g6IDB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB1LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaDogOTk5OTk5OTk5OTk5OTlcbiAgICAgICAgICAgICAgICAgICAgfSksIHUuY2gtLSwgdSAhPT0gZiAmJiBmLmNoLS0sIGMuc2V0U2VsZWN0aW9uKHUsIGYpLCBjLmZvY3VzKClcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiZmVuY2VkXCIgPT09IHApaWYgKHUubGluZSAhPT0gZi5saW5lIHx8IHUuY2ggIT09IGYuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChvID0gdS5saW5lOyBvID49IDAgJiYgKGQgPSBjLmdldExpbmVIYW5kbGUobyksICF0KGQpKTsgby0tKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYsIHksIHgsIGIsIHcgPSBjLmdldFRva2VuQXQoe2xpbmU6IG8sIGNoOiAxfSksIGsgPSBuKHcpLmZlbmNlZENoYXJzO1xuICAgICAgICAgICAgICAgICAgICB0KGMuZ2V0TGluZUhhbmRsZSh1LmxpbmUpKSA/ICh2ID0gXCJcIiwgeSA9IHUubGluZSkgOiB0KGMuZ2V0TGluZUhhbmRsZSh1LmxpbmUgLSAxKSkgPyAodiA9IFwiXCIsIHkgPSB1LmxpbmUgLSAxKSA6ICh2ID0gayArIFwiXFxuXCIsIHkgPSB1LmxpbmUpLCB0KGMuZ2V0TGluZUhhbmRsZShmLmxpbmUpKSA/ICh4ID0gXCJcIiwgYiA9IGYubGluZSwgMCA9PT0gZi5jaCAmJiAoYiArPSAxKSkgOiAwICE9PSBmLmNoICYmIHQoYy5nZXRMaW5lSGFuZGxlKGYubGluZSArIDEpKSA/ICh4ID0gXCJcIiwgYiA9IGYubGluZSArIDEpIDogKHggPSBrICsgXCJcXG5cIiwgYiA9IGYubGluZSArIDEpLCAwID09PSBmLmNoICYmIChiIC09IDEpLCBjLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnJlcGxhY2VSYW5nZSh4LCB7bGluZTogYiwgY2g6IDB9LCB7bGluZTogYiArICh4ID8gMCA6IDEpLCBjaDogMH0pLCBjLnJlcGxhY2VSYW5nZSh2LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge2xpbmU6IHkgKyAodiA/IDAgOiAxKSwgY2g6IDB9KVxuICAgICAgICAgICAgICAgICAgICB9KSwgYy5zZXRTZWxlY3Rpb24oe2xpbmU6IHkgKyAodiA/IDEgOiAwKSwgY2g6IDB9LCB7bGluZTogYiArICh2ID8gMSA6IC0xKSwgY2g6IDB9KSwgYy5mb2N1cygpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFMgPSB1LmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0KGMuZ2V0TGluZUhhbmRsZSh1LmxpbmUpKSAmJiAoXCJmZW5jZWRcIiA9PT0gcihjLCB1LmxpbmUgKyAxKSA/IChvID0gdS5saW5lLCBTID0gdS5saW5lICsgMSkgOiAoYSA9IHUubGluZSwgUyA9IHUubGluZSAtIDEpKSwgdm9pZCAwID09PSBvKWZvciAobyA9IFM7IG8gPj0gMCAmJiAoZCA9IGMuZ2V0TGluZUhhbmRsZShvKSwgIXQoZCkpOyBvLS0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBhKWZvciAobCA9IGMubGluZUNvdW50KCksIGEgPSBTOyBsID4gYSAmJiAoZCA9IGMuZ2V0TGluZUhhbmRsZShhKSwgIXQoZCkpOyBhKyspO1xuICAgICAgICAgICAgICAgICAgICBjLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnJlcGxhY2VSYW5nZShcIlwiLCB7bGluZTogbywgY2g6IDB9LCB7bGluZTogbyArIDEsIGNoOiAwfSksIGMucmVwbGFjZVJhbmdlKFwiXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBhIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge2xpbmU6IGEsIGNoOiAwfSlcbiAgICAgICAgICAgICAgICAgICAgfSksIGMuZm9jdXMoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJpbmRlbnRlZFwiID09PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1LmxpbmUgIT09IGYubGluZSB8fCB1LmNoICE9PSBmLmNoKSBvID0gdS5saW5lLCBhID0gZi5saW5lLCAwID09PSBmLmNoICYmIGEtLTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG8gPSB1LmxpbmU7IG8gPj0gMDsgby0tKWlmIChkID0gYy5nZXRMaW5lSGFuZGxlKG8pLCAhZC50ZXh0Lm1hdGNoKC9eXFxzKiQvKSAmJiBcImluZGVudGVkXCIgIT09IHIoYywgbywgZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobCA9IGMubGluZUNvdW50KCksIGEgPSB1LmxpbmU7IGwgPiBhOyBhKyspaWYgKGQgPSBjLmdldExpbmVIYW5kbGUoYSksICFkLnRleHQubWF0Y2goL15cXHMqJC8pICYmIFwiaW5kZW50ZWRcIiAhPT0gcihjLCBhLCBkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBDID0gYy5nZXRMaW5lSGFuZGxlKGEgKyAxKSwgTCA9IEMgJiYgYy5nZXRUb2tlbkF0KHtsaW5lOiBhICsgMSwgY2g6IEMudGV4dC5sZW5ndGggLSAxfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBUID0gTCAmJiBuKEwpLmluZGVudGVkQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgVCAmJiBjLnJlcGxhY2VSYW5nZShcIlxcblwiLCB7bGluZTogYSArIDEsIGNoOiAwfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIE0gPSBvOyBhID49IE07IE0rKyljLmluZGVudExpbmUoTSwgXCJzdWJ0cmFjdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgYy5mb2N1cygpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIE4gPSB1LmxpbmUgPT09IGYubGluZSAmJiB1LmNoID09PSBmLmNoICYmIDAgPT09IHUuY2gsIEEgPSB1LmxpbmUgIT09IGYubGluZTtcbiAgICAgICAgICAgICAgICAgICAgTiB8fCBBID8gaShjLCB1LCBmLCBzKSA6IEUoYywgITEsIFtcImBcIiwgXCJgXCJdKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBlLmNvZGVtaXJyb3I7XG4gICAgICAgICAgICAgICAgSSh0LCBcInF1b3RlXCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHAoZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZS5jb2RlbWlycm9yO1xuICAgICAgICAgICAgICAgIE8odCwgXCJzbWFsbGVyXCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG0oZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZS5jb2RlbWlycm9yO1xuICAgICAgICAgICAgICAgIE8odCwgXCJiaWdnZXJcIilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZyhlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBlLmNvZGVtaXJyb3I7XG4gICAgICAgICAgICAgICAgTyh0LCB2b2lkIDAsIDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHYoZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZS5jb2RlbWlycm9yO1xuICAgICAgICAgICAgICAgIE8odCwgdm9pZCAwLCAyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB5KGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUuY29kZW1pcnJvcjtcbiAgICAgICAgICAgICAgICBPKHQsIHZvaWQgMCwgMylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24geChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBlLmNvZGVtaXJyb3I7XG4gICAgICAgICAgICAgICAgSSh0LCBcInVub3JkZXJlZC1saXN0XCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGIoZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZS5jb2RlbWlycm9yO1xuICAgICAgICAgICAgICAgIEkodCwgXCJvcmRlcmVkLWxpc3RcIilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdyhlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBlLmNvZGVtaXJyb3I7XG4gICAgICAgICAgICAgICAgUih0KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBrKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUuY29kZW1pcnJvciwgbiA9IGwodCksIHIgPSBlLm9wdGlvbnMsIGkgPSBcImh0dHA6Ly9cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gci5wcm9tcHRVUkxzICYmIChpID0gcHJvbXB0KHIucHJvbXB0VGV4dHMubGluayksICFpKSA/ICExIDogdm9pZCBFKHQsIG4ubGluaywgci5pbnNlcnRUZXh0cy5saW5rLCBpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBTKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUuY29kZW1pcnJvciwgbiA9IGwodCksIHIgPSBlLm9wdGlvbnMsIGkgPSBcImh0dHA6Ly9cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gci5wcm9tcHRVUkxzICYmIChpID0gcHJvbXB0KHIucHJvbXB0VGV4dHMuaW1hZ2UpLCAhaSkgPyAhMSA6IHZvaWQgRSh0LCBuLmltYWdlLCByLmluc2VydFRleHRzLmltYWdlLCBpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBDKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUuY29kZW1pcnJvciwgbiA9IGwodCksIHIgPSBlLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgRSh0LCBuLnRhYmxlLCByLmluc2VydFRleHRzLnRhYmxlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBMKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUuY29kZW1pcnJvciwgbiA9IGwodCksIHIgPSBlLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgRSh0LCBuLmltYWdlLCByLmluc2VydFRleHRzLmhvcml6b250YWxSdWxlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBUKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUuY29kZW1pcnJvcjtcbiAgICAgICAgICAgICAgICB0LnVuZG8oKSwgdC5mb2N1cygpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIE0oZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZS5jb2RlbWlycm9yO1xuICAgICAgICAgICAgICAgIHQucmVkbygpLCB0LmZvY3VzKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gTihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBlLmNvZGVtaXJyb3IsIG4gPSB0LmdldFdyYXBwZXJFbGVtZW50KCksIHIgPSBuLm5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICBpID0gZS50b29sYmFyRWxlbWVudHNbXCJzaWRlLWJ5LXNpZGVcIl0sIG8gPSAhMTtcbiAgICAgICAgICAgICAgICAvZWRpdG9yLXByZXZpZXctYWN0aXZlLXNpZGUvLnRlc3Qoci5jbGFzc05hbWUpID8gKHIuY2xhc3NOYW1lID0gci5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmVkaXRvci1wcmV2aWV3LWFjdGl2ZS1zaWRlXFxzKi9nLCBcIlwiKSwgaS5jbGFzc05hbWUgPSBpLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqYWN0aXZlXFxzKi9nLCBcIlwiKSwgbi5jbGFzc05hbWUgPSBuLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqQ29kZU1pcnJvci1zaWRlZFxccyovZywgXCIgXCIpKSA6IChzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpIHx8IHMoZSksIHIuY2xhc3NOYW1lICs9IFwiIGVkaXRvci1wcmV2aWV3LWFjdGl2ZS1zaWRlXCJcbiAgICAgICAgICAgICAgICB9LCAxKSwgaS5jbGFzc05hbWUgKz0gXCIgYWN0aXZlXCIsIG4uY2xhc3NOYW1lICs9IFwiIENvZGVNaXJyb3Itc2lkZWRcIiwgbyA9ICEwKTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG4ubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICgvZWRpdG9yLXByZXZpZXctYWN0aXZlLy50ZXN0KGEuY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBhLmNsYXNzTmFtZSA9IGEuY2xhc3NOYW1lLnJlcGxhY2UoL1xccyplZGl0b3ItcHJldmlldy1hY3RpdmVcXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGUudG9vbGJhckVsZW1lbnRzLnByZXZpZXcsIGMgPSBuLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgbC5jbGFzc05hbWUgPSBsLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqYWN0aXZlXFxzKi9nLCBcIlwiKSwgYy5jbGFzc05hbWUgPSBjLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqZGlzYWJsZWQtZm9yLXByZXZpZXcqL2csIFwiXCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB1ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByLmlubmVySFRNTCA9IGUub3B0aW9ucy5wcmV2aWV3UmVuZGVyKGUudmFsdWUoKSwgcilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHQuc2lkZUJ5U2lkZVJlbmRlcmluZ0Z1bmN0aW9uIHx8ICh0LnNpZGVCeVNpZGVSZW5kZXJpbmdGdW5jdGlvbiA9IHUpLCBvID8gKHIuaW5uZXJIVE1MID0gZS5vcHRpb25zLnByZXZpZXdSZW5kZXIoZS52YWx1ZSgpLCByKSwgdC5vbihcInVwZGF0ZVwiLCB0LnNpZGVCeVNpZGVSZW5kZXJpbmdGdW5jdGlvbikpIDogdC5vZmYoXCJ1cGRhdGVcIiwgdC5zaWRlQnlTaWRlUmVuZGVyaW5nRnVuY3Rpb24pLCB0LnJlZnJlc2goKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBBKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUuY29kZW1pcnJvciwgbiA9IHQuZ2V0V3JhcHBlckVsZW1lbnQoKSwgciA9IG4ucHJldmlvdXNTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICBpID0gZS5vcHRpb25zLnRvb2xiYXIgPyBlLnRvb2xiYXJFbGVtZW50cy5wcmV2aWV3IDogITEsIG8gPSBuLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBvICYmIC9lZGl0b3ItcHJldmlldy8udGVzdChvLmNsYXNzTmFtZSkgfHwgKG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBvLmNsYXNzTmFtZSA9IFwiZWRpdG9yLXByZXZpZXdcIiwgbi5hcHBlbmRDaGlsZChvKSksIC9lZGl0b3ItcHJldmlldy1hY3RpdmUvLnRlc3Qoby5jbGFzc05hbWUpID8gKG8uY2xhc3NOYW1lID0gby5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmVkaXRvci1wcmV2aWV3LWFjdGl2ZVxccyovZywgXCJcIiksIGkgJiYgKGkuY2xhc3NOYW1lID0gaS5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmFjdGl2ZVxccyovZywgXCJcIiksIHIuY2xhc3NOYW1lID0gci5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmRpc2FibGVkLWZvci1wcmV2aWV3Ki9nLCBcIlwiKSkpIDogKHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBvLmNsYXNzTmFtZSArPSBcIiBlZGl0b3ItcHJldmlldy1hY3RpdmVcIlxuICAgICAgICAgICAgICAgIH0sIDEpLCBpICYmIChpLmNsYXNzTmFtZSArPSBcIiBhY3RpdmVcIiwgci5jbGFzc05hbWUgKz0gXCIgZGlzYWJsZWQtZm9yLXByZXZpZXdcIikpLCBvLmlubmVySFRNTCA9IGUub3B0aW9ucy5wcmV2aWV3UmVuZGVyKGUudmFsdWUoKSwgbyk7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0LmdldFdyYXBwZXJFbGVtZW50KCkubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgL2VkaXRvci1wcmV2aWV3LWFjdGl2ZS1zaWRlLy50ZXN0KGEuY2xhc3NOYW1lKSAmJiBOKGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEUoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgICAgIGlmICghL2VkaXRvci1wcmV2aWV3LWFjdGl2ZS8udGVzdChlLmdldFdyYXBwZXJFbGVtZW50KCkubGFzdENoaWxkLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8gPSBuWzBdLCBhID0gblsxXSwgbCA9IGUuZ2V0Q3Vyc29yKFwic3RhcnRcIiksIHMgPSBlLmdldEN1cnNvcihcImVuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgciAmJiAoYSA9IGEucmVwbGFjZShcIiN1cmwjXCIsIHIpKSwgdCA/IChpID0gZS5nZXRMaW5lKGwubGluZSksIG8gPSBpLnNsaWNlKDAsIGwuY2gpLCBhID0gaS5zbGljZShsLmNoKSwgZS5yZXBsYWNlUmFuZ2UobyArIGEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGwubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoOiAwXG4gICAgICAgICAgICAgICAgICAgIH0pKSA6IChpID0gZS5nZXRTZWxlY3Rpb24oKSwgZS5yZXBsYWNlU2VsZWN0aW9uKG8gKyBpICsgYSksIGwuY2ggKz0gby5sZW5ndGgsIGwgIT09IHMgJiYgKHMuY2ggKz0gby5sZW5ndGgpKSwgZS5zZXRTZWxlY3Rpb24obCwgcyksIGUuZm9jdXMoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gTyhlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEvZWRpdG9yLXByZXZpZXctYWN0aXZlLy50ZXN0KGUuZ2V0V3JhcHBlckVsZW1lbnQoKS5sYXN0Q2hpbGQuY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gZS5nZXRDdXJzb3IoXCJzdGFydFwiKSwgaSA9IGUuZ2V0Q3Vyc29yKFwiZW5kXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gci5saW5lOyBvIDw9IGkubGluZTsgbysrKSFmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlLmdldExpbmUociksIG8gPSBpLnNlYXJjaCgvW14jXS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHZvaWQgMCAhPT0gdCA/IDAgPj0gbyA/IFwiYmlnZ2VyXCIgPT0gdCA/IFwiIyMjIyMjIFwiICsgaSA6IFwiIyBcIiArIGkgOiA2ID09IG8gJiYgXCJzbWFsbGVyXCIgPT0gdCA/IGkuc3Vic3RyKDcpIDogMSA9PSBvICYmIFwiYmlnZ2VyXCIgPT0gdCA/IGkuc3Vic3RyKDIpIDogXCJiaWdnZXJcIiA9PSB0ID8gaS5zdWJzdHIoMSkgOiBcIiNcIiArIGkgOiAxID09IG4gPyAwID49IG8gPyBcIiMgXCIgKyBpIDogbyA9PSBuID8gaS5zdWJzdHIobyArIDEpIDogXCIjIFwiICsgaS5zdWJzdHIobyArIDEpIDogMiA9PSBuID8gMCA+PSBvID8gXCIjIyBcIiArIGkgOiBvID09IG4gPyBpLnN1YnN0cihvICsgMSkgOiBcIiMjIFwiICsgaS5zdWJzdHIobyArIDEpIDogMCA+PSBvID8gXCIjIyMgXCIgKyBpIDogbyA9PSBuID8gaS5zdWJzdHIobyArIDEpIDogXCIjIyMgXCIgKyBpLnN1YnN0cihvICsgMSksIGUucmVwbGFjZVJhbmdlKGksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiByLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7bGluZTogciwgY2g6IDk5OTk5OTk5OTk5OTk5fSlcbiAgICAgICAgICAgICAgICAgICAgfShvKTtcbiAgICAgICAgICAgICAgICAgICAgZS5mb2N1cygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBJKGUsIHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIS9lZGl0b3ItcHJldmlldy1hY3RpdmUvLnRlc3QoZS5nZXRXcmFwcGVyRWxlbWVudCgpLmxhc3RDaGlsZC5jbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSBsKGUpLCByID0gZS5nZXRDdXJzb3IoXCJzdGFydFwiKSwgaSA9IGUuZ2V0Q3Vyc29yKFwiZW5kXCIpLCBvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlOiAvXihcXHMqKVxcPlxccysvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidW5vcmRlcmVkLWxpc3RcIjogL14oXFxzKikoXFwqfFxcLXxcXCspXFxzKy8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmRlcmVkLWxpc3RcIjogL14oXFxzKilcXGQrXFwuXFxzKy9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGEgPSB7cXVvdGU6IFwiPiBcIiwgXCJ1bm9yZGVyZWQtbGlzdFwiOiBcIiogXCIsIFwib3JkZXJlZC1saXN0XCI6IFwiMS4gXCJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gci5saW5lOyBzIDw9IGkubGluZTsgcysrKSFmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlLmdldExpbmUocik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gblt0XSA/IGkucmVwbGFjZShvW3RdLCBcIiQxXCIpIDogYVt0XSArIGksIGUucmVwbGFjZVJhbmdlKGksIHtsaW5lOiByLCBjaDogMH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiByLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoOiA5OTk5OTk5OTk5OTk5OVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfShzKTtcbiAgICAgICAgICAgICAgICAgICAgZS5mb2N1cygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBQKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIS9lZGl0b3ItcHJldmlldy1hY3RpdmUvLnRlc3QoZS5jb2RlbWlycm9yLmdldFdyYXBwZXJFbGVtZW50KCkubGFzdENoaWxkLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIHIgPyBuIDogcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8gPSBlLmNvZGVtaXJyb3IsIGEgPSBsKG8pLCBzID0gbiwgYyA9IHIsIHUgPSBvLmdldEN1cnNvcihcInN0YXJ0XCIpLCBmID0gby5nZXRDdXJzb3IoXCJlbmRcIik7XG4gICAgICAgICAgICAgICAgICAgIGFbdF0gPyAoaSA9IG8uZ2V0TGluZSh1LmxpbmUpLCBzID0gaS5zbGljZSgwLCB1LmNoKSwgYyA9IGkuc2xpY2UodS5jaCksIFwiYm9sZFwiID09IHQgPyAocyA9IHMucmVwbGFjZSgvKFxcKlxcKnxfXykoPyFbXFxzXFxTXSooXFwqXFwqfF9fKSkvLCBcIlwiKSwgYyA9IGMucmVwbGFjZSgvKFxcKlxcKnxfXykvLCBcIlwiKSkgOiBcIml0YWxpY1wiID09IHQgPyAocyA9IHMucmVwbGFjZSgvKFxcKnxfKSg/IVtcXHNcXFNdKihcXCp8XykpLywgXCJcIiksIGMgPSBjLnJlcGxhY2UoLyhcXCp8XykvLCBcIlwiKSkgOiBcInN0cmlrZXRocm91Z2hcIiA9PSB0ICYmIChzID0gcy5yZXBsYWNlKC8oXFwqXFwqfH5+KSg/IVtcXHNcXFNdKihcXCpcXCp8fn4pKS8sIFwiXCIpLCBjID0gYy5yZXBsYWNlKC8oXFwqXFwqfH5+KS8sIFwiXCIpKSwgby5yZXBsYWNlUmFuZ2UocyArIGMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHUubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoOiAwXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHUubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoOiA5OTk5OTk5OTk5OTk5OVxuICAgICAgICAgICAgICAgICAgICB9KSwgXCJib2xkXCIgPT0gdCB8fCBcInN0cmlrZXRocm91Z2hcIiA9PSB0ID8gKHUuY2ggLT0gMiwgdSAhPT0gZiAmJiAoZi5jaCAtPSAyKSkgOiBcIml0YWxpY1wiID09IHQgJiYgKHUuY2ggLT0gMSwgdSAhPT0gZiAmJiAoZi5jaCAtPSAxKSkpIDogKGkgPSBvLmdldFNlbGVjdGlvbigpLCBcImJvbGRcIiA9PSB0ID8gKGkgPSBpLnNwbGl0KFwiKipcIikuam9pbihcIlwiKSwgaSA9IGkuc3BsaXQoXCJfX1wiKS5qb2luKFwiXCIpKSA6IFwiaXRhbGljXCIgPT0gdCA/IChpID0gaS5zcGxpdChcIipcIikuam9pbihcIlwiKSwgaSA9IGkuc3BsaXQoXCJfXCIpLmpvaW4oXCJcIikpIDogXCJzdHJpa2V0aHJvdWdoXCIgPT0gdCAmJiAoaSA9IGkuc3BsaXQoXCJ+flwiKS5qb2luKFwiXCIpKSwgby5yZXBsYWNlU2VsZWN0aW9uKHMgKyBpICsgYyksIHUuY2ggKz0gbi5sZW5ndGgsIGYuY2ggPSB1LmNoICsgaS5sZW5ndGgpLCBvLnNldFNlbGVjdGlvbih1LCBmKSwgby5mb2N1cygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBSKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIS9lZGl0b3ItcHJldmlldy1hY3RpdmUvLnRlc3QoZS5nZXRXcmFwcGVyRWxlbWVudCgpLmxhc3RDaGlsZC5jbGFzc05hbWUpKWZvciAodmFyIHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gZS5nZXRDdXJzb3IoXCJzdGFydFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBlLmdldEN1cnNvcihcImVuZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBuLmxpbmU7IGkgPD0gci5saW5lOyBpKyspdCA9IGUuZ2V0TGluZShpKSwgdCA9IHQucmVwbGFjZSgvXlsgXSooWyMgXSt8XFwqfFxcLXxbPiBdK3xbMC05XSsoLnxcXCkpKVsgXSovLCBcIlwiKSwgZS5yZXBsYWNlUmFuZ2UodCwge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBpLFxuICAgICAgICAgICAgICAgICAgICBjaDogMFxuICAgICAgICAgICAgICAgIH0sIHtsaW5lOiBpLCBjaDogOTk5OTk5OTk5OTk5OTl9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBEKGUsIHQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShuKSAmJiAodFtuXSBpbnN0YW5jZW9mIEFycmF5ID8gZVtuXSA9IHRbbl0uY29uY2F0KGVbbl0gaW5zdGFuY2VvZiBBcnJheSA/IGVbbl0gOiBbXSkgOiBudWxsICE9PSB0W25dICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHRbbl0gJiYgdFtuXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ID8gZVtuXSA9IEQoZVtuXSB8fCB7fSwgdFtuXSkgOiBlW25dID0gdFtuXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gSChlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IDE7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspZSA9IEQoZSwgYXJndW1lbnRzW3RdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBXKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IC9bYS16QS1aMC05X1xcdTAzOTItXFx1MDNjOVxcdTA0MTAtXFx1MDRGOV0rfFtcXHU0RTAwLVxcdTlGRkZcXHUzNDAwLVxcdTRkYmZcXHVmOTAwLVxcdWZhZmZcXHUzMDQwLVxcdTMwOWZcXHVhYzAwLVxcdWQ3YWZdKy9nLFxuICAgICAgICAgICAgICAgICAgICBuID0gZS5tYXRjaCh0KSwgciA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IG4pcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKXIgKz0gbltpXS5jaGFyQ29kZUF0KDApID49IDE5OTY4ID8gbltpXS5sZW5ndGggOiAxO1xuICAgICAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEIoZSkge1xuICAgICAgICAgICAgICAgIGUgPSBlIHx8IHt9LCBlLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSAhMDtcbiAgICAgICAgICAgICAgICBpZiAoZS5hdXRvRG93bmxvYWRGb250QXdlc29tZSA9PT0gITEgJiYgKHQgPSAhMSksIGUuYXV0b0Rvd25sb2FkRm9udEF3ZXNvbWUgIT09ICEwKWZvciAodmFyIG4gPSBkb2N1bWVudC5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAwOyByIDwgbi5sZW5ndGg7IHIrKyluW3JdLmhyZWYgJiYgbltyXS5ocmVmLmluZGV4T2YoXCIvL21heGNkbi5ib290c3RyYXBjZG4uY29tL2ZvbnQtYXdlc29tZS9cIikgPiAtMSAmJiAodCA9ICExKTtcbiAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgICAgICAgICAgICAgICBpLnJlbCA9IFwic3R5bGVzaGVldFwiLCBpLmhyZWYgPSBcImh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lL2xhdGVzdC9jc3MvZm9udC1hd2Vzb21lLm1pbi5jc3NcIiwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKGkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlLmVsZW1lbnQpIHRoaXMuZWxlbWVudCA9IGUuZWxlbWVudDsgZWxzZSBpZiAobnVsbCA9PT0gZS5lbGVtZW50KXJldHVybiB2b2lkIGNvbnNvbGUubG9nKFwiU2ltcGxlTURFOiBFcnJvci4gTm8gZWxlbWVudCB3YXMgZm91bmQuXCIpO1xuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUudG9vbGJhcikge1xuICAgICAgICAgICAgICAgICAgICBlLnRvb2xiYXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbyBpbiBLKUsuaGFzT3duUHJvcGVydHkobykgJiYgKC0xICE9IG8uaW5kZXhPZihcInNlcGFyYXRvci1cIikgJiYgZS50b29sYmFyLnB1c2goXCJ8XCIpLCAoS1tvXVtcImRlZmF1bHRcIl0gPT09ICEwIHx8IGUuc2hvd0ljb25zICYmIGUuc2hvd0ljb25zLmNvbnN0cnVjdG9yID09PSBBcnJheSAmJiAtMSAhPSBlLnNob3dJY29ucy5pbmRleE9mKG8pKSAmJiBlLnRvb2xiYXIucHVzaChvKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZS5oYXNPd25Qcm9wZXJ0eShcInN0YXR1c1wiKSB8fCAoZS5zdGF0dXMgPSBbXCJhdXRvc2F2ZVwiLCBcImxpbmVzXCIsIFwid29yZHNcIiwgXCJjdXJzb3JcIl0pLCBlLnByZXZpZXdSZW5kZXIgfHwgKGUucHJldmlld1JlbmRlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5tYXJrZG93bihlKVxuICAgICAgICAgICAgICAgIH0pLCBlLnBhcnNpbmdDb25maWcgPSBIKHtoaWdobGlnaHRGb3JtYXR0aW5nOiAhMH0sIGUucGFyc2luZ0NvbmZpZyB8fCB7fSksIGUuaW5zZXJ0VGV4dHMgPSBIKHt9LCBYLCBlLmluc2VydFRleHRzIHx8IHt9KSwgZS5wcm9tcHRUZXh0cyA9IFosIGUuYmxvY2tTdHlsZXMgPSBIKHt9LCBKLCBlLmJsb2NrU3R5bGVzIHx8IHt9KSwgZS5zaG9ydGN1dHMgPSBIKHt9LCBHLCBlLnNob3J0Y3V0cyB8fCB7fSksIHZvaWQgMCAhPSBlLmF1dG9zYXZlICYmIHZvaWQgMCAhPSBlLmF1dG9zYXZlLnVuaXF1ZV9pZCAmJiBcIlwiICE9IGUuYXV0b3NhdmUudW5pcXVlX2lkICYmIChlLmF1dG9zYXZlLnVuaXF1ZUlkID0gZS5hdXRvc2F2ZS51bmlxdWVfaWQpLCB0aGlzLm9wdGlvbnMgPSBlLCB0aGlzLnJlbmRlcigpLCAhZS5pbml0aWFsVmFsdWUgfHwgdGhpcy5vcHRpb25zLmF1dG9zYXZlICYmIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5mb3VuZFNhdmVkVmFsdWUgPT09ICEwIHx8IHRoaXMudmFsdWUoZS5pbml0aWFsVmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF8oKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGxvY2FsU3RvcmFnZSlyZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzbWRlX2xvY2FsU3RvcmFnZVwiLCAxKSwgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJzbWRlX2xvY2FsU3RvcmFnZVwiKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhMFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgRiA9IGUoXCJjb2RlbWlycm9yXCIpO1xuICAgICAgICAgICAgZShcImNvZGVtaXJyb3IvYWRkb24vZWRpdC9jb250aW51ZWxpc3QuanNcIiksIGUoXCIuL2NvZGVtaXJyb3IvdGFibGlzdFwiKSwgZShcImNvZGVtaXJyb3IvYWRkb24vZGlzcGxheS9mdWxsc2NyZWVuLmpzXCIpLCBlKFwiY29kZW1pcnJvci9tb2RlL21hcmtkb3duL21hcmtkb3duLmpzXCIpLCBlKFwiY29kZW1pcnJvci9hZGRvbi9tb2RlL292ZXJsYXkuanNcIiksIGUoXCJjb2RlbWlycm9yL2FkZG9uL2Rpc3BsYXkvcGxhY2Vob2xkZXIuanNcIiksIGUoXCJjb2RlbWlycm9yL2FkZG9uL3NlbGVjdGlvbi9tYXJrLXNlbGVjdGlvbi5qc1wiKSwgZShcImNvZGVtaXJyb3IvbW9kZS9nZm0vZ2ZtLmpzXCIpLCBlKFwiY29kZW1pcnJvci9tb2RlL3htbC94bWwuanNcIik7XG4gICAgICAgICAgICB2YXIgeiA9IGUoXCJjb2RlbWlycm9yLXNwZWxsLWNoZWNrZXJcIiksIGogPSBlKFwibWFya2VkXCIpLCBVID0gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pLCBxID0ge1xuICAgICAgICAgICAgICAgIHRvZ2dsZUJvbGQ6IGMsXG4gICAgICAgICAgICAgICAgdG9nZ2xlSXRhbGljOiB1LFxuICAgICAgICAgICAgICAgIGRyYXdMaW5rOiBrLFxuICAgICAgICAgICAgICAgIHRvZ2dsZUhlYWRpbmdTbWFsbGVyOiBwLFxuICAgICAgICAgICAgICAgIHRvZ2dsZUhlYWRpbmdCaWdnZXI6IG0sXG4gICAgICAgICAgICAgICAgZHJhd0ltYWdlOiBTLFxuICAgICAgICAgICAgICAgIHRvZ2dsZUJsb2NrcXVvdGU6IGQsXG4gICAgICAgICAgICAgICAgdG9nZ2xlT3JkZXJlZExpc3Q6IGIsXG4gICAgICAgICAgICAgICAgdG9nZ2xlVW5vcmRlcmVkTGlzdDogeCxcbiAgICAgICAgICAgICAgICB0b2dnbGVDb2RlQmxvY2s6IGgsXG4gICAgICAgICAgICAgICAgdG9nZ2xlUHJldmlldzogQSxcbiAgICAgICAgICAgICAgICB0b2dnbGVTdHJpa2V0aHJvdWdoOiBmLFxuICAgICAgICAgICAgICAgIHRvZ2dsZUhlYWRpbmcxOiBnLFxuICAgICAgICAgICAgICAgIHRvZ2dsZUhlYWRpbmcyOiB2LFxuICAgICAgICAgICAgICAgIHRvZ2dsZUhlYWRpbmczOiB5LFxuICAgICAgICAgICAgICAgIGNsZWFuQmxvY2s6IHcsXG4gICAgICAgICAgICAgICAgZHJhd1RhYmxlOiBDLFxuICAgICAgICAgICAgICAgIGRyYXdIb3Jpem9udGFsUnVsZTogTCxcbiAgICAgICAgICAgICAgICB1bmRvOiBULFxuICAgICAgICAgICAgICAgIHJlZG86IE0sXG4gICAgICAgICAgICAgICAgdG9nZ2xlU2lkZUJ5U2lkZTogTixcbiAgICAgICAgICAgICAgICB0b2dnbGVGdWxsU2NyZWVuOiBzXG4gICAgICAgICAgICB9LCBHID0ge1xuICAgICAgICAgICAgICAgIHRvZ2dsZUJvbGQ6IFwiQ21kLUJcIixcbiAgICAgICAgICAgICAgICB0b2dnbGVJdGFsaWM6IFwiQ21kLUlcIixcbiAgICAgICAgICAgICAgICBkcmF3TGluazogXCJDbWQtS1wiLFxuICAgICAgICAgICAgICAgIHRvZ2dsZUhlYWRpbmdTbWFsbGVyOiBcIkNtZC1IXCIsXG4gICAgICAgICAgICAgICAgdG9nZ2xlSGVhZGluZ0JpZ2dlcjogXCJTaGlmdC1DbWQtSFwiLFxuICAgICAgICAgICAgICAgIGNsZWFuQmxvY2s6IFwiQ21kLUVcIixcbiAgICAgICAgICAgICAgICBkcmF3SW1hZ2U6IFwiQ21kLUFsdC1JXCIsXG4gICAgICAgICAgICAgICAgdG9nZ2xlQmxvY2txdW90ZTogXCJDbWQtJ1wiLFxuICAgICAgICAgICAgICAgIHRvZ2dsZU9yZGVyZWRMaXN0OiBcIkNtZC1BbHQtTFwiLFxuICAgICAgICAgICAgICAgIHRvZ2dsZVVub3JkZXJlZExpc3Q6IFwiQ21kLUxcIixcbiAgICAgICAgICAgICAgICB0b2dnbGVDb2RlQmxvY2s6IFwiQ21kLUFsdC1DXCIsXG4gICAgICAgICAgICAgICAgdG9nZ2xlUHJldmlldzogXCJDbWQtUFwiLFxuICAgICAgICAgICAgICAgIHRvZ2dsZVNpZGVCeVNpZGU6IFwiRjlcIixcbiAgICAgICAgICAgICAgICB0b2dnbGVGdWxsU2NyZWVuOiBcIkYxMVwiXG4gICAgICAgICAgICB9LCBZID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0IGluIHEpaWYgKHFbdF0gPT09IGUpcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH0sICQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSAhMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgKC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm98YW5kcm9pZHxpcGFkfHBsYXlib29rfHNpbGsvaS50ZXN0KHQpIHx8IC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLnRlc3QodC5zdWJzdHIoMCwgNCkpKSAmJiAoZSA9ICEwKTtcbiAgICAgICAgICAgICAgICB9KG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmEpLCBlXG4gICAgICAgICAgICB9LCBWID0gXCJcIiwgSyA9IHtcbiAgICAgICAgICAgICAgICBib2xkOiB7bmFtZTogXCJib2xkXCIsIGFjdGlvbjogYywgY2xhc3NOYW1lOiBcImZhIGZhLWJvbGRcIiwgdGl0bGU6IFwiQm9sZFwiLCBcImRlZmF1bHRcIjogITB9LFxuICAgICAgICAgICAgICAgIGl0YWxpYzoge25hbWU6IFwiaXRhbGljXCIsIGFjdGlvbjogdSwgY2xhc3NOYW1lOiBcImZhIGZhLWl0YWxpY1wiLCB0aXRsZTogXCJJdGFsaWNcIiwgXCJkZWZhdWx0XCI6ICEwfSxcbiAgICAgICAgICAgICAgICBzdHJpa2V0aHJvdWdoOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3RyaWtldGhyb3VnaFwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGYsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJmYSBmYS1zdHJpa2V0aHJvdWdoXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlN0cmlrZXRocm91Z2hcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGVhZGluZzoge25hbWU6IFwiaGVhZGluZ1wiLCBhY3Rpb246IHAsIGNsYXNzTmFtZTogXCJmYSBmYS1oZWFkZXJcIiwgdGl0bGU6IFwiSGVhZGluZ1wiLCBcImRlZmF1bHRcIjogITB9LFxuICAgICAgICAgICAgICAgIFwiaGVhZGluZy1zbWFsbGVyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJoZWFkaW5nLXNtYWxsZXJcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBwLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiZmEgZmEtaGVhZGVyIGZhLWhlYWRlci14IGZhLWhlYWRlci1zbWFsbGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlNtYWxsZXIgSGVhZGluZ1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImhlYWRpbmctYmlnZ2VyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJoZWFkaW5nLWJpZ2dlclwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IG0sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJmYSBmYS1oZWFkZXIgZmEtaGVhZGVyLXggZmEtaGVhZGVyLWJpZ2dlclwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJCaWdnZXIgSGVhZGluZ1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImhlYWRpbmctMVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaGVhZGluZy0xXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImZhIGZhLWhlYWRlciBmYS1oZWFkZXIteCBmYS1oZWFkZXItMVwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJCaWcgSGVhZGluZ1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImhlYWRpbmctMlwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaGVhZGluZy0yXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogdixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImZhIGZhLWhlYWRlciBmYS1oZWFkZXIteCBmYS1oZWFkZXItMlwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJNZWRpdW0gSGVhZGluZ1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImhlYWRpbmctM1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaGVhZGluZy0zXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogeSxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImZhIGZhLWhlYWRlciBmYS1oZWFkZXIteCBmYS1oZWFkZXItM1wiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJTbWFsbCBIZWFkaW5nXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic2VwYXJhdG9yLTFcIjoge25hbWU6IFwic2VwYXJhdG9yLTFcIn0sXG4gICAgICAgICAgICAgICAgY29kZToge25hbWU6IFwiY29kZVwiLCBhY3Rpb246IGgsIGNsYXNzTmFtZTogXCJmYSBmYS1jb2RlXCIsIHRpdGxlOiBcIkNvZGVcIn0sXG4gICAgICAgICAgICAgICAgcXVvdGU6IHtuYW1lOiBcInF1b3RlXCIsIGFjdGlvbjogZCwgY2xhc3NOYW1lOiBcImZhIGZhLXF1b3RlLWxlZnRcIiwgdGl0bGU6IFwiUXVvdGVcIiwgXCJkZWZhdWx0XCI6ICEwfSxcbiAgICAgICAgICAgICAgICBcInVub3JkZXJlZC1saXN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJ1bm9yZGVyZWQtbGlzdFwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHgsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJmYSBmYS1saXN0LXVsXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkdlbmVyaWMgTGlzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHRcIjogITBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwib3JkZXJlZC1saXN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJvcmRlcmVkLWxpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiZmEgZmEtbGlzdC1vbFwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJOdW1iZXJlZCBMaXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiOiAhMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJjbGVhbi1ibG9ja1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY2xlYW4tYmxvY2tcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB3LFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiZmEgZmEtZXJhc2VyIGZhLWNsZWFuLWJsb2NrXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkNsZWFuIGJsb2NrXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic2VwYXJhdG9yLTJcIjoge25hbWU6IFwic2VwYXJhdG9yLTJcIn0sXG4gICAgICAgICAgICAgICAgbGluazoge25hbWU6IFwibGlua1wiLCBhY3Rpb246IGssIGNsYXNzTmFtZTogXCJmYSBmYS1saW5rXCIsIHRpdGxlOiBcIkNyZWF0ZSBMaW5rXCIsIFwiZGVmYXVsdFwiOiAhMH0sXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHtuYW1lOiBcImltYWdlXCIsIGFjdGlvbjogZnVuY3Rpb24oZWRpdG9yKXtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBlZGl0b3Iub3B0aW9ucy5pbWFnZXNNb2RhbFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQ6IGVkaXRvci5vcHRpb25zLmltYWdlc01vZGFsSW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlZGl0b3IuY29kZW1pcnJvciwgbiA9IGwodCksIHIgPSBlZGl0b3Iub3B0aW9ucywgaSA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNpbWFnZXMtcm93IC5pbWFnZXMtc3F1YXJlLnNlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRSh0LCBuLmltYWdlLCBbXCIhW1wiLCBcIl0oXFxcIlwiICsgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW1hZ2UnKSsgXCIpXFxuXFxuICAgIFwiXSwgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIH0sIGNsYXNzTmFtZTogXCJmYSBmYS1waWN0dXJlLW9cIiwgdGl0bGU6IFwiSW5zZXJ0IEltYWdlXCIsIFwiZGVmYXVsdFwiOiAhMH0sXG4gICAgICAgICAgICAgICAgdGFibGU6IHtuYW1lOiBcInRhYmxlXCIsIGFjdGlvbjogQywgY2xhc3NOYW1lOiBcImZhIGZhLXRhYmxlXCIsIHRpdGxlOiBcIkluc2VydCBUYWJsZVwifSxcbiAgICAgICAgICAgICAgICBcImhvcml6b250YWwtcnVsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaG9yaXpvbnRhbC1ydWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogTCxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImZhIGZhLW1pbnVzXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkluc2VydCBIb3Jpem9udGFsIExpbmVcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJzZXBhcmF0b3ItM1wiOiB7bmFtZTogXCJzZXBhcmF0b3ItM1wifSxcbiAgICAgICAgICAgICAgICBwcmV2aWV3OiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicHJldmlld1wiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IEEsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJmYSBmYS1leWUgbm8tZGlzYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJUb2dnbGUgUHJldmlld1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHRcIjogITBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic2lkZS1ieS1zaWRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzaWRlLWJ5LXNpZGVcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBOLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiZmEgZmEtY29sdW1ucyBuby1kaXNhYmxlIG5vLW1vYmlsZVwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJUb2dnbGUgU2lkZSBieSBTaWRlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiOiAhMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVsbHNjcmVlbjoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImZ1bGxzY3JlZW5cIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBzLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiZmEgZmEtYXJyb3dzLWFsdCBuby1kaXNhYmxlIG5vLW1vYmlsZVwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJUb2dnbGUgRnVsbHNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHRcIjogITBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwic2VwYXJhdG9yLTRcIjoge25hbWU6IFwic2VwYXJhdG9yLTRcIn0sXG4gICAgICAgICAgICAgICAgZ3VpZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJndWlkZVwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiaHR0cHM6Ly9zaW1wbGVtZGUuY29tL21hcmtkb3duLWd1aWRlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJmYSBmYS1xdWVzdGlvbi1jaXJjbGVcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiTWFya2Rvd24gR3VpZGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkZWZhdWx0XCI6ICEwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInNlcGFyYXRvci01XCI6IHtuYW1lOiBcInNlcGFyYXRvci01XCJ9LFxuICAgICAgICAgICAgICAgIHVuZG86IHtuYW1lOiBcInVuZG9cIiwgYWN0aW9uOiBULCBjbGFzc05hbWU6IFwiZmEgZmEtdW5kbyBuby1kaXNhYmxlXCIsIHRpdGxlOiBcIlVuZG9cIn0sXG4gICAgICAgICAgICAgICAgcmVkbzoge25hbWU6IFwicmVkb1wiLCBhY3Rpb246IE0sIGNsYXNzTmFtZTogXCJmYSBmYS1yZXBlYXQgbm8tZGlzYWJsZVwiLCB0aXRsZTogXCJSZWRvXCJ9XG4gICAgICAgICAgICB9LCBYID0ge1xuICAgICAgICAgICAgICAgIGxpbms6IFtcIltcIiwgXCJdKCN1cmwjKVwiXSxcbiAgICAgICAgICAgICAgICBpbWFnZTogW1wiIVtdKFwiLCBcIiN1cmwjKVwiXSxcbiAgICAgICAgICAgICAgICB0YWJsZTogW1wiXCIsIFwiXFxuXFxufCBDb2x1bW4gMSB8IENvbHVtbiAyIHwgQ29sdW1uIDMgfFxcbnwgLS0tLS0tLS0gfCAtLS0tLS0tLSB8IC0tLS0tLS0tIHxcXG58IFRleHQgICAgIHwgVGV4dCAgICAgfCBUZXh0ICAgICB8XFxuXFxuXCJdLFxuICAgICAgICAgICAgICAgIGhvcml6b250YWxSdWxlOiBbXCJcIiwgXCJcXG5cXG4tLS0tLVxcblxcblwiXVxuICAgICAgICAgICAgfSwgWiA9IHtsaW5rOiBcIlVSTCBmb3IgdGhlIGxpbms6XCIsIGltYWdlOiBcIlVSTCBvZiB0aGUgaW1hZ2U6XCJ9LCBKID0ge2JvbGQ6IFwiKipcIiwgY29kZTogXCJgYGBcIiwgaXRhbGljOiBcIipcIn07XG4gICAgICAgICAgICBCLnByb3RvdHlwZS5tYXJrZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGopIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucmVuZGVyaW5nQ29uZmlnICYmIHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcuc2luZ2xlTGluZUJyZWFrcyA9PT0gITEgPyB0LmJyZWFrcyA9ICExIDogdC5icmVha3MgPSAhMCwgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5yZW5kZXJpbmdDb25maWcgJiYgdGhpcy5vcHRpb25zLnJlbmRlcmluZ0NvbmZpZy5jb2RlU3ludGF4SGlnaGxpZ2h0aW5nID09PSAhMCAmJiB3aW5kb3cuaGxqcyAmJiAodC5oaWdobGlnaHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5obGpzLmhpZ2hsaWdodEF1dG8oZSkudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSksIGouc2V0T3B0aW9ucyh0KSwgaihlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIEIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgfHwgKGUgPSB0aGlzLmVsZW1lbnQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZXh0YXJlYVwiKVswXSksICF0aGlzLl9yZW5kZXJlZCB8fCB0aGlzLl9yZW5kZXJlZCAhPT0gZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucywgbiA9IHRoaXMsIGkgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbyBpbiB0LnNob3J0Y3V0cyludWxsICE9PSB0LnNob3J0Y3V0c1tvXSAmJiBudWxsICE9PSBxW29dICYmICFmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaVtyKHQuc2hvcnRjdXRzW2VdKV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcVtlXShuKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KG8pO1xuICAgICAgICAgICAgICAgICAgICBpLkVudGVyID0gXCJuZXdsaW5lQW5kSW5kZW50Q29udGludWVNYXJrZG93bkxpc3RcIiwgaS5UYWIgPSBcInRhYkFuZEluZGVudE1hcmtkb3duTGlzdFwiLCBpW1wiU2hpZnQtVGFiXCJdID0gXCJzaGlmdFRhYkFuZFVuaW5kZW50TWFya2Rvd25MaXN0XCIsIGkuRXNjID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSAmJiBzKG4pXG4gICAgICAgICAgICAgICAgICAgIH0sIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQsIDI3ID09IGUua2V5Q29kZSAmJiBuLmNvZGVtaXJyb3IuZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSAmJiBzKG4pXG4gICAgICAgICAgICAgICAgICAgIH0sICExKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEsIGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LnNwZWxsQ2hlY2tlciAhPT0gITEgPyAoYSA9IFwic3BlbGwtY2hlY2tlclwiLCBsID0gdC5wYXJzaW5nQ29uZmlnLCBsLm5hbWUgPSBcImdmbVwiLCBsLmdpdEh1YlNwaWNlID0gITEsIHooe2NvZGVNaXJyb3JJbnN0YW5jZTogRn0pKSA6IChhID0gdC5wYXJzaW5nQ29uZmlnLCBhLm5hbWUgPSBcImdmbVwiLCBhLmdpdEh1YlNwaWNlID0gITEpLCB0aGlzLmNvZGVtaXJyb3IgPSBGLmZyb21UZXh0QXJlYShlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcDogbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZTogXCJwYXBlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYlNpemU6IHZvaWQgMCAhPSB0LnRhYlNpemUgPyB0LnRhYlNpemUgOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudFVuaXQ6IHZvaWQgMCAhPSB0LnRhYlNpemUgPyB0LnRhYlNpemUgOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiB0LmluZGVudFdpdGhUYWJzICE9PSAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyczogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b2ZvY3VzOiB0LmF1dG9mb2N1cyA9PT0gITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFLZXlzOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXcmFwcGluZzogdC5saW5lV3JhcHBpbmcgIT09ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93RHJvcEZpbGVUeXBlczogW1widGV4dC9wbGFpblwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogdC5wbGFjZWhvbGRlciB8fCBlLmdldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVTZWxlY3RlZFRleHQ6IHZvaWQgMCAhPSB0LnN0eWxlU2VsZWN0ZWRUZXh0ID8gdC5zdHlsZVNlbGVjdGVkVGV4dCA6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgdC5mb3JjZVN5bmMgPT09ICEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc2F2ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3VpID0ge30sIHQudG9vbGJhciAhPT0gITEgJiYgKHRoaXMuZ3VpLnRvb2xiYXIgPSB0aGlzLmNyZWF0ZVRvb2xiYXIoKSksIHQuc3RhdHVzICE9PSAhMSAmJiAodGhpcy5ndWkuc3RhdHVzYmFyID0gdGhpcy5jcmVhdGVTdGF0dXNiYXIoKSksIHZvaWQgMCAhPSB0LmF1dG9zYXZlICYmIHQuYXV0b3NhdmUuZW5hYmxlZCA9PT0gITAgJiYgdGhpcy5hdXRvc2F2ZSgpLCB0aGlzLmd1aS5zaWRlQnlTaWRlID0gdGhpcy5jcmVhdGVTaWRlQnlTaWRlKCksIHRoaXMuX3JlbmRlcmVkID0gdGhpcy5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1LnJlZnJlc2goKVxuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodSksIDApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUuYXV0b3NhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF8oKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT0gdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkIHx8IFwiXCIgPT0gdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkKXJldHVybiB2b2lkIGNvbnNvbGUubG9nKFwiU2ltcGxlTURFOiBZb3UgbXVzdCBzZXQgYSB1bmlxdWVJZCB0byB1c2UgdGhlIGF1dG9zYXZlIGZlYXR1cmVcIik7XG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT0gZS5lbGVtZW50LmZvcm0gJiYgdm9pZCAwICE9IGUuZWxlbWVudC5mb3JtICYmIGUuZWxlbWVudC5mb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJzbWRlX1wiICsgZS5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkKVxuICAgICAgICAgICAgICAgICAgICB9KSwgdGhpcy5vcHRpb25zLmF1dG9zYXZlLmxvYWRlZCAhPT0gITAgJiYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic21kZV9cIiArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCkgJiYgXCJcIiAhPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNtZGVfXCIgKyB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQpICYmICh0aGlzLmNvZGVtaXJyb3Iuc2V0VmFsdWUobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzbWRlX1wiICsgdGhpcy5vcHRpb25zLmF1dG9zYXZlLnVuaXF1ZUlkKSksIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5mb3VuZFNhdmVkVmFsdWUgPSAhMCksIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5sb2FkZWQgPSAhMCksIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic21kZV9cIiArIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCwgZS52YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImF1dG9zYXZlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gdCAmJiB2b2lkIDAgIT0gdCAmJiBcIlwiICE9IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gbmV3IERhdGUsIHIgPSBuLmdldEhvdXJzKCksIGkgPSBuLmdldE1pbnV0ZXMoKSwgbyA9IFwiYW1cIiwgYSA9IHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBhID49IDEyICYmIChhID0gciAtIDEyLCBvID0gXCJwbVwiKSwgMCA9PSBhICYmIChhID0gMTIpLCBpID0gMTAgPiBpID8gXCIwXCIgKyBpIDogaSwgdC5pbm5lckhUTUwgPSBcIkF1dG9zYXZlZDogXCIgKyBhICsgXCI6XCIgKyBpICsgXCIgXCIgKyBvXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvc2F2ZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5hdXRvc2F2ZSgpXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5hdXRvc2F2ZS5kZWxheSB8fCAxZTQpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGNvbnNvbGUubG9nKFwiU2ltcGxlTURFOiBsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZSwgY2Fubm90IGF1dG9zYXZlXCIpXG4gICAgICAgICAgICB9LCBCLnByb3RvdHlwZS5jbGVhckF1dG9zYXZlZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PSB0aGlzLm9wdGlvbnMuYXV0b3NhdmUgfHwgdm9pZCAwID09IHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZCB8fCBcIlwiID09IHRoaXMub3B0aW9ucy5hdXRvc2F2ZS51bmlxdWVJZClyZXR1cm4gdm9pZCBjb25zb2xlLmxvZyhcIlNpbXBsZU1ERTogWW91IG11c3Qgc2V0IGEgdW5pcXVlSWQgdG8gY2xlYXIgdGhlIGF1dG9zYXZlIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInNtZGVfXCIgKyB0aGlzLm9wdGlvbnMuYXV0b3NhdmUudW5pcXVlSWQpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGNvbnNvbGUubG9nKFwiU2ltcGxlTURFOiBsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZSwgY2Fubm90IGF1dG9zYXZlXCIpXG4gICAgICAgICAgICB9LCBCLnByb3RvdHlwZS5jcmVhdGVTaWRlQnlTaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5jb2RlbWlycm9yLCB0ID0gZS5nZXRXcmFwcGVyRWxlbWVudCgpLCBuID0gdC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBuICYmIC9lZGl0b3ItcHJldmlldy1zaWRlLy50ZXN0KG4uY2xhc3NOYW1lKSB8fCAobiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIG4uY2xhc3NOYW1lID0gXCJlZGl0b3ItcHJldmlldy1zaWRlXCIsIHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobiwgdC5uZXh0U2libGluZykpO1xuICAgICAgICAgICAgICAgIHZhciByID0gITEsIGkgPSAhMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5vbihcInNjcm9sbFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocilyZXR1cm4gdm9pZChyID0gITEpO1xuICAgICAgICAgICAgICAgICAgICBpID0gITA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5nZXRTY3JvbGxJbmZvKCkuaGVpZ2h0IC0gZS5nZXRTY3JvbGxJbmZvKCkuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHBhcnNlRmxvYXQoZS5nZXRTY3JvbGxJbmZvKCkudG9wKSAvIHQsIGEgPSAobi5zY3JvbGxIZWlnaHQgLSBuLmNsaWVudEhlaWdodCkgKiBvO1xuICAgICAgICAgICAgICAgICAgICBuLnNjcm9sbFRvcCA9IGFcbiAgICAgICAgICAgICAgICB9KSwgbi5vbnNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkpcmV0dXJuIHZvaWQoaSA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgciA9ICEwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG4uc2Nyb2xsSGVpZ2h0IC0gbi5jbGllbnRIZWlnaHQsIG8gPSBwYXJzZUZsb2F0KG4uc2Nyb2xsVG9wKSAvIHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gKGUuZ2V0U2Nyb2xsSW5mbygpLmhlaWdodCAtIGUuZ2V0U2Nyb2xsSW5mbygpLmNsaWVudEhlaWdodCkgKiBvO1xuICAgICAgICAgICAgICAgICAgICBlLnNjcm9sbFRvKDAsIGEpXG4gICAgICAgICAgICAgICAgfSwgblxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUuY3JlYXRlVG9vbGJhciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgPSBlIHx8IHRoaXMub3B0aW9ucy50b29sYmFyLCBlICYmIDAgIT09IGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQrKyl2b2lkIDAgIT0gS1tlW3RdXSAmJiAoZVt0XSA9IEtbZVt0XV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIG4uY2xhc3NOYW1lID0gXCJlZGl0b3ItdG9vbGJhclwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMsIGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyLnRvb2xiYXIgPSBlLCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspaWYgKChcImd1aWRlXCIgIT0gZVt0XS5uYW1lIHx8IHIub3B0aW9ucy50b29sYmFyR3VpZGVJY29uICE9PSAhMSkgJiYgIShyLm9wdGlvbnMuaGlkZUljb25zICYmIC0xICE9IHIub3B0aW9ucy5oaWRlSWNvbnMuaW5kZXhPZihlW3RdLm5hbWUpIHx8IChcImZ1bGxzY3JlZW5cIiA9PSBlW3RdLm5hbWUgfHwgXCJzaWRlLWJ5LXNpZGVcIiA9PSBlW3RdLm5hbWUpICYmICQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInxcIiA9PT0gZVt0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdCArIDE7IGMgPCBlLmxlbmd0aDsgYysrKVwifFwiID09PSBlW2NdIHx8IHIub3B0aW9ucy5oaWRlSWNvbnMgJiYgLTEgIT0gci5vcHRpb25zLmhpZGVJY29ucy5pbmRleE9mKGVbY10ubmFtZSkgfHwgKHMgPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzKWNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gXCJ8XCIgPT09IGUgPyBvKCkgOiBpKGUsIHIub3B0aW9ucy50b29sYmFyVGlwcywgci5vcHRpb25zLnNob3J0Y3V0cyksIGUuYWN0aW9uICYmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUuYWN0aW9uID8gdC5vbmNsaWNrID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCBlLmFjdGlvbihyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBcInN0cmluZ1wiID09IHR5cGVvZiBlLmFjdGlvbiAmJiAodC5ocmVmID0gZS5hY3Rpb24sIHQudGFyZ2V0ID0gXCJfYmxhbmtcIikpLCBhW2UubmFtZSB8fCBlXSA9IHQsIG4uYXBwZW5kQ2hpbGQodClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oZVt0XSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByLnRvb2xiYXJFbGVtZW50cyA9IGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1ID0gdGhpcy5jb2RlbWlycm9yO1xuICAgICAgICAgICAgICAgICAgICB1Lm9uKFwiY3Vyc29yQWN0aXZpdHlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBsKHUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCBpbiBhKSFmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gYVt0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlW3RdID8gbi5jbGFzc05hbWUgKz0gXCIgYWN0aXZlXCIgOiBcImZ1bGxzY3JlZW5cIiAhPSB0ICYmIFwic2lkZS1ieS1zaWRlXCIgIT0gdCAmJiAobi5jbGFzc05hbWUgPSBuLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqYWN0aXZlXFxzKi9nLCBcIlwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0odClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gdS5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuLCBmKSwgblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIEIucHJvdG90eXBlLmNyZWF0ZVN0YXR1c2JhciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZSA9IGUgfHwgdGhpcy5vcHRpb25zLnN0YXR1cztcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucywgbiA9IHRoaXMuY29kZW1pcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoZSAmJiAwICE9PSBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciwgaSwgbywgYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKylpZiAoaSA9IHZvaWQgMCwgbyA9IHZvaWQgMCwgXCJvYmplY3RcIiA9PSB0eXBlb2YgZVtyXSkgYS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZVtyXS5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGVbcl0uZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25VcGRhdGU6IGVbcl0ub25VcGRhdGVcbiAgICAgICAgICAgICAgICAgICAgfSk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBlW3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3b3Jkc1wiID09PSBsID8gKG8gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5uZXJIVE1MID0gVyhuLmdldFZhbHVlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBpID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmlubmVySFRNTCA9IFcobi5nZXRWYWx1ZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBcImxpbmVzXCIgPT09IGwgPyAobyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5pbm5lckhUTUwgPSBuLmxpbmVDb3VudCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBpID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmlubmVySFRNTCA9IG4ubGluZUNvdW50KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogXCJjdXJzb3JcIiA9PT0gbCA/IChvID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmlubmVySFRNTCA9IFwiMDowXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbi5nZXRDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmlubmVySFRNTCA9IHQubGluZSArIFwiOlwiICsgdC5jaFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBcImF1dG9zYXZlXCIgPT09IGwgJiYgKG8gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT0gdC5hdXRvc2F2ZSAmJiB0LmF1dG9zYXZlLmVuYWJsZWQgPT09ICEwICYmIGUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJhdXRvc2F2ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgYS5wdXNoKHtjbGFzc05hbWU6IGwsIGRlZmF1bHRWYWx1ZTogbywgb25VcGRhdGU6IGl9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChzLmNsYXNzTmFtZSA9IFwiZWRpdG9yLXN0YXR1c2JhclwiLCByID0gMDsgciA8IGEubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gYVtyXSwgdSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdS5jbGFzc05hbWUgPSBjLmNsYXNzTmFtZSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBjLmRlZmF1bHRWYWx1ZSAmJiBjLmRlZmF1bHRWYWx1ZSh1KSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBjLm9uVXBkYXRlICYmIHRoaXMuY29kZW1pcnJvci5vbihcInVwZGF0ZVwiLCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQub25VcGRhdGUoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHUsIGMpKSwgcy5hcHBlbmRDaGlsZCh1KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gdGhpcy5jb2RlbWlycm9yLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHMsIGYubmV4dFNpYmxpbmcpLCBzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IGUgPyB0aGlzLmNvZGVtaXJyb3IuZ2V0VmFsdWUoKSA6ICh0aGlzLmNvZGVtaXJyb3IuZ2V0RG9jKCkuc2V0VmFsdWUoZSksIHRoaXMpXG4gICAgICAgICAgICB9LCBCLnRvZ2dsZUJvbGQgPSBjLCBCLnRvZ2dsZUl0YWxpYyA9IHUsIEIudG9nZ2xlU3RyaWtldGhyb3VnaCA9IGYsIEIudG9nZ2xlQmxvY2txdW90ZSA9IGQsIEIudG9nZ2xlSGVhZGluZ1NtYWxsZXIgPSBwLCBCLnRvZ2dsZUhlYWRpbmdCaWdnZXIgPSBtLCBCLnRvZ2dsZUhlYWRpbmcxID0gZywgQi50b2dnbGVIZWFkaW5nMiA9IHYsIEIudG9nZ2xlSGVhZGluZzMgPSB5LCBCLnRvZ2dsZUNvZGVCbG9jayA9IGgsIEIudG9nZ2xlVW5vcmRlcmVkTGlzdCA9IHgsIEIudG9nZ2xlT3JkZXJlZExpc3QgPSBiLCBCLmNsZWFuQmxvY2sgPSB3LCBCLmRyYXdMaW5rID0gaywgQi5kcmF3SW1hZ2UgPSBTLCBCLmRyYXdUYWJsZSA9IEMsIEIuZHJhd0hvcml6b250YWxSdWxlID0gTCwgQi51bmRvID0gVCwgQi5yZWRvID0gTSwgQi50b2dnbGVQcmV2aWV3ID0gQSwgQi50b2dnbGVTaWRlQnlTaWRlID0gTiwgQi50b2dnbGVGdWxsU2NyZWVuID0gcywgQi5wcm90b3R5cGUudG9nZ2xlQm9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjKHRoaXMpXG4gICAgICAgICAgICB9LCBCLnByb3RvdHlwZS50b2dnbGVJdGFsaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdSh0aGlzKVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUudG9nZ2xlU3RyaWtldGhyb3VnaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmKHRoaXMpXG4gICAgICAgICAgICB9LCBCLnByb3RvdHlwZS50b2dnbGVCbG9ja3F1b3RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGQodGhpcylcbiAgICAgICAgICAgIH0sIEIucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmdTbWFsbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHAodGhpcylcbiAgICAgICAgICAgIH0sIEIucHJvdG90eXBlLnRvZ2dsZUhlYWRpbmdCaWdnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbSh0aGlzKVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUudG9nZ2xlSGVhZGluZzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZyh0aGlzKVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUudG9nZ2xlSGVhZGluZzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdih0aGlzKVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUudG9nZ2xlSGVhZGluZzMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgeSh0aGlzKVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUudG9nZ2xlQ29kZUJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGgodGhpcylcbiAgICAgICAgICAgIH0sIEIucHJvdG90eXBlLnRvZ2dsZVVub3JkZXJlZExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgeCh0aGlzKVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUudG9nZ2xlT3JkZXJlZExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYih0aGlzKVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUuY2xlYW5CbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB3KHRoaXMpXG4gICAgICAgICAgICB9LCBCLnByb3RvdHlwZS5kcmF3TGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBrKHRoaXMpXG4gICAgICAgICAgICB9LCBCLnByb3RvdHlwZS5kcmF3SW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgUyh0aGlzKVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUuZHJhd1RhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIEModGhpcylcbiAgICAgICAgICAgIH0sIEIucHJvdG90eXBlLmRyYXdIb3Jpem9udGFsUnVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBMKHRoaXMpXG4gICAgICAgICAgICB9LCBCLnByb3RvdHlwZS51bmRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIFQodGhpcylcbiAgICAgICAgICAgIH0sIEIucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgTSh0aGlzKVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUudG9nZ2xlUHJldmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBBKHRoaXMpXG4gICAgICAgICAgICB9LCBCLnByb3RvdHlwZS50b2dnbGVTaWRlQnlTaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIE4odGhpcylcbiAgICAgICAgICAgIH0sIEIucHJvdG90eXBlLnRvZ2dsZUZ1bGxTY3JlZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcyh0aGlzKVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUuaXNQcmV2aWV3QWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5jb2RlbWlycm9yLCB0ID0gZS5nZXRXcmFwcGVyRWxlbWVudCgpLCBuID0gdC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC9lZGl0b3ItcHJldmlldy1hY3RpdmUvLnRlc3Qobi5jbGFzc05hbWUpXG4gICAgICAgICAgICB9LCBCLnByb3RvdHlwZS5pc1NpZGVCeVNpZGVBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNvZGVtaXJyb3IsIHQgPSBlLmdldFdyYXBwZXJFbGVtZW50KCksIG4gPSB0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHJldHVybiAvZWRpdG9yLXByZXZpZXctYWN0aXZlLXNpZGUvLnRlc3Qobi5jbGFzc05hbWUpXG4gICAgICAgICAgICB9LCBCLnByb3RvdHlwZS5pc0Z1bGxzY3JlZW5BY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKVxuICAgICAgICAgICAgfSwgQi5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNvZGVtaXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGwoZSlcbiAgICAgICAgICAgIH0sIEIucHJvdG90eXBlLnRvVGV4dEFyZWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNvZGVtaXJyb3IsIHQgPSBlLmdldFdyYXBwZXJFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgdC5wYXJlbnROb2RlICYmICh0aGlzLmd1aS50b29sYmFyICYmIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmd1aS50b29sYmFyKSwgdGhpcy5ndWkuc3RhdHVzYmFyICYmIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmd1aS5zdGF0dXNiYXIpLCB0aGlzLmd1aS5zaWRlQnlTaWRlICYmIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmd1aS5zaWRlQnlTaWRlKSksIGUudG9UZXh0QXJlYSgpLCB0aGlzLmF1dG9zYXZlVGltZW91dElkICYmIChjbGVhclRpbWVvdXQodGhpcy5hdXRvc2F2ZVRpbWVvdXRJZCksIHRoaXMuYXV0b3NhdmVUaW1lb3V0SWQgPSB2b2lkIDAsIHRoaXMuY2xlYXJBdXRvc2F2ZWRWYWx1ZSgpKVxuICAgICAgICAgICAgfSwgdC5leHBvcnRzID0gQlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIi4vY29kZW1pcnJvci90YWJsaXN0XCI6IDE5LFxuICAgICAgICAgICAgY29kZW1pcnJvcjogMTAsXG4gICAgICAgICAgICBcImNvZGVtaXJyb3Itc3BlbGwtY2hlY2tlclwiOiA0LFxuICAgICAgICAgICAgXCJjb2RlbWlycm9yL2FkZG9uL2Rpc3BsYXkvZnVsbHNjcmVlbi5qc1wiOiA1LFxuICAgICAgICAgICAgXCJjb2RlbWlycm9yL2FkZG9uL2Rpc3BsYXkvcGxhY2Vob2xkZXIuanNcIjogNixcbiAgICAgICAgICAgIFwiY29kZW1pcnJvci9hZGRvbi9lZGl0L2NvbnRpbnVlbGlzdC5qc1wiOiA3LFxuICAgICAgICAgICAgXCJjb2RlbWlycm9yL2FkZG9uL21vZGUvb3ZlcmxheS5qc1wiOiA4LFxuICAgICAgICAgICAgXCJjb2RlbWlycm9yL2FkZG9uL3NlbGVjdGlvbi9tYXJrLXNlbGVjdGlvbi5qc1wiOiA5LFxuICAgICAgICAgICAgXCJjb2RlbWlycm9yL21vZGUvZ2ZtL2dmbS5qc1wiOiAxMSxcbiAgICAgICAgICAgIFwiY29kZW1pcnJvci9tb2RlL21hcmtkb3duL21hcmtkb3duLmpzXCI6IDEyLFxuICAgICAgICAgICAgXCJjb2RlbWlycm9yL21vZGUveG1sL3htbC5qc1wiOiAxNCxcbiAgICAgICAgICAgIG1hcmtlZDogMTdcbiAgICAgICAgfV1cbiAgICB9LCB7fSwgWzIwXSkoMjApXG59KTsiLCIvKlxuICogalF1ZXJ5IElmcmFtZSBUcmFuc3BvcnQgUGx1Z2luXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9qUXVlcnktRmlsZS1VcGxvYWRcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyogZ2xvYmFsIGRlZmluZSwgcmVxdWlyZSwgd2luZG93LCBkb2N1bWVudCAqL1xuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBOb2RlL0NvbW1vbkpTOlxuICAgICAgICBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgICAgIGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XG4gICAgfVxufShmdW5jdGlvbiAoJCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIEhlbHBlciB2YXJpYWJsZSB0byBjcmVhdGUgdW5pcXVlIG5hbWVzIGZvciB0aGUgdHJhbnNwb3J0IGlmcmFtZXM6XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgLy8gVGhlIGlmcmFtZSB0cmFuc3BvcnQgYWNjZXB0cyBmb3VyIGFkZGl0aW9uYWwgb3B0aW9uczpcbiAgICAvLyBvcHRpb25zLmZpbGVJbnB1dDogYSBqUXVlcnkgY29sbGVjdGlvbiBvZiBmaWxlIGlucHV0IGZpZWxkc1xuICAgIC8vIG9wdGlvbnMucGFyYW1OYW1lOiB0aGUgcGFyYW1ldGVyIG5hbWUgZm9yIHRoZSBmaWxlIGZvcm0gZGF0YSxcbiAgICAvLyAgb3ZlcnJpZGVzIHRoZSBuYW1lIHByb3BlcnR5IG9mIHRoZSBmaWxlIGlucHV0IGZpZWxkKHMpLFxuICAgIC8vICBjYW4gYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAvLyBvcHRpb25zLmZvcm1EYXRhOiBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggbmFtZSBhbmQgdmFsdWUgcHJvcGVydGllcyxcbiAgICAvLyAgZXF1aXZhbGVudCB0byB0aGUgcmV0dXJuIGRhdGEgb2YgLnNlcmlhbGl6ZUFycmF5KCksIGUuZy46XG4gICAgLy8gIFt7bmFtZTogJ2EnLCB2YWx1ZTogMX0sIHtuYW1lOiAnYicsIHZhbHVlOiAyfV1cbiAgICAvLyBvcHRpb25zLmluaXRpYWxJZnJhbWVTcmM6IHRoZSBVUkwgb2YgdGhlIGluaXRpYWwgaWZyYW1lIHNyYyxcbiAgICAvLyAgYnkgZGVmYXVsdCBzZXQgdG8gXCJqYXZhc2NyaXB0OmZhbHNlO1wiXG4gICAgJC5hamF4VHJhbnNwb3J0KCdpZnJhbWUnLCBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5hc3luYykge1xuICAgICAgICAgICAgLy8gamF2YXNjcmlwdDpmYWxzZSBhcyBpbml0aWFsIGlmcmFtZSBzcmNcbiAgICAgICAgICAgIC8vIHByZXZlbnRzIHdhcm5pbmcgcG9wdXBzIG9uIEhUVFBTIGluIElFNjpcbiAgICAgICAgICAgIC8qanNoaW50IHNjcmlwdHVybDogdHJ1ZSAqL1xuICAgICAgICAgICAgdmFyIGluaXRpYWxJZnJhbWVTcmMgPSBvcHRpb25zLmluaXRpYWxJZnJhbWVTcmMgfHwgJ2phdmFzY3JpcHQ6ZmFsc2U7JyxcbiAgICAgICAgICAgIC8qanNoaW50IHNjcmlwdHVybDogZmFsc2UgKi9cbiAgICAgICAgICAgICAgICBmb3JtLFxuICAgICAgICAgICAgICAgIGlmcmFtZSxcbiAgICAgICAgICAgICAgICBhZGRQYXJhbUNoYXI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uIChfLCBjb21wbGV0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0gPSAkKCc8Zm9ybSBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj48L2Zvcm0+Jyk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0uYXR0cignYWNjZXB0LWNoYXJzZXQnLCBvcHRpb25zLmZvcm1BY2NlcHRDaGFyc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkUGFyYW1DaGFyID0gL1xcPy8udGVzdChvcHRpb25zLnVybCkgPyAnJicgOiAnPyc7XG4gICAgICAgICAgICAgICAgICAgIC8vIFhEb21haW5SZXF1ZXN0IG9ubHkgc3VwcG9ydHMgR0VUIGFuZCBQT1NUOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSAnREVMRVRFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBvcHRpb25zLnVybCArIGFkZFBhcmFtQ2hhciArICdfbWV0aG9kPURFTEVURSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGUgPSAnUE9TVCc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50eXBlID09PSAnUFVUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBvcHRpb25zLnVybCArIGFkZFBhcmFtQ2hhciArICdfbWV0aG9kPVBVVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGUgPSAnUE9TVCc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50eXBlID09PSAnUEFUQ0gnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsICsgYWRkUGFyYW1DaGFyICsgJ19tZXRob2Q9UEFUQ0gnO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlID0gJ1BPU1QnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElFIHZlcnNpb25zIGJlbG93IElFOCBjYW5ub3Qgc2V0IHRoZSBuYW1lIHByb3BlcnR5IG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gdGhlIERPTSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2Ugc2V0IHRoZSBuYW1lIGFsb25nIHdpdGggdGhlIGlmcmFtZSBIVE1MIG1hcmt1cDpcbiAgICAgICAgICAgICAgICAgICAgY291bnRlciArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZnJhbWUgPSAkKFxuICAgICAgICAgICAgICAgICAgICAgICAgJzxpZnJhbWUgc3JjPVwiJyArIGluaXRpYWxJZnJhbWVTcmMgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIiBuYW1lPVwiaWZyYW1lLXRyYW5zcG9ydC0nICsgY291bnRlciArICdcIj48L2lmcmFtZT4nXG4gICAgICAgICAgICAgICAgICAgICkuYmluZCgnbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlSW5wdXRDbG9uZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lcyA9ICQuaXNBcnJheShvcHRpb25zLnBhcmFtTmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbU5hbWUgOiBbb3B0aW9ucy5wYXJhbU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVuYmluZCgnbG9hZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmJpbmQoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV3JhcCBpbiBhIHRyeS9jYXRjaCBibG9jayB0byBjYXRjaCBleGNlcHRpb25zIHRocm93blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBhY2Nlc3MgY3Jvc3MtZG9tYWluIGlmcmFtZSBjb250ZW50czpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gaWZyYW1lLmNvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lIGFuZCBGaXJlZm94IGRvIG5vdCB0aHJvdyBhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIHdoZW4gY2FsbGluZyBpZnJhbWUuY29udGVudHMoKSBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzbyB3ZSB1bmlmeSB0aGUgcmVzcG9uc2U6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmxlbmd0aCB8fCAhcmVzcG9uc2VbMF0uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29tcGxldGUgY2FsbGJhY2sgcmV0dXJucyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWZyYW1lIGNvbnRlbnQgZG9jdW1lbnQgYXMgcmVzcG9uc2Ugb2JqZWN0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeydpZnJhbWUnOiByZXNwb25zZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IGZvciBJRSBlbmRsZXNzIHByb2dyZXNzIGJhciBhY3Rpdml0eSBidWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGhhcHBlbnMgb24gZm9ybSBzdWJtaXRzIHRvIGlmcmFtZSB0YXJnZXRzKTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGlmcmFtZSBzcmM9XCInICsgaW5pdGlhbElmcmFtZVNyYyArICdcIj48L2lmcmFtZT4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGZvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmluZyB0aGUgZm9ybSBpbiBhIHNldFRpbWVvdXQgY2FsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3dzIENocm9tZSdzIGRldmVsb3BlciB0b29scyB0byBkaXNwbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVzcG9uc2UgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgndGFyZ2V0JywgaWZyYW1lLnByb3AoJ25hbWUnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgnYWN0aW9uJywgb3B0aW9ucy51cmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ21ldGhvZCcsIG9wdGlvbnMudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChvcHRpb25zLmZvcm1EYXRhLCBmdW5jdGlvbiAoaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCIvPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgnbmFtZScsIGZpZWxkLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsKGZpZWxkLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGZvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmlsZUlucHV0ICYmIG9wdGlvbnMuZmlsZUlucHV0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGUgPT09ICdQT1NUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVJbnB1dENsb25lcyA9IG9wdGlvbnMuZmlsZUlucHV0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IGEgY2xvbmUgZm9yIGVhY2ggZmlsZSBpbnB1dCBmaWVsZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZpbGVJbnB1dC5hZnRlcihmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVJbnB1dENsb25lc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyYW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsZUlucHV0LmVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnByb3AoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZXNbaW5kZXhdIHx8IG9wdGlvbnMucGFyYW1OYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kaW5nIHRoZSBmaWxlIGlucHV0IGZpZWxkcyB0byB0aGUgaGlkZGVuIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVzIHRoZW0gZnJvbSB0aGVpciBvcmlnaW5hbCBsb2NhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQob3B0aW9ucy5maWxlSW5wdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCdlbmN0eXBlJywgJ211bHRpcGFydC9mb3JtLWRhdGEnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmN0eXBlIG11c3QgYmUgc2V0IGFzIGVuY29kaW5nIGZvciBJRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ2VuY29kaW5nJywgJ211bHRpcGFydC9mb3JtLWRhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIEhUTUw1IGZvcm0gYXR0cmlidXRlIGZyb20gdGhlIGlucHV0KHMpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsZUlucHV0LnJlbW92ZUF0dHIoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgdGhlIGZpbGUgaW5wdXQgZmllbGRzIGF0IHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBieSByZXBsYWNpbmcgdGhlIGNsb25lcyB3aXRoIHRoZSBvcmlnaW5hbHM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUlucHV0Q2xvbmVzICYmIGZpbGVJbnB1dENsb25lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZpbGVJbnB1dC5lYWNoKGZ1bmN0aW9uIChpbmRleCwgaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lID0gJChmaWxlSW5wdXRDbG9uZXNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgbmFtZSBhbmQgZm9ybSBwcm9wZXJ0aWVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGlucHV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ25hbWUnLCBjbG9uZS5wcm9wKCduYW1lJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9ybScsIGNsb25lLmF0dHIoJ2Zvcm0nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lLnJlcGxhY2VXaXRoKGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGlmcmFtZSkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqYXZhc2NyaXB0OmZhbHNlIGFzIGlmcmFtZSBzcmMgYWJvcnRzIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJldmVudHMgd2FybmluZyBwb3B1cHMgb24gSFRUUFMgaW4gSUU2LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uY2F0IGlzIHVzZWQgdG8gYXZvaWQgdGhlIFwiU2NyaXB0IFVSTFwiIEpTTGludCBlcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51bmJpbmQoJ2xvYWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCdzcmMnLCBpbml0aWFsSWZyYW1lU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRoZSBpZnJhbWUgdHJhbnNwb3J0IHJldHVybnMgdGhlIGlmcmFtZSBjb250ZW50IGRvY3VtZW50IGFzIHJlc3BvbnNlLlxuICAgIC8vIFRoZSBmb2xsb3dpbmcgYWRkcyBjb252ZXJ0ZXJzIGZyb20gaWZyYW1lIHRvIHRleHQsIGpzb24sIGh0bWwsIHhtbFxuICAgIC8vIGFuZCBzY3JpcHQuXG4gICAgLy8gUGxlYXNlIG5vdGUgdGhhdCB0aGUgQ29udGVudC1UeXBlIGZvciBKU09OIHJlc3BvbnNlcyBoYXMgdG8gYmUgdGV4dC9wbGFpblxuICAgIC8vIG9yIHRleHQvaHRtbCwgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBpbmNsdWRlIGFwcGxpY2F0aW9uL2pzb24gaW4gdGhlXG4gICAgLy8gQWNjZXB0IGhlYWRlciwgZWxzZSBJRSB3aWxsIHNob3cgYSBkb3dubG9hZCBkaWFsb2cuXG4gICAgLy8gVGhlIENvbnRlbnQtVHlwZSBmb3IgWE1MIHJlc3BvbnNlcyBvbiB0aGUgb3RoZXIgaGFuZCBoYXMgdG8gYmUgYWx3YXlzXG4gICAgLy8gYXBwbGljYXRpb24veG1sIG9yIHRleHQveG1sLCBzbyBJRSBwcm9wZXJseSBwYXJzZXMgdGhlIFhNTCByZXNwb25zZS5cbiAgICAvLyBTZWUgYWxzb1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL2pRdWVyeS1GaWxlLVVwbG9hZC93aWtpL1NldHVwI2NvbnRlbnQtdHlwZS1uZWdvdGlhdGlvblxuICAgICQuYWpheFNldHVwKHtcbiAgICAgICAgY29udmVydGVyczoge1xuICAgICAgICAgICAgJ2lmcmFtZSB0ZXh0JzogZnVuY3Rpb24gKGlmcmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZnJhbWUgJiYgJChpZnJhbWVbMF0uYm9keSkudGV4dCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdpZnJhbWUganNvbic6IGZ1bmN0aW9uIChpZnJhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZyYW1lICYmICQucGFyc2VKU09OKCQoaWZyYW1lWzBdLmJvZHkpLnRleHQoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2lmcmFtZSBodG1sJzogZnVuY3Rpb24gKGlmcmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZnJhbWUgJiYgJChpZnJhbWVbMF0uYm9keSkuaHRtbCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdpZnJhbWUgeG1sJzogZnVuY3Rpb24gKGlmcmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciB4bWxEb2MgPSBpZnJhbWUgJiYgaWZyYW1lWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiB4bWxEb2MgJiYgJC5pc1hNTERvYyh4bWxEb2MpID8geG1sRG9jIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICQucGFyc2VYTUwoKHhtbERvYy5YTUxEb2N1bWVudCAmJiB4bWxEb2MuWE1MRG9jdW1lbnQueG1sKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoeG1sRG9jLmJvZHkpLmh0bWwoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2lmcmFtZSBzY3JpcHQnOiBmdW5jdGlvbiAoaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmcmFtZSAmJiAkLmdsb2JhbEV2YWwoJChpZnJhbWVbMF0uYm9keSkudGV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59KSk7XG4iLCIvKlxuICogalF1ZXJ5IEZpbGUgVXBsb2FkIFBsdWdpblxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvalF1ZXJ5LUZpbGUtVXBsb2FkXG4gKlxuICogQ29weXJpZ2h0IDIwMTAsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qIGpzaGludCBub21lbjpmYWxzZSAqL1xuLyogZ2xvYmFsIGRlZmluZSwgcmVxdWlyZSwgd2luZG93LCBkb2N1bWVudCwgbG9jYXRpb24sIEJsb2IsIEZvcm1EYXRhICovXG5cbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgQU1EIG1vZHVsZTpcbiAgICAgICAgZGVmaW5lKFtcbiAgICAgICAgICAgICdqcXVlcnknLFxuICAgICAgICAgICAgJ2pxdWVyeS11aS93aWRnZXQnXG4gICAgICAgIF0sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUvQ29tbW9uSlM6XG4gICAgICAgIGZhY3RvcnkoXG4gICAgICAgICAgICByZXF1aXJlKCdqcXVlcnknKSxcbiAgICAgICAgICAgIHJlcXVpcmUoJy4vdmVuZG9yL2pxdWVyeS51aS53aWRnZXQnKVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICAgICAgZmFjdG9yeSh3aW5kb3cualF1ZXJ5KTtcbiAgICB9XG59KGZ1bmN0aW9uICgkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gRGV0ZWN0IGZpbGUgaW5wdXQgc3VwcG9ydCwgYmFzZWQgb25cbiAgICAvLyBodHRwOi8vdmlsamFtaXMuY29tL2Jsb2cvMjAxMi9maWxlLXVwbG9hZC1zdXBwb3J0LW9uLW1vYmlsZS9cbiAgICAkLnN1cHBvcnQuZmlsZUlucHV0ID0gIShuZXcgUmVnRXhwKFxuICAgICAgICAvLyBIYW5kbGUgZGV2aWNlcyB3aGljaCBnaXZlIGZhbHNlIHBvc2l0aXZlcyBmb3IgdGhlIGZlYXR1cmUgZGV0ZWN0aW9uOlxuICAgICAgICAnKEFuZHJvaWQgKDFcXFxcLlswMTU2XXwyXFxcXC5bMDFdKSknICtcbiAgICAgICAgICAgICd8KFdpbmRvd3MgUGhvbmUgKE9TIDd8OFxcXFwuMCkpfChYQkxXUCl8KFp1bmVXUCl8KFdQRGVza3RvcCknICtcbiAgICAgICAgICAgICd8KHcoZWIpP09TQnJvd3Nlcil8KHdlYk9TKScgK1xuICAgICAgICAgICAgJ3woS2luZGxlLygxXFxcXC4wfDJcXFxcLlswNV18M1xcXFwuMCkpJ1xuICAgICkudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHxcbiAgICAgICAgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZm9yIGFsbCBvdGhlciBkZXZpY2VzOlxuICAgICAgICAkKCc8aW5wdXQgdHlwZT1cImZpbGVcIj4nKS5wcm9wKCdkaXNhYmxlZCcpKTtcblxuICAgIC8vIFRoZSBGaWxlUmVhZGVyIEFQSSBpcyBub3QgYWN0dWFsbHkgdXNlZCwgYnV0IHdvcmtzIGFzIGZlYXR1cmUgZGV0ZWN0aW9uLFxuICAgIC8vIGFzIHNvbWUgU2FmYXJpIHZlcnNpb25zICg1Pykgc3VwcG9ydCBYSFIgZmlsZSB1cGxvYWRzIHZpYSB0aGUgRm9ybURhdGEgQVBJLFxuICAgIC8vIGJ1dCBub3Qgbm9uLW11bHRpcGFydCBYSFIgZmlsZSB1cGxvYWRzLlxuICAgIC8vIHdpbmRvdy5YTUxIdHRwUmVxdWVzdFVwbG9hZCBpcyBub3QgYXZhaWxhYmxlIG9uIElFMTAsIHNvIHdlIGNoZWNrIGZvclxuICAgIC8vIHdpbmRvdy5Qcm9ncmVzc0V2ZW50IGluc3RlYWQgdG8gZGV0ZWN0IFhIUjIgZmlsZSB1cGxvYWQgY2FwYWJpbGl0eTpcbiAgICAkLnN1cHBvcnQueGhyRmlsZVVwbG9hZCA9ICEhKHdpbmRvdy5Qcm9ncmVzc0V2ZW50ICYmIHdpbmRvdy5GaWxlUmVhZGVyKTtcbiAgICAkLnN1cHBvcnQueGhyRm9ybURhdGFGaWxlVXBsb2FkID0gISF3aW5kb3cuRm9ybURhdGE7XG5cbiAgICAvLyBEZXRlY3Qgc3VwcG9ydCBmb3IgQmxvYiBzbGljaW5nIChyZXF1aXJlZCBmb3IgY2h1bmtlZCB1cGxvYWRzKTpcbiAgICAkLnN1cHBvcnQuYmxvYlNsaWNlID0gd2luZG93LkJsb2IgJiYgKEJsb2IucHJvdG90eXBlLnNsaWNlIHx8XG4gICAgICAgIEJsb2IucHJvdG90eXBlLndlYmtpdFNsaWNlIHx8IEJsb2IucHJvdG90eXBlLm1velNsaWNlKTtcblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgZHJhZyBoYW5kbGVycyBmb3IgZHJhZ292ZXIvZHJhZ2VudGVyL2RyYWdsZWF2ZTpcbiAgICBmdW5jdGlvbiBnZXREcmFnSGFuZGxlcih0eXBlKSB7XG4gICAgICAgIHZhciBpc0RyYWdPdmVyID0gdHlwZSA9PT0gJ2RyYWdvdmVyJztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLmRhdGFUcmFuc2ZlciA9IGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyO1xuICAgICAgICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuICAgICAgICAgICAgaWYgKGRhdGFUcmFuc2ZlciAmJiAkLmluQXJyYXkoJ0ZpbGVzJywgZGF0YVRyYW5zZmVyLnR5cGVzKSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAkLkV2ZW50KHR5cGUsIHtkZWxlZ2F0ZWRFdmVudDogZX0pXG4gICAgICAgICAgICAgICAgICAgICkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChpc0RyYWdPdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ2NvcHknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZmlsZXVwbG9hZCB3aWRnZXQgbGlzdGVucyBmb3IgY2hhbmdlIGV2ZW50cyBvbiBmaWxlIGlucHV0IGZpZWxkcyBkZWZpbmVkXG4gICAgLy8gdmlhIGZpbGVJbnB1dCBzZXR0aW5nIGFuZCBwYXN0ZSBvciBkcm9wIGV2ZW50cyBvZiB0aGUgZ2l2ZW4gZHJvcFpvbmUuXG4gICAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGRlZmF1bHQgalF1ZXJ5IFdpZGdldCBtZXRob2RzLCB0aGUgZmlsZXVwbG9hZCB3aWRnZXRcbiAgICAvLyBleHBvc2VzIHRoZSBcImFkZFwiIGFuZCBcInNlbmRcIiBtZXRob2RzLCB0byBhZGQgb3IgZGlyZWN0bHkgc2VuZCBmaWxlcyB1c2luZ1xuICAgIC8vIHRoZSBmaWxldXBsb2FkIEFQSS5cbiAgICAvLyBCeSBkZWZhdWx0LCBmaWxlcyBhZGRlZCB2aWEgZmlsZSBpbnB1dCBzZWxlY3Rpb24sIHBhc3RlLCBkcmFnICYgZHJvcCBvclxuICAgIC8vIFwiYWRkXCIgbWV0aG9kIGFyZSB1cGxvYWRlZCBpbW1lZGlhdGVseSwgYnV0IGl0IGlzIHBvc3NpYmxlIHRvIG92ZXJyaWRlXG4gICAgLy8gdGhlIFwiYWRkXCIgY2FsbGJhY2sgb3B0aW9uIHRvIHF1ZXVlIGZpbGUgdXBsb2Fkcy5cbiAgICAkLndpZGdldCgnYmx1ZWltcC5maWxldXBsb2FkJywge1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIC8vIFRoZSBkcm9wIHRhcmdldCBlbGVtZW50KHMpLCBieSB0aGUgZGVmYXVsdCB0aGUgY29tcGxldGUgZG9jdW1lbnQuXG4gICAgICAgICAgICAvLyBTZXQgdG8gbnVsbCB0byBkaXNhYmxlIGRyYWcgJiBkcm9wIHN1cHBvcnQ6XG4gICAgICAgICAgICBkcm9wWm9uZTogJChkb2N1bWVudCksXG4gICAgICAgICAgICAvLyBUaGUgcGFzdGUgdGFyZ2V0IGVsZW1lbnQocyksIGJ5IHRoZSBkZWZhdWx0IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIC8vIFNldCB0byBhIERPTSBub2RlIG9yIGpRdWVyeSBvYmplY3QgdG8gZW5hYmxlIGZpbGUgcGFzdGluZzpcbiAgICAgICAgICAgIHBhc3RlWm9uZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gVGhlIGZpbGUgaW5wdXQgZmllbGQocyksIHRoYXQgYXJlIGxpc3RlbmVkIHRvIGZvciBjaGFuZ2UgZXZlbnRzLlxuICAgICAgICAgICAgLy8gSWYgdW5kZWZpbmVkLCBpdCBpcyBzZXQgdG8gdGhlIGZpbGUgaW5wdXQgZmllbGRzIGluc2lkZVxuICAgICAgICAgICAgLy8gb2YgdGhlIHdpZGdldCBlbGVtZW50IG9uIHBsdWdpbiBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICAgIC8vIFNldCB0byBudWxsIHRvIGRpc2FibGUgdGhlIGNoYW5nZSBsaXN0ZW5lci5cbiAgICAgICAgICAgIGZpbGVJbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIGZpbGUgaW5wdXQgZmllbGQgaXMgcmVwbGFjZWQgd2l0aCBhIGNsb25lIGFmdGVyXG4gICAgICAgICAgICAvLyBlYWNoIGlucHV0IGZpZWxkIGNoYW5nZSBldmVudC4gVGhpcyBpcyByZXF1aXJlZCBmb3IgaWZyYW1lIHRyYW5zcG9ydFxuICAgICAgICAgICAgLy8gcXVldWVzIGFuZCBhbGxvd3MgY2hhbmdlIGV2ZW50cyB0byBiZSBmaXJlZCBmb3IgdGhlIHNhbWUgZmlsZVxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uLCBidXQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgdGhlIGZvbGxvd2luZyBvcHRpb24gdG8gZmFsc2U6XG4gICAgICAgICAgICByZXBsYWNlRmlsZUlucHV0OiB0cnVlLFxuICAgICAgICAgICAgLy8gVGhlIHBhcmFtZXRlciBuYW1lIGZvciB0aGUgZmlsZSBmb3JtIGRhdGEgKHRoZSByZXF1ZXN0IGFyZ3VtZW50IG5hbWUpLlxuICAgICAgICAgICAgLy8gSWYgdW5kZWZpbmVkIG9yIGVtcHR5LCB0aGUgbmFtZSBwcm9wZXJ0eSBvZiB0aGUgZmlsZSBpbnB1dCBmaWVsZCBpc1xuICAgICAgICAgICAgLy8gdXNlZCwgb3IgXCJmaWxlc1tdXCIgaWYgdGhlIGZpbGUgaW5wdXQgbmFtZSBwcm9wZXJ0eSBpcyBhbHNvIGVtcHR5LFxuICAgICAgICAgICAgLy8gY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3M6XG4gICAgICAgICAgICBwYXJhbU5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIGVhY2ggZmlsZSBvZiBhIHNlbGVjdGlvbiBpcyB1cGxvYWRlZCB1c2luZyBhbiBpbmRpdmlkdWFsXG4gICAgICAgICAgICAvLyByZXF1ZXN0IGZvciBYSFIgdHlwZSB1cGxvYWRzLiBTZXQgdG8gZmFsc2UgdG8gdXBsb2FkIGZpbGVcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbnMgaW4gb25lIHJlcXVlc3QgZWFjaDpcbiAgICAgICAgICAgIHNpbmdsZUZpbGVVcGxvYWRzOiB0cnVlLFxuICAgICAgICAgICAgLy8gVG8gbGltaXQgdGhlIG51bWJlciBvZiBmaWxlcyB1cGxvYWRlZCB3aXRoIG9uZSBYSFIgcmVxdWVzdCxcbiAgICAgICAgICAgIC8vIHNldCB0aGUgZm9sbG93aW5nIG9wdGlvbiB0byBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwOlxuICAgICAgICAgICAgbGltaXRNdWx0aUZpbGVVcGxvYWRzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIG9wdGlvbiBsaW1pdHMgdGhlIG51bWJlciBvZiBmaWxlcyB1cGxvYWRlZCB3aXRoIG9uZVxuICAgICAgICAgICAgLy8gWEhSIHJlcXVlc3QgdG8ga2VlcCB0aGUgcmVxdWVzdCBzaXplIHVuZGVyIG9yIGVxdWFsIHRvIHRoZSBkZWZpbmVkXG4gICAgICAgICAgICAvLyBsaW1pdCBpbiBieXRlczpcbiAgICAgICAgICAgIGxpbWl0TXVsdGlGaWxlVXBsb2FkU2l6ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gTXVsdGlwYXJ0IGZpbGUgdXBsb2FkcyBhZGQgYSBudW1iZXIgb2YgYnl0ZXMgdG8gZWFjaCB1cGxvYWRlZCBmaWxlLFxuICAgICAgICAgICAgLy8gdGhlcmVmb3JlIHRoZSBmb2xsb3dpbmcgb3B0aW9uIGFkZHMgYW4gb3ZlcmhlYWQgZm9yIGVhY2ggZmlsZSB1c2VkXG4gICAgICAgICAgICAvLyBpbiB0aGUgbGltaXRNdWx0aUZpbGVVcGxvYWRTaXplIGNvbmZpZ3VyYXRpb246XG4gICAgICAgICAgICBsaW1pdE11bHRpRmlsZVVwbG9hZFNpemVPdmVyaGVhZDogNTEyLFxuICAgICAgICAgICAgLy8gU2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIHRydWUgdG8gaXNzdWUgYWxsIGZpbGUgdXBsb2FkIHJlcXVlc3RzXG4gICAgICAgICAgICAvLyBpbiBhIHNlcXVlbnRpYWwgb3JkZXI6XG4gICAgICAgICAgICBzZXF1ZW50aWFsVXBsb2FkczogZmFsc2UsXG4gICAgICAgICAgICAvLyBUbyBsaW1pdCB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgdXBsb2FkcyxcbiAgICAgICAgICAgIC8vIHNldCB0aGUgZm9sbG93aW5nIG9wdGlvbiB0byBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwOlxuICAgICAgICAgICAgbGltaXRDb25jdXJyZW50VXBsb2FkczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gU2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIHRydWUgdG8gZm9yY2UgaWZyYW1lIHRyYW5zcG9ydCB1cGxvYWRzOlxuICAgICAgICAgICAgZm9yY2VJZnJhbWVUcmFuc3BvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgLy8gU2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIHRoZSBsb2NhdGlvbiBvZiBhIHJlZGlyZWN0IHVybCBvbiB0aGVcbiAgICAgICAgICAgIC8vIG9yaWdpbiBzZXJ2ZXIsIGZvciBjcm9zcy1kb21haW4gaWZyYW1lIHRyYW5zcG9ydCB1cGxvYWRzOlxuICAgICAgICAgICAgcmVkaXJlY3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIFRoZSBwYXJhbWV0ZXIgbmFtZSBmb3IgdGhlIHJlZGlyZWN0IHVybCwgc2VudCBhcyBwYXJ0IG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAvLyBkYXRhIGFuZCBzZXQgdG8gJ3JlZGlyZWN0JyBpZiB0aGlzIG9wdGlvbiBpcyBlbXB0eTpcbiAgICAgICAgICAgIHJlZGlyZWN0UGFyYW1OYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGZvbGxvd2luZyBvcHRpb24gdG8gdGhlIGxvY2F0aW9uIG9mIGEgcG9zdE1lc3NhZ2Ugd2luZG93LFxuICAgICAgICAgICAgLy8gdG8gZW5hYmxlIHBvc3RNZXNzYWdlIHRyYW5zcG9ydCB1cGxvYWRzOlxuICAgICAgICAgICAgcG9zdE1lc3NhZ2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIFhIUiBmaWxlIHVwbG9hZHMgYXJlIHNlbnQgYXMgbXVsdGlwYXJ0L2Zvcm0tZGF0YS5cbiAgICAgICAgICAgIC8vIFRoZSBpZnJhbWUgdHJhbnNwb3J0IGlzIGFsd2F5cyB1c2luZyBtdWx0aXBhcnQvZm9ybS1kYXRhLlxuICAgICAgICAgICAgLy8gU2V0IHRvIGZhbHNlIHRvIGVuYWJsZSBub24tbXVsdGlwYXJ0IFhIUiB1cGxvYWRzOlxuICAgICAgICAgICAgbXVsdGlwYXJ0OiB0cnVlLFxuICAgICAgICAgICAgLy8gVG8gdXBsb2FkIGxhcmdlIGZpbGVzIGluIHNtYWxsZXIgY2h1bmtzLCBzZXQgdGhlIGZvbGxvd2luZyBvcHRpb25cbiAgICAgICAgICAgIC8vIHRvIGEgcHJlZmVycmVkIG1heGltdW0gY2h1bmsgc2l6ZS4gSWYgc2V0IHRvIDAsIG51bGwgb3IgdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gb3IgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgcmVxdWlyZWQgQmxvYiBBUEksIGZpbGVzIHdpbGxcbiAgICAgICAgICAgIC8vIGJlIHVwbG9hZGVkIGFzIGEgd2hvbGUuXG4gICAgICAgICAgICBtYXhDaHVua1NpemU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIFdoZW4gYSBub24tbXVsdGlwYXJ0IHVwbG9hZCBvciBhIGNodW5rZWQgbXVsdGlwYXJ0IHVwbG9hZCBoYXMgYmVlblxuICAgICAgICAgICAgLy8gYWJvcnRlZCwgdGhpcyBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVzdW1lIHRoZSB1cGxvYWQgYnkgc2V0dGluZ1xuICAgICAgICAgICAgLy8gaXQgdG8gdGhlIHNpemUgb2YgdGhlIGFscmVhZHkgdXBsb2FkZWQgYnl0ZXMuIFRoaXMgb3B0aW9uIGlzIG1vc3RcbiAgICAgICAgICAgIC8vIHVzZWZ1bCB3aGVuIG1vZGlmeWluZyB0aGUgb3B0aW9ucyBvYmplY3QgaW5zaWRlIG9mIHRoZSBcImFkZFwiIG9yXG4gICAgICAgICAgICAvLyBcInNlbmRcIiBjYWxsYmFja3MsIGFzIHRoZSBvcHRpb25zIGFyZSBjbG9uZWQgZm9yIGVhY2ggZmlsZSB1cGxvYWQuXG4gICAgICAgICAgICB1cGxvYWRlZEJ5dGVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBmYWlsZWQgKGFib3J0IG9yIGVycm9yKSBmaWxlIHVwbG9hZHMgYXJlIHJlbW92ZWQgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIGdsb2JhbCBwcm9ncmVzcyBjYWxjdWxhdGlvbi4gU2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9uIHRvIGZhbHNlIHRvXG4gICAgICAgICAgICAvLyBwcmV2ZW50IHJlY2FsY3VsYXRpbmcgdGhlIGdsb2JhbCBwcm9ncmVzcyBkYXRhOlxuICAgICAgICAgICAgcmVjYWxjdWxhdGVQcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgICAgIC8vIEludGVydmFsIGluIG1pbGxpc2Vjb25kcyB0byBjYWxjdWxhdGUgYW5kIHRyaWdnZXIgcHJvZ3Jlc3MgZXZlbnRzOlxuICAgICAgICAgICAgcHJvZ3Jlc3NJbnRlcnZhbDogMTAwLFxuICAgICAgICAgICAgLy8gSW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzIHRvIGNhbGN1bGF0ZSBwcm9ncmVzcyBiaXRyYXRlOlxuICAgICAgICAgICAgYml0cmF0ZUludGVydmFsOiA1MDAsXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCB1cGxvYWRzIGFyZSBzdGFydGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhZGRpbmcgZmlsZXM6XG4gICAgICAgICAgICBhdXRvVXBsb2FkOiB0cnVlLFxuXG4gICAgICAgICAgICAvLyBFcnJvciBhbmQgaW5mbyBtZXNzYWdlczpcbiAgICAgICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICAgICAgdXBsb2FkZWRCeXRlczogJ1VwbG9hZGVkIGJ5dGVzIGV4Y2VlZCBmaWxlIHNpemUnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBUcmFuc2xhdGlvbiBmdW5jdGlvbiwgZ2V0cyB0aGUgbWVzc2FnZSBrZXkgdG8gYmUgdHJhbnNsYXRlZFxuICAgICAgICAgICAgLy8gYW5kIGFuIG9iamVjdCB3aXRoIGNvbnRleHQgc3BlY2lmaWMgZGF0YSBhcyBhcmd1bWVudHM6XG4gICAgICAgICAgICBpMThuOiBmdW5jdGlvbiAobWVzc2FnZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW21lc3NhZ2VdIHx8IG1lc3NhZ2UudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAkLmVhY2goY29udGV4dCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoJ3snICsga2V5ICsgJ30nLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEFkZGl0aW9uYWwgZm9ybSBkYXRhIHRvIGJlIHNlbnQgYWxvbmcgd2l0aCB0aGUgZmlsZSB1cGxvYWRzIGNhbiBiZSBzZXRcbiAgICAgICAgICAgIC8vIHVzaW5nIHRoaXMgb3B0aW9uLCB3aGljaCBhY2NlcHRzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBuYW1lIGFuZFxuICAgICAgICAgICAgLy8gdmFsdWUgcHJvcGVydGllcywgYSBmdW5jdGlvbiByZXR1cm5pbmcgc3VjaCBhbiBhcnJheSwgYSBGb3JtRGF0YVxuICAgICAgICAgICAgLy8gb2JqZWN0IChmb3IgWEhSIGZpbGUgdXBsb2FkcyksIG9yIGEgc2ltcGxlIG9iamVjdC5cbiAgICAgICAgICAgIC8vIFRoZSBmb3JtIG9mIHRoZSBmaXJzdCBmaWxlSW5wdXQgaXMgZ2l2ZW4gYXMgcGFyYW1ldGVyIHRvIHRoZSBmdW5jdGlvbjpcbiAgICAgICAgICAgIGZvcm1EYXRhOiBmdW5jdGlvbiAoZm9ybSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtLnNlcmlhbGl6ZUFycmF5KCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBUaGUgYWRkIGNhbGxiYWNrIGlzIGludm9rZWQgYXMgc29vbiBhcyBmaWxlcyBhcmUgYWRkZWQgdG8gdGhlIGZpbGV1cGxvYWRcbiAgICAgICAgICAgIC8vIHdpZGdldCAodmlhIGZpbGUgaW5wdXQgc2VsZWN0aW9uLCBkcmFnICYgZHJvcCwgcGFzdGUgb3IgYWRkIEFQSSBjYWxsKS5cbiAgICAgICAgICAgIC8vIElmIHRoZSBzaW5nbGVGaWxlVXBsb2FkcyBvcHRpb24gaXMgZW5hYmxlZCwgdGhpcyBjYWxsYmFjayB3aWxsIGJlXG4gICAgICAgICAgICAvLyBjYWxsZWQgb25jZSBmb3IgZWFjaCBmaWxlIGluIHRoZSBzZWxlY3Rpb24gZm9yIFhIUiBmaWxlIHVwbG9hZHMsIGVsc2VcbiAgICAgICAgICAgIC8vIG9uY2UgZm9yIGVhY2ggZmlsZSBzZWxlY3Rpb24uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIHVwbG9hZCBzdGFydHMgd2hlbiB0aGUgc3VibWl0IG1ldGhvZCBpcyBpbnZva2VkIG9uIHRoZSBkYXRhIHBhcmFtZXRlci5cbiAgICAgICAgICAgIC8vIFRoZSBkYXRhIG9iamVjdCBjb250YWlucyBhIGZpbGVzIHByb3BlcnR5IGhvbGRpbmcgdGhlIGFkZGVkIGZpbGVzXG4gICAgICAgICAgICAvLyBhbmQgYWxsb3dzIHlvdSB0byBvdmVycmlkZSBwbHVnaW4gb3B0aW9ucyBhcyB3ZWxsIGFzIGRlZmluZSBhamF4IHNldHRpbmdzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIExpc3RlbmVycyBmb3IgdGhpcyBjYWxsYmFjayBjYW4gYWxzbyBiZSBib3VuZCB0aGUgZm9sbG93aW5nIHdheTpcbiAgICAgICAgICAgIC8vIC5iaW5kKCdmaWxldXBsb2FkYWRkJywgZnVuYyk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gZGF0YS5zdWJtaXQoKSByZXR1cm5zIGEgUHJvbWlzZSBvYmplY3QgYW5kIGFsbG93cyB0byBhdHRhY2ggYWRkaXRpb25hbFxuICAgICAgICAgICAgLy8gaGFuZGxlcnMgdXNpbmcgalF1ZXJ5J3MgRGVmZXJyZWQgY2FsbGJhY2tzOlxuICAgICAgICAgICAgLy8gZGF0YS5zdWJtaXQoKS5kb25lKGZ1bmMpLmZhaWwoZnVuYykuYWx3YXlzKGZ1bmMpO1xuICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuYXV0b1VwbG9hZCB8fCAoZGF0YS5hdXRvVXBsb2FkICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5maWxldXBsb2FkKCdvcHRpb24nLCAnYXV0b1VwbG9hZCcpKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnByb2Nlc3MoKS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIE90aGVyIGNhbGxiYWNrczpcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHRoZSBzdWJtaXQgZXZlbnQgb2YgZWFjaCBmaWxlIHVwbG9hZDpcbiAgICAgICAgICAgIC8vIHN1Ym1pdDogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZHN1Ym1pdCcsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgdGhlIHN0YXJ0IG9mIGVhY2ggZmlsZSB1cGxvYWQgcmVxdWVzdDpcbiAgICAgICAgICAgIC8vIHNlbmQ6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRzZW5kJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciBzdWNjZXNzZnVsIHVwbG9hZHM6XG4gICAgICAgICAgICAvLyBkb25lOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkZG9uZScsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgZmFpbGVkIChhYm9ydCBvciBlcnJvcikgdXBsb2FkczpcbiAgICAgICAgICAgIC8vIGZhaWw6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRmYWlsJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciBjb21wbGV0ZWQgKHN1Y2Nlc3MsIGFib3J0IG9yIGVycm9yKSByZXF1ZXN0czpcbiAgICAgICAgICAgIC8vIGFsd2F5czogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZGFsd2F5cycsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgdXBsb2FkIHByb2dyZXNzIGV2ZW50czpcbiAgICAgICAgICAgIC8vIHByb2dyZXNzOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkcHJvZ3Jlc3MnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIGdsb2JhbCB1cGxvYWQgcHJvZ3Jlc3MgZXZlbnRzOlxuICAgICAgICAgICAgLy8gcHJvZ3Jlc3NhbGw6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRwcm9ncmVzc2FsbCcsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgdXBsb2FkcyBzdGFydCwgZXF1aXZhbGVudCB0byB0aGUgZ2xvYmFsIGFqYXhTdGFydCBldmVudDpcbiAgICAgICAgICAgIC8vIHN0YXJ0OiBmdW5jdGlvbiAoZSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2Fkc3RhcnQnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHVwbG9hZHMgc3RvcCwgZXF1aXZhbGVudCB0byB0aGUgZ2xvYmFsIGFqYXhTdG9wIGV2ZW50OlxuICAgICAgICAgICAgLy8gc3RvcDogZnVuY3Rpb24gKGUpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZHN0b3AnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIGNoYW5nZSBldmVudHMgb2YgdGhlIGZpbGVJbnB1dChzKTpcbiAgICAgICAgICAgIC8vIGNoYW5nZTogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZGNoYW5nZScsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgcGFzdGUgZXZlbnRzIHRvIHRoZSBwYXN0ZVpvbmUocyk6XG4gICAgICAgICAgICAvLyBwYXN0ZTogZnVuY3Rpb24gKGUsIGRhdGEpIHt9LCAvLyAuYmluZCgnZmlsZXVwbG9hZHBhc3RlJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciBkcm9wIGV2ZW50cyBvZiB0aGUgZHJvcFpvbmUocyk6XG4gICAgICAgICAgICAvLyBkcm9wOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkZHJvcCcsIGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBDYWxsYmFjayBmb3IgZHJhZ292ZXIgZXZlbnRzIG9mIHRoZSBkcm9wWm9uZShzKTpcbiAgICAgICAgICAgIC8vIGRyYWdvdmVyOiBmdW5jdGlvbiAoZSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkZHJhZ292ZXInLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHRoZSBzdGFydCBvZiBlYWNoIGNodW5rIHVwbG9hZCByZXF1ZXN0OlxuICAgICAgICAgICAgLy8gY2h1bmtzZW5kOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkY2h1bmtzZW5kJywgZnVuYyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxiYWNrIGZvciBzdWNjZXNzZnVsIGNodW5rIHVwbG9hZHM6XG4gICAgICAgICAgICAvLyBjaHVua2RvbmU6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRjaHVua2RvbmUnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIGZhaWxlZCAoYWJvcnQgb3IgZXJyb3IpIGNodW5rIHVwbG9hZHM6XG4gICAgICAgICAgICAvLyBjaHVua2ZhaWw6IGZ1bmN0aW9uIChlLCBkYXRhKSB7fSwgLy8gLmJpbmQoJ2ZpbGV1cGxvYWRjaHVua2ZhaWwnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIGNvbXBsZXRlZCAoc3VjY2VzcywgYWJvcnQgb3IgZXJyb3IpIGNodW5rIHVwbG9hZCByZXF1ZXN0czpcbiAgICAgICAgICAgIC8vIGNodW5rYWx3YXlzOiBmdW5jdGlvbiAoZSwgZGF0YSkge30sIC8vIC5iaW5kKCdmaWxldXBsb2FkY2h1bmthbHdheXMnLCBmdW5jKTtcblxuICAgICAgICAgICAgLy8gVGhlIHBsdWdpbiBvcHRpb25zIGFyZSB1c2VkIGFzIHNldHRpbmdzIG9iamVjdCBmb3IgdGhlIGFqYXggY2FsbHMuXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZSBqUXVlcnkgYWpheCBzZXR0aW5ncyByZXF1aXJlZCBmb3IgdGhlIGZpbGUgdXBsb2FkczpcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBBIGxpc3Qgb2Ygb3B0aW9ucyB0aGF0IHJlcXVpcmUgcmVpbml0aWFsaXppbmcgZXZlbnQgbGlzdGVuZXJzIGFuZC9vclxuICAgICAgICAvLyBzcGVjaWFsIGluaXRpYWxpemF0aW9uIGNvZGU6XG4gICAgICAgIF9zcGVjaWFsT3B0aW9uczogW1xuICAgICAgICAgICAgJ2ZpbGVJbnB1dCcsXG4gICAgICAgICAgICAnZHJvcFpvbmUnLFxuICAgICAgICAgICAgJ3Bhc3RlWm9uZScsXG4gICAgICAgICAgICAnbXVsdGlwYXJ0JyxcbiAgICAgICAgICAgICdmb3JjZUlmcmFtZVRyYW5zcG9ydCdcbiAgICAgICAgXSxcblxuICAgICAgICBfYmxvYlNsaWNlOiAkLnN1cHBvcnQuYmxvYlNsaWNlICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzbGljZSA9IHRoaXMuc2xpY2UgfHwgdGhpcy53ZWJraXRTbGljZSB8fCB0aGlzLm1velNsaWNlO1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX0JpdHJhdGVUaW1lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSAoKERhdGUubm93KSA/IERhdGUubm93KCkgOiAobmV3IERhdGUoKSkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVkID0gMDtcbiAgICAgICAgICAgIHRoaXMuYml0cmF0ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmdldEJpdHJhdGUgPSBmdW5jdGlvbiAobm93LCBsb2FkZWQsIGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVEaWZmID0gbm93IC0gdGhpcy50aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJpdHJhdGUgfHwgIWludGVydmFsIHx8IHRpbWVEaWZmID4gaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaXRyYXRlID0gKGxvYWRlZCAtIHRoaXMubG9hZGVkKSAqICgxMDAwIC8gdGltZURpZmYpICogODtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSBsb2FkZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gbm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iaXRyYXRlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaXNYSFJVcGxvYWQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gIW9wdGlvbnMuZm9yY2VJZnJhbWVUcmFuc3BvcnQgJiZcbiAgICAgICAgICAgICAgICAoKCFvcHRpb25zLm11bHRpcGFydCAmJiAkLnN1cHBvcnQueGhyRmlsZVVwbG9hZCkgfHxcbiAgICAgICAgICAgICAgICAkLnN1cHBvcnQueGhyRm9ybURhdGFGaWxlVXBsb2FkKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0Rm9ybURhdGE6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZm9ybURhdGE7XG4gICAgICAgICAgICBpZiAoJC50eXBlKG9wdGlvbnMuZm9ybURhdGEpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZm9ybURhdGEob3B0aW9ucy5mb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkLmlzQXJyYXkob3B0aW9ucy5mb3JtRGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5mb3JtRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkLnR5cGUob3B0aW9ucy5mb3JtRGF0YSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAkLmVhY2gob3B0aW9ucy5mb3JtRGF0YSwgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0VG90YWw6IGZ1bmN0aW9uIChmaWxlcykge1xuICAgICAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgICAgICQuZWFjaChmaWxlcywgZnVuY3Rpb24gKGluZGV4LCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZmlsZS5zaXplIHx8IDE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdFByb2dyZXNzT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgICAgICAgbG9hZGVkOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICAgICAgICAgIGJpdHJhdGU6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob2JqLl9wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICQuZXh0ZW5kKG9iai5fcHJvZ3Jlc3MsIHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqLl9wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0UmVzcG9uc2VPYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBwcm9wO1xuICAgICAgICAgICAgaWYgKG9iai5fcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gb2JqLl9yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqLl9yZXNwb25zZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9iai5fcmVzcG9uc2VbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iai5fcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfb25Qcm9ncmVzczogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gKChEYXRlLm5vdykgPyBEYXRlLm5vdygpIDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKSksXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZDtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5fdGltZSAmJiBkYXRhLnByb2dyZXNzSW50ZXJ2YWwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChub3cgLSBkYXRhLl90aW1lIDwgZGF0YS5wcm9ncmVzc0ludGVydmFsKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5sb2FkZWQgIT09IGUudG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLl90aW1lID0gbm93O1xuICAgICAgICAgICAgICAgIGxvYWRlZCA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgICAgICAgIGUubG9hZGVkIC8gZS50b3RhbCAqIChkYXRhLmNodW5rU2l6ZSB8fCBkYXRhLl9wcm9ncmVzcy50b3RhbClcbiAgICAgICAgICAgICAgICApICsgKGRhdGEudXBsb2FkZWRCeXRlcyB8fCAwKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJldmlvdXNseSBsb2FkZWQgc3RhdGVcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgZ2xvYmFsIGxvYWRlZCBjb3VudGVyOlxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzLmxvYWRlZCArPSAobG9hZGVkIC0gZGF0YS5fcHJvZ3Jlc3MubG9hZGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzcy5iaXRyYXRlID0gdGhpcy5fYml0cmF0ZVRpbWVyLmdldEJpdHJhdGUoXG4gICAgICAgICAgICAgICAgICAgIG5vdyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MubG9hZGVkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLmJpdHJhdGVJbnRlcnZhbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZGF0YS5fcHJvZ3Jlc3MubG9hZGVkID0gZGF0YS5sb2FkZWQgPSBsb2FkZWQ7XG4gICAgICAgICAgICAgICAgZGF0YS5fcHJvZ3Jlc3MuYml0cmF0ZSA9IGRhdGEuYml0cmF0ZSA9IGRhdGEuX2JpdHJhdGVUaW1lci5nZXRCaXRyYXRlKFxuICAgICAgICAgICAgICAgICAgICBub3csXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5iaXRyYXRlSW50ZXJ2YWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgYSBjdXN0b20gcHJvZ3Jlc3MgZXZlbnQgd2l0aCBhIHRvdGFsIGRhdGEgcHJvcGVydHkgc2V0XG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIGZpbGUgc2l6ZShzKSBvZiB0aGUgY3VycmVudCB1cGxvYWQgYW5kIGEgbG9hZGVkIGRhdGFcbiAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBjYWxjdWxhdGVkIGFjY29yZGluZ2x5OlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXG4gICAgICAgICAgICAgICAgICAgICdwcm9ncmVzcycsXG4gICAgICAgICAgICAgICAgICAgICQuRXZlbnQoJ3Byb2dyZXNzJywge2RlbGVnYXRlZEV2ZW50OiBlfSksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgYSBnbG9iYWwgcHJvZ3Jlc3MgZXZlbnQgZm9yIGFsbCBjdXJyZW50IGZpbGUgdXBsb2FkcyxcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRpbmcgYWpheCBjYWxscyBxdWV1ZWQgZm9yIHNlcXVlbnRpYWwgZmlsZSB1cGxvYWRzOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXG4gICAgICAgICAgICAgICAgICAgICdwcm9ncmVzc2FsbCcsXG4gICAgICAgICAgICAgICAgICAgICQuRXZlbnQoJ3Byb2dyZXNzYWxsJywge2RlbGVnYXRlZEV2ZW50OiBlfSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdFByb2dyZXNzTGlzdGVuZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgeGhyID0gb3B0aW9ucy54aHIgPyBvcHRpb25zLnhocigpIDogJC5hamF4U2V0dGluZ3MueGhyKCk7XG4gICAgICAgICAgICAvLyBBY2Nlc3NzIHRvIHRoZSBuYXRpdmUgWEhSIG9iamVjdCBpcyByZXF1aXJlZCB0byBhZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICAvLyBmb3IgdGhlIHVwbG9hZCBwcm9ncmVzcyBldmVudDpcbiAgICAgICAgICAgIGlmICh4aHIudXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgJCh4aHIudXBsb2FkKS5iaW5kKCdwcm9ncmVzcycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvZSA9IGUub3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwcm9ncmVzcyBldmVudCBwcm9wZXJ0aWVzIGdldCBjb3BpZWQgb3ZlcjpcbiAgICAgICAgICAgICAgICAgICAgZS5sZW5ndGhDb21wdXRhYmxlID0gb2UubGVuZ3RoQ29tcHV0YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgZS5sb2FkZWQgPSBvZS5sb2FkZWQ7XG4gICAgICAgICAgICAgICAgICAgIGUudG90YWwgPSBvZS50b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fb25Qcm9ncmVzcyhlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnhociA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhocjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9pc0luc3RhbmNlT2Y6IGZ1bmN0aW9uICh0eXBlLCBvYmopIHtcbiAgICAgICAgICAgIC8vIENyb3NzLWZyYW1lIGluc3RhbmNlb2YgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIHR5cGUgKyAnXSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRYSFJEYXRhOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgIGZpbGUgPSBvcHRpb25zLmZpbGVzWzBdLFxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBub24tbXVsdGlwYXJ0IHNldHRpbmcgaWYgbm90IHN1cHBvcnRlZDpcbiAgICAgICAgICAgICAgICBtdWx0aXBhcnQgPSBvcHRpb25zLm11bHRpcGFydCB8fCAhJC5zdXBwb3J0LnhockZpbGVVcGxvYWQsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lID0gJC50eXBlKG9wdGlvbnMucGFyYW1OYW1lKSA9PT0gJ2FycmF5JyA/XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1OYW1lWzBdIDogb3B0aW9ucy5wYXJhbU5hbWU7XG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRSYW5nZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1SYW5nZSddID0gb3B0aW9ucy5jb250ZW50UmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW11bHRpcGFydCB8fCBvcHRpb25zLmJsb2IgfHwgIXRoaXMuX2lzSW5zdGFuY2VPZignRmlsZScsIGZpbGUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydDb250ZW50LURpc3Bvc2l0aW9uJ10gPSAnYXR0YWNobWVudDsgZmlsZW5hbWU9XCInICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJKGZpbGUubmFtZSkgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtdWx0aXBhcnQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbnRlbnRUeXBlID0gZmlsZS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuYmxvYiB8fCBmaWxlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkLnN1cHBvcnQueGhyRm9ybURhdGFGaWxlVXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2luZG93LnBvc3RNZXNzYWdlIGRvZXMgbm90IGFsbG93IHNlbmRpbmcgRm9ybURhdGFcbiAgICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0cywgc28gd2UganVzdCBhZGQgdGhlIEZpbGUvQmxvYiBvYmplY3RzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmb3JtRGF0YSBhcnJheSBhbmQgbGV0IHRoZSBwb3N0TWVzc2FnZSB3aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBGb3JtRGF0YSBvYmplY3Qgb3V0IG9mIHRoaXMgYXJyYXk6XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhID0gdGhpcy5fZ2V0Rm9ybURhdGEob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy5ibG9iXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChvcHRpb25zLmZpbGVzLCBmdW5jdGlvbiAoaW5kZXgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogKCQudHlwZShvcHRpb25zLnBhcmFtTmFtZSkgPT09ICdhcnJheScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1OYW1lW2luZGV4XSkgfHwgcGFyYW1OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5faXNJbnN0YW5jZU9mKCdGb3JtRGF0YScsIG9wdGlvbnMuZm9ybURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YSA9IG9wdGlvbnMuZm9ybURhdGE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHRoaXMuX2dldEZvcm1EYXRhKG9wdGlvbnMpLCBmdW5jdGlvbiAoaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZpZWxkLm5hbWUsIGZpZWxkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChwYXJhbU5hbWUsIG9wdGlvbnMuYmxvYiwgZmlsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChvcHRpb25zLmZpbGVzLCBmdW5jdGlvbiAoaW5kZXgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNoZWNrIGFsbG93cyB0aGUgdGVzdHMgdG8gcnVuIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkdW1teSBvYmplY3RzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9pc0luc3RhbmNlT2YoJ0ZpbGUnLCBmaWxlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5faXNJbnN0YW5jZU9mKCdCbG9iJywgZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCQudHlwZShvcHRpb25zLnBhcmFtTmFtZSkgPT09ICdhcnJheScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtTmFtZVtpbmRleF0pIHx8IHBhcmFtTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnVwbG9hZE5hbWUgfHwgZmlsZS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gZm9ybURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCbG9iIHJlZmVyZW5jZSBpcyBub3QgbmVlZGVkIGFueW1vcmUsIGZyZWUgbWVtb3J5OlxuICAgICAgICAgICAgb3B0aW9ucy5ibG9iID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdElmcmFtZVNldHRpbmdzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHRhcmdldEhvc3QgPSAkKCc8YT48L2E+JykucHJvcCgnaHJlZicsIG9wdGlvbnMudXJsKS5wcm9wKCdob3N0Jyk7XG4gICAgICAgICAgICAvLyBTZXR0aW5nIHRoZSBkYXRhVHlwZSB0byBpZnJhbWUgZW5hYmxlcyB0aGUgaWZyYW1lIHRyYW5zcG9ydDpcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YVR5cGUgPSAnaWZyYW1lICcgKyAob3B0aW9ucy5kYXRhVHlwZSB8fCAnJyk7XG4gICAgICAgICAgICAvLyBUaGUgaWZyYW1lIHRyYW5zcG9ydCBhY2NlcHRzIGEgc2VyaWFsaXplZCBhcnJheSBhcyBmb3JtIGRhdGE6XG4gICAgICAgICAgICBvcHRpb25zLmZvcm1EYXRhID0gdGhpcy5fZ2V0Rm9ybURhdGEob3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBBZGQgcmVkaXJlY3QgdXJsIHRvIGZvcm0gZGF0YSBvbiBjcm9zcy1kb21haW4gdXBsb2FkczpcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlZGlyZWN0ICYmIHRhcmdldEhvc3QgJiYgdGFyZ2V0SG9zdCAhPT0gbG9jYXRpb24uaG9zdCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZm9ybURhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMucmVkaXJlY3RQYXJhbU5hbWUgfHwgJ3JlZGlyZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMucmVkaXJlY3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdERhdGFTZXR0aW5nczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1hIUlVwbG9hZChvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2h1bmtlZFVwbG9hZChvcHRpb25zLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdFhIUkRhdGEob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdFByb2dyZXNzTGlzdGVuZXIob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgdGhlIGRhdGFUeXBlIHRvIHBvc3RtZXNzYWdlIGVuYWJsZXMgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc3RNZXNzYWdlIHRyYW5zcG9ydDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhVHlwZSA9ICdwb3N0bWVzc2FnZSAnICsgKG9wdGlvbnMuZGF0YVR5cGUgfHwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdElmcmFtZVNldHRpbmdzKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRQYXJhbU5hbWU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZmlsZUlucHV0ID0gJChvcHRpb25zLmZpbGVJbnB1dCksXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lID0gb3B0aW9ucy5wYXJhbU5hbWU7XG4gICAgICAgICAgICBpZiAoIXBhcmFtTmFtZSkge1xuICAgICAgICAgICAgICAgIHBhcmFtTmFtZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZpbGVJbnB1dC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBpbnB1dC5wcm9wKCduYW1lJykgfHwgJ2ZpbGVzW10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IChpbnB1dC5wcm9wKCdmaWxlcycpIHx8IFsxXSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lLnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtTmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lID0gW2ZpbGVJbnB1dC5wcm9wKCduYW1lJykgfHwgJ2ZpbGVzW10nXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEkLmlzQXJyYXkocGFyYW1OYW1lKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtTmFtZSA9IFtwYXJhbU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtTmFtZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdEZvcm1TZXR0aW5nczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIG1pc3Npbmcgb3B0aW9ucyBmcm9tIHRoZSBpbnB1dCBmaWVsZCBhbmQgdGhlXG4gICAgICAgICAgICAvLyBhc3NvY2lhdGVkIGZvcm0sIGlmIGF2YWlsYWJsZTpcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5mb3JtIHx8ICFvcHRpb25zLmZvcm0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mb3JtID0gJChvcHRpb25zLmZpbGVJbnB1dC5wcm9wKCdmb3JtJykpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBnaXZlbiBmaWxlIGlucHV0IGRvZXNuJ3QgaGF2ZSBhbiBhc3NvY2lhdGVkIGZvcm0sXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBkZWZhdWx0IHdpZGdldCBmaWxlIGlucHV0J3MgZm9ybTpcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZm9ybS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5mb3JtID0gJCh0aGlzLm9wdGlvbnMuZmlsZUlucHV0LnByb3AoJ2Zvcm0nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5wYXJhbU5hbWUgPSB0aGlzLl9nZXRQYXJhbU5hbWUob3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudXJsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBvcHRpb25zLmZvcm0ucHJvcCgnYWN0aW9uJykgfHwgbG9jYXRpb24uaHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBIVFRQIHJlcXVlc3QgbWV0aG9kIG11c3QgYmUgXCJQT1NUXCIgb3IgXCJQVVRcIjpcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9IChvcHRpb25zLnR5cGUgfHxcbiAgICAgICAgICAgICAgICAoJC50eXBlKG9wdGlvbnMuZm9ybS5wcm9wKCdtZXRob2QnKSkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZm9ybS5wcm9wKCdtZXRob2QnKSkgfHwgJydcbiAgICAgICAgICAgICAgICApLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50eXBlICE9PSAnUE9TVCcgJiYgb3B0aW9ucy50eXBlICE9PSAnUFVUJyAmJlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGUgIT09ICdQQVRDSCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGUgPSAnUE9TVCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZm9ybUFjY2VwdENoYXJzZXQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZvcm1BY2NlcHRDaGFyc2V0ID0gb3B0aW9ucy5mb3JtLmF0dHIoJ2FjY2VwdC1jaGFyc2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEFKQVhTZXR0aW5nczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9pbml0Rm9ybVNldHRpbmdzKG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5faW5pdERhdGFTZXR0aW5ncyhvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGpRdWVyeSAxLjYgZG9lc24ndCBwcm92aWRlIC5zdGF0ZSgpLFxuICAgICAgICAvLyB3aGlsZSBqUXVlcnkgMS44KyByZW1vdmVkIC5pc1JlamVjdGVkKCkgYW5kIC5pc1Jlc29sdmVkKCk6XG4gICAgICAgIF9nZXREZWZlcnJlZFN0YXRlOiBmdW5jdGlvbiAoZGVmZXJyZWQpIHtcbiAgICAgICAgICAgIGlmIChkZWZlcnJlZC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5zdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZmVycmVkLmlzUmVzb2x2ZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncmVzb2x2ZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZmVycmVkLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncmVqZWN0ZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdwZW5kaW5nJztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBNYXBzIGpxWEhSIGNhbGxiYWNrcyB0byB0aGUgZXF1aXZhbGVudFxuICAgICAgICAvLyBtZXRob2RzIG9mIHRoZSBnaXZlbiBQcm9taXNlIG9iamVjdDpcbiAgICAgICAgX2VuaGFuY2VQcm9taXNlOiBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzID0gcHJvbWlzZS5kb25lO1xuICAgICAgICAgICAgcHJvbWlzZS5lcnJvciA9IHByb21pc2UuZmFpbDtcbiAgICAgICAgICAgIHByb21pc2UuY29tcGxldGUgPSBwcm9taXNlLmFsd2F5cztcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENyZWF0ZXMgYW5kIHJldHVybnMgYSBQcm9taXNlIG9iamVjdCBlbmhhbmNlZCB3aXRoXG4gICAgICAgIC8vIHRoZSBqcVhIUiBtZXRob2RzIGFib3J0LCBzdWNjZXNzLCBlcnJvciBhbmQgY29tcGxldGU6XG4gICAgICAgIF9nZXRYSFJQcm9taXNlOiBmdW5jdGlvbiAocmVzb2x2ZU9yUmVqZWN0LCBjb250ZXh0LCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgZGZkID0gJC5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIHByb21pc2UgPSBkZmQucHJvbWlzZSgpO1xuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcy5vcHRpb25zLmNvbnRleHQgfHwgcHJvbWlzZTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlT3JSZWplY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBkZmQucmVzb2x2ZVdpdGgoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc29sdmVPclJlamVjdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkZmQucmVqZWN0V2l0aChjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2UuYWJvcnQgPSBkZmQucHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmhhbmNlUHJvbWlzZShwcm9taXNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBBZGRzIGNvbnZlbmllbmNlIG1ldGhvZHMgdG8gdGhlIGRhdGEgY2FsbGJhY2sgYXJndW1lbnQ6XG4gICAgICAgIF9hZGRDb252ZW5pZW5jZU1ldGhvZHM6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZ2V0UHJvbWlzZSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkLkRlZmVycmVkKCkucmVzb2x2ZVdpdGgodGhhdCwgYXJncykucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhLnByb2Nlc3MgPSBmdW5jdGlvbiAocmVzb2x2ZUZ1bmMsIHJlamVjdEZ1bmMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZUZ1bmMgfHwgcmVqZWN0RnVuYykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLl9wcm9jZXNzUXVldWUgPSB0aGlzLl9wcm9jZXNzUXVldWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuX3Byb2Nlc3NRdWV1ZSB8fCBnZXRQcm9taXNlKFt0aGlzXSkpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5lcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuRGVmZXJyZWQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWplY3RXaXRoKHRoYXQsIFtkYXRhXSkucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9taXNlKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKS50aGVuKHJlc29sdmVGdW5jLCByZWplY3RGdW5jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NRdWV1ZSB8fCBnZXRQcm9taXNlKFt0aGlzXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YS5zdWJtaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSAhPT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuanFYSFIgPSB0aGlzLmpxWEhSID1cbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGF0Ll90cmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdWJtaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuRXZlbnQoJ3N1Ym1pdCcsIHtkZWxlZ2F0ZWRFdmVudDogZX0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICkgIT09IGZhbHNlKSAmJiB0aGF0Ll9vblNlbmQoZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmpxWEhSIHx8IHRoYXQuX2dldFhIUlByb21pc2UoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmpxWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmpxWEhSLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JUaHJvd24gPSAnYWJvcnQnO1xuICAgICAgICAgICAgICAgIHRoYXQuX3RyaWdnZXIoJ2ZhaWwnLCBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5fZ2V0WEhSUHJvbWlzZShmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YS5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5qcVhIUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5fZ2V0RGVmZXJyZWRTdGF0ZSh0aGlzLmpxWEhSKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Byb2Nlc3NRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5fZ2V0RGVmZXJyZWRTdGF0ZSh0aGlzLl9wcm9jZXNzUXVldWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhLnByb2Nlc3NpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmpxWEhSICYmIHRoaXMuX3Byb2Nlc3NRdWV1ZSAmJiB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC5fZ2V0RGVmZXJyZWRTdGF0ZSh0aGlzLl9wcm9jZXNzUXVldWUpID09PSAncGVuZGluZyc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YS5wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YS5yZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFBhcnNlcyB0aGUgUmFuZ2UgaGVhZGVyIGZyb20gdGhlIHNlcnZlciByZXNwb25zZVxuICAgICAgICAvLyBhbmQgcmV0dXJucyB0aGUgdXBsb2FkZWQgYnl0ZXM6XG4gICAgICAgIF9nZXRVcGxvYWRlZEJ5dGVzOiBmdW5jdGlvbiAoanFYSFIpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCdSYW5nZScpLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gcmFuZ2UgJiYgcmFuZ2Uuc3BsaXQoJy0nKSxcbiAgICAgICAgICAgICAgICB1cHBlckJ5dGVzUG9zID0gcGFydHMgJiYgcGFydHMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xuICAgICAgICAgICAgcmV0dXJuIHVwcGVyQnl0ZXNQb3MgJiYgdXBwZXJCeXRlc1BvcyArIDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVXBsb2FkcyBhIGZpbGUgaW4gbXVsdGlwbGUsIHNlcXVlbnRpYWwgcmVxdWVzdHNcbiAgICAgICAgLy8gYnkgc3BsaXR0aW5nIHRoZSBmaWxlIHVwIGluIG11bHRpcGxlIGJsb2IgY2h1bmtzLlxuICAgICAgICAvLyBJZiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyB0cnVlLCBvbmx5IHRlc3RzIGlmIHRoZSBmaWxlXG4gICAgICAgIC8vIHNob3VsZCBiZSB1cGxvYWRlZCBpbiBjaHVua3MsIGJ1dCBkb2VzIG5vdCBpbnZva2UgYW55XG4gICAgICAgIC8vIHVwbG9hZCByZXF1ZXN0czpcbiAgICAgICAgX2NodW5rZWRVcGxvYWQ6IGZ1bmN0aW9uIChvcHRpb25zLCB0ZXN0T25seSkge1xuICAgICAgICAgICAgb3B0aW9ucy51cGxvYWRlZEJ5dGVzID0gb3B0aW9ucy51cGxvYWRlZEJ5dGVzIHx8IDA7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZmlsZSA9IG9wdGlvbnMuZmlsZXNbMF0sXG4gICAgICAgICAgICAgICAgZnMgPSBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICAgdWIgPSBvcHRpb25zLnVwbG9hZGVkQnl0ZXMsXG4gICAgICAgICAgICAgICAgbWNzID0gb3B0aW9ucy5tYXhDaHVua1NpemUgfHwgZnMsXG4gICAgICAgICAgICAgICAgc2xpY2UgPSB0aGlzLl9ibG9iU2xpY2UsXG4gICAgICAgICAgICAgICAgZGZkID0gJC5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIHByb21pc2UgPSBkZmQucHJvbWlzZSgpLFxuICAgICAgICAgICAgICAgIGpxWEhSLFxuICAgICAgICAgICAgICAgIHVwbG9hZDtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX2lzWEhSVXBsb2FkKG9wdGlvbnMpICYmIHNsaWNlICYmICh1YiB8fCBtY3MgPCBmcykpIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXN0T25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHViID49IGZzKSB7XG4gICAgICAgICAgICAgICAgZmlsZS5lcnJvciA9IG9wdGlvbnMuaTE4bigndXBsb2FkZWRCeXRlcycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRYSFJQcm9taXNlKFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBbbnVsbCwgJ2Vycm9yJywgZmlsZS5lcnJvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGNodW5rIHVwbG9hZCBtZXRob2Q6XG4gICAgICAgICAgICB1cGxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIG9wdGlvbnMgb2JqZWN0IGZvciBlYWNoIGNodW5rIHVwbG9hZDpcbiAgICAgICAgICAgICAgICB2YXIgbyA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExvYWRlZCA9IG8uX3Byb2dyZXNzLmxvYWRlZDtcbiAgICAgICAgICAgICAgICBvLmJsb2IgPSBzbGljZS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICAgICAgICB1YixcbiAgICAgICAgICAgICAgICAgICAgdWIgKyBtY3MsXG4gICAgICAgICAgICAgICAgICAgIGZpbGUudHlwZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgY2h1bmsgc2l6ZSwgYXMgdGhlIGJsb2IgaXRzZWxmXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBkZXJlZmVyZW5jZWQgYWZ0ZXIgZGF0YSBwcm9jZXNzaW5nOlxuICAgICAgICAgICAgICAgIG8uY2h1bmtTaXplID0gby5ibG9iLnNpemU7XG4gICAgICAgICAgICAgICAgLy8gRXhwb3NlIHRoZSBjaHVuayBieXRlcyBwb3NpdGlvbiByYW5nZTpcbiAgICAgICAgICAgICAgICBvLmNvbnRlbnRSYW5nZSA9ICdieXRlcyAnICsgdWIgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAodWIgKyBvLmNodW5rU2l6ZSAtIDEpICsgJy8nICsgZnM7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgdXBsb2FkIGRhdGEgKHRoZSBibG9iIGFuZCBwb3RlbnRpYWwgZm9ybSBkYXRhKTpcbiAgICAgICAgICAgICAgICB0aGF0Ll9pbml0WEhSRGF0YShvKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgcHJvZ3Jlc3MgbGlzdGVuZXJzIGZvciB0aGlzIGNodW5rIHVwbG9hZDpcbiAgICAgICAgICAgICAgICB0aGF0Ll9pbml0UHJvZ3Jlc3NMaXN0ZW5lcihvKTtcbiAgICAgICAgICAgICAgICBqcVhIUiA9ICgodGhhdC5fdHJpZ2dlcignY2h1bmtzZW5kJywgbnVsbCwgbykgIT09IGZhbHNlICYmICQuYWpheChvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2dldFhIUlByb21pc2UoZmFsc2UsIG8uY29udGV4dCkpXG4gICAgICAgICAgICAgICAgICAgIC5kb25lKGZ1bmN0aW9uIChyZXN1bHQsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1YiA9IHRoYXQuX2dldFVwbG9hZGVkQnl0ZXMoanFYSFIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHViICsgby5jaHVua1NpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJvZ3Jlc3MgZXZlbnQgaWYgbm8gZmluYWwgcHJvZ3Jlc3MgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGggbG9hZGVkIGVxdWFsaW5nIHRvdGFsIGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoaXMgY2h1bms6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudExvYWRlZCArIG8uY2h1bmtTaXplIC0gby5fcHJvZ3Jlc3MubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fb25Qcm9ncmVzcygkLkV2ZW50KCdwcm9ncmVzcycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiB1YiAtIG8udXBsb2FkZWRCeXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWw6IHViIC0gby51cGxvYWRlZEJ5dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cGxvYWRlZEJ5dGVzID0gby51cGxvYWRlZEJ5dGVzID0gdWI7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8udGV4dFN0YXR1cyA9IHRleHRTdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLmpxWEhSID0ganFYSFI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKCdjaHVua2RvbmUnLCBudWxsLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RyaWdnZXIoJ2NodW5rYWx3YXlzJywgbnVsbCwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodWIgPCBmcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbGUgdXBsb2FkIG5vdCB5ZXQgY29tcGxldGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgd2l0aCB0aGUgbmV4dCBjaHVuazpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGZkLnJlc29sdmVXaXRoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZXN1bHQsIHRleHRTdGF0dXMsIGpxWEhSXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5mYWlsKGZ1bmN0aW9uIChqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uanFYSFIgPSBqcVhIUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8udGV4dFN0YXR1cyA9IHRleHRTdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLmVycm9yVGhyb3duID0gZXJyb3JUaHJvd247XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKCdjaHVua2ZhaWwnLCBudWxsLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RyaWdnZXIoJ2NodW5rYWx3YXlzJywgbnVsbCwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZmQucmVqZWN0V2l0aChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2pxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bl1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2VuaGFuY2VQcm9taXNlKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB1cGxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9iZWZvcmVTZW5kOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBzdGFydCBjYWxsYmFjayBpcyB0cmlnZ2VyZWQgd2hlbiBhbiB1cGxvYWQgc3RhcnRzXG4gICAgICAgICAgICAgICAgLy8gYW5kIG5vIG90aGVyIHVwbG9hZHMgYXJlIGN1cnJlbnRseSBydW5uaW5nLFxuICAgICAgICAgICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhlIGdsb2JhbCBhamF4U3RhcnQgZXZlbnQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGltZXIgZm9yIGdsb2JhbCBiaXRyYXRlIHByb2dyZXNzIGNhbGN1bGF0aW9uOlxuICAgICAgICAgICAgICAgIHRoaXMuX2JpdHJhdGVUaW1lciA9IG5ldyB0aGlzLl9CaXRyYXRlVGltZXIoKTtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZ2xvYmFsIHByb2dyZXNzIHZhbHVlczpcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzcy5sb2FkZWQgPSB0aGlzLl9wcm9ncmVzcy50b3RhbCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MuYml0cmF0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnRhaW5lciBvYmplY3RzIGZvciB0aGUgLnJlc3BvbnNlKCkgYW5kXG4gICAgICAgICAgICAvLyAucHJvZ3Jlc3MoKSBtZXRob2RzIG9uIHRoZSBkYXRhIG9iamVjdCBhcmUgYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBhbmQgcmVzZXQgdG8gdGhlaXIgaW5pdGlhbCBzdGF0ZTpcbiAgICAgICAgICAgIHRoaXMuX2luaXRSZXNwb25zZU9iamVjdChkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRQcm9ncmVzc09iamVjdChkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuX3Byb2dyZXNzLmxvYWRlZCA9IGRhdGEubG9hZGVkID0gZGF0YS51cGxvYWRlZEJ5dGVzIHx8IDA7XG4gICAgICAgICAgICBkYXRhLl9wcm9ncmVzcy50b3RhbCA9IGRhdGEudG90YWwgPSB0aGlzLl9nZXRUb3RhbChkYXRhLmZpbGVzKSB8fCAxO1xuICAgICAgICAgICAgZGF0YS5fcHJvZ3Jlc3MuYml0cmF0ZSA9IGRhdGEuYml0cmF0ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgKz0gMTtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGdsb2JhbCBwcm9ncmVzcyB2YWx1ZXM6XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzcy5sb2FkZWQgKz0gZGF0YS5sb2FkZWQ7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzcy50b3RhbCArPSBkYXRhLnRvdGFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkRvbmU6IGZ1bmN0aW9uIChyZXN1bHQsIHRleHRTdGF0dXMsIGpxWEhSLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSBvcHRpb25zLl9wcm9ncmVzcy50b3RhbCxcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IG9wdGlvbnMuX3Jlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuX3Byb2dyZXNzLmxvYWRlZCA8IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJvZ3Jlc3MgZXZlbnQgaWYgbm8gZmluYWwgcHJvZ3Jlc3MgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB3aXRoIGxvYWRlZCBlcXVhbGluZyB0b3RhbCBoYXMgYmVlbiB0cmlnZ2VyZWQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Qcm9ncmVzcygkLkV2ZW50KCdwcm9ncmVzcycsIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiB0b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgdG90YWw6IHRvdGFsXG4gICAgICAgICAgICAgICAgfSksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2UucmVzdWx0ID0gb3B0aW9ucy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICByZXNwb25zZS50ZXh0U3RhdHVzID0gb3B0aW9ucy50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcbiAgICAgICAgICAgIHJlc3BvbnNlLmpxWEhSID0gb3B0aW9ucy5qcVhIUiA9IGpxWEhSO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignZG9uZScsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkZhaWw6IGZ1bmN0aW9uIChqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IG9wdGlvbnMuX3Jlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVjYWxjdWxhdGVQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmFpbGVkIChlcnJvciBvciBhYm9ydCkgZmlsZSB1cGxvYWQgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHRoZSBnbG9iYWwgcHJvZ3Jlc3MgY2FsY3VsYXRpb246XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MubG9hZGVkIC09IG9wdGlvbnMuX3Byb2dyZXNzLmxvYWRlZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzcy50b3RhbCAtPSBvcHRpb25zLl9wcm9ncmVzcy50b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlLmpxWEhSID0gb3B0aW9ucy5qcVhIUiA9IGpxWEhSO1xuICAgICAgICAgICAgcmVzcG9uc2UudGV4dFN0YXR1cyA9IG9wdGlvbnMudGV4dFN0YXR1cyA9IHRleHRTdGF0dXM7XG4gICAgICAgICAgICByZXNwb25zZS5lcnJvclRocm93biA9IG9wdGlvbnMuZXJyb3JUaHJvd24gPSBlcnJvclRocm93bjtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoJ2ZhaWwnLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25BbHdheXM6IGZ1bmN0aW9uIChqcVhIUm9yUmVzdWx0LCB0ZXh0U3RhdHVzLCBqcVhIUm9yRXJyb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIGpxWEhSb3JSZXN1bHQsIHRleHRTdGF0dXMgYW5kIGpxWEhSb3JFcnJvciBhcmUgYWRkZWQgdG8gdGhlXG4gICAgICAgICAgICAvLyBvcHRpb25zIG9iamVjdCB2aWEgZG9uZSBhbmQgZmFpbCBjYWxsYmFja3NcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoJ2Fsd2F5cycsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vblNlbmQ6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEuc3VibWl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQ29udmVuaWVuY2VNZXRob2RzKGUsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGpxWEhSLFxuICAgICAgICAgICAgICAgIGFib3J0ZWQsXG4gICAgICAgICAgICAgICAgc2xvdCxcbiAgICAgICAgICAgICAgICBwaXBlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0aGF0Ll9nZXRBSkFYU2V0dGluZ3MoZGF0YSksXG4gICAgICAgICAgICAgICAgc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fc2VuZGluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGltZXIgZm9yIGJpdHJhdGUgcHJvZ3Jlc3MgY2FsY3VsYXRpb246XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuX2JpdHJhdGVUaW1lciA9IG5ldyB0aGF0Ll9CaXRyYXRlVGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAganFYSFIgPSBqcVhIUiB8fCAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoKGFib3J0ZWQgfHwgdGhhdC5fdHJpZ2dlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5FdmVudCgnc2VuZCcsIHtkZWxlZ2F0ZWRFdmVudDogZX0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICkgPT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fZ2V0WEhSUHJvbWlzZShmYWxzZSwgb3B0aW9ucy5jb250ZXh0LCBhYm9ydGVkKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2NodW5rZWRVcGxvYWQob3B0aW9ucykgfHwgJC5hamF4KG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICkuZG9uZShmdW5jdGlvbiAocmVzdWx0LCB0ZXh0U3RhdHVzLCBqcVhIUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fb25Eb25lKHJlc3VsdCwgdGV4dFN0YXR1cywganFYSFIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9KS5mYWlsKGZ1bmN0aW9uIChqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX29uRmFpbChqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9KS5hbHdheXMoZnVuY3Rpb24gKGpxWEhSb3JSZXN1bHQsIHRleHRTdGF0dXMsIGpxWEhSb3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fb25BbHdheXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganFYSFJvclJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0U3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSb3JFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fc2VuZGluZyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fYWN0aXZlIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5saW1pdENvbmN1cnJlbnRVcGxvYWRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubGltaXRDb25jdXJyZW50VXBsb2FkcyA+IHRoYXQuX3NlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCBxdWV1ZWQgdXBsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgaGFzIG5vdCBiZWVuIGFib3J0ZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRTbG90ID0gdGhhdC5fc2xvdHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmV4dFNsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuX2dldERlZmVycmVkU3RhdGUobmV4dFNsb3QpID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTbG90LnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTbG90ID0gdGhhdC5fc2xvdHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5fYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHN0b3AgY2FsbGJhY2sgaXMgdHJpZ2dlcmVkIHdoZW4gYWxsIHVwbG9hZHMgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlZW4gY29tcGxldGVkLCBlcXVpdmFsZW50IHRvIHRoZSBnbG9iYWwgYWpheFN0b3AgZXZlbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcignc3RvcCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9iZWZvcmVTZW5kKGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZXF1ZW50aWFsVXBsb2FkcyB8fFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5vcHRpb25zLmxpbWl0Q29uY3VycmVudFVwbG9hZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxpbWl0Q29uY3VycmVudFVwbG9hZHMgPD0gdGhpcy5fc2VuZGluZykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxpbWl0Q29uY3VycmVudFVwbG9hZHMgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3QgPSAkLkRlZmVycmVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nsb3RzLnB1c2goc2xvdCk7XG4gICAgICAgICAgICAgICAgICAgIHBpcGUgPSBzbG90LnRoZW4oc2VuZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VxdWVuY2UgPSB0aGlzLl9zZXF1ZW5jZS50aGVuKHNlbmQsIHNlbmQpO1xuICAgICAgICAgICAgICAgICAgICBwaXBlID0gdGhpcy5fc2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgcGlwZWQgUHJvbWlzZSBvYmplY3QsIGVuaGFuY2VkIHdpdGggYW4gYWJvcnQgbWV0aG9kLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIGRlbGVnYXRlZCB0byB0aGUganFYSFIgb2JqZWN0IG9mIHRoZSBjdXJyZW50IHVwbG9hZCxcbiAgICAgICAgICAgICAgICAvLyBhbmQganFYSFIgY2FsbGJhY2tzIG1hcHBlZCB0byB0aGUgZXF1aXZhbGVudCBQcm9taXNlIG1ldGhvZHM6XG4gICAgICAgICAgICAgICAgcGlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRlZCA9IFt1bmRlZmluZWQsICdhYm9ydCcsICdhYm9ydCddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWpxWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QucmVqZWN0V2l0aChvcHRpb25zLmNvbnRleHQsIGFib3J0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmhhbmNlUHJvbWlzZShwaXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZW5kKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uQWRkOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIGRhdGEpLFxuICAgICAgICAgICAgICAgIGZpbGVzID0gZGF0YS5maWxlcyxcbiAgICAgICAgICAgICAgICBmaWxlc0xlbmd0aCA9IGZpbGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBsaW1pdCA9IG9wdGlvbnMubGltaXRNdWx0aUZpbGVVcGxvYWRzLFxuICAgICAgICAgICAgICAgIGxpbWl0U2l6ZSA9IG9wdGlvbnMubGltaXRNdWx0aUZpbGVVcGxvYWRTaXplLFxuICAgICAgICAgICAgICAgIG92ZXJoZWFkID0gb3B0aW9ucy5saW1pdE11bHRpRmlsZVVwbG9hZFNpemVPdmVyaGVhZCxcbiAgICAgICAgICAgICAgICBiYXRjaFNpemUgPSAwLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZSA9IHRoaXMuX2dldFBhcmFtTmFtZShvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWVTZXQsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgZmlsZVNldCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgaWYgKCFmaWxlc0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdFNpemUgJiYgZmlsZXNbMF0uc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGltaXRTaXplID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEob3B0aW9ucy5zaW5nbGVGaWxlVXBsb2FkcyB8fCBsaW1pdCB8fCBsaW1pdFNpemUpIHx8XG4gICAgICAgICAgICAgICAgICAgICF0aGlzLl9pc1hIUlVwbG9hZChvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIGZpbGVTZXQgPSBbZmlsZXNdO1xuICAgICAgICAgICAgICAgIHBhcmFtTmFtZVNldCA9IFtwYXJhbU5hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKG9wdGlvbnMuc2luZ2xlRmlsZVVwbG9hZHMgfHwgbGltaXRTaXplKSAmJiBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGZpbGVTZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWVTZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZXNMZW5ndGg7IGkgKz0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZVNldC5wdXNoKGZpbGVzLnNsaWNlKGksIGkgKyBsaW1pdCkpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWVTbGljZSA9IHBhcmFtTmFtZS5zbGljZShpLCBpICsgbGltaXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtTmFtZVNsaWNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lU2xpY2UgPSBwYXJhbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lU2V0LnB1c2gocGFyYW1OYW1lU2xpY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuc2luZ2xlRmlsZVVwbG9hZHMgJiYgbGltaXRTaXplKSB7XG4gICAgICAgICAgICAgICAgZmlsZVNldCA9IFtdO1xuICAgICAgICAgICAgICAgIHBhcmFtTmFtZVNldCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWxlc0xlbmd0aDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZSArPSBmaWxlc1tpXS5zaXplICsgb3ZlcmhlYWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA9PT0gZmlsZXNMZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGJhdGNoU2l6ZSArIGZpbGVzW2kgKyAxXS5zaXplICsgb3ZlcmhlYWQpID4gbGltaXRTaXplKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsaW1pdCAmJiBpICsgMSAtIGogPj0gbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlU2V0LnB1c2goZmlsZXMuc2xpY2UoaiwgaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZVNsaWNlID0gcGFyYW1OYW1lLnNsaWNlKGosIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW1OYW1lU2xpY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lU2xpY2UgPSBwYXJhbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWVTZXQucHVzaChwYXJhbU5hbWVTbGljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWVTZXQgPSBwYXJhbU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsRmlsZXMgPSBmaWxlcztcbiAgICAgICAgICAgICQuZWFjaChmaWxlU2V0IHx8IGZpbGVzLCBmdW5jdGlvbiAoaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9ICQuZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgICAgICAgICAgICBuZXdEYXRhLmZpbGVzID0gZmlsZVNldCA/IGVsZW1lbnQgOiBbZWxlbWVudF07XG4gICAgICAgICAgICAgICAgbmV3RGF0YS5wYXJhbU5hbWUgPSBwYXJhbU5hbWVTZXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoYXQuX2luaXRSZXNwb25zZU9iamVjdChuZXdEYXRhKTtcbiAgICAgICAgICAgICAgICB0aGF0Ll9pbml0UHJvZ3Jlc3NPYmplY3QobmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgdGhhdC5fYWRkQ29udmVuaWVuY2VNZXRob2RzKGUsIG5ld0RhdGEpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoYXQuX3RyaWdnZXIoXG4gICAgICAgICAgICAgICAgICAgICdhZGQnLFxuICAgICAgICAgICAgICAgICAgICAkLkV2ZW50KCdhZGQnLCB7ZGVsZWdhdGVkRXZlbnQ6IGV9KSxcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVwbGFjZUZpbGVJbnB1dDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGRhdGEuZmlsZUlucHV0LFxuICAgICAgICAgICAgICAgIGlucHV0Q2xvbmUgPSBpbnB1dC5jbG9uZSh0cnVlKSxcbiAgICAgICAgICAgICAgICByZXN0b3JlRm9jdXMgPSBpbnB1dC5pcyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIC8vIEFkZCBhIHJlZmVyZW5jZSBmb3IgdGhlIG5ldyBjbG9uZWQgZmlsZSBpbnB1dCB0byB0aGUgZGF0YSBhcmd1bWVudDpcbiAgICAgICAgICAgIGRhdGEuZmlsZUlucHV0Q2xvbmUgPSBpbnB1dENsb25lO1xuICAgICAgICAgICAgJCgnPGZvcm0+PC9mb3JtPicpLmFwcGVuZChpbnB1dENsb25lKVswXS5yZXNldCgpO1xuICAgICAgICAgICAgLy8gRGV0YWNoaW5nIGFsbG93cyB0byBpbnNlcnQgdGhlIGZpbGVJbnB1dCBvbiBhbm90aGVyIGZvcm1cbiAgICAgICAgICAgIC8vIHdpdGhvdXQgbG9vc2luZyB0aGUgZmlsZSBpbnB1dCB2YWx1ZTpcbiAgICAgICAgICAgIGlucHV0LmFmdGVyKGlucHV0Q2xvbmUpLmRldGFjaCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGZpbGVJbnB1dCBoYWQgZm9jdXMgYmVmb3JlIGl0IHdhcyBkZXRhY2hlZCxcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgZm9jdXMgdG8gdGhlIGlucHV0Q2xvbmUuXG4gICAgICAgICAgICBpZiAocmVzdG9yZUZvY3VzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRDbG9uZS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXZvaWQgbWVtb3J5IGxlYWtzIHdpdGggdGhlIGRldGFjaGVkIGZpbGUgaW5wdXQ6XG4gICAgICAgICAgICAkLmNsZWFuRGF0YShpbnB1dC51bmJpbmQoJ3JlbW92ZScpKTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIG9yaWdpbmFsIGZpbGUgaW5wdXQgZWxlbWVudCBpbiB0aGUgZmlsZUlucHV0XG4gICAgICAgICAgICAvLyBlbGVtZW50cyBzZXQgd2l0aCB0aGUgY2xvbmUsIHdoaWNoIGhhcyBiZWVuIGNvcGllZCBpbmNsdWRpbmdcbiAgICAgICAgICAgIC8vIGV2ZW50IGhhbmRsZXJzOlxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpbGVJbnB1dCA9IHRoaXMub3B0aW9ucy5maWxlSW5wdXQubWFwKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gaW5wdXRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0Q2xvbmVbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHdpZGdldCBoYXMgYmVlbiBpbml0aWFsaXplZCBvbiB0aGUgZmlsZSBpbnB1dCBpdHNlbGYsXG4gICAgICAgICAgICAvLyBvdmVycmlkZSB0aGlzLmVsZW1lbnQgd2l0aCB0aGUgZmlsZSBpbnB1dCBjbG9uZTpcbiAgICAgICAgICAgIGlmIChpbnB1dFswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gaW5wdXRDbG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaGFuZGxlRmlsZVRyZWVFbnRyeTogZnVuY3Rpb24gKGVudHJ5LCBwYXRoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZGZkID0gJC5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIGVudHJpZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBkaXJSZWFkZXIsXG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgIWUuZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZW50cnkgPSBlbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSAkLndoZW4gcmV0dXJucyBpbW1lZGlhdGVseSBpZiBvbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmZXJyZWQgaXMgcmVqZWN0ZWQsIHdlIHVzZSByZXNvbHZlIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHZhbGlkIGZpbGVzIGFuZCBpbnZhbGlkIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIHJldHVybmVkIHRvZ2V0aGVyIGluIG9uZSBzZXQ6XG4gICAgICAgICAgICAgICAgICAgIGRmZC5yZXNvbHZlKFtlXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzSGFuZGxlciA9IGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX2hhbmRsZUZpbGVUcmVlRW50cmllcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoICsgZW50cnkubmFtZSArICcvJ1xuICAgICAgICAgICAgICAgICAgICApLmRvbmUoZnVuY3Rpb24gKGZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZmQucmVzb2x2ZShmaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZhaWwoZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXJSZWFkZXIucmVhZEVudHJpZXMoZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzSGFuZGxlcihlbnRyaWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcyA9IGVudHJpZXMuY29uY2F0KHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoIHx8ICcnO1xuICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5fZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBDaHJvbWUgYnVnICMxNDk3MzVcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuX2ZpbGUucmVsYXRpdmVQYXRoID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgZGZkLnJlc29sdmUoZW50cnkuX2ZpbGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmZpbGUoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUucmVsYXRpdmVQYXRoID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmZC5yZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBkaXJSZWFkZXIgPSBlbnRyeS5jcmVhdGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYW4gZW1weSBsaXN0IGZvciBmaWxlIHN5c3RlbSBpdGVtc1xuICAgICAgICAgICAgICAgIC8vIG90aGVyIHRoYW4gZmlsZXMgb3IgZGlyZWN0b3JpZXM6XG4gICAgICAgICAgICAgICAgZGZkLnJlc29sdmUoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRmZC5wcm9taXNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2hhbmRsZUZpbGVUcmVlRW50cmllczogZnVuY3Rpb24gKGVudHJpZXMsIHBhdGgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiAkLndoZW4uYXBwbHkoXG4gICAgICAgICAgICAgICAgJCxcbiAgICAgICAgICAgICAgICAkLm1hcChlbnRyaWVzLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuX2hhbmRsZUZpbGVUcmVlRW50cnkoZW50cnksIHBhdGgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXREcm9wcGVkRmlsZXM6IGZ1bmN0aW9uIChkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgIGRhdGFUcmFuc2ZlciA9IGRhdGFUcmFuc2ZlciB8fCB7fTtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IGRhdGFUcmFuc2Zlci5pdGVtcztcbiAgICAgICAgICAgIGlmIChpdGVtcyAmJiBpdGVtcy5sZW5ndGggJiYgKGl0ZW1zWzBdLndlYmtpdEdldEFzRW50cnkgfHxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbMF0uZ2V0QXNFbnRyeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlRmlsZVRyZWVFbnRyaWVzKFxuICAgICAgICAgICAgICAgICAgICAkLm1hcChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLndlYmtpdEdldEFzRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeSA9IGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBDaHJvbWUgYnVnICMxNDk3MzU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5Ll9maWxlID0gaXRlbS5nZXRBc0ZpbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZ2V0QXNFbnRyeSgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJC5EZWZlcnJlZCgpLnJlc29sdmUoXG4gICAgICAgICAgICAgICAgJC5tYWtlQXJyYXkoZGF0YVRyYW5zZmVyLmZpbGVzKVxuICAgICAgICAgICAgKS5wcm9taXNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFNpbmdsZUZpbGVJbnB1dEZpbGVzOiBmdW5jdGlvbiAoZmlsZUlucHV0KSB7XG4gICAgICAgICAgICBmaWxlSW5wdXQgPSAkKGZpbGVJbnB1dCk7XG4gICAgICAgICAgICB2YXIgZW50cmllcyA9IGZpbGVJbnB1dC5wcm9wKCd3ZWJraXRFbnRyaWVzJykgfHxcbiAgICAgICAgICAgICAgICAgICAgZmlsZUlucHV0LnByb3AoJ2VudHJpZXMnKSxcbiAgICAgICAgICAgICAgICBmaWxlcyxcbiAgICAgICAgICAgICAgICB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUZpbGVUcmVlRW50cmllcyhlbnRyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGVzID0gJC5tYWtlQXJyYXkoZmlsZUlucHV0LnByb3AoJ2ZpbGVzJykpO1xuICAgICAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpbGVJbnB1dC5wcm9wKCd2YWx1ZScpO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuRGVmZXJyZWQoKS5yZXNvbHZlKFtdKS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmaWxlcyBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLCB0aGUgYnJvd3NlciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgdGhlIEZpbGUgQVBJIGFuZCB3ZSBhZGQgYSBwc2V1ZG8gRmlsZSBvYmplY3Qgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHRoZSBpbnB1dCB2YWx1ZSBhcyBuYW1lIHdpdGggcGF0aCBpbmZvcm1hdGlvbiByZW1vdmVkOlxuICAgICAgICAgICAgICAgIGZpbGVzID0gW3tuYW1lOiB2YWx1ZS5yZXBsYWNlKC9eLipcXFxcLywgJycpfV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGVzWzBdLm5hbWUgPT09IHVuZGVmaW5lZCAmJiBmaWxlc1swXS5maWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbGUgbm9ybWFsaXphdGlvbiBmb3IgU2FmYXJpIDQgYW5kIEZpcmVmb3ggMzpcbiAgICAgICAgICAgICAgICAkLmVhY2goZmlsZXMsIGZ1bmN0aW9uIChpbmRleCwgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlLm5hbWUgPSBmaWxlLmZpbGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBmaWxlLnNpemUgPSBmaWxlLmZpbGVTaXplO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICQuRGVmZXJyZWQoKS5yZXNvbHZlKGZpbGVzKS5wcm9taXNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEZpbGVJbnB1dEZpbGVzOiBmdW5jdGlvbiAoZmlsZUlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIShmaWxlSW5wdXQgaW5zdGFuY2VvZiAkKSB8fCBmaWxlSW5wdXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNpbmdsZUZpbGVJbnB1dEZpbGVzKGZpbGVJbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJC53aGVuLmFwcGx5KFxuICAgICAgICAgICAgICAgICQsXG4gICAgICAgICAgICAgICAgJC5tYXAoZmlsZUlucHV0LCB0aGlzLl9nZXRTaW5nbGVGaWxlSW5wdXRGaWxlcylcbiAgICAgICAgICAgICkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVJbnB1dDogJChlLnRhcmdldCksXG4gICAgICAgICAgICAgICAgICAgIGZvcm06ICQoZS50YXJnZXQuZm9ybSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fZ2V0RmlsZUlucHV0RmlsZXMoZGF0YS5maWxlSW5wdXQpLmFsd2F5cyhmdW5jdGlvbiAoZmlsZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmZpbGVzID0gZmlsZXM7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5yZXBsYWNlRmlsZUlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX3JlcGxhY2VGaWxlSW5wdXQoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGF0Ll90cmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NoYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAkLkV2ZW50KCdjaGFuZ2UnLCB7ZGVsZWdhdGVkRXZlbnQ6IGV9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fb25BZGQoZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uUGFzdGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEuaXRlbXMsXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtmaWxlczogW119O1xuICAgICAgICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICQuZWFjaChpdGVtcywgZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gaXRlbS5nZXRBc0ZpbGUgJiYgaXRlbS5nZXRBc0ZpbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmlnZ2VyKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bhc3RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICQuRXZlbnQoJ3Bhc3RlJywge2RlbGVnYXRlZEV2ZW50OiBlfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgICAgICkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQWRkKGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfb25Ecm9wOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIgPSBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcixcbiAgICAgICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgICBpZiAoZGF0YVRyYW5zZmVyICYmIGRhdGFUcmFuc2Zlci5maWxlcyAmJiBkYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldERyb3BwZWRGaWxlcyhkYXRhVHJhbnNmZXIpLmFsd2F5cyhmdW5jdGlvbiAoZmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5maWxlcyA9IGZpbGVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5fdHJpZ2dlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZHJvcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5FdmVudCgnZHJvcCcsIHtkZWxlZ2F0ZWRFdmVudDogZX0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9vbkFkZChlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkRyYWdPdmVyOiBnZXREcmFnSGFuZGxlcignZHJhZ292ZXInKSxcblxuICAgICAgICBfb25EcmFnRW50ZXI6IGdldERyYWdIYW5kbGVyKCdkcmFnZW50ZXInKSxcblxuICAgICAgICBfb25EcmFnTGVhdmU6IGdldERyYWdIYW5kbGVyKCdkcmFnbGVhdmUnKSxcblxuICAgICAgICBfaW5pdEV2ZW50SGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1hIUlVwbG9hZCh0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb24odGhpcy5vcHRpb25zLmRyb3Bab25lLCB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdvdmVyOiB0aGlzLl9vbkRyYWdPdmVyLFxuICAgICAgICAgICAgICAgICAgICBkcm9wOiB0aGlzLl9vbkRyb3AsXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgb24gZHJhZ2VudGVyIGlzIHJlcXVpcmVkIGZvciBJRTEwKzpcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2VudGVyOiB0aGlzLl9vbkRyYWdFbnRlcixcbiAgICAgICAgICAgICAgICAgICAgLy8gZHJhZ2xlYXZlIGlzIG5vdCByZXF1aXJlZCwgYnV0IGFkZGVkIGZvciBjb21wbGV0ZW5lc3M6XG4gICAgICAgICAgICAgICAgICAgIGRyYWdsZWF2ZTogdGhpcy5fb25EcmFnTGVhdmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbih0aGlzLm9wdGlvbnMucGFzdGVab25lLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3RlOiB0aGlzLl9vblBhc3RlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJC5zdXBwb3J0LmZpbGVJbnB1dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uKHRoaXMub3B0aW9ucy5maWxlSW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiB0aGlzLl9vbkNoYW5nZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kZXN0cm95RXZlbnRIYW5kbGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fb2ZmKHRoaXMub3B0aW9ucy5kcm9wWm9uZSwgJ2RyYWdlbnRlciBkcmFnbGVhdmUgZHJhZ292ZXIgZHJvcCcpO1xuICAgICAgICAgICAgdGhpcy5fb2ZmKHRoaXMub3B0aW9ucy5wYXN0ZVpvbmUsICdwYXN0ZScpO1xuICAgICAgICAgICAgdGhpcy5fb2ZmKHRoaXMub3B0aW9ucy5maWxlSW5wdXQsICdjaGFuZ2UnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJlaW5pdCA9ICQuaW5BcnJheShrZXksIHRoaXMuX3NwZWNpYWxPcHRpb25zKSAhPT0gLTE7XG4gICAgICAgICAgICBpZiAocmVpbml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N1cGVyKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlaW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRTcGVjaWFsT3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRTcGVjaWFsT3B0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maWxlSW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsZUlucHV0ID0gdGhpcy5lbGVtZW50LmlzKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCA6IHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKG9wdGlvbnMuZmlsZUlucHV0IGluc3RhbmNlb2YgJCkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpbGVJbnB1dCA9ICQob3B0aW9ucy5maWxlSW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEob3B0aW9ucy5kcm9wWm9uZSBpbnN0YW5jZW9mICQpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kcm9wWm9uZSA9ICQob3B0aW9ucy5kcm9wWm9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShvcHRpb25zLnBhc3RlWm9uZSBpbnN0YW5jZW9mICQpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXN0ZVpvbmUgPSAkKG9wdGlvbnMucGFzdGVab25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0UmVnRXhwOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy8nKSxcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXJ0cy5qb2luKCcvJyksIG1vZGlmaWVycyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2lzUmVnRXhwT3B0aW9uOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleSAhPT0gJ3VybCcgJiYgJC50eXBlKHZhbHVlKSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAvXlxcLy4qXFwvW2lnbV17MCwzfSQvLnRlc3QodmFsdWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0RGF0YUF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmVsZW1lbnQuZGF0YSgpO1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBvcHRpb25zIHNldCB2aWEgSFRNTDUgZGF0YS1hdHRyaWJ1dGVzOlxuICAgICAgICAgICAgJC5lYWNoKFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudFswXS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChpbmRleCwgYXR0cikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eZGF0YS0vLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBoeXBoZW4tYXRlZCBrZXkgdG8gY2FtZWxDYXNlOlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5LnNsaWNlKDUpLnJlcGxhY2UoLy1bYS16XS9nLCBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5faXNSZWdFeHBPcHRpb24oa2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoYXQuX2dldFJlZ0V4cCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5faW5pdERhdGFBdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9pbml0U3BlY2lhbE9wdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nsb3RzID0gW107XG4gICAgICAgICAgICB0aGlzLl9zZXF1ZW5jZSA9IHRoaXMuX2dldFhIUlByb21pc2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kaW5nID0gdGhpcy5fYWN0aXZlID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2luaXRQcm9ncmVzc09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgZXhwb3NlZCB0byB0aGUgd2lkZ2V0IEFQSSBhbmQgYWxsb3dzIHRvIHF1ZXJ5XG4gICAgICAgIC8vIHRoZSBudW1iZXIgb2YgYWN0aXZlIHVwbG9hZHM6XG4gICAgICAgIGFjdGl2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBleHBvc2VkIHRvIHRoZSB3aWRnZXQgQVBJIGFuZCBhbGxvd3MgdG8gcXVlcnlcbiAgICAgICAgLy8gdGhlIHdpZGdldCB1cGxvYWQgcHJvZ3Jlc3MuXG4gICAgICAgIC8vIEl0IHJldHVybnMgYW4gb2JqZWN0IHdpdGggbG9hZGVkLCB0b3RhbCBhbmQgYml0cmF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIGZvciB0aGUgcnVubmluZyB1cGxvYWRzOlxuICAgICAgICBwcm9ncmVzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyZXNzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIGV4cG9zZWQgdG8gdGhlIHdpZGdldCBBUEkgYW5kIGFsbG93cyBhZGRpbmcgZmlsZXNcbiAgICAgICAgLy8gdXNpbmcgdGhlIGZpbGV1cGxvYWQgQVBJLiBUaGUgZGF0YSBwYXJhbWV0ZXIgYWNjZXB0cyBhbiBvYmplY3Qgd2hpY2hcbiAgICAgICAgLy8gbXVzdCBoYXZlIGEgZmlsZXMgcHJvcGVydHkgYW5kIGNhbiBjb250YWluIGFkZGl0aW9uYWwgb3B0aW9uczpcbiAgICAgICAgLy8gLmZpbGV1cGxvYWQoJ2FkZCcsIHtmaWxlczogZmlsZXNMaXN0fSk7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIGlmICghZGF0YSB8fCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5maWxlSW5wdXQgJiYgIWRhdGEuZmlsZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRGaWxlSW5wdXRGaWxlcyhkYXRhLmZpbGVJbnB1dCkuYWx3YXlzKGZ1bmN0aW9uIChmaWxlcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZpbGVzID0gZmlsZXM7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX29uQWRkKG51bGwsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhLmZpbGVzID0gJC5tYWtlQXJyYXkoZGF0YS5maWxlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25BZGQobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgZXhwb3NlZCB0byB0aGUgd2lkZ2V0IEFQSSBhbmQgYWxsb3dzIHNlbmRpbmcgZmlsZXNcbiAgICAgICAgLy8gdXNpbmcgdGhlIGZpbGV1cGxvYWQgQVBJLiBUaGUgZGF0YSBwYXJhbWV0ZXIgYWNjZXB0cyBhbiBvYmplY3Qgd2hpY2hcbiAgICAgICAgLy8gbXVzdCBoYXZlIGEgZmlsZXMgb3IgZmlsZUlucHV0IHByb3BlcnR5IGFuZCBjYW4gY29udGFpbiBhZGRpdGlvbmFsIG9wdGlvbnM6XG4gICAgICAgIC8vIC5maWxldXBsb2FkKCdzZW5kJywge2ZpbGVzOiBmaWxlc0xpc3R9KTtcbiAgICAgICAgLy8gVGhlIG1ldGhvZCByZXR1cm5zIGEgUHJvbWlzZSBvYmplY3QgZm9yIHRoZSBmaWxlIHVwbG9hZCBjYWxsLlxuICAgICAgICBzZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEgJiYgIXRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZpbGVJbnB1dCAmJiAhZGF0YS5maWxlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZmQgPSAkLkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gZGZkLnByb21pc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRlZDtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpxWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZmQucmVqZWN0KG51bGwsICdhYm9ydCcsICdhYm9ydCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldEZpbGVJbnB1dEZpbGVzKGRhdGEuZmlsZUlucHV0KS5hbHdheXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmZC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmZpbGVzID0gZmlsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganFYSFIgPSB0aGF0Ll9vblNlbmQobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganFYSFIudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3VsdCwgdGV4dFN0YXR1cywganFYSFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmZC5yZXNvbHZlKHJlc3VsdCwgdGV4dFN0YXR1cywganFYSFIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZmQucmVqZWN0KGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZW5oYW5jZVByb21pc2UocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEuZmlsZXMgPSAkLm1ha2VBcnJheShkYXRhLmZpbGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uU2VuZChudWxsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0WEhSUHJvbWlzZShmYWxzZSwgZGF0YSAmJiBkYXRhLmNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxufSkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBib290c3RyYXAtZGF0ZXBpY2tlci5qc1xuICogUmVwbzogaHR0cHM6Ly9naXRodWIuY29tL3V4c29sdXRpb25zL2Jvb3RzdHJhcC1kYXRlcGlja2VyL1xuICogRGVtbzogaHR0cHM6Ly9ldGVybmljb2RlLmdpdGh1Yi5pby9ib290c3RyYXAtZGF0ZXBpY2tlci9cbiAqIERvY3M6IGh0dHBzOi8vYm9vdHN0cmFwLWRhdGVwaWNrZXIucmVhZHRoZWRvY3Mub3JnL1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4oZnVuY3Rpb24oZmFjdG9yeSl7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeShqUXVlcnkpO1xuICAgIH1cbn0oZnVuY3Rpb24oJCwgdW5kZWZpbmVkKXtcblx0ZnVuY3Rpb24gVVRDRGF0ZSgpe1xuXHRcdHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShEYXRlLCBhcmd1bWVudHMpKTtcblx0fVxuXHRmdW5jdGlvbiBVVENUb2RheSgpe1xuXHRcdHZhciB0b2RheSA9IG5ldyBEYXRlKCk7XG5cdFx0cmV0dXJuIFVUQ0RhdGUodG9kYXkuZ2V0RnVsbFllYXIoKSwgdG9kYXkuZ2V0TW9udGgoKSwgdG9kYXkuZ2V0RGF0ZSgpKTtcblx0fVxuXHRmdW5jdGlvbiBpc1VUQ0VxdWFscyhkYXRlMSwgZGF0ZTIpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0ZGF0ZTEuZ2V0VVRDRnVsbFllYXIoKSA9PT0gZGF0ZTIuZ2V0VVRDRnVsbFllYXIoKSAmJlxuXHRcdFx0ZGF0ZTEuZ2V0VVRDTW9udGgoKSA9PT0gZGF0ZTIuZ2V0VVRDTW9udGgoKSAmJlxuXHRcdFx0ZGF0ZTEuZ2V0VVRDRGF0ZSgpID09PSBkYXRlMi5nZXRVVENEYXRlKClcblx0XHQpO1xuXHR9XG5cdGZ1bmN0aW9uIGFsaWFzKG1ldGhvZCwgZGVwcmVjYXRpb25Nc2cpe1xuXHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKGRlcHJlY2F0aW9uTXNnICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0JC5mbi5kYXRlcGlja2VyLmRlcHJlY2F0ZWQoZGVwcmVjYXRpb25Nc2cpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpc1ttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fVxuXHRmdW5jdGlvbiBpc1ZhbGlkRGF0ZShkKSB7XG5cdFx0cmV0dXJuIGQgJiYgIWlzTmFOKGQuZ2V0VGltZSgpKTtcblx0fVxuXG5cdHZhciBEYXRlQXJyYXkgPSAoZnVuY3Rpb24oKXtcblx0XHR2YXIgZXh0cmFzID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbihpKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2xpY2UoaSlbMF07XG5cdFx0XHR9LFxuXHRcdFx0Y29udGFpbnM6IGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHQvLyBBcnJheS5pbmRleE9mIGlzIG5vdCBjcm9zcy1icm93c2VyO1xuXHRcdFx0XHQvLyAkLmluQXJyYXkgZG9lc24ndCB3b3JrIHdpdGggRGF0ZXNcblx0XHRcdFx0dmFyIHZhbCA9IGQgJiYgZC52YWx1ZU9mKCk7XG5cdFx0XHRcdGZvciAodmFyIGk9MCwgbD10aGlzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAvLyBVc2UgZGF0ZSBhcml0aG1ldGljIHRvIGFsbG93IGRhdGVzIHdpdGggZGlmZmVyZW50IHRpbWVzIHRvIG1hdGNoXG4gICAgICAgICAgaWYgKDAgPD0gdGhpc1tpXS52YWx1ZU9mKCkgLSB2YWwgJiYgdGhpc1tpXS52YWx1ZU9mKCkgLSB2YWwgPCAxMDAwKjYwKjYwKjI0KVxuXHRcdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH0sXG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKGkpe1xuXHRcdFx0XHR0aGlzLnNwbGljZShpLDEpO1xuXHRcdFx0fSxcblx0XHRcdHJlcGxhY2U6IGZ1bmN0aW9uKG5ld19hcnJheSl7XG5cdFx0XHRcdGlmICghbmV3X2FycmF5KVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0aWYgKCEkLmlzQXJyYXkobmV3X2FycmF5KSlcblx0XHRcdFx0XHRuZXdfYXJyYXkgPSBbbmV3X2FycmF5XTtcblx0XHRcdFx0dGhpcy5jbGVhcigpO1xuXHRcdFx0XHR0aGlzLnB1c2guYXBwbHkodGhpcywgbmV3X2FycmF5KTtcblx0XHRcdH0sXG5cdFx0XHRjbGVhcjogZnVuY3Rpb24oKXtcblx0XHRcdFx0dGhpcy5sZW5ndGggPSAwO1xuXHRcdFx0fSxcblx0XHRcdGNvcHk6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciBhID0gbmV3IERhdGVBcnJheSgpO1xuXHRcdFx0XHRhLnJlcGxhY2UodGhpcyk7XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBhID0gW107XG5cdFx0XHRhLnB1c2guYXBwbHkoYSwgYXJndW1lbnRzKTtcblx0XHRcdCQuZXh0ZW5kKGEsIGV4dHJhcyk7XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXHR9KSgpO1xuXG5cblx0Ly8gUGlja2VyIG9iamVjdFxuXG5cdHZhciBEYXRlcGlja2VyID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucyl7XG5cdFx0JC5kYXRhKGVsZW1lbnQsICdkYXRlcGlja2VyJywgdGhpcyk7XG5cdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5kYXRlcyA9IG5ldyBEYXRlQXJyYXkoKTtcblx0XHR0aGlzLnZpZXdEYXRlID0gdGhpcy5vLmRlZmF1bHRWaWV3RGF0ZTtcblx0XHR0aGlzLmZvY3VzRGF0ZSA9IG51bGw7XG5cblx0XHR0aGlzLmVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuXHRcdHRoaXMuaXNJbnB1dCA9IHRoaXMuZWxlbWVudC5pcygnaW5wdXQnKTtcblx0XHR0aGlzLmlucHV0RmllbGQgPSB0aGlzLmlzSW5wdXQgPyB0aGlzLmVsZW1lbnQgOiB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKTtcblx0XHR0aGlzLmNvbXBvbmVudCA9IHRoaXMuZWxlbWVudC5oYXNDbGFzcygnZGF0ZScpID8gdGhpcy5lbGVtZW50LmZpbmQoJy5hZGQtb24sIC5pbnB1dC1ncm91cC1hZGRvbiwgLmJ0bicpIDogZmFsc2U7XG5cdFx0aWYgKHRoaXMuY29tcG9uZW50ICYmIHRoaXMuY29tcG9uZW50Lmxlbmd0aCA9PT0gMClcblx0XHRcdHRoaXMuY29tcG9uZW50ID0gZmFsc2U7XG5cdFx0dGhpcy5pc0lubGluZSA9ICF0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmVsZW1lbnQuaXMoJ2RpdicpO1xuXG5cdFx0dGhpcy5waWNrZXIgPSAkKERQR2xvYmFsLnRlbXBsYXRlKTtcblxuXHRcdC8vIENoZWNraW5nIHRlbXBsYXRlcyBhbmQgaW5zZXJ0aW5nXG5cdFx0aWYgKHRoaXMuX2NoZWNrX3RlbXBsYXRlKHRoaXMuby50ZW1wbGF0ZXMubGVmdEFycm93KSkge1xuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLnByZXYnKS5odG1sKHRoaXMuby50ZW1wbGF0ZXMubGVmdEFycm93KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fY2hlY2tfdGVtcGxhdGUodGhpcy5vLnRlbXBsYXRlcy5yaWdodEFycm93KSkge1xuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLm5leHQnKS5odG1sKHRoaXMuby50ZW1wbGF0ZXMucmlnaHRBcnJvdyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYnVpbGRFdmVudHMoKTtcblx0XHR0aGlzLl9hdHRhY2hFdmVudHMoKTtcblxuXHRcdGlmICh0aGlzLmlzSW5saW5lKXtcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLWlubGluZScpLmFwcGVuZFRvKHRoaXMuZWxlbWVudCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItZHJvcGRvd24gZHJvcGRvd24tbWVudScpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm8ucnRsKXtcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLXJ0bCcpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm8uY2FsZW5kYXJXZWVrcykge1xuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItZGF5cyAuZGF0ZXBpY2tlci1zd2l0Y2gsIHRoZWFkIC5kYXRlcGlja2VyLXRpdGxlLCB0Zm9vdCAudG9kYXksIHRmb290IC5jbGVhcicpXG5cdFx0XHRcdC5hdHRyKCdjb2xzcGFuJywgZnVuY3Rpb24oaSwgdmFsKXtcblx0XHRcdFx0XHRyZXR1cm4gTnVtYmVyKHZhbCkgKyAxO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe1xuXHRcdFx0c3RhcnREYXRlOiB0aGlzLl9vLnN0YXJ0RGF0ZSxcblx0XHRcdGVuZERhdGU6IHRoaXMuX28uZW5kRGF0ZSxcblx0XHRcdGRheXNPZldlZWtEaXNhYmxlZDogdGhpcy5vLmRheXNPZldlZWtEaXNhYmxlZCxcblx0XHRcdGRheXNPZldlZWtIaWdobGlnaHRlZDogdGhpcy5vLmRheXNPZldlZWtIaWdobGlnaHRlZCxcblx0XHRcdGRhdGVzRGlzYWJsZWQ6IHRoaXMuby5kYXRlc0Rpc2FibGVkXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9hbGxvd191cGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLnNldFZpZXdNb2RlKHRoaXMuby5zdGFydFZpZXcpO1xuXHRcdHRoaXMuX2FsbG93X3VwZGF0ZSA9IHRydWU7XG5cblx0XHR0aGlzLmZpbGxEb3coKTtcblx0XHR0aGlzLmZpbGxNb250aHMoKTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRpZiAodGhpcy5pc0lubGluZSl7XG5cdFx0XHR0aGlzLnNob3coKTtcblx0XHR9XG5cdH07XG5cblx0RGF0ZXBpY2tlci5wcm90b3R5cGUgPSB7XG5cdFx0Y29uc3RydWN0b3I6IERhdGVwaWNrZXIsXG5cblx0XHRfcmVzb2x2ZVZpZXdOYW1lOiBmdW5jdGlvbih2aWV3KXtcblx0XHRcdCQuZWFjaChEUEdsb2JhbC52aWV3TW9kZXMsIGZ1bmN0aW9uKGksIHZpZXdNb2RlKXtcblx0XHRcdFx0aWYgKHZpZXcgPT09IGkgfHwgJC5pbkFycmF5KHZpZXcsIHZpZXdNb2RlLm5hbWVzKSAhPT0gLTEpe1xuXHRcdFx0XHRcdHZpZXcgPSBpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiB2aWV3O1xuXHRcdH0sXG5cblx0XHRfcmVzb2x2ZURheXNPZldlZWs6IGZ1bmN0aW9uKGRheXNPZldlZWspe1xuXHRcdFx0aWYgKCEkLmlzQXJyYXkoZGF5c09mV2VlaykpXG5cdFx0XHRcdGRheXNPZldlZWsgPSBkYXlzT2ZXZWVrLnNwbGl0KC9bLFxcc10qLyk7XG5cdFx0XHRyZXR1cm4gJC5tYXAoZGF5c09mV2VlaywgTnVtYmVyKTtcblx0XHR9LFxuXG5cdFx0X2NoZWNrX3RlbXBsYXRlOiBmdW5jdGlvbih0bXApe1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSWYgZW1wdHlcblx0XHRcdFx0aWYgKHRtcCA9PT0gdW5kZWZpbmVkIHx8IHRtcCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiBubyBodG1sLCBldmVyeXRoaW5nIG9rXG5cdFx0XHRcdGlmICgodG1wLm1hdGNoKC9bPD5dL2cpIHx8IFtdKS5sZW5ndGggPD0gMCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENoZWNraW5nIGlmIGh0bWwgaXMgZmluZVxuXHRcdFx0XHR2YXIgakRvbSA9ICQodG1wKTtcblx0XHRcdFx0cmV0dXJuIGpEb20ubGVuZ3RoID4gMDtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChleCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9wcm9jZXNzX29wdGlvbnM6IGZ1bmN0aW9uKG9wdHMpe1xuXHRcdFx0Ly8gU3RvcmUgcmF3IG9wdGlvbnMgZm9yIHJlZmVyZW5jZVxuXHRcdFx0dGhpcy5fbyA9ICQuZXh0ZW5kKHt9LCB0aGlzLl9vLCBvcHRzKTtcblx0XHRcdC8vIFByb2Nlc3NlZCBvcHRpb25zXG5cdFx0XHR2YXIgbyA9IHRoaXMubyA9ICQuZXh0ZW5kKHt9LCB0aGlzLl9vKTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgXCJkZS1ERVwiIHN0eWxlIGRhdGUgaXMgYXZhaWxhYmxlLCBpZiBub3QgbGFuZ3VhZ2Ugc2hvdWxkXG5cdFx0XHQvLyBmYWxsYmFjayB0byAyIGxldHRlciBjb2RlIGVnIFwiZGVcIlxuXHRcdFx0dmFyIGxhbmcgPSBvLmxhbmd1YWdlO1xuXHRcdFx0aWYgKCFkYXRlc1tsYW5nXSl7XG5cdFx0XHRcdGxhbmcgPSBsYW5nLnNwbGl0KCctJylbMF07XG5cdFx0XHRcdGlmICghZGF0ZXNbbGFuZ10pXG5cdFx0XHRcdFx0bGFuZyA9IGRlZmF1bHRzLmxhbmd1YWdlO1xuXHRcdFx0fVxuXHRcdFx0by5sYW5ndWFnZSA9IGxhbmc7XG5cblx0XHRcdC8vIFJldHJpZXZlIHZpZXcgaW5kZXggZnJvbSBhbnkgYWxpYXNlc1xuXHRcdFx0by5zdGFydFZpZXcgPSB0aGlzLl9yZXNvbHZlVmlld05hbWUoby5zdGFydFZpZXcpO1xuXHRcdFx0by5taW5WaWV3TW9kZSA9IHRoaXMuX3Jlc29sdmVWaWV3TmFtZShvLm1pblZpZXdNb2RlKTtcblx0XHRcdG8ubWF4Vmlld01vZGUgPSB0aGlzLl9yZXNvbHZlVmlld05hbWUoby5tYXhWaWV3TW9kZSk7XG5cblx0XHRcdC8vIENoZWNrIHZpZXcgaXMgYmV0d2VlbiBtaW4gYW5kIG1heFxuXHRcdFx0by5zdGFydFZpZXcgPSBNYXRoLm1heCh0aGlzLm8ubWluVmlld01vZGUsIE1hdGgubWluKHRoaXMuby5tYXhWaWV3TW9kZSwgby5zdGFydFZpZXcpKTtcblxuXHRcdFx0Ly8gdHJ1ZSwgZmFsc2UsIG9yIE51bWJlciA+IDBcblx0XHRcdGlmIChvLm11bHRpZGF0ZSAhPT0gdHJ1ZSl7XG5cdFx0XHRcdG8ubXVsdGlkYXRlID0gTnVtYmVyKG8ubXVsdGlkYXRlKSB8fCBmYWxzZTtcblx0XHRcdFx0aWYgKG8ubXVsdGlkYXRlICE9PSBmYWxzZSlcblx0XHRcdFx0XHRvLm11bHRpZGF0ZSA9IE1hdGgubWF4KDAsIG8ubXVsdGlkYXRlKTtcblx0XHRcdH1cblx0XHRcdG8ubXVsdGlkYXRlU2VwYXJhdG9yID0gU3RyaW5nKG8ubXVsdGlkYXRlU2VwYXJhdG9yKTtcblxuXHRcdFx0by53ZWVrU3RhcnQgJT0gNztcblx0XHRcdG8ud2Vla0VuZCA9IChvLndlZWtTdGFydCArIDYpICUgNztcblxuXHRcdFx0dmFyIGZvcm1hdCA9IERQR2xvYmFsLnBhcnNlRm9ybWF0KG8uZm9ybWF0KTtcblx0XHRcdGlmIChvLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5KXtcblx0XHRcdFx0aWYgKCEhby5zdGFydERhdGUpe1xuXHRcdFx0XHRcdGlmIChvLnN0YXJ0RGF0ZSBpbnN0YW5jZW9mIERhdGUpXG5cdFx0XHRcdFx0XHRvLnN0YXJ0RGF0ZSA9IHRoaXMuX2xvY2FsX3RvX3V0Yyh0aGlzLl96ZXJvX3RpbWUoby5zdGFydERhdGUpKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRvLnN0YXJ0RGF0ZSA9IERQR2xvYmFsLnBhcnNlRGF0ZShvLnN0YXJ0RGF0ZSwgZm9ybWF0LCBvLmxhbmd1YWdlLCBvLmFzc3VtZU5lYXJieVllYXIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG8uc3RhcnREYXRlID0gLUluZmluaXR5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoby5lbmREYXRlICE9PSBJbmZpbml0eSl7XG5cdFx0XHRcdGlmICghIW8uZW5kRGF0ZSl7XG5cdFx0XHRcdFx0aWYgKG8uZW5kRGF0ZSBpbnN0YW5jZW9mIERhdGUpXG5cdFx0XHRcdFx0XHRvLmVuZERhdGUgPSB0aGlzLl9sb2NhbF90b191dGModGhpcy5femVyb190aW1lKG8uZW5kRGF0ZSkpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdG8uZW5kRGF0ZSA9IERQR2xvYmFsLnBhcnNlRGF0ZShvLmVuZERhdGUsIGZvcm1hdCwgby5sYW5ndWFnZSwgby5hc3N1bWVOZWFyYnlZZWFyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRvLmVuZERhdGUgPSBJbmZpbml0eTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRvLmRheXNPZldlZWtEaXNhYmxlZCA9IHRoaXMuX3Jlc29sdmVEYXlzT2ZXZWVrKG8uZGF5c09mV2Vla0Rpc2FibGVkfHxbXSk7XG5cdFx0XHRvLmRheXNPZldlZWtIaWdobGlnaHRlZCA9IHRoaXMuX3Jlc29sdmVEYXlzT2ZXZWVrKG8uZGF5c09mV2Vla0hpZ2hsaWdodGVkfHxbXSk7XG5cblx0XHRcdG8uZGF0ZXNEaXNhYmxlZCA9IG8uZGF0ZXNEaXNhYmxlZHx8W107XG5cdFx0XHRpZiAoISQuaXNBcnJheShvLmRhdGVzRGlzYWJsZWQpKSB7XG5cdFx0XHRcdG8uZGF0ZXNEaXNhYmxlZCA9IG8uZGF0ZXNEaXNhYmxlZC5zcGxpdCgnLCcpO1xuXHRcdFx0fVxuXHRcdFx0by5kYXRlc0Rpc2FibGVkID0gJC5tYXAoby5kYXRlc0Rpc2FibGVkLCBmdW5jdGlvbihkKXtcblx0XHRcdFx0cmV0dXJuIERQR2xvYmFsLnBhcnNlRGF0ZShkLCBmb3JtYXQsIG8ubGFuZ3VhZ2UsIG8uYXNzdW1lTmVhcmJ5WWVhcik7XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIHBsYyA9IFN0cmluZyhvLm9yaWVudGF0aW9uKS50b0xvd2VyQ2FzZSgpLnNwbGl0KC9cXHMrL2cpLFxuXHRcdFx0XHRfcGxjID0gby5vcmllbnRhdGlvbi50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cGxjID0gJC5ncmVwKHBsYywgZnVuY3Rpb24od29yZCl7XG5cdFx0XHRcdHJldHVybiAvXmF1dG98bGVmdHxyaWdodHx0b3B8Ym90dG9tJC8udGVzdCh3b3JkKTtcblx0XHRcdH0pO1xuXHRcdFx0by5vcmllbnRhdGlvbiA9IHt4OiAnYXV0bycsIHk6ICdhdXRvJ307XG5cdFx0XHRpZiAoIV9wbGMgfHwgX3BsYyA9PT0gJ2F1dG8nKVxuXHRcdFx0XHQ7IC8vIG5vIGFjdGlvblxuXHRcdFx0ZWxzZSBpZiAocGxjLmxlbmd0aCA9PT0gMSl7XG5cdFx0XHRcdHN3aXRjaCAocGxjWzBdKXtcblx0XHRcdFx0XHRjYXNlICd0b3AnOlxuXHRcdFx0XHRcdGNhc2UgJ2JvdHRvbSc6XG5cdFx0XHRcdFx0XHRvLm9yaWVudGF0aW9uLnkgPSBwbGNbMF07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdsZWZ0Jzpcblx0XHRcdFx0XHRjYXNlICdyaWdodCc6XG5cdFx0XHRcdFx0XHRvLm9yaWVudGF0aW9uLnggPSBwbGNbMF07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdF9wbGMgPSAkLmdyZXAocGxjLCBmdW5jdGlvbih3b3JkKXtcblx0XHRcdFx0XHRyZXR1cm4gL15sZWZ0fHJpZ2h0JC8udGVzdCh3b3JkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdG8ub3JpZW50YXRpb24ueCA9IF9wbGNbMF0gfHwgJ2F1dG8nO1xuXG5cdFx0XHRcdF9wbGMgPSAkLmdyZXAocGxjLCBmdW5jdGlvbih3b3JkKXtcblx0XHRcdFx0XHRyZXR1cm4gL150b3B8Ym90dG9tJC8udGVzdCh3b3JkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdG8ub3JpZW50YXRpb24ueSA9IF9wbGNbMF0gfHwgJ2F1dG8nO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG8uZGVmYXVsdFZpZXdEYXRlIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2Ygby5kZWZhdWx0Vmlld0RhdGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdG8uZGVmYXVsdFZpZXdEYXRlID0gRFBHbG9iYWwucGFyc2VEYXRlKG8uZGVmYXVsdFZpZXdEYXRlLCBmb3JtYXQsIG8ubGFuZ3VhZ2UsIG8uYXNzdW1lTmVhcmJ5WWVhcik7XG5cdFx0XHR9IGVsc2UgaWYgKG8uZGVmYXVsdFZpZXdEYXRlKSB7XG5cdFx0XHRcdHZhciB5ZWFyID0gby5kZWZhdWx0Vmlld0RhdGUueWVhciB8fCBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdHZhciBtb250aCA9IG8uZGVmYXVsdFZpZXdEYXRlLm1vbnRoIHx8IDA7XG5cdFx0XHRcdHZhciBkYXkgPSBvLmRlZmF1bHRWaWV3RGF0ZS5kYXkgfHwgMTtcblx0XHRcdFx0by5kZWZhdWx0Vmlld0RhdGUgPSBVVENEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0by5kZWZhdWx0Vmlld0RhdGUgPSBVVENUb2RheSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X2V2ZW50czogW10sXG5cdFx0X3NlY29uZGFyeUV2ZW50czogW10sXG5cdFx0X2FwcGx5RXZlbnRzOiBmdW5jdGlvbihldnMpe1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBlbCwgY2gsIGV2OyBpIDwgZXZzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0ZWwgPSBldnNbaV1bMF07XG5cdFx0XHRcdGlmIChldnNbaV0ubGVuZ3RoID09PSAyKXtcblx0XHRcdFx0XHRjaCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRldiA9IGV2c1tpXVsxXTtcblx0XHRcdFx0fSBlbHNlIGlmIChldnNbaV0ubGVuZ3RoID09PSAzKXtcblx0XHRcdFx0XHRjaCA9IGV2c1tpXVsxXTtcblx0XHRcdFx0XHRldiA9IGV2c1tpXVsyXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbC5vbihldiwgY2gpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X3VuYXBwbHlFdmVudHM6IGZ1bmN0aW9uKGV2cyl7XG5cdFx0XHRmb3IgKHZhciBpPTAsIGVsLCBldiwgY2g7IGkgPCBldnMubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRlbCA9IGV2c1tpXVswXTtcblx0XHRcdFx0aWYgKGV2c1tpXS5sZW5ndGggPT09IDIpe1xuXHRcdFx0XHRcdGNoID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGV2ID0gZXZzW2ldWzFdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGV2c1tpXS5sZW5ndGggPT09IDMpe1xuXHRcdFx0XHRcdGNoID0gZXZzW2ldWzFdO1xuXHRcdFx0XHRcdGV2ID0gZXZzW2ldWzJdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsLm9mZihldiwgY2gpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X2J1aWxkRXZlbnRzOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHtcbiAgICAgICAgICAgICAgICBrZXl1cDogJC5wcm94eShmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheShlLmtleUNvZGUsIFsyNywgMzcsIDM5LCAzOCwgNDAsIDMyLCAxMywgOV0pID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICAgICAga2V5ZG93bjogJC5wcm94eSh0aGlzLmtleWRvd24sIHRoaXMpLFxuICAgICAgICAgICAgICAgIHBhc3RlOiAkLnByb3h5KHRoaXMucGFzdGUsIHRoaXMpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vLnNob3dPbkZvY3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLmZvY3VzID0gJC5wcm94eSh0aGlzLnNob3csIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0lucHV0KSB7IC8vIHNpbmdsZSBpbnB1dFxuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMuZWxlbWVudCwgZXZlbnRzXVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb21wb25lbnQ6IGlucHV0ICsgYnV0dG9uXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmlucHV0RmllbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gW1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgY29tcG9uZW50cyB0aGF0IGFyZSBub3QgcmVhZG9ubHksIGFsbG93IGtleWJvYXJkIG5hdlxuICAgICAgICAgICAgICAgICAgICBbdGhpcy5pbnB1dEZpZWxkLCBldmVudHNdLFxuICAgICAgICAgICAgICAgICAgICBbdGhpcy5jb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAkLnByb3h5KHRoaXMuc2hvdywgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2V2ZW50cyA9IFtcblx0XHRcdFx0XHRbdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdFx0XHRjbGljazogJC5wcm94eSh0aGlzLnNob3csIHRoaXMpLFxuXHRcdFx0XHRcdFx0a2V5ZG93bjogJC5wcm94eSh0aGlzLmtleWRvd24sIHRoaXMpXG5cdFx0XHRcdFx0fV1cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2V2ZW50cy5wdXNoKFxuXHRcdFx0XHQvLyBDb21wb25lbnQ6IGxpc3RlbiBmb3IgYmx1ciBvbiBlbGVtZW50IGRlc2NlbmRhbnRzXG5cdFx0XHRcdFt0aGlzLmVsZW1lbnQsICcqJywge1xuXHRcdFx0XHRcdGJsdXI6ICQucHJveHkoZnVuY3Rpb24oZSl7XG5cdFx0XHRcdFx0XHR0aGlzLl9mb2N1c2VkX2Zyb20gPSBlLnRhcmdldDtcblx0XHRcdFx0XHR9LCB0aGlzKVxuXHRcdFx0XHR9XSxcblx0XHRcdFx0Ly8gSW5wdXQ6IGxpc3RlbiBmb3IgYmx1ciBvbiBlbGVtZW50XG5cdFx0XHRcdFt0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0XHRibHVyOiAkLnByb3h5KGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHRcdFx0dGhpcy5fZm9jdXNlZF9mcm9tID0gZS50YXJnZXQ7XG5cdFx0XHRcdFx0fSwgdGhpcylcblx0XHRcdFx0fV1cblx0XHRcdCk7XG5cblx0XHRcdGlmICh0aGlzLm8uaW1tZWRpYXRlVXBkYXRlcykge1xuXHRcdFx0XHQvLyBUcmlnZ2VyIGlucHV0IHVwZGF0ZXMgaW1tZWRpYXRlbHkgb24gY2hhbmdlZCB5ZWFyL21vbnRoXG5cdFx0XHRcdHRoaXMuX2V2ZW50cy5wdXNoKFt0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0XHQnY2hhbmdlWWVhciBjaGFuZ2VNb250aCc6ICQucHJveHkoZnVuY3Rpb24oZSl7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZShlLmRhdGUpO1xuXHRcdFx0XHRcdH0sIHRoaXMpXG5cdFx0XHRcdH1dKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2Vjb25kYXJ5RXZlbnRzID0gW1xuXHRcdFx0XHRbdGhpcy5waWNrZXIsIHtcblx0XHRcdFx0XHRjbGljazogJC5wcm94eSh0aGlzLmNsaWNrLCB0aGlzKVxuXHRcdFx0XHR9XSxcblx0XHRcdFx0W3RoaXMucGlja2VyLCAnLnByZXYsIC5uZXh0Jywge1xuXHRcdFx0XHRcdGNsaWNrOiAkLnByb3h5KHRoaXMubmF2QXJyb3dzQ2xpY2ssIHRoaXMpXG5cdFx0XHRcdH1dLFxuXHRcdFx0XHRbdGhpcy5waWNrZXIsICcuZGF5Om5vdCguZGlzYWJsZWQpJywge1xuXHRcdFx0XHRcdGNsaWNrOiAkLnByb3h5KHRoaXMuZGF5Q2VsbENsaWNrLCB0aGlzKVxuXHRcdFx0XHR9XSxcblx0XHRcdFx0WyQod2luZG93KSwge1xuXHRcdFx0XHRcdHJlc2l6ZTogJC5wcm94eSh0aGlzLnBsYWNlLCB0aGlzKVxuXHRcdFx0XHR9XSxcblx0XHRcdFx0WyQoZG9jdW1lbnQpLCB7XG5cdFx0XHRcdFx0J21vdXNlZG93biB0b3VjaHN0YXJ0JzogJC5wcm94eShmdW5jdGlvbihlKXtcblx0XHRcdFx0XHRcdC8vIENsaWNrZWQgb3V0c2lkZSB0aGUgZGF0ZXBpY2tlciwgaGlkZSBpdFxuXHRcdFx0XHRcdFx0aWYgKCEoXG5cdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5pcyhlLnRhcmdldCkgfHxcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoZS50YXJnZXQpLmxlbmd0aCB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5pcyhlLnRhcmdldCkgfHxcblx0XHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZChlLnRhcmdldCkubGVuZ3RoIHx8XG5cdFx0XHRcdFx0XHRcdHRoaXMuaXNJbmxpbmVcblx0XHRcdFx0XHRcdCkpe1xuXHRcdFx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKVxuXHRcdFx0XHR9XVxuXHRcdFx0XTtcblx0XHR9LFxuXHRcdF9hdHRhY2hFdmVudHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLl9kZXRhY2hFdmVudHMoKTtcblx0XHRcdHRoaXMuX2FwcGx5RXZlbnRzKHRoaXMuX2V2ZW50cyk7XG5cdFx0fSxcblx0XHRfZGV0YWNoRXZlbnRzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5fdW5hcHBseUV2ZW50cyh0aGlzLl9ldmVudHMpO1xuXHRcdH0sXG5cdFx0X2F0dGFjaFNlY29uZGFyeUV2ZW50czogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuX2RldGFjaFNlY29uZGFyeUV2ZW50cygpO1xuXHRcdFx0dGhpcy5fYXBwbHlFdmVudHModGhpcy5fc2Vjb25kYXJ5RXZlbnRzKTtcblx0XHR9LFxuXHRcdF9kZXRhY2hTZWNvbmRhcnlFdmVudHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLl91bmFwcGx5RXZlbnRzKHRoaXMuX3NlY29uZGFyeUV2ZW50cyk7XG5cdFx0fSxcblx0XHRfdHJpZ2dlcjogZnVuY3Rpb24oZXZlbnQsIGFsdGRhdGUpe1xuXHRcdFx0dmFyIGRhdGUgPSBhbHRkYXRlIHx8IHRoaXMuZGF0ZXMuZ2V0KC0xKSxcblx0XHRcdFx0bG9jYWxfZGF0ZSA9IHRoaXMuX3V0Y190b19sb2NhbChkYXRlKTtcblxuXHRcdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoe1xuXHRcdFx0XHR0eXBlOiBldmVudCxcblx0XHRcdFx0ZGF0ZTogbG9jYWxfZGF0ZSxcblx0XHRcdFx0dmlld01vZGU6IHRoaXMudmlld01vZGUsXG5cdFx0XHRcdGRhdGVzOiAkLm1hcCh0aGlzLmRhdGVzLCB0aGlzLl91dGNfdG9fbG9jYWwpLFxuXHRcdFx0XHRmb3JtYXQ6ICQucHJveHkoZnVuY3Rpb24oaXgsIGZvcm1hdCl7XG5cdFx0XHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApe1xuXHRcdFx0XHRcdFx0aXggPSB0aGlzLmRhdGVzLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRmb3JtYXQgPSB0aGlzLm8uZm9ybWF0O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGl4ID09PSAnc3RyaW5nJyl7XG5cdFx0XHRcdFx0XHRmb3JtYXQgPSBpeDtcblx0XHRcdFx0XHRcdGl4ID0gdGhpcy5kYXRlcy5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3JtYXQgPSBmb3JtYXQgfHwgdGhpcy5vLmZvcm1hdDtcblx0XHRcdFx0XHR2YXIgZGF0ZSA9IHRoaXMuZGF0ZXMuZ2V0KGl4KTtcblx0XHRcdFx0XHRyZXR1cm4gRFBHbG9iYWwuZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIHRoaXMuby5sYW5ndWFnZSk7XG5cdFx0XHRcdH0sIHRoaXMpXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0c2hvdzogZnVuY3Rpb24oKXtcblx0XHRcdGlmICh0aGlzLmlucHV0RmllbGQucHJvcCgnZGlzYWJsZWQnKSB8fCAodGhpcy5pbnB1dEZpZWxkLnByb3AoJ3JlYWRvbmx5JykgJiYgdGhpcy5vLmVuYWJsZU9uUmVhZG9ubHkgPT09IGZhbHNlKSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0aWYgKCF0aGlzLmlzSW5saW5lKVxuXHRcdFx0XHR0aGlzLnBpY2tlci5hcHBlbmRUbyh0aGlzLm8uY29udGFpbmVyKTtcblx0XHRcdHRoaXMucGxhY2UoKTtcblx0XHRcdHRoaXMucGlja2VyLnNob3coKTtcblx0XHRcdHRoaXMuX2F0dGFjaFNlY29uZGFyeUV2ZW50cygpO1xuXHRcdFx0dGhpcy5fdHJpZ2dlcignc2hvdycpO1xuXHRcdFx0aWYgKCh3aW5kb3cubmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgfHwgJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQpICYmIHRoaXMuby5kaXNhYmxlVG91Y2hLZXlib2FyZCkge1xuXHRcdFx0XHQkKHRoaXMuZWxlbWVudCkuYmx1cigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGhpZGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAodGhpcy5pc0lubGluZSB8fCAhdGhpcy5waWNrZXIuaXMoJzp2aXNpYmxlJykpXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0dGhpcy5mb2N1c0RhdGUgPSBudWxsO1xuXHRcdFx0dGhpcy5waWNrZXIuaGlkZSgpLmRldGFjaCgpO1xuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHR0aGlzLnNldFZpZXdNb2RlKHRoaXMuby5zdGFydFZpZXcpO1xuXG5cdFx0XHRpZiAodGhpcy5vLmZvcmNlUGFyc2UgJiYgdGhpcy5pbnB1dEZpZWxkLnZhbCgpKVxuXHRcdFx0XHR0aGlzLnNldFZhbHVlKCk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCdoaWRlJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0dGhpcy5fZGV0YWNoRXZlbnRzKCk7XG5cdFx0XHR0aGlzLl9kZXRhY2hTZWNvbmRhcnlFdmVudHMoKTtcblx0XHRcdHRoaXMucGlja2VyLnJlbW92ZSgpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRhKCkuZGF0ZXBpY2tlcjtcblx0XHRcdGlmICghdGhpcy5pc0lucHV0KXtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRhKCkuZGF0ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRwYXN0ZTogZnVuY3Rpb24oZSl7XG5cdFx0XHR2YXIgZGF0ZVN0cmluZztcblx0XHRcdGlmIChlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YSAmJiBlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YS50eXBlc1xuXHRcdFx0XHQmJiAkLmluQXJyYXkoJ3RleHQvcGxhaW4nLCBlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YS50eXBlcykgIT09IC0xKSB7XG5cdFx0XHRcdGRhdGVTdHJpbmcgPSBlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG5cdFx0XHR9IGVsc2UgaWYgKHdpbmRvdy5jbGlwYm9hcmREYXRhKSB7XG5cdFx0XHRcdGRhdGVTdHJpbmcgPSB3aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCdUZXh0Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNldERhdGUoZGF0ZVN0cmluZyk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH0sXG5cblx0XHRfdXRjX3RvX2xvY2FsOiBmdW5jdGlvbih1dGMpe1xuXHRcdFx0aWYgKCF1dGMpIHtcblx0XHRcdFx0cmV0dXJuIHV0Yztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxvY2FsID0gbmV3IERhdGUodXRjLmdldFRpbWUoKSArICh1dGMuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKSk7XG5cblx0XHRcdGlmIChsb2NhbC5nZXRUaW1lem9uZU9mZnNldCgpICE9PSB1dGMuZ2V0VGltZXpvbmVPZmZzZXQoKSkge1xuXHRcdFx0XHRsb2NhbCA9IG5ldyBEYXRlKHV0Yy5nZXRUaW1lKCkgKyAobG9jYWwuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBsb2NhbDtcblx0XHR9LFxuXHRcdF9sb2NhbF90b191dGM6IGZ1bmN0aW9uKGxvY2FsKXtcblx0XHRcdHJldHVybiBsb2NhbCAmJiBuZXcgRGF0ZShsb2NhbC5nZXRUaW1lKCkgLSAobG9jYWwuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMCkpO1xuXHRcdH0sXG5cdFx0X3plcm9fdGltZTogZnVuY3Rpb24obG9jYWwpe1xuXHRcdFx0cmV0dXJuIGxvY2FsICYmIG5ldyBEYXRlKGxvY2FsLmdldEZ1bGxZZWFyKCksIGxvY2FsLmdldE1vbnRoKCksIGxvY2FsLmdldERhdGUoKSk7XG5cdFx0fSxcblx0XHRfemVyb191dGNfdGltZTogZnVuY3Rpb24odXRjKXtcblx0XHRcdHJldHVybiB1dGMgJiYgVVRDRGF0ZSh1dGMuZ2V0VVRDRnVsbFllYXIoKSwgdXRjLmdldFVUQ01vbnRoKCksIHV0Yy5nZXRVVENEYXRlKCkpO1xuXHRcdH0sXG5cblx0XHRnZXREYXRlczogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiAkLm1hcCh0aGlzLmRhdGVzLCB0aGlzLl91dGNfdG9fbG9jYWwpO1xuXHRcdH0sXG5cblx0XHRnZXRVVENEYXRlczogZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiAkLm1hcCh0aGlzLmRhdGVzLCBmdW5jdGlvbihkKXtcblx0XHRcdFx0cmV0dXJuIG5ldyBEYXRlKGQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGdldERhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdXRjX3RvX2xvY2FsKHRoaXMuZ2V0VVRDRGF0ZSgpKTtcblx0XHR9LFxuXG5cdFx0Z2V0VVRDRGF0ZTogZnVuY3Rpb24oKXtcblx0XHRcdHZhciBzZWxlY3RlZF9kYXRlID0gdGhpcy5kYXRlcy5nZXQoLTEpO1xuXHRcdFx0aWYgKHNlbGVjdGVkX2RhdGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IERhdGUoc2VsZWN0ZWRfZGF0ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y2xlYXJEYXRlczogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuaW5wdXRGaWVsZC52YWwoJycpO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZURhdGUnKTtcblxuXHRcdFx0aWYgKHRoaXMuby5hdXRvY2xvc2UpIHtcblx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldERhdGVzOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGFyZ3MgPSAkLmlzQXJyYXkoYXJndW1lbnRzWzBdKSA/IGFyZ3VtZW50c1swXSA6IGFyZ3VtZW50cztcblx0XHRcdHRoaXMudXBkYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlRGF0ZScpO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHNldFVUQ0RhdGVzOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGFyZ3MgPSAkLmlzQXJyYXkoYXJndW1lbnRzWzBdKSA/IGFyZ3VtZW50c1swXSA6IGFyZ3VtZW50cztcblx0XHRcdHRoaXMuc2V0RGF0ZXMuYXBwbHkodGhpcywgJC5tYXAoYXJncywgdGhpcy5fdXRjX3RvX2xvY2FsKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0c2V0RGF0ZTogYWxpYXMoJ3NldERhdGVzJyksXG5cdFx0c2V0VVRDRGF0ZTogYWxpYXMoJ3NldFVUQ0RhdGVzJyksXG5cdFx0cmVtb3ZlOiBhbGlhcygnZGVzdHJveScsICdNZXRob2QgYHJlbW92ZWAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMi4wLiBVc2UgYGRlc3Ryb3lgIGluc3RlYWQnKSxcblxuXHRcdHNldFZhbHVlOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGZvcm1hdHRlZCA9IHRoaXMuZ2V0Rm9ybWF0dGVkRGF0ZSgpO1xuXHRcdFx0dGhpcy5pbnB1dEZpZWxkLnZhbChmb3JtYXR0ZWQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGdldEZvcm1hdHRlZERhdGU6IGZ1bmN0aW9uKGZvcm1hdCl7XG5cdFx0XHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGZvcm1hdCA9IHRoaXMuby5mb3JtYXQ7XG5cblx0XHRcdHZhciBsYW5nID0gdGhpcy5vLmxhbmd1YWdlO1xuXHRcdFx0cmV0dXJuICQubWFwKHRoaXMuZGF0ZXMsIGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRyZXR1cm4gRFBHbG9iYWwuZm9ybWF0RGF0ZShkLCBmb3JtYXQsIGxhbmcpO1xuXHRcdFx0fSkuam9pbih0aGlzLm8ubXVsdGlkYXRlU2VwYXJhdG9yKTtcblx0XHR9LFxuXG5cdFx0Z2V0U3RhcnREYXRlOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMuby5zdGFydERhdGU7XG5cdFx0fSxcblxuXHRcdHNldFN0YXJ0RGF0ZTogZnVuY3Rpb24oc3RhcnREYXRlKXtcblx0XHRcdHRoaXMuX3Byb2Nlc3Nfb3B0aW9ucyh7c3RhcnREYXRlOiBzdGFydERhdGV9KTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGdldEVuZERhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5vLmVuZERhdGU7XG5cdFx0fSxcblxuXHRcdHNldEVuZERhdGU6IGZ1bmN0aW9uKGVuZERhdGUpe1xuXHRcdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKHtlbmREYXRlOiBlbmREYXRlfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRzZXREYXlzT2ZXZWVrRGlzYWJsZWQ6IGZ1bmN0aW9uKGRheXNPZldlZWtEaXNhYmxlZCl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe2RheXNPZldlZWtEaXNhYmxlZDogZGF5c09mV2Vla0Rpc2FibGVkfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHNldERheXNPZldlZWtIaWdobGlnaHRlZDogZnVuY3Rpb24oZGF5c09mV2Vla0hpZ2hsaWdodGVkKXtcblx0XHRcdHRoaXMuX3Byb2Nlc3Nfb3B0aW9ucyh7ZGF5c09mV2Vla0hpZ2hsaWdodGVkOiBkYXlzT2ZXZWVrSGlnaGxpZ2h0ZWR9KTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0c2V0RGF0ZXNEaXNhYmxlZDogZnVuY3Rpb24oZGF0ZXNEaXNhYmxlZCl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe2RhdGVzRGlzYWJsZWQ6IGRhdGVzRGlzYWJsZWR9KTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0cGxhY2U6IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAodGhpcy5pc0lubGluZSlcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR2YXIgY2FsZW5kYXJXaWR0aCA9IHRoaXMucGlja2VyLm91dGVyV2lkdGgoKSxcblx0XHRcdFx0Y2FsZW5kYXJIZWlnaHQgPSB0aGlzLnBpY2tlci5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHR2aXN1YWxQYWRkaW5nID0gMTAsXG5cdFx0XHRcdGNvbnRhaW5lciA9ICQodGhpcy5vLmNvbnRhaW5lciksXG5cdFx0XHRcdHdpbmRvd1dpZHRoID0gY29udGFpbmVyLndpZHRoKCksXG5cdFx0XHRcdHNjcm9sbFRvcCA9IHRoaXMuby5jb250YWluZXIgPT09ICdib2R5JyA/ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDogY29udGFpbmVyLnNjcm9sbFRvcCgpLFxuXHRcdFx0XHRhcHBlbmRPZmZzZXQgPSBjb250YWluZXIub2Zmc2V0KCk7XG5cblx0XHRcdHZhciBwYXJlbnRzWmluZGV4ID0gWzBdO1xuXHRcdFx0dGhpcy5lbGVtZW50LnBhcmVudHMoKS5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciBpdGVtWkluZGV4ID0gJCh0aGlzKS5jc3MoJ3otaW5kZXgnKTtcblx0XHRcdFx0aWYgKGl0ZW1aSW5kZXggIT09ICdhdXRvJyAmJiBOdW1iZXIoaXRlbVpJbmRleCkgIT09IDApIHBhcmVudHNaaW5kZXgucHVzaChOdW1iZXIoaXRlbVpJbmRleCkpO1xuXHRcdFx0fSk7XG5cdFx0XHR2YXIgekluZGV4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgcGFyZW50c1ppbmRleCkgKyB0aGlzLm8uekluZGV4T2Zmc2V0O1xuXHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQucGFyZW50KCkub2Zmc2V0KCkgOiB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XG5cdFx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5jb21wb25lbnQgPyB0aGlzLmNvbXBvbmVudC5vdXRlckhlaWdodCh0cnVlKSA6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodChmYWxzZSk7XG5cdFx0XHR2YXIgd2lkdGggPSB0aGlzLmNvbXBvbmVudCA/IHRoaXMuY29tcG9uZW50Lm91dGVyV2lkdGgodHJ1ZSkgOiB0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aChmYWxzZSk7XG5cdFx0XHR2YXIgbGVmdCA9IG9mZnNldC5sZWZ0IC0gYXBwZW5kT2Zmc2V0LmxlZnQ7XG5cdFx0XHR2YXIgdG9wID0gb2Zmc2V0LnRvcCAtIGFwcGVuZE9mZnNldC50b3A7XG5cblx0XHRcdGlmICh0aGlzLm8uY29udGFpbmVyICE9PSAnYm9keScpIHtcblx0XHRcdFx0dG9wICs9IHNjcm9sbFRvcDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5waWNrZXIucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdCdkYXRlcGlja2VyLW9yaWVudC10b3AgZGF0ZXBpY2tlci1vcmllbnQtYm90dG9tICcrXG5cdFx0XHRcdCdkYXRlcGlja2VyLW9yaWVudC1yaWdodCBkYXRlcGlja2VyLW9yaWVudC1sZWZ0J1xuXHRcdFx0KTtcblxuXHRcdFx0aWYgKHRoaXMuby5vcmllbnRhdGlvbi54ICE9PSAnYXV0bycpe1xuXHRcdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1vcmllbnQtJyArIHRoaXMuby5vcmllbnRhdGlvbi54KTtcblx0XHRcdFx0aWYgKHRoaXMuby5vcmllbnRhdGlvbi54ID09PSAncmlnaHQnKVxuXHRcdFx0XHRcdGxlZnQgLT0gY2FsZW5kYXJXaWR0aCAtIHdpZHRoO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYXV0byB4IG9yaWVudGF0aW9uIGlzIGJlc3QtcGxhY2VtZW50OiBpZiBpdCBjcm9zc2VzIGEgd2luZG93XG5cdFx0XHQvLyBlZGdlLCBmdWRnZSBpdCBzaWRld2F5c1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChvZmZzZXQubGVmdCA8IDApIHtcblx0XHRcdFx0XHQvLyBjb21wb25lbnQgaXMgb3V0c2lkZSB0aGUgd2luZG93IG9uIHRoZSBsZWZ0IHNpZGUuIE1vdmUgaXQgaW50byB2aXNpYmxlIHJhbmdlXG5cdFx0XHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItb3JpZW50LWxlZnQnKTtcblx0XHRcdFx0XHRsZWZ0IC09IG9mZnNldC5sZWZ0IC0gdmlzdWFsUGFkZGluZztcblx0XHRcdFx0fSBlbHNlIGlmIChsZWZ0ICsgY2FsZW5kYXJXaWR0aCA+IHdpbmRvd1dpZHRoKSB7XG5cdFx0XHRcdFx0Ly8gdGhlIGNhbGVuZGFyIHBhc3NlcyB0aGUgd2lkb3cgcmlnaHQgZWRnZS4gQWxpZ24gaXQgdG8gY29tcG9uZW50IHJpZ2h0IHNpZGVcblx0XHRcdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1vcmllbnQtcmlnaHQnKTtcblx0XHRcdFx0XHRsZWZ0ICs9IHdpZHRoIC0gY2FsZW5kYXJXaWR0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5vLnJ0bCkge1xuXHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCB0byByaWdodFxuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItb3JpZW50LXJpZ2h0Jyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIERlZmF1bHQgdG8gbGVmdFxuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItb3JpZW50LWxlZnQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYXV0byB5IG9yaWVudGF0aW9uIGlzIGJlc3Qtc2l0dWF0aW9uOiB0b3Agb3IgYm90dG9tLCBubyBmdWRnaW5nLFxuXHRcdFx0Ly8gZGVjaXNpb24gYmFzZWQgb24gd2hpY2ggc2hvd3MgbW9yZSBvZiB0aGUgY2FsZW5kYXJcblx0XHRcdHZhciB5b3JpZW50ID0gdGhpcy5vLm9yaWVudGF0aW9uLnksXG5cdFx0XHRcdHRvcF9vdmVyZmxvdztcblx0XHRcdGlmICh5b3JpZW50ID09PSAnYXV0bycpe1xuXHRcdFx0XHR0b3Bfb3ZlcmZsb3cgPSAtc2Nyb2xsVG9wICsgdG9wIC0gY2FsZW5kYXJIZWlnaHQ7XG5cdFx0XHRcdHlvcmllbnQgPSB0b3Bfb3ZlcmZsb3cgPCAwID8gJ2JvdHRvbScgOiAndG9wJztcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItb3JpZW50LScgKyB5b3JpZW50KTtcblx0XHRcdGlmICh5b3JpZW50ID09PSAndG9wJylcblx0XHRcdFx0dG9wIC09IGNhbGVuZGFySGVpZ2h0ICsgcGFyc2VJbnQodGhpcy5waWNrZXIuY3NzKCdwYWRkaW5nLXRvcCcpKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dG9wICs9IGhlaWdodDtcblxuXHRcdFx0aWYgKHRoaXMuby5ydGwpIHtcblx0XHRcdFx0dmFyIHJpZ2h0ID0gd2luZG93V2lkdGggLSAobGVmdCArIHdpZHRoKTtcblx0XHRcdFx0dGhpcy5waWNrZXIuY3NzKHtcblx0XHRcdFx0XHR0b3A6IHRvcCxcblx0XHRcdFx0XHRyaWdodDogcmlnaHQsXG5cdFx0XHRcdFx0ekluZGV4OiB6SW5kZXhcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnBpY2tlci5jc3Moe1xuXHRcdFx0XHRcdHRvcDogdG9wLFxuXHRcdFx0XHRcdGxlZnQ6IGxlZnQsXG5cdFx0XHRcdFx0ekluZGV4OiB6SW5kZXhcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0X2FsbG93X3VwZGF0ZTogdHJ1ZSxcblx0XHR1cGRhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAoIXRoaXMuX2FsbG93X3VwZGF0ZSlcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdHZhciBvbGREYXRlcyA9IHRoaXMuZGF0ZXMuY29weSgpLFxuXHRcdFx0XHRkYXRlcyA9IFtdLFxuXHRcdFx0XHRmcm9tQXJncyA9IGZhbHNlO1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpe1xuXHRcdFx0XHQkLmVhY2goYXJndW1lbnRzLCAkLnByb3h5KGZ1bmN0aW9uKGksIGRhdGUpe1xuXHRcdFx0XHRcdGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSlcblx0XHRcdFx0XHRcdGRhdGUgPSB0aGlzLl9sb2NhbF90b191dGMoZGF0ZSk7XG5cdFx0XHRcdFx0ZGF0ZXMucHVzaChkYXRlKTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHRmcm9tQXJncyA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRlcyA9IHRoaXMuaXNJbnB1dFxuXHRcdFx0XHRcdFx0PyB0aGlzLmVsZW1lbnQudmFsKClcblx0XHRcdFx0XHRcdDogdGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUnKSB8fCB0aGlzLmlucHV0RmllbGQudmFsKCk7XG5cdFx0XHRcdGlmIChkYXRlcyAmJiB0aGlzLm8ubXVsdGlkYXRlKVxuXHRcdFx0XHRcdGRhdGVzID0gZGF0ZXMuc3BsaXQodGhpcy5vLm11bHRpZGF0ZVNlcGFyYXRvcik7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRkYXRlcyA9IFtkYXRlc107XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmVsZW1lbnQuZGF0YSgpLmRhdGU7XG5cdFx0XHR9XG5cblx0XHRcdGRhdGVzID0gJC5tYXAoZGF0ZXMsICQucHJveHkoZnVuY3Rpb24oZGF0ZSl7XG5cdFx0XHRcdHJldHVybiBEUEdsb2JhbC5wYXJzZURhdGUoZGF0ZSwgdGhpcy5vLmZvcm1hdCwgdGhpcy5vLmxhbmd1YWdlLCB0aGlzLm8uYXNzdW1lTmVhcmJ5WWVhcik7XG5cdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRkYXRlcyA9ICQuZ3JlcChkYXRlcywgJC5wcm94eShmdW5jdGlvbihkYXRlKXtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQhdGhpcy5kYXRlV2l0aGluUmFuZ2UoZGF0ZSkgfHxcblx0XHRcdFx0XHQhZGF0ZVxuXHRcdFx0XHQpO1xuXHRcdFx0fSwgdGhpcyksIHRydWUpO1xuXHRcdFx0dGhpcy5kYXRlcy5yZXBsYWNlKGRhdGVzKTtcblxuXHRcdFx0aWYgKHRoaXMuby51cGRhdGVWaWV3RGF0ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5kYXRlcy5sZW5ndGgpXG5cdFx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuZGF0ZXMuZ2V0KC0xKSk7XG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMudmlld0RhdGUgPCB0aGlzLm8uc3RhcnREYXRlKVxuXHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLm8uc3RhcnREYXRlKTtcblx0XHRcdFx0ZWxzZSBpZiAodGhpcy52aWV3RGF0ZSA+IHRoaXMuby5lbmREYXRlKVxuXHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLm8uZW5kRGF0ZSk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gdGhpcy5vLmRlZmF1bHRWaWV3RGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGZyb21BcmdzKXtcblx0XHRcdFx0Ly8gc2V0dGluZyBkYXRlIGJ5IGNsaWNraW5nXG5cdFx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmNoYW5nZSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodGhpcy5kYXRlcy5sZW5ndGgpe1xuXHRcdFx0XHQvLyBzZXR0aW5nIGRhdGUgYnkgdHlwaW5nXG5cdFx0XHRcdGlmIChTdHJpbmcob2xkRGF0ZXMpICE9PSBTdHJpbmcodGhpcy5kYXRlcykgJiYgZnJvbUFyZ3MpIHtcblx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LmNoYW5nZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXRoaXMuZGF0ZXMubGVuZ3RoICYmIG9sZERhdGVzLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjbGVhckRhdGUnKTtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmNoYW5nZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZpbGwoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRmaWxsRG93OiBmdW5jdGlvbigpe1xuICAgICAgaWYgKHRoaXMuby5zaG93V2Vla0RheXMpIHtcblx0XHRcdHZhciBkb3dDbnQgPSB0aGlzLm8ud2Vla1N0YXJ0LFxuXHRcdFx0XHRodG1sID0gJzx0cj4nO1xuXHRcdFx0aWYgKHRoaXMuby5jYWxlbmRhcldlZWtzKXtcblx0XHRcdFx0aHRtbCArPSAnPHRoIGNsYXNzPVwiY3dcIj4mIzE2MDs8L3RoPic7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoZG93Q250IDwgdGhpcy5vLndlZWtTdGFydCArIDcpe1xuXHRcdFx0XHRodG1sICs9ICc8dGggY2xhc3M9XCJkb3cnO1xuICAgICAgICBpZiAoJC5pbkFycmF5KGRvd0NudCwgdGhpcy5vLmRheXNPZldlZWtEaXNhYmxlZCkgIT09IC0xKVxuICAgICAgICAgIGh0bWwgKz0gJyBkaXNhYmxlZCc7XG4gICAgICAgIGh0bWwgKz0gJ1wiPicrZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5kYXlzTWluWyhkb3dDbnQrKyklN10rJzwvdGg+Jztcblx0XHRcdH1cblx0XHRcdGh0bWwgKz0gJzwvdHI+Jztcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQnKS5hcHBlbmQoaHRtbCk7XG4gICAgICB9XG5cdFx0fSxcblxuXHRcdGZpbGxNb250aHM6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgbG9jYWxEYXRlID0gdGhpcy5fdXRjX3RvX2xvY2FsKHRoaXMudmlld0RhdGUpO1xuXHRcdFx0dmFyIGh0bWwgPSAnJztcblx0XHRcdHZhciBmb2N1c2VkO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKXtcblx0XHRcdFx0Zm9jdXNlZCA9IGxvY2FsRGF0ZSAmJiBsb2NhbERhdGUuZ2V0TW9udGgoKSA9PT0gaSA/ICcgZm9jdXNlZCcgOiAnJztcblx0XHRcdFx0aHRtbCArPSAnPHNwYW4gY2xhc3M9XCJtb250aCcgKyBmb2N1c2VkICsgJ1wiPicgKyBkYXRlc1t0aGlzLm8ubGFuZ3VhZ2VdLm1vbnRoc1Nob3J0W2ldICsgJzwvc3Bhbj4nO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzIHRkJykuaHRtbChodG1sKTtcblx0XHR9LFxuXG5cdFx0c2V0UmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKXtcblx0XHRcdGlmICghcmFuZ2UgfHwgIXJhbmdlLmxlbmd0aClcblx0XHRcdFx0ZGVsZXRlIHRoaXMucmFuZ2U7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRoaXMucmFuZ2UgPSAkLm1hcChyYW5nZSwgZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0cmV0dXJuIGQudmFsdWVPZigpO1xuXHRcdFx0XHR9KTtcblx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdH0sXG5cblx0XHRnZXRDbGFzc05hbWVzOiBmdW5jdGlvbihkYXRlKXtcblx0XHRcdHZhciBjbHMgPSBbXSxcblx0XHRcdFx0eWVhciA9IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKSxcblx0XHRcdFx0bW9udGggPSB0aGlzLnZpZXdEYXRlLmdldFVUQ01vbnRoKCksXG5cdFx0XHRcdHRvZGF5ID0gVVRDVG9kYXkoKTtcblx0XHRcdGlmIChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPCB5ZWFyIHx8IChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPT09IHllYXIgJiYgZGF0ZS5nZXRVVENNb250aCgpIDwgbW9udGgpKXtcblx0XHRcdFx0Y2xzLnB1c2goJ29sZCcpO1xuXHRcdFx0fSBlbHNlIGlmIChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPiB5ZWFyIHx8IChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPT09IHllYXIgJiYgZGF0ZS5nZXRVVENNb250aCgpID4gbW9udGgpKXtcblx0XHRcdFx0Y2xzLnB1c2goJ25ldycpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuZm9jdXNEYXRlICYmIGRhdGUudmFsdWVPZigpID09PSB0aGlzLmZvY3VzRGF0ZS52YWx1ZU9mKCkpXG5cdFx0XHRcdGNscy5wdXNoKCdmb2N1c2VkJyk7XG5cdFx0XHQvLyBDb21wYXJlIGludGVybmFsIFVUQyBkYXRlIHdpdGggVVRDIHRvZGF5LCBub3QgbG9jYWwgdG9kYXlcblx0XHRcdGlmICh0aGlzLm8udG9kYXlIaWdobGlnaHQgJiYgaXNVVENFcXVhbHMoZGF0ZSwgdG9kYXkpKSB7XG5cdFx0XHRcdGNscy5wdXNoKCd0b2RheScpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuZGF0ZXMuY29udGFpbnMoZGF0ZSkgIT09IC0xKVxuXHRcdFx0XHRjbHMucHVzaCgnYWN0aXZlJyk7XG5cdFx0XHRpZiAoIXRoaXMuZGF0ZVdpdGhpblJhbmdlKGRhdGUpKXtcblx0XHRcdFx0Y2xzLnB1c2goJ2Rpc2FibGVkJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5kYXRlSXNEaXNhYmxlZChkYXRlKSl7XG5cdFx0XHRcdGNscy5wdXNoKCdkaXNhYmxlZCcsICdkaXNhYmxlZC1kYXRlJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJC5pbkFycmF5KGRhdGUuZ2V0VVRDRGF5KCksIHRoaXMuby5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQpICE9PSAtMSl7XG5cdFx0XHRcdGNscy5wdXNoKCdoaWdobGlnaHRlZCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5yYW5nZSl7XG5cdFx0XHRcdGlmIChkYXRlID4gdGhpcy5yYW5nZVswXSAmJiBkYXRlIDwgdGhpcy5yYW5nZVt0aGlzLnJhbmdlLmxlbmd0aC0xXSl7XG5cdFx0XHRcdFx0Y2xzLnB1c2goJ3JhbmdlJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCQuaW5BcnJheShkYXRlLnZhbHVlT2YoKSwgdGhpcy5yYW5nZSkgIT09IC0xKXtcblx0XHRcdFx0XHRjbHMucHVzaCgnc2VsZWN0ZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZGF0ZS52YWx1ZU9mKCkgPT09IHRoaXMucmFuZ2VbMF0pe1xuICAgICAgICAgIGNscy5wdXNoKCdyYW5nZS1zdGFydCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlLnZhbHVlT2YoKSA9PT0gdGhpcy5yYW5nZVt0aGlzLnJhbmdlLmxlbmd0aC0xXSl7XG4gICAgICAgICAgY2xzLnB1c2goJ3JhbmdlLWVuZCcpO1xuICAgICAgICB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2xzO1xuXHRcdH0sXG5cblx0XHRfZmlsbF95ZWFyc1ZpZXc6IGZ1bmN0aW9uKHNlbGVjdG9yLCBjc3NDbGFzcywgZmFjdG9yLCB5ZWFyLCBzdGFydFllYXIsIGVuZFllYXIsIGJlZm9yZUZuKXtcblx0XHRcdHZhciBodG1sID0gJyc7XG5cdFx0XHR2YXIgc3RlcCA9IGZhY3RvciAvIDEwO1xuXHRcdFx0dmFyIHZpZXcgPSB0aGlzLnBpY2tlci5maW5kKHNlbGVjdG9yKTtcblx0XHRcdHZhciBzdGFydFZhbCA9IE1hdGguZmxvb3IoeWVhciAvIGZhY3RvcikgKiBmYWN0b3I7XG5cdFx0XHR2YXIgZW5kVmFsID0gc3RhcnRWYWwgKyBzdGVwICogOTtcblx0XHRcdHZhciBmb2N1c2VkVmFsID0gTWF0aC5mbG9vcih0aGlzLnZpZXdEYXRlLmdldEZ1bGxZZWFyKCkgLyBzdGVwKSAqIHN0ZXA7XG5cdFx0XHR2YXIgc2VsZWN0ZWQgPSAkLm1hcCh0aGlzLmRhdGVzLCBmdW5jdGlvbihkKXtcblx0XHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoZC5nZXRVVENGdWxsWWVhcigpIC8gc3RlcCkgKiBzdGVwO1xuXHRcdFx0fSk7XG5cblx0XHRcdHZhciBjbGFzc2VzLCB0b29sdGlwLCBiZWZvcmU7XG5cdFx0XHRmb3IgKHZhciBjdXJyVmFsID0gc3RhcnRWYWwgLSBzdGVwOyBjdXJyVmFsIDw9IGVuZFZhbCArIHN0ZXA7IGN1cnJWYWwgKz0gc3RlcCkge1xuXHRcdFx0XHRjbGFzc2VzID0gW2Nzc0NsYXNzXTtcblx0XHRcdFx0dG9vbHRpcCA9IG51bGw7XG5cblx0XHRcdFx0aWYgKGN1cnJWYWwgPT09IHN0YXJ0VmFsIC0gc3RlcCkge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaCgnb2xkJyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY3VyclZhbCA9PT0gZW5kVmFsICsgc3RlcCkge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaCgnbmV3Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCQuaW5BcnJheShjdXJyVmFsLCBzZWxlY3RlZCkgIT09IC0xKSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKCdhY3RpdmUnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY3VyclZhbCA8IHN0YXJ0WWVhciB8fCBjdXJyVmFsID4gZW5kWWVhcikge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaCgnZGlzYWJsZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY3VyclZhbCA9PT0gZm9jdXNlZFZhbCkge1xuXHRcdFx0XHQgIGNsYXNzZXMucHVzaCgnZm9jdXNlZCcpO1xuICAgICAgICB9XG5cblx0XHRcdFx0aWYgKGJlZm9yZUZuICE9PSAkLm5vb3ApIHtcblx0XHRcdFx0XHRiZWZvcmUgPSBiZWZvcmVGbihuZXcgRGF0ZShjdXJyVmFsLCAwLCAxKSk7XG5cdFx0XHRcdFx0aWYgKGJlZm9yZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRiZWZvcmUgPSB7fTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBiZWZvcmUgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHRcdFx0YmVmb3JlID0ge2VuYWJsZWQ6IGJlZm9yZX07XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgYmVmb3JlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0YmVmb3JlID0ge2NsYXNzZXM6IGJlZm9yZX07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChiZWZvcmUuZW5hYmxlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaCgnZGlzYWJsZWQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGJlZm9yZS5jbGFzc2VzKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzID0gY2xhc3Nlcy5jb25jYXQoYmVmb3JlLmNsYXNzZXMuc3BsaXQoL1xccysvKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChiZWZvcmUudG9vbHRpcCkge1xuXHRcdFx0XHRcdFx0dG9vbHRpcCA9IGJlZm9yZS50b29sdGlwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArICh0b29sdGlwID8gJyB0aXRsZT1cIicgKyB0b29sdGlwICsgJ1wiJyA6ICcnKSArICc+JyArIGN1cnJWYWwgKyAnPC9zcGFuPic7XG5cdFx0XHR9XG5cblx0XHRcdHZpZXcuZmluZCgnLmRhdGVwaWNrZXItc3dpdGNoJykudGV4dChzdGFydFZhbCArICctJyArIGVuZFZhbCk7XG5cdFx0XHR2aWV3LmZpbmQoJ3RkJykuaHRtbChodG1sKTtcblx0XHR9LFxuXG5cdFx0ZmlsbDogZnVuY3Rpb24oKXtcblx0XHRcdHZhciBkID0gbmV3IERhdGUodGhpcy52aWV3RGF0ZSksXG5cdFx0XHRcdHllYXIgPSBkLmdldFVUQ0Z1bGxZZWFyKCksXG5cdFx0XHRcdG1vbnRoID0gZC5nZXRVVENNb250aCgpLFxuXHRcdFx0XHRzdGFydFllYXIgPSB0aGlzLm8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkgPyB0aGlzLm8uc3RhcnREYXRlLmdldFVUQ0Z1bGxZZWFyKCkgOiAtSW5maW5pdHksXG5cdFx0XHRcdHN0YXJ0TW9udGggPSB0aGlzLm8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkgPyB0aGlzLm8uc3RhcnREYXRlLmdldFVUQ01vbnRoKCkgOiAtSW5maW5pdHksXG5cdFx0XHRcdGVuZFllYXIgPSB0aGlzLm8uZW5kRGF0ZSAhPT0gSW5maW5pdHkgPyB0aGlzLm8uZW5kRGF0ZS5nZXRVVENGdWxsWWVhcigpIDogSW5maW5pdHksXG5cdFx0XHRcdGVuZE1vbnRoID0gdGhpcy5vLmVuZERhdGUgIT09IEluZmluaXR5ID8gdGhpcy5vLmVuZERhdGUuZ2V0VVRDTW9udGgoKSA6IEluZmluaXR5LFxuXHRcdFx0XHR0b2RheXR4dCA9IGRhdGVzW3RoaXMuby5sYW5ndWFnZV0udG9kYXkgfHwgZGF0ZXNbJ2VuJ10udG9kYXkgfHwgJycsXG5cdFx0XHRcdGNsZWFydHh0ID0gZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5jbGVhciB8fCBkYXRlc1snZW4nXS5jbGVhciB8fCAnJyxcblx0XHRcdFx0dGl0bGVGb3JtYXQgPSBkYXRlc1t0aGlzLm8ubGFuZ3VhZ2VdLnRpdGxlRm9ybWF0IHx8IGRhdGVzWydlbiddLnRpdGxlRm9ybWF0LFxuXHRcdFx0XHR0b29sdGlwLFxuXHRcdFx0XHRiZWZvcmU7XG5cdFx0XHRpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIC5kYXRlcGlja2VyLXN3aXRjaCcpXG5cdFx0XHRcdFx0XHQudGV4dChEUEdsb2JhbC5mb3JtYXREYXRlKGQsIHRpdGxlRm9ybWF0LCB0aGlzLm8ubGFuZ3VhZ2UpKTtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJ3Rmb290IC50b2RheScpXG5cdFx0XHRcdFx0XHQudGV4dCh0b2RheXR4dClcblx0XHRcdFx0XHRcdC5jc3MoJ2Rpc3BsYXknLCB0aGlzLm8udG9kYXlCdG4gPT09IHRydWUgfHwgdGhpcy5vLnRvZGF5QnRuID09PSAnbGlua2VkJyA/ICd0YWJsZS1jZWxsJyA6ICdub25lJyk7XG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCd0Zm9vdCAuY2xlYXInKVxuXHRcdFx0XHRcdFx0LnRleHQoY2xlYXJ0eHQpXG5cdFx0XHRcdFx0XHQuY3NzKCdkaXNwbGF5JywgdGhpcy5vLmNsZWFyQnRuID09PSB0cnVlID8gJ3RhYmxlLWNlbGwnIDogJ25vbmUnKTtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJ3RoZWFkIC5kYXRlcGlja2VyLXRpdGxlJylcblx0XHRcdFx0XHRcdC50ZXh0KHRoaXMuby50aXRsZSlcblx0XHRcdFx0XHRcdC5jc3MoJ2Rpc3BsYXknLCB0eXBlb2YgdGhpcy5vLnRpdGxlID09PSAnc3RyaW5nJyAmJiB0aGlzLm8udGl0bGUgIT09ICcnID8gJ3RhYmxlLWNlbGwnIDogJ25vbmUnKTtcblx0XHRcdHRoaXMudXBkYXRlTmF2QXJyb3dzKCk7XG5cdFx0XHR0aGlzLmZpbGxNb250aHMoKTtcblx0XHRcdHZhciBwcmV2TW9udGggPSBVVENEYXRlKHllYXIsIG1vbnRoLCAwKSxcblx0XHRcdFx0ZGF5ID0gcHJldk1vbnRoLmdldFVUQ0RhdGUoKTtcblx0XHRcdHByZXZNb250aC5zZXRVVENEYXRlKGRheSAtIChwcmV2TW9udGguZ2V0VVRDRGF5KCkgLSB0aGlzLm8ud2Vla1N0YXJ0ICsgNyklNyk7XG5cdFx0XHR2YXIgbmV4dE1vbnRoID0gbmV3IERhdGUocHJldk1vbnRoKTtcblx0XHRcdGlmIChwcmV2TW9udGguZ2V0VVRDRnVsbFllYXIoKSA8IDEwMCl7XG4gICAgICAgIG5leHRNb250aC5zZXRVVENGdWxsWWVhcihwcmV2TW9udGguZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICB9XG5cdFx0XHRuZXh0TW9udGguc2V0VVRDRGF0ZShuZXh0TW9udGguZ2V0VVRDRGF0ZSgpICsgNDIpO1xuXHRcdFx0bmV4dE1vbnRoID0gbmV4dE1vbnRoLnZhbHVlT2YoKTtcblx0XHRcdHZhciBodG1sID0gW107XG5cdFx0XHR2YXIgd2Vla0RheSwgY2xzTmFtZTtcblx0XHRcdHdoaWxlIChwcmV2TW9udGgudmFsdWVPZigpIDwgbmV4dE1vbnRoKXtcblx0XHRcdFx0d2Vla0RheSA9IHByZXZNb250aC5nZXRVVENEYXkoKTtcblx0XHRcdFx0aWYgKHdlZWtEYXkgPT09IHRoaXMuby53ZWVrU3RhcnQpe1xuXHRcdFx0XHRcdGh0bWwucHVzaCgnPHRyPicpO1xuXHRcdFx0XHRcdGlmICh0aGlzLm8uY2FsZW5kYXJXZWVrcyl7XG5cdFx0XHRcdFx0XHQvLyBJU08gODYwMTogRmlyc3Qgd2VlayBjb250YWlucyBmaXJzdCB0aHVyc2RheS5cblx0XHRcdFx0XHRcdC8vIElTTyBhbHNvIHN0YXRlcyB3ZWVrIHN0YXJ0cyBvbiBNb25kYXksIGJ1dCB3ZSBjYW4gYmUgbW9yZSBhYnN0cmFjdCBoZXJlLlxuXHRcdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHRcdC8vIFN0YXJ0IG9mIGN1cnJlbnQgd2VlazogYmFzZWQgb24gd2Vla3N0YXJ0L2N1cnJlbnQgZGF0ZVxuXHRcdFx0XHRcdFx0XHR3cyA9IG5ldyBEYXRlKCtwcmV2TW9udGggKyAodGhpcy5vLndlZWtTdGFydCAtIHdlZWtEYXkgLSA3KSAlIDcgKiA4NjRlNSksXG5cdFx0XHRcdFx0XHRcdC8vIFRodXJzZGF5IG9mIHRoaXMgd2Vla1xuXHRcdFx0XHRcdFx0XHR0aCA9IG5ldyBEYXRlKE51bWJlcih3cykgKyAoNyArIDQgLSB3cy5nZXRVVENEYXkoKSkgJSA3ICogODY0ZTUpLFxuXHRcdFx0XHRcdFx0XHQvLyBGaXJzdCBUaHVyc2RheSBvZiB5ZWFyLCB5ZWFyIGZyb20gdGh1cnNkYXlcblx0XHRcdFx0XHRcdFx0eXRoID0gbmV3IERhdGUoTnVtYmVyKHl0aCA9IFVUQ0RhdGUodGguZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpICsgKDcgKyA0IC0geXRoLmdldFVUQ0RheSgpKSAlIDcgKiA4NjRlNSksXG5cdFx0XHRcdFx0XHRcdC8vIENhbGVuZGFyIHdlZWs6IG1zIGJldHdlZW4gdGh1cnNkYXlzLCBkaXYgbXMgcGVyIGRheSwgZGl2IDcgZGF5c1xuXHRcdFx0XHRcdFx0XHRjYWxXZWVrID0gKHRoIC0geXRoKSAvIDg2NGU1IC8gNyArIDE7XG5cdFx0XHRcdFx0XHRodG1sLnB1c2goJzx0ZCBjbGFzcz1cImN3XCI+JysgY2FsV2VlayArJzwvdGQ+Jyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNsc05hbWUgPSB0aGlzLmdldENsYXNzTmFtZXMocHJldk1vbnRoKTtcblx0XHRcdFx0Y2xzTmFtZS5wdXNoKCdkYXknKTtcblxuXHRcdFx0XHR2YXIgY29udGVudCA9IHByZXZNb250aC5nZXRVVENEYXRlKCk7XG5cblx0XHRcdFx0aWYgKHRoaXMuby5iZWZvcmVTaG93RGF5ICE9PSAkLm5vb3Ape1xuXHRcdFx0XHRcdGJlZm9yZSA9IHRoaXMuby5iZWZvcmVTaG93RGF5KHRoaXMuX3V0Y190b19sb2NhbChwcmV2TW9udGgpKTtcblx0XHRcdFx0XHRpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRiZWZvcmUgPSB7fTtcblx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgYmVmb3JlID09PSAnYm9vbGVhbicpXG5cdFx0XHRcdFx0XHRiZWZvcmUgPSB7ZW5hYmxlZDogYmVmb3JlfTtcblx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgYmVmb3JlID09PSAnc3RyaW5nJylcblx0XHRcdFx0XHRcdGJlZm9yZSA9IHtjbGFzc2VzOiBiZWZvcmV9O1xuXHRcdFx0XHRcdGlmIChiZWZvcmUuZW5hYmxlZCA9PT0gZmFsc2UpXG5cdFx0XHRcdFx0XHRjbHNOYW1lLnB1c2goJ2Rpc2FibGVkJyk7XG5cdFx0XHRcdFx0aWYgKGJlZm9yZS5jbGFzc2VzKVxuXHRcdFx0XHRcdFx0Y2xzTmFtZSA9IGNsc05hbWUuY29uY2F0KGJlZm9yZS5jbGFzc2VzLnNwbGl0KC9cXHMrLykpO1xuXHRcdFx0XHRcdGlmIChiZWZvcmUudG9vbHRpcClcblx0XHRcdFx0XHRcdHRvb2x0aXAgPSBiZWZvcmUudG9vbHRpcDtcblx0XHRcdFx0XHRpZiAoYmVmb3JlLmNvbnRlbnQpXG5cdFx0XHRcdFx0XHRjb250ZW50ID0gYmVmb3JlLmNvbnRlbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL0NoZWNrIGlmIHVuaXF1ZVNvcnQgZXhpc3RzIChzdXBwb3J0ZWQgYnkganF1ZXJ5ID49MS4xMiBhbmQgPj0yLjIpXG5cdFx0XHRcdC8vRmFsbGJhY2sgdG8gdW5pcXVlIGZ1bmN0aW9uIGZvciBvbGRlciBqcXVlcnkgdmVyc2lvbnNcblx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbigkLnVuaXF1ZVNvcnQpKSB7XG5cdFx0XHRcdFx0Y2xzTmFtZSA9ICQudW5pcXVlU29ydChjbHNOYW1lKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjbHNOYW1lID0gJC51bmlxdWUoY2xzTmFtZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRodG1sLnB1c2goJzx0ZCBjbGFzcz1cIicrY2xzTmFtZS5qb2luKCcgJykrJ1wiJyArICh0b29sdGlwID8gJyB0aXRsZT1cIicrdG9vbHRpcCsnXCInIDogJycpICsgJyBkYXRhLWRhdGU9XCInICsgcHJldk1vbnRoLmdldFRpbWUoKS50b1N0cmluZygpICsgJ1wiPicgKyBjb250ZW50ICsgJzwvdGQ+Jyk7XG5cdFx0XHRcdHRvb2x0aXAgPSBudWxsO1xuXHRcdFx0XHRpZiAod2Vla0RheSA9PT0gdGhpcy5vLndlZWtFbmQpe1xuXHRcdFx0XHRcdGh0bWwucHVzaCgnPC90cj4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcmV2TW9udGguc2V0VVRDRGF0ZShwcmV2TW9udGguZ2V0VVRDRGF0ZSgpICsgMSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRib2R5JykuaHRtbChodG1sLmpvaW4oJycpKTtcblxuXHRcdFx0dmFyIG1vbnRoc1RpdGxlID0gZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5tb250aHNUaXRsZSB8fCBkYXRlc1snZW4nXS5tb250aHNUaXRsZSB8fCAnTW9udGhzJztcblx0XHRcdHZhciBtb250aHMgPSB0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMnKVxuXHRcdFx0XHRcdFx0LmZpbmQoJy5kYXRlcGlja2VyLXN3aXRjaCcpXG5cdFx0XHRcdFx0XHRcdC50ZXh0KHRoaXMuby5tYXhWaWV3TW9kZSA8IDIgPyBtb250aHNUaXRsZSA6IHllYXIpXG5cdFx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdFx0LmZpbmQoJ3Rib2R5IHNwYW4nKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cblx0XHRcdCQuZWFjaCh0aGlzLmRhdGVzLCBmdW5jdGlvbihpLCBkKXtcblx0XHRcdFx0aWYgKGQuZ2V0VVRDRnVsbFllYXIoKSA9PT0geWVhcilcblx0XHRcdFx0XHRtb250aHMuZXEoZC5nZXRVVENNb250aCgpKS5hZGRDbGFzcygnYWN0aXZlJyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHllYXIgPCBzdGFydFllYXIgfHwgeWVhciA+IGVuZFllYXIpe1xuXHRcdFx0XHRtb250aHMuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoeWVhciA9PT0gc3RhcnRZZWFyKXtcblx0XHRcdFx0bW9udGhzLnNsaWNlKDAsIHN0YXJ0TW9udGgpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHllYXIgPT09IGVuZFllYXIpe1xuXHRcdFx0XHRtb250aHMuc2xpY2UoZW5kTW9udGgrMSkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLm8uYmVmb3JlU2hvd01vbnRoICE9PSAkLm5vb3Ape1xuXHRcdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRcdCQuZWFjaChtb250aHMsIGZ1bmN0aW9uKGksIG1vbnRoKXtcbiAgICAgICAgICB2YXIgbW9EYXRlID0gbmV3IERhdGUoeWVhciwgaSwgMSk7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IHRoYXQuby5iZWZvcmVTaG93TW9udGgobW9EYXRlKTtcblx0XHRcdFx0XHRpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRiZWZvcmUgPSB7fTtcblx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgYmVmb3JlID09PSAnYm9vbGVhbicpXG5cdFx0XHRcdFx0XHRiZWZvcmUgPSB7ZW5hYmxlZDogYmVmb3JlfTtcblx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgYmVmb3JlID09PSAnc3RyaW5nJylcblx0XHRcdFx0XHRcdGJlZm9yZSA9IHtjbGFzc2VzOiBiZWZvcmV9O1xuXHRcdFx0XHRcdGlmIChiZWZvcmUuZW5hYmxlZCA9PT0gZmFsc2UgJiYgISQobW9udGgpLmhhc0NsYXNzKCdkaXNhYmxlZCcpKVxuXHRcdFx0XHRcdCAgICAkKG1vbnRoKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblx0XHRcdFx0XHRpZiAoYmVmb3JlLmNsYXNzZXMpXG5cdFx0XHRcdFx0ICAgICQobW9udGgpLmFkZENsYXNzKGJlZm9yZS5jbGFzc2VzKTtcblx0XHRcdFx0XHRpZiAoYmVmb3JlLnRvb2x0aXApXG5cdFx0XHRcdFx0ICAgICQobW9udGgpLnByb3AoJ3RpdGxlJywgYmVmb3JlLnRvb2x0aXApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2VuZXJhdGluZyBkZWNhZGUveWVhcnMgcGlja2VyXG5cdFx0XHR0aGlzLl9maWxsX3llYXJzVmlldyhcblx0XHRcdFx0Jy5kYXRlcGlja2VyLXllYXJzJyxcblx0XHRcdFx0J3llYXInLFxuXHRcdFx0XHQxMCxcblx0XHRcdFx0eWVhcixcblx0XHRcdFx0c3RhcnRZZWFyLFxuXHRcdFx0XHRlbmRZZWFyLFxuXHRcdFx0XHR0aGlzLm8uYmVmb3JlU2hvd1llYXJcblx0XHRcdCk7XG5cblx0XHRcdC8vIEdlbmVyYXRpbmcgY2VudHVyeS9kZWNhZGVzIHBpY2tlclxuXHRcdFx0dGhpcy5fZmlsbF95ZWFyc1ZpZXcoXG5cdFx0XHRcdCcuZGF0ZXBpY2tlci1kZWNhZGVzJyxcblx0XHRcdFx0J2RlY2FkZScsXG5cdFx0XHRcdDEwMCxcblx0XHRcdFx0eWVhcixcblx0XHRcdFx0c3RhcnRZZWFyLFxuXHRcdFx0XHRlbmRZZWFyLFxuXHRcdFx0XHR0aGlzLm8uYmVmb3JlU2hvd0RlY2FkZVxuXHRcdFx0KTtcblxuXHRcdFx0Ly8gR2VuZXJhdGluZyBtaWxsZW5uaXVtL2NlbnR1cmllcyBwaWNrZXJcblx0XHRcdHRoaXMuX2ZpbGxfeWVhcnNWaWV3KFxuXHRcdFx0XHQnLmRhdGVwaWNrZXItY2VudHVyaWVzJyxcblx0XHRcdFx0J2NlbnR1cnknLFxuXHRcdFx0XHQxMDAwLFxuXHRcdFx0XHR5ZWFyLFxuXHRcdFx0XHRzdGFydFllYXIsXG5cdFx0XHRcdGVuZFllYXIsXG5cdFx0XHRcdHRoaXMuby5iZWZvcmVTaG93Q2VudHVyeVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlTmF2QXJyb3dzOiBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKCF0aGlzLl9hbGxvd191cGRhdGUpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0dmFyIGQgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKSxcblx0XHRcdFx0eWVhciA9IGQuZ2V0VVRDRnVsbFllYXIoKSxcblx0XHRcdFx0bW9udGggPSBkLmdldFVUQ01vbnRoKCksXG5cdFx0XHRcdHN0YXJ0WWVhciA9IHRoaXMuby5zdGFydERhdGUgIT09IC1JbmZpbml0eSA/IHRoaXMuby5zdGFydERhdGUuZ2V0VVRDRnVsbFllYXIoKSA6IC1JbmZpbml0eSxcblx0XHRcdFx0c3RhcnRNb250aCA9IHRoaXMuby5zdGFydERhdGUgIT09IC1JbmZpbml0eSA/IHRoaXMuby5zdGFydERhdGUuZ2V0VVRDTW9udGgoKSA6IC1JbmZpbml0eSxcblx0XHRcdFx0ZW5kWWVhciA9IHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSA/IHRoaXMuby5lbmREYXRlLmdldFVUQ0Z1bGxZZWFyKCkgOiBJbmZpbml0eSxcblx0XHRcdFx0ZW5kTW9udGggPSB0aGlzLm8uZW5kRGF0ZSAhPT0gSW5maW5pdHkgPyB0aGlzLm8uZW5kRGF0ZS5nZXRVVENNb250aCgpIDogSW5maW5pdHksXG5cdFx0XHRcdHByZXZJc0Rpc2FibGVkLFxuXHRcdFx0XHRuZXh0SXNEaXNhYmxlZCxcblx0XHRcdFx0ZmFjdG9yID0gMTtcblx0XHRcdHN3aXRjaCAodGhpcy52aWV3TW9kZSl7XG5cdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRmYWN0b3IgKj0gMTA7XG5cdFx0XHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0ZmFjdG9yICo9IDEwO1xuXHRcdFx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdGZhY3RvciAqPSAxMDtcblx0XHRcdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRwcmV2SXNEaXNhYmxlZCA9IE1hdGguZmxvb3IoeWVhciAvIGZhY3RvcikgKiBmYWN0b3IgPD0gc3RhcnRZZWFyO1xuXHRcdFx0XHRcdG5leHRJc0Rpc2FibGVkID0gTWF0aC5mbG9vcih5ZWFyIC8gZmFjdG9yKSAqIGZhY3RvciArIGZhY3RvciA+IGVuZFllYXI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHRwcmV2SXNEaXNhYmxlZCA9IHllYXIgPD0gc3RhcnRZZWFyICYmIG1vbnRoIDw9IHN0YXJ0TW9udGg7XG5cdFx0XHRcdFx0bmV4dElzRGlzYWJsZWQgPSB5ZWFyID49IGVuZFllYXIgJiYgbW9udGggPj0gZW5kTW9udGg7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5wcmV2JykudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJywgcHJldklzRGlzYWJsZWQpO1xuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLm5leHQnKS50b2dnbGVDbGFzcygnZGlzYWJsZWQnLCBuZXh0SXNEaXNhYmxlZCk7XG5cdFx0fSxcblxuXHRcdGNsaWNrOiBmdW5jdGlvbihlKXtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRcdHZhciB0YXJnZXQsIGRpciwgZGF5LCB5ZWFyLCBtb250aDtcblx0XHRcdHRhcmdldCA9ICQoZS50YXJnZXQpO1xuXG5cdFx0XHQvLyBDbGlja2VkIG9uIHRoZSBzd2l0Y2hcblx0XHRcdGlmICh0YXJnZXQuaGFzQ2xhc3MoJ2RhdGVwaWNrZXItc3dpdGNoJykgJiYgdGhpcy52aWV3TW9kZSAhPT0gdGhpcy5vLm1heFZpZXdNb2RlKXtcblx0XHRcdFx0dGhpcy5zZXRWaWV3TW9kZSh0aGlzLnZpZXdNb2RlICsgMSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsaWNrZWQgb24gdG9kYXkgYnV0dG9uXG5cdFx0XHRpZiAodGFyZ2V0Lmhhc0NsYXNzKCd0b2RheScpICYmICF0YXJnZXQuaGFzQ2xhc3MoJ2RheScpKXtcblx0XHRcdFx0dGhpcy5zZXRWaWV3TW9kZSgwKTtcblx0XHRcdFx0dGhpcy5fc2V0RGF0ZShVVENUb2RheSgpLCB0aGlzLm8udG9kYXlCdG4gPT09ICdsaW5rZWQnID8gbnVsbCA6ICd2aWV3Jyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsaWNrZWQgb24gY2xlYXIgYnV0dG9uXG5cdFx0XHRpZiAodGFyZ2V0Lmhhc0NsYXNzKCdjbGVhcicpKXtcblx0XHRcdFx0dGhpcy5jbGVhckRhdGVzKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGFyZ2V0Lmhhc0NsYXNzKCdkaXNhYmxlZCcpKXtcblx0XHRcdFx0Ly8gQ2xpY2tlZCBvbiBhIG1vbnRoLCB5ZWFyLCBkZWNhZGUsIGNlbnR1cnlcblx0XHRcdFx0aWYgKHRhcmdldC5oYXNDbGFzcygnbW9udGgnKVxuXHRcdFx0XHRcdFx0fHwgdGFyZ2V0Lmhhc0NsYXNzKCd5ZWFyJylcblx0XHRcdFx0XHRcdHx8IHRhcmdldC5oYXNDbGFzcygnZGVjYWRlJylcblx0XHRcdFx0XHRcdHx8IHRhcmdldC5oYXNDbGFzcygnY2VudHVyeScpKSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3RGF0ZS5zZXRVVENEYXRlKDEpO1xuXG5cdFx0XHRcdFx0ZGF5ID0gMTtcblx0XHRcdFx0XHRpZiAodGhpcy52aWV3TW9kZSA9PT0gMSl7XG5cdFx0XHRcdFx0XHRtb250aCA9IHRhcmdldC5wYXJlbnQoKS5maW5kKCdzcGFuJykuaW5kZXgodGFyZ2V0KTtcblx0XHRcdFx0XHRcdHllYXIgPSB0aGlzLnZpZXdEYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlLnNldFVUQ01vbnRoKG1vbnRoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bW9udGggPSAwO1xuXHRcdFx0XHRcdFx0eWVhciA9IE51bWJlcih0YXJnZXQudGV4dCgpKTtcblx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUuc2V0VVRDRnVsbFllYXIoeWVhcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5fdHJpZ2dlcihEUEdsb2JhbC52aWV3TW9kZXNbdGhpcy52aWV3TW9kZSAtIDFdLmUsIHRoaXMudmlld0RhdGUpO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMudmlld01vZGUgPT09IHRoaXMuby5taW5WaWV3TW9kZSl7XG5cdFx0XHRcdFx0XHR0aGlzLl9zZXREYXRlKFVUQ0RhdGUoeWVhciwgbW9udGgsIGRheSkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFZpZXdNb2RlKHRoaXMudmlld01vZGUgLSAxKTtcblx0XHRcdFx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5waWNrZXIuaXMoJzp2aXNpYmxlJykgJiYgdGhpcy5fZm9jdXNlZF9mcm9tKXtcblx0XHRcdFx0dGhpcy5fZm9jdXNlZF9mcm9tLmZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgdGhpcy5fZm9jdXNlZF9mcm9tO1xuXHRcdH0sXG5cblx0XHRkYXlDZWxsQ2xpY2s6IGZ1bmN0aW9uKGUpe1xuXHRcdFx0dmFyICR0YXJnZXQgPSAkKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHR2YXIgdGltZXN0YW1wID0gJHRhcmdldC5kYXRhKCdkYXRlJyk7XG5cdFx0XHR2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCk7XG5cblx0XHRcdGlmICh0aGlzLm8udXBkYXRlVmlld0RhdGUpIHtcblx0XHRcdFx0aWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAhPT0gdGhpcy52aWV3RGF0ZS5nZXRVVENGdWxsWWVhcigpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlWWVhcicsIHRoaXMudmlld0RhdGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRhdGUuZ2V0VVRDTW9udGgoKSAhPT0gdGhpcy52aWV3RGF0ZS5nZXRVVENNb250aCgpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlTW9udGgnLCB0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2V0RGF0ZShkYXRlKTtcblx0XHR9LFxuXG5cdFx0Ly8gQ2xpY2tlZCBvbiBwcmV2IG9yIG5leHRcblx0XHRuYXZBcnJvd3NDbGljazogZnVuY3Rpb24oZSl7XG5cdFx0XHR2YXIgJHRhcmdldCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdHZhciBkaXIgPSAkdGFyZ2V0Lmhhc0NsYXNzKCdwcmV2JykgPyAtMSA6IDE7XG5cdFx0XHRpZiAodGhpcy52aWV3TW9kZSAhPT0gMCl7XG5cdFx0XHRcdGRpciAqPSBEUEdsb2JhbC52aWV3TW9kZXNbdGhpcy52aWV3TW9kZV0ubmF2U3RlcCAqIDEyO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy52aWV3RGF0ZSA9IHRoaXMubW92ZU1vbnRoKHRoaXMudmlld0RhdGUsIGRpcik7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKERQR2xvYmFsLnZpZXdNb2Rlc1t0aGlzLnZpZXdNb2RlXS5lLCB0aGlzLnZpZXdEYXRlKTtcblx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdH0sXG5cblx0XHRfdG9nZ2xlX211bHRpZGF0ZTogZnVuY3Rpb24oZGF0ZSl7XG5cdFx0XHR2YXIgaXggPSB0aGlzLmRhdGVzLmNvbnRhaW5zKGRhdGUpO1xuXHRcdFx0aWYgKCFkYXRlKXtcblx0XHRcdFx0dGhpcy5kYXRlcy5jbGVhcigpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXggIT09IC0xKXtcblx0XHRcdFx0aWYgKHRoaXMuby5tdWx0aWRhdGUgPT09IHRydWUgfHwgdGhpcy5vLm11bHRpZGF0ZSA+IDEgfHwgdGhpcy5vLnRvZ2dsZUFjdGl2ZSl7XG5cdFx0XHRcdFx0dGhpcy5kYXRlcy5yZW1vdmUoaXgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuby5tdWx0aWRhdGUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuZGF0ZXMuY2xlYXIoKTtcblx0XHRcdFx0dGhpcy5kYXRlcy5wdXNoKGRhdGUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGF0ZXMucHVzaChkYXRlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiB0aGlzLm8ubXVsdGlkYXRlID09PSAnbnVtYmVyJylcblx0XHRcdFx0d2hpbGUgKHRoaXMuZGF0ZXMubGVuZ3RoID4gdGhpcy5vLm11bHRpZGF0ZSlcblx0XHRcdFx0XHR0aGlzLmRhdGVzLnJlbW92ZSgwKTtcblx0XHR9LFxuXG5cdFx0X3NldERhdGU6IGZ1bmN0aW9uKGRhdGUsIHdoaWNoKXtcblx0XHRcdGlmICghd2hpY2ggfHwgd2hpY2ggPT09ICdkYXRlJylcblx0XHRcdFx0dGhpcy5fdG9nZ2xlX211bHRpZGF0ZShkYXRlICYmIG5ldyBEYXRlKGRhdGUpKTtcblx0XHRcdGlmICgoIXdoaWNoICYmIHRoaXMuby51cGRhdGVWaWV3RGF0ZSkgfHwgd2hpY2ggPT09ICd2aWV3Jylcblx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IGRhdGUgJiYgbmV3IERhdGUoZGF0ZSk7XG5cblx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xuXHRcdFx0aWYgKCF3aGljaCB8fCB3aGljaCAhPT0gJ3ZpZXcnKSB7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZURhdGUnKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaW5wdXRGaWVsZC50cmlnZ2VyKCdjaGFuZ2UnKTtcblx0XHRcdGlmICh0aGlzLm8uYXV0b2Nsb3NlICYmICghd2hpY2ggfHwgd2hpY2ggPT09ICdkYXRlJykpe1xuXHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0bW92ZURheTogZnVuY3Rpb24oZGF0ZSwgZGlyKXtcblx0XHRcdHZhciBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG5cdFx0XHRuZXdEYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIpO1xuXG5cdFx0XHRyZXR1cm4gbmV3RGF0ZTtcblx0XHR9LFxuXG5cdFx0bW92ZVdlZWs6IGZ1bmN0aW9uKGRhdGUsIGRpcil7XG5cdFx0XHRyZXR1cm4gdGhpcy5tb3ZlRGF5KGRhdGUsIGRpciAqIDcpO1xuXHRcdH0sXG5cblx0XHRtb3ZlTW9udGg6IGZ1bmN0aW9uKGRhdGUsIGRpcil7XG5cdFx0XHRpZiAoIWlzVmFsaWREYXRlKGRhdGUpKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vLmRlZmF1bHRWaWV3RGF0ZTtcblx0XHRcdGlmICghZGlyKVxuXHRcdFx0XHRyZXR1cm4gZGF0ZTtcblx0XHRcdHZhciBuZXdfZGF0ZSA9IG5ldyBEYXRlKGRhdGUudmFsdWVPZigpKSxcblx0XHRcdFx0ZGF5ID0gbmV3X2RhdGUuZ2V0VVRDRGF0ZSgpLFxuXHRcdFx0XHRtb250aCA9IG5ld19kYXRlLmdldFVUQ01vbnRoKCksXG5cdFx0XHRcdG1hZyA9IE1hdGguYWJzKGRpciksXG5cdFx0XHRcdG5ld19tb250aCwgdGVzdDtcblx0XHRcdGRpciA9IGRpciA+IDAgPyAxIDogLTE7XG5cdFx0XHRpZiAobWFnID09PSAxKXtcblx0XHRcdFx0dGVzdCA9IGRpciA9PT0gLTFcblx0XHRcdFx0XHQvLyBJZiBnb2luZyBiYWNrIG9uZSBtb250aCwgbWFrZSBzdXJlIG1vbnRoIGlzIG5vdCBjdXJyZW50IG1vbnRoXG5cdFx0XHRcdFx0Ly8gKGVnLCBNYXIgMzEgLT4gRmViIDMxID09IEZlYiAyOCwgbm90IE1hciAwMilcblx0XHRcdFx0XHQ/IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKSA9PT0gbW9udGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIElmIGdvaW5nIGZvcndhcmQgb25lIG1vbnRoLCBtYWtlIHN1cmUgbW9udGggaXMgYXMgZXhwZWN0ZWRcblx0XHRcdFx0XHQvLyAoZWcsIEphbiAzMSAtPiBGZWIgMzEgPT0gRmViIDI4LCBub3QgTWFyIDAyKVxuXHRcdFx0XHRcdDogZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdHJldHVybiBuZXdfZGF0ZS5nZXRVVENNb250aCgpICE9PSBuZXdfbW9udGg7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0bmV3X21vbnRoID0gbW9udGggKyBkaXI7XG5cdFx0XHRcdG5ld19kYXRlLnNldFVUQ01vbnRoKG5ld19tb250aCk7XG5cdFx0XHRcdC8vIERlYyAtPiBKYW4gKDEyKSBvciBKYW4gLT4gRGVjICgtMSkgLS0gbGltaXQgZXhwZWN0ZWQgZGF0ZSB0byAwLTExXG5cdFx0XHRcdG5ld19tb250aCA9IChuZXdfbW9udGggKyAxMikgJSAxMjtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBGb3IgbWFnbml0dWRlcyA+MSwgbW92ZSBvbmUgbW9udGggYXQgYSB0aW1lLi4uXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaSA8IG1hZzsgaSsrKVxuXHRcdFx0XHRcdC8vIC4uLndoaWNoIG1pZ2h0IGRlY3JlYXNlIHRoZSBkYXkgKGVnLCBKYW4gMzEgdG8gRmViIDI4LCBldGMpLi4uXG5cdFx0XHRcdFx0bmV3X2RhdGUgPSB0aGlzLm1vdmVNb250aChuZXdfZGF0ZSwgZGlyKTtcblx0XHRcdFx0Ly8gLi4udGhlbiByZXNldCB0aGUgZGF5LCBrZWVwaW5nIGl0IGluIHRoZSBuZXcgbW9udGhcblx0XHRcdFx0bmV3X21vbnRoID0gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKTtcblx0XHRcdFx0bmV3X2RhdGUuc2V0VVRDRGF0ZShkYXkpO1xuXHRcdFx0XHR0ZXN0ID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRyZXR1cm4gbmV3X21vbnRoICE9PSBuZXdfZGF0ZS5nZXRVVENNb250aCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ29tbW9uIGRhdGUtcmVzZXR0aW5nIGxvb3AgLS0gaWYgZGF0ZSBpcyBiZXlvbmQgZW5kIG9mIG1vbnRoLCBtYWtlIGl0XG5cdFx0XHQvLyBlbmQgb2YgbW9udGhcblx0XHRcdHdoaWxlICh0ZXN0KCkpe1xuXHRcdFx0XHRuZXdfZGF0ZS5zZXRVVENEYXRlKC0tZGF5KTtcblx0XHRcdFx0bmV3X2RhdGUuc2V0VVRDTW9udGgobmV3X21vbnRoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXdfZGF0ZTtcblx0XHR9LFxuXG5cdFx0bW92ZVllYXI6IGZ1bmN0aW9uKGRhdGUsIGRpcil7XG5cdFx0XHRyZXR1cm4gdGhpcy5tb3ZlTW9udGgoZGF0ZSwgZGlyKjEyKTtcblx0XHR9LFxuXG5cdFx0bW92ZUF2YWlsYWJsZURhdGU6IGZ1bmN0aW9uKGRhdGUsIGRpciwgZm4pe1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRkYXRlID0gdGhpc1tmbl0oZGF0ZSwgZGlyKTtcblxuXHRcdFx0XHRpZiAoIXRoaXMuZGF0ZVdpdGhpblJhbmdlKGRhdGUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRmbiA9ICdtb3ZlRGF5Jztcblx0XHRcdH1cblx0XHRcdHdoaWxlICh0aGlzLmRhdGVJc0Rpc2FibGVkKGRhdGUpKTtcblxuXHRcdFx0cmV0dXJuIGRhdGU7XG5cdFx0fSxcblxuXHRcdHdlZWtPZkRhdGVJc0Rpc2FibGVkOiBmdW5jdGlvbihkYXRlKXtcblx0XHRcdHJldHVybiAkLmluQXJyYXkoZGF0ZS5nZXRVVENEYXkoKSwgdGhpcy5vLmRheXNPZldlZWtEaXNhYmxlZCkgIT09IC0xO1xuXHRcdH0sXG5cblx0XHRkYXRlSXNEaXNhYmxlZDogZnVuY3Rpb24oZGF0ZSl7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHR0aGlzLndlZWtPZkRhdGVJc0Rpc2FibGVkKGRhdGUpIHx8XG5cdFx0XHRcdCQuZ3JlcCh0aGlzLm8uZGF0ZXNEaXNhYmxlZCwgZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0cmV0dXJuIGlzVVRDRXF1YWxzKGRhdGUsIGQpO1xuXHRcdFx0XHR9KS5sZW5ndGggPiAwXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRkYXRlV2l0aGluUmFuZ2U6IGZ1bmN0aW9uKGRhdGUpe1xuXHRcdFx0cmV0dXJuIGRhdGUgPj0gdGhpcy5vLnN0YXJ0RGF0ZSAmJiBkYXRlIDw9IHRoaXMuby5lbmREYXRlO1xuXHRcdH0sXG5cblx0XHRrZXlkb3duOiBmdW5jdGlvbihlKXtcblx0XHRcdGlmICghdGhpcy5waWNrZXIuaXMoJzp2aXNpYmxlJykpe1xuXHRcdFx0XHRpZiAoZS5rZXlDb2RlID09PSA0MCB8fCBlLmtleUNvZGUgPT09IDI3KSB7IC8vIGFsbG93IGRvd24gdG8gcmUtc2hvdyBwaWNrZXJcblx0XHRcdFx0XHR0aGlzLnNob3coKTtcblx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBkYXRlQ2hhbmdlZCA9IGZhbHNlLFxuXHRcdFx0XHRkaXIsIG5ld1ZpZXdEYXRlLFxuXHRcdFx0XHRmb2N1c0RhdGUgPSB0aGlzLmZvY3VzRGF0ZSB8fCB0aGlzLnZpZXdEYXRlO1xuXHRcdFx0c3dpdGNoIChlLmtleUNvZGUpe1xuXHRcdFx0XHRjYXNlIDI3OiAvLyBlc2NhcGVcblx0XHRcdFx0XHRpZiAodGhpcy5mb2N1c0RhdGUpe1xuXHRcdFx0XHRcdFx0dGhpcy5mb2N1c0RhdGUgPSBudWxsO1xuXHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IHRoaXMuZGF0ZXMuZ2V0KC0xKSB8fCB0aGlzLnZpZXdEYXRlO1xuXHRcdFx0XHRcdFx0dGhpcy5maWxsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM3OiAvLyBsZWZ0XG5cdFx0XHRcdGNhc2UgMzg6IC8vIHVwXG5cdFx0XHRcdGNhc2UgMzk6IC8vIHJpZ2h0XG5cdFx0XHRcdGNhc2UgNDA6IC8vIGRvd25cblx0XHRcdFx0XHRpZiAoIXRoaXMuby5rZXlib2FyZE5hdmlnYXRpb24gfHwgdGhpcy5vLmRheXNPZldlZWtEaXNhYmxlZC5sZW5ndGggPT09IDcpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkaXIgPSBlLmtleUNvZGUgPT09IDM3IHx8IGUua2V5Q29kZSA9PT0gMzggPyAtMSA6IDE7XG4gICAgICAgICAgaWYgKHRoaXMudmlld01vZGUgPT09IDApIHtcbiAgXHRcdFx0XHRcdGlmIChlLmN0cmxLZXkpe1xuICBcdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZUF2YWlsYWJsZURhdGUoZm9jdXNEYXRlLCBkaXIsICdtb3ZlWWVhcicpO1xuXG4gIFx0XHRcdFx0XHRcdGlmIChuZXdWaWV3RGF0ZSlcbiAgXHRcdFx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VZZWFyJywgdGhpcy52aWV3RGF0ZSk7XG4gIFx0XHRcdFx0XHR9IGVsc2UgaWYgKGUuc2hpZnRLZXkpe1xuICBcdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZUF2YWlsYWJsZURhdGUoZm9jdXNEYXRlLCBkaXIsICdtb3ZlTW9udGgnKTtcblxuICBcdFx0XHRcdFx0XHRpZiAobmV3Vmlld0RhdGUpXG4gIFx0XHRcdFx0XHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlTW9udGgnLCB0aGlzLnZpZXdEYXRlKTtcbiAgXHRcdFx0XHRcdH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzNyB8fCBlLmtleUNvZGUgPT09IDM5KXtcbiAgXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVBdmFpbGFibGVEYXRlKGZvY3VzRGF0ZSwgZGlyLCAnbW92ZURheScpO1xuICBcdFx0XHRcdFx0fSBlbHNlIGlmICghdGhpcy53ZWVrT2ZEYXRlSXNEaXNhYmxlZChmb2N1c0RhdGUpKXtcbiAgXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVBdmFpbGFibGVEYXRlKGZvY3VzRGF0ZSwgZGlyLCAnbW92ZVdlZWsnKTtcbiAgXHRcdFx0XHRcdH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmlld01vZGUgPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDM4IHx8IGUua2V5Q29kZSA9PT0gNDApIHtcbiAgICAgICAgICAgICAgZGlyID0gZGlyICogNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1ZpZXdEYXRlID0gdGhpcy5tb3ZlQXZhaWxhYmxlRGF0ZShmb2N1c0RhdGUsIGRpciwgJ21vdmVNb250aCcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy52aWV3TW9kZSA9PT0gMikge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMzggfHwgZS5rZXlDb2RlID09PSA0MCkge1xuICAgICAgICAgICAgICBkaXIgPSBkaXIgKiA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVBdmFpbGFibGVEYXRlKGZvY3VzRGF0ZSwgZGlyLCAnbW92ZVllYXInKTtcbiAgICAgICAgICB9XG5cdFx0XHRcdFx0aWYgKG5ld1ZpZXdEYXRlKXtcblx0XHRcdFx0XHRcdHRoaXMuZm9jdXNEYXRlID0gdGhpcy52aWV3RGF0ZSA9IG5ld1ZpZXdEYXRlO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xuXHRcdFx0XHRcdFx0dGhpcy5maWxsKCk7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDEzOiAvLyBlbnRlclxuXHRcdFx0XHRcdGlmICghdGhpcy5vLmZvcmNlUGFyc2UpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRmb2N1c0RhdGUgPSB0aGlzLmZvY3VzRGF0ZSB8fCB0aGlzLmRhdGVzLmdldCgtMSkgfHwgdGhpcy52aWV3RGF0ZTtcblx0XHRcdFx0XHRpZiAodGhpcy5vLmtleWJvYXJkTmF2aWdhdGlvbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fdG9nZ2xlX211bHRpZGF0ZShmb2N1c0RhdGUpO1xuXHRcdFx0XHRcdFx0ZGF0ZUNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmZvY3VzRGF0ZSA9IG51bGw7XG5cdFx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IHRoaXMuZGF0ZXMuZ2V0KC0xKSB8fCB0aGlzLnZpZXdEYXRlO1xuXHRcdFx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcblx0XHRcdFx0XHR0aGlzLmZpbGwoKTtcblx0XHRcdFx0XHRpZiAodGhpcy5waWNrZXIuaXMoJzp2aXNpYmxlJykpe1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLm8uYXV0b2Nsb3NlKVxuXHRcdFx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgOTogLy8gdGFiXG5cdFx0XHRcdFx0dGhpcy5mb2N1c0RhdGUgPSBudWxsO1xuXHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSB0aGlzLmRhdGVzLmdldCgtMSkgfHwgdGhpcy52aWV3RGF0ZTtcblx0XHRcdFx0XHR0aGlzLmZpbGwoKTtcblx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmIChkYXRlQ2hhbmdlZCl7XG5cdFx0XHRcdGlmICh0aGlzLmRhdGVzLmxlbmd0aClcblx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjbGVhckRhdGUnKTtcblx0XHRcdFx0dGhpcy5pbnB1dEZpZWxkLnRyaWdnZXIoJ2NoYW5nZScpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXRWaWV3TW9kZTogZnVuY3Rpb24odmlld01vZGUpe1xuXHRcdFx0dGhpcy52aWV3TW9kZSA9IHZpZXdNb2RlO1xuXHRcdFx0dGhpcy5waWNrZXJcblx0XHRcdFx0LmNoaWxkcmVuKCdkaXYnKVxuXHRcdFx0XHQuaGlkZSgpXG5cdFx0XHRcdC5maWx0ZXIoJy5kYXRlcGlja2VyLScgKyBEUEdsb2JhbC52aWV3TW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZSlcblx0XHRcdFx0XHQuc2hvdygpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2NoYW5nZVZpZXdNb2RlJywgbmV3IERhdGUodGhpcy52aWV3RGF0ZSkpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgRGF0ZVJhbmdlUGlja2VyID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucyl7XG5cdFx0JC5kYXRhKGVsZW1lbnQsICdkYXRlcGlja2VyJywgdGhpcyk7XG5cdFx0dGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcblx0XHR0aGlzLmlucHV0cyA9ICQubWFwKG9wdGlvbnMuaW5wdXRzLCBmdW5jdGlvbihpKXtcblx0XHRcdHJldHVybiBpLmpxdWVyeSA/IGlbMF0gOiBpO1xuXHRcdH0pO1xuXHRcdGRlbGV0ZSBvcHRpb25zLmlucHV0cztcblxuXHRcdHRoaXMua2VlcEVtcHR5VmFsdWVzID0gb3B0aW9ucy5rZWVwRW1wdHlWYWx1ZXM7XG5cdFx0ZGVsZXRlIG9wdGlvbnMua2VlcEVtcHR5VmFsdWVzO1xuXG5cdFx0ZGF0ZXBpY2tlclBsdWdpbi5jYWxsKCQodGhpcy5pbnB1dHMpLCBvcHRpb25zKVxuXHRcdFx0Lm9uKCdjaGFuZ2VEYXRlJywgJC5wcm94eSh0aGlzLmRhdGVVcGRhdGVkLCB0aGlzKSk7XG5cblx0XHR0aGlzLnBpY2tlcnMgPSAkLm1hcCh0aGlzLmlucHV0cywgZnVuY3Rpb24oaSl7XG5cdFx0XHRyZXR1cm4gJC5kYXRhKGksICdkYXRlcGlja2VyJyk7XG5cdFx0fSk7XG5cdFx0dGhpcy51cGRhdGVEYXRlcygpO1xuXHR9O1xuXHREYXRlUmFuZ2VQaWNrZXIucHJvdG90eXBlID0ge1xuXHRcdHVwZGF0ZURhdGVzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5kYXRlcyA9ICQubWFwKHRoaXMucGlja2VycywgZnVuY3Rpb24oaSl7XG5cdFx0XHRcdHJldHVybiBpLmdldFVUQ0RhdGUoKTtcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy51cGRhdGVSYW5nZXMoKTtcblx0XHR9LFxuXHRcdHVwZGF0ZVJhbmdlczogZnVuY3Rpb24oKXtcblx0XHRcdHZhciByYW5nZSA9ICQubWFwKHRoaXMuZGF0ZXMsIGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRyZXR1cm4gZC52YWx1ZU9mKCk7XG5cdFx0XHR9KTtcblx0XHRcdCQuZWFjaCh0aGlzLnBpY2tlcnMsIGZ1bmN0aW9uKGksIHApe1xuXHRcdFx0XHRwLnNldFJhbmdlKHJhbmdlKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0Y2xlYXJEYXRlczogZnVuY3Rpb24oKXtcblx0XHRcdCQuZWFjaCh0aGlzLnBpY2tlcnMsIGZ1bmN0aW9uKGksIHApe1xuXHRcdFx0XHRwLmNsZWFyRGF0ZXMoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0ZGF0ZVVwZGF0ZWQ6IGZ1bmN0aW9uKGUpe1xuXHRcdFx0Ly8gYHRoaXMudXBkYXRpbmdgIGlzIGEgd29ya2Fyb3VuZCBmb3IgcHJldmVudGluZyBpbmZpbml0ZSByZWN1cnNpb25cblx0XHRcdC8vIGJldHdlZW4gYGNoYW5nZURhdGVgIHRyaWdnZXJpbmcgYW5kIGBzZXRVVENEYXRlYCBjYWxsaW5nLiAgVW50aWxcblx0XHRcdC8vIHRoZXJlIGlzIGEgYmV0dGVyIG1lY2hhbmlzbS5cblx0XHRcdGlmICh0aGlzLnVwZGF0aW5nKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblxuXHRcdFx0dmFyIGRwID0gJC5kYXRhKGUudGFyZ2V0LCAnZGF0ZXBpY2tlcicpO1xuXG5cdFx0XHRpZiAoZHAgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBuZXdfZGF0ZSA9IGRwLmdldFVUQ0RhdGUoKSxcblx0XHRcdFx0a2VlcF9lbXB0eV92YWx1ZXMgPSB0aGlzLmtlZXBFbXB0eVZhbHVlcyxcblx0XHRcdFx0aSA9ICQuaW5BcnJheShlLnRhcmdldCwgdGhpcy5pbnB1dHMpLFxuXHRcdFx0XHRqID0gaSAtIDEsXG5cdFx0XHRcdGsgPSBpICsgMSxcblx0XHRcdFx0bCA9IHRoaXMuaW5wdXRzLmxlbmd0aDtcblx0XHRcdGlmIChpID09PSAtMSlcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQkLmVhY2godGhpcy5waWNrZXJzLCBmdW5jdGlvbihpLCBwKXtcblx0XHRcdFx0aWYgKCFwLmdldFVUQ0RhdGUoKSAmJiAocCA9PT0gZHAgfHwgIWtlZXBfZW1wdHlfdmFsdWVzKSlcblx0XHRcdFx0XHRwLnNldFVUQ0RhdGUobmV3X2RhdGUpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChuZXdfZGF0ZSA8IHRoaXMuZGF0ZXNbal0pe1xuXHRcdFx0XHQvLyBEYXRlIGJlaW5nIG1vdmVkIGVhcmxpZXIvbGVmdFxuXHRcdFx0XHR3aGlsZSAoaiA+PSAwICYmIG5ld19kYXRlIDwgdGhpcy5kYXRlc1tqXSl7XG5cdFx0XHRcdFx0dGhpcy5waWNrZXJzW2otLV0uc2V0VVRDRGF0ZShuZXdfZGF0ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAobmV3X2RhdGUgPiB0aGlzLmRhdGVzW2tdKXtcblx0XHRcdFx0Ly8gRGF0ZSBiZWluZyBtb3ZlZCBsYXRlci9yaWdodFxuXHRcdFx0XHR3aGlsZSAoayA8IGwgJiYgbmV3X2RhdGUgPiB0aGlzLmRhdGVzW2tdKXtcblx0XHRcdFx0XHR0aGlzLnBpY2tlcnNbaysrXS5zZXRVVENEYXRlKG5ld19kYXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGVEYXRlcygpO1xuXG5cdFx0XHRkZWxldGUgdGhpcy51cGRhdGluZztcblx0XHR9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG5cdFx0XHQkLm1hcCh0aGlzLnBpY2tlcnMsIGZ1bmN0aW9uKHApeyBwLmRlc3Ryb3koKTsgfSk7XG5cdFx0XHQkKHRoaXMuaW5wdXRzKS5vZmYoJ2NoYW5nZURhdGUnLCB0aGlzLmRhdGVVcGRhdGVkKTtcblx0XHRcdGRlbGV0ZSB0aGlzLmVsZW1lbnQuZGF0YSgpLmRhdGVwaWNrZXI7XG5cdFx0fSxcblx0XHRyZW1vdmU6IGFsaWFzKCdkZXN0cm95JywgJ01ldGhvZCBgcmVtb3ZlYCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiAyLjAuIFVzZSBgZGVzdHJveWAgaW5zdGVhZCcpXG5cdH07XG5cblx0ZnVuY3Rpb24gb3B0c19mcm9tX2VsKGVsLCBwcmVmaXgpe1xuXHRcdC8vIERlcml2ZSBvcHRpb25zIGZyb20gZWxlbWVudCBkYXRhLWF0dHJzXG5cdFx0dmFyIGRhdGEgPSAkKGVsKS5kYXRhKCksXG5cdFx0XHRvdXQgPSB7fSwgaW5rZXksXG5cdFx0XHRyZXBsYWNlID0gbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXgudG9Mb3dlckNhc2UoKSArICcoW0EtWl0pJyk7XG5cdFx0cHJlZml4ID0gbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXgudG9Mb3dlckNhc2UoKSk7XG5cdFx0ZnVuY3Rpb24gcmVfbG93ZXIoXyxhKXtcblx0XHRcdHJldHVybiBhLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGtleSBpbiBkYXRhKVxuXHRcdFx0aWYgKHByZWZpeC50ZXN0KGtleSkpe1xuXHRcdFx0XHRpbmtleSA9IGtleS5yZXBsYWNlKHJlcGxhY2UsIHJlX2xvd2VyKTtcblx0XHRcdFx0b3V0W2lua2V5XSA9IGRhdGFba2V5XTtcblx0XHRcdH1cblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0ZnVuY3Rpb24gb3B0c19mcm9tX2xvY2FsZShsYW5nKXtcblx0XHQvLyBEZXJpdmUgb3B0aW9ucyBmcm9tIGxvY2FsZSBwbHVnaW5zXG5cdFx0dmFyIG91dCA9IHt9O1xuXHRcdC8vIENoZWNrIGlmIFwiZGUtREVcIiBzdHlsZSBkYXRlIGlzIGF2YWlsYWJsZSwgaWYgbm90IGxhbmd1YWdlIHNob3VsZFxuXHRcdC8vIGZhbGxiYWNrIHRvIDIgbGV0dGVyIGNvZGUgZWcgXCJkZVwiXG5cdFx0aWYgKCFkYXRlc1tsYW5nXSl7XG5cdFx0XHRsYW5nID0gbGFuZy5zcGxpdCgnLScpWzBdO1xuXHRcdFx0aWYgKCFkYXRlc1tsYW5nXSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgZCA9IGRhdGVzW2xhbmddO1xuXHRcdCQuZWFjaChsb2NhbGVfb3B0cywgZnVuY3Rpb24oaSxrKXtcblx0XHRcdGlmIChrIGluIGQpXG5cdFx0XHRcdG91dFtrXSA9IGRba107XG5cdFx0fSk7XG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdHZhciBvbGQgPSAkLmZuLmRhdGVwaWNrZXI7XG5cdHZhciBkYXRlcGlja2VyUGx1Z2luID0gZnVuY3Rpb24ob3B0aW9uKXtcblx0XHR2YXIgYXJncyA9IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0YXJncy5zaGlmdCgpO1xuXHRcdHZhciBpbnRlcm5hbF9yZXR1cm47XG5cdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpLFxuXHRcdFx0XHRkYXRhID0gJHRoaXMuZGF0YSgnZGF0ZXBpY2tlcicpLFxuXHRcdFx0XHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuXHRcdFx0aWYgKCFkYXRhKXtcblx0XHRcdFx0dmFyIGVsb3B0cyA9IG9wdHNfZnJvbV9lbCh0aGlzLCAnZGF0ZScpLFxuXHRcdFx0XHRcdC8vIFByZWxpbWluYXJ5IG90aW9uc1xuXHRcdFx0XHRcdHhvcHRzID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBlbG9wdHMsIG9wdGlvbnMpLFxuXHRcdFx0XHRcdGxvY29wdHMgPSBvcHRzX2Zyb21fbG9jYWxlKHhvcHRzLmxhbmd1YWdlKSxcblx0XHRcdFx0XHQvLyBPcHRpb25zIHByaW9yaXR5OiBqcyBhcmdzLCBkYXRhLWF0dHJzLCBsb2NhbGVzLCBkZWZhdWx0c1xuXHRcdFx0XHRcdG9wdHMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGxvY29wdHMsIGVsb3B0cywgb3B0aW9ucyk7XG5cdFx0XHRcdGlmICgkdGhpcy5oYXNDbGFzcygnaW5wdXQtZGF0ZXJhbmdlJykgfHwgb3B0cy5pbnB1dHMpe1xuXHRcdFx0XHRcdCQuZXh0ZW5kKG9wdHMsIHtcblx0XHRcdFx0XHRcdGlucHV0czogb3B0cy5pbnB1dHMgfHwgJHRoaXMuZmluZCgnaW5wdXQnKS50b0FycmF5KClcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRkYXRhID0gbmV3IERhdGVSYW5nZVBpY2tlcih0aGlzLCBvcHRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRkYXRhID0gbmV3IERhdGVwaWNrZXIodGhpcywgb3B0cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JHRoaXMuZGF0YSgnZGF0ZXBpY2tlcicsIGRhdGEpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBkYXRhW29wdGlvbl0gPT09ICdmdW5jdGlvbicpe1xuXHRcdFx0XHRpbnRlcm5hbF9yZXR1cm4gPSBkYXRhW29wdGlvbl0uYXBwbHkoZGF0YSwgYXJncyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoXG5cdFx0XHRpbnRlcm5hbF9yZXR1cm4gPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0aW50ZXJuYWxfcmV0dXJuIGluc3RhbmNlb2YgRGF0ZXBpY2tlciB8fFxuXHRcdFx0aW50ZXJuYWxfcmV0dXJuIGluc3RhbmNlb2YgRGF0ZVJhbmdlUGlja2VyXG5cdFx0KVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRpZiAodGhpcy5sZW5ndGggPiAxKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVc2luZyBvbmx5IGFsbG93ZWQgZm9yIHRoZSBjb2xsZWN0aW9uIG9mIGEgc2luZ2xlIGVsZW1lbnQgKCcgKyBvcHRpb24gKyAnIGZ1bmN0aW9uKScpO1xuXHRcdGVsc2Vcblx0XHRcdHJldHVybiBpbnRlcm5hbF9yZXR1cm47XG5cdH07XG5cdCQuZm4uZGF0ZXBpY2tlciA9IGRhdGVwaWNrZXJQbHVnaW47XG5cblx0dmFyIGRlZmF1bHRzID0gJC5mbi5kYXRlcGlja2VyLmRlZmF1bHRzID0ge1xuXHRcdGFzc3VtZU5lYXJieVllYXI6IGZhbHNlLFxuXHRcdGF1dG9jbG9zZTogZmFsc2UsXG5cdFx0YmVmb3JlU2hvd0RheTogJC5ub29wLFxuXHRcdGJlZm9yZVNob3dNb250aDogJC5ub29wLFxuXHRcdGJlZm9yZVNob3dZZWFyOiAkLm5vb3AsXG5cdFx0YmVmb3JlU2hvd0RlY2FkZTogJC5ub29wLFxuXHRcdGJlZm9yZVNob3dDZW50dXJ5OiAkLm5vb3AsXG5cdFx0Y2FsZW5kYXJXZWVrczogZmFsc2UsXG5cdFx0Y2xlYXJCdG46IGZhbHNlLFxuXHRcdHRvZ2dsZUFjdGl2ZTogZmFsc2UsXG5cdFx0ZGF5c09mV2Vla0Rpc2FibGVkOiBbXSxcblx0XHRkYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQ6IFtdLFxuXHRcdGRhdGVzRGlzYWJsZWQ6IFtdLFxuXHRcdGVuZERhdGU6IEluZmluaXR5LFxuXHRcdGZvcmNlUGFyc2U6IHRydWUsXG5cdFx0Zm9ybWF0OiAnbW0vZGQveXl5eScsXG5cdFx0a2VlcEVtcHR5VmFsdWVzOiBmYWxzZSxcblx0XHRrZXlib2FyZE5hdmlnYXRpb246IHRydWUsXG5cdFx0bGFuZ3VhZ2U6ICdlbicsXG5cdFx0bWluVmlld01vZGU6IDAsXG5cdFx0bWF4Vmlld01vZGU6IDQsXG5cdFx0bXVsdGlkYXRlOiBmYWxzZSxcblx0XHRtdWx0aWRhdGVTZXBhcmF0b3I6ICcsJyxcblx0XHRvcmllbnRhdGlvbjogXCJhdXRvXCIsXG5cdFx0cnRsOiBmYWxzZSxcblx0XHRzdGFydERhdGU6IC1JbmZpbml0eSxcblx0XHRzdGFydFZpZXc6IDAsXG5cdFx0dG9kYXlCdG46IGZhbHNlLFxuXHRcdHRvZGF5SGlnaGxpZ2h0OiBmYWxzZSxcblx0XHR1cGRhdGVWaWV3RGF0ZTogdHJ1ZSxcblx0XHR3ZWVrU3RhcnQ6IDAsXG5cdFx0ZGlzYWJsZVRvdWNoS2V5Ym9hcmQ6IGZhbHNlLFxuXHRcdGVuYWJsZU9uUmVhZG9ubHk6IHRydWUsXG5cdFx0c2hvd09uRm9jdXM6IHRydWUsXG5cdFx0ekluZGV4T2Zmc2V0OiAxMCxcblx0XHRjb250YWluZXI6ICdib2R5Jyxcblx0XHRpbW1lZGlhdGVVcGRhdGVzOiBmYWxzZSxcblx0XHR0aXRsZTogJycsXG5cdFx0dGVtcGxhdGVzOiB7XG5cdFx0XHRsZWZ0QXJyb3c6ICcmI3gwMEFCOycsXG5cdFx0XHRyaWdodEFycm93OiAnJiN4MDBCQjsnXG5cdFx0fSxcbiAgICBzaG93V2Vla0RheXM6IHRydWVcblx0fTtcblx0dmFyIGxvY2FsZV9vcHRzID0gJC5mbi5kYXRlcGlja2VyLmxvY2FsZV9vcHRzID0gW1xuXHRcdCdmb3JtYXQnLFxuXHRcdCdydGwnLFxuXHRcdCd3ZWVrU3RhcnQnXG5cdF07XG5cdCQuZm4uZGF0ZXBpY2tlci5Db25zdHJ1Y3RvciA9IERhdGVwaWNrZXI7XG5cdHZhciBkYXRlcyA9ICQuZm4uZGF0ZXBpY2tlci5kYXRlcyA9IHtcblx0XHRlbjoge1xuXHRcdFx0ZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG5cdFx0XHRkYXlzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcblx0XHRcdGRheXNNaW46IFtcIlN1XCIsIFwiTW9cIiwgXCJUdVwiLCBcIldlXCIsIFwiVGhcIiwgXCJGclwiLCBcIlNhXCJdLFxuXHRcdFx0bW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcblx0XHRcdG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXG5cdFx0XHR0b2RheTogXCJUb2RheVwiLFxuXHRcdFx0Y2xlYXI6IFwiQ2xlYXJcIixcblx0XHRcdHRpdGxlRm9ybWF0OiBcIk1NIHl5eXlcIlxuXHRcdH1cblx0fTtcblxuXHR2YXIgRFBHbG9iYWwgPSB7XG5cdFx0dmlld01vZGVzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWVzOiBbJ2RheXMnLCAnbW9udGgnXSxcblx0XHRcdFx0Y2xzTmFtZTogJ2RheXMnLFxuXHRcdFx0XHRlOiAnY2hhbmdlTW9udGgnXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lczogWydtb250aHMnLCAneWVhciddLFxuXHRcdFx0XHRjbHNOYW1lOiAnbW9udGhzJyxcblx0XHRcdFx0ZTogJ2NoYW5nZVllYXInLFxuXHRcdFx0XHRuYXZTdGVwOiAxXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lczogWyd5ZWFycycsICdkZWNhZGUnXSxcblx0XHRcdFx0Y2xzTmFtZTogJ3llYXJzJyxcblx0XHRcdFx0ZTogJ2NoYW5nZURlY2FkZScsXG5cdFx0XHRcdG5hdlN0ZXA6IDEwXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lczogWydkZWNhZGVzJywgJ2NlbnR1cnknXSxcblx0XHRcdFx0Y2xzTmFtZTogJ2RlY2FkZXMnLFxuXHRcdFx0XHRlOiAnY2hhbmdlQ2VudHVyeScsXG5cdFx0XHRcdG5hdlN0ZXA6IDEwMFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZXM6IFsnY2VudHVyaWVzJywgJ21pbGxlbm5pdW0nXSxcblx0XHRcdFx0Y2xzTmFtZTogJ2NlbnR1cmllcycsXG5cdFx0XHRcdGU6ICdjaGFuZ2VNaWxsZW5uaXVtJyxcblx0XHRcdFx0bmF2U3RlcDogMTAwMFxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0dmFsaWRQYXJ0czogL2RkP3xERD98bW0/fE1NP3x5eSg/Onl5KT8vZyxcblx0XHRub25wdW5jdHVhdGlvbjogL1teIC1cXC86LUBcXHU1ZTc0XFx1NjcwOFxcdTY1ZTVcXFstYHstflxcdFxcblxccl0rL2csXG5cdFx0cGFyc2VGb3JtYXQ6IGZ1bmN0aW9uKGZvcm1hdCl7XG5cdFx0XHRpZiAodHlwZW9mIGZvcm1hdC50b1ZhbHVlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBmb3JtYXQudG9EaXNwbGF5ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgICAgICAvLyBJRSB0cmVhdHMgXFwwIGFzIGEgc3RyaW5nIGVuZCBpbiBpbnB1dHMgKHRydW5jYXRpbmcgdGhlIHZhbHVlKSxcblx0XHRcdC8vIHNvIGl0J3MgYSBiYWQgZm9ybWF0IGRlbGltaXRlciwgYW55d2F5XG5cdFx0XHR2YXIgc2VwYXJhdG9ycyA9IGZvcm1hdC5yZXBsYWNlKHRoaXMudmFsaWRQYXJ0cywgJ1xcMCcpLnNwbGl0KCdcXDAnKSxcblx0XHRcdFx0cGFydHMgPSBmb3JtYXQubWF0Y2godGhpcy52YWxpZFBhcnRzKTtcblx0XHRcdGlmICghc2VwYXJhdG9ycyB8fCAhc2VwYXJhdG9ycy5sZW5ndGggfHwgIXBhcnRzIHx8IHBhcnRzLmxlbmd0aCA9PT0gMCl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtzZXBhcmF0b3JzOiBzZXBhcmF0b3JzLCBwYXJ0czogcGFydHN9O1xuXHRcdH0sXG5cdFx0cGFyc2VEYXRlOiBmdW5jdGlvbihkYXRlLCBmb3JtYXQsIGxhbmd1YWdlLCBhc3N1bWVOZWFyYnkpe1xuXHRcdFx0aWYgKCFkYXRlKVxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0aWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKVxuXHRcdFx0XHRyZXR1cm4gZGF0ZTtcblx0XHRcdGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJylcblx0XHRcdFx0Zm9ybWF0ID0gRFBHbG9iYWwucGFyc2VGb3JtYXQoZm9ybWF0KTtcblx0XHRcdGlmIChmb3JtYXQudG9WYWx1ZSlcblx0XHRcdFx0cmV0dXJuIGZvcm1hdC50b1ZhbHVlKGRhdGUsIGZvcm1hdCwgbGFuZ3VhZ2UpO1xuXHRcdFx0dmFyIGZuX21hcCA9IHtcblx0XHRcdFx0XHRkOiAnbW92ZURheScsXG5cdFx0XHRcdFx0bTogJ21vdmVNb250aCcsXG5cdFx0XHRcdFx0dzogJ21vdmVXZWVrJyxcblx0XHRcdFx0XHR5OiAnbW92ZVllYXInXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGRhdGVBbGlhc2VzID0ge1xuXHRcdFx0XHRcdHllc3RlcmRheTogJy0xZCcsXG5cdFx0XHRcdFx0dG9kYXk6ICcrMGQnLFxuXHRcdFx0XHRcdHRvbW9ycm93OiAnKzFkJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRwYXJ0cywgcGFydCwgZGlyLCBpLCBmbjtcblx0XHRcdGlmIChkYXRlIGluIGRhdGVBbGlhc2VzKXtcblx0XHRcdFx0ZGF0ZSA9IGRhdGVBbGlhc2VzW2RhdGVdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKC9eW1xcLStdXFxkK1tkbXd5XShbXFxzLF0rW1xcLStdXFxkK1tkbXd5XSkqJC9pLnRlc3QoZGF0ZSkpe1xuXHRcdFx0XHRwYXJ0cyA9IGRhdGUubWF0Y2goLyhbXFwtK11cXGQrKShbZG13eV0pL2dpKTtcblx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdGZvciAoaT0wOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdHBhcnQgPSBwYXJ0c1tpXS5tYXRjaCgvKFtcXC0rXVxcZCspKFtkbXd5XSkvaSk7XG5cdFx0XHRcdFx0ZGlyID0gTnVtYmVyKHBhcnRbMV0pO1xuXHRcdFx0XHRcdGZuID0gZm5fbWFwW3BhcnRbMl0udG9Mb3dlckNhc2UoKV07XG5cdFx0XHRcdFx0ZGF0ZSA9IERhdGVwaWNrZXIucHJvdG90eXBlW2ZuXShkYXRlLCBkaXIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBEYXRlcGlja2VyLnByb3RvdHlwZS5femVyb191dGNfdGltZShkYXRlKTtcblx0XHRcdH1cblxuXHRcdFx0cGFydHMgPSBkYXRlICYmIGRhdGUubWF0Y2godGhpcy5ub25wdW5jdHVhdGlvbikgfHwgW107XG5cblx0XHRcdGZ1bmN0aW9uIGFwcGx5TmVhcmJ5WWVhcih5ZWFyLCB0aHJlc2hvbGQpe1xuXHRcdFx0XHRpZiAodGhyZXNob2xkID09PSB0cnVlKVxuXHRcdFx0XHRcdHRocmVzaG9sZCA9IDEwO1xuXG5cdFx0XHRcdC8vIGlmIHllYXIgaXMgMiBkaWdpdHMgb3IgbGVzcywgdGhhbiB0aGUgdXNlciBtb3N0IGxpa2VseSBpcyB0cnlpbmcgdG8gZ2V0IGEgcmVjZW50IGNlbnR1cnlcblx0XHRcdFx0aWYgKHllYXIgPCAxMDApe1xuXHRcdFx0XHRcdHllYXIgKz0gMjAwMDtcblx0XHRcdFx0XHQvLyBpZiB0aGUgbmV3IHllYXIgaXMgbW9yZSB0aGFuIHRocmVzaG9sZCB5ZWFycyBpbiBhZHZhbmNlLCB1c2UgbGFzdCBjZW50dXJ5XG5cdFx0XHRcdFx0aWYgKHllYXIgPiAoKG5ldyBEYXRlKCkpLmdldEZ1bGxZZWFyKCkrdGhyZXNob2xkKSl7XG5cdFx0XHRcdFx0XHR5ZWFyIC09IDEwMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4geWVhcjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHBhcnNlZCA9IHt9LFxuXHRcdFx0XHRzZXR0ZXJzX29yZGVyID0gWyd5eXl5JywgJ3l5JywgJ00nLCAnTU0nLCAnbScsICdtbScsICdkJywgJ2RkJ10sXG5cdFx0XHRcdHNldHRlcnNfbWFwID0ge1xuXHRcdFx0XHRcdHl5eXk6IGZ1bmN0aW9uKGQsdil7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZC5zZXRVVENGdWxsWWVhcihhc3N1bWVOZWFyYnkgPyBhcHBseU5lYXJieVllYXIodiwgYXNzdW1lTmVhcmJ5KSA6IHYpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bTogZnVuY3Rpb24oZCx2KXtcblx0XHRcdFx0XHRcdGlmIChpc05hTihkKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGQ7XG5cdFx0XHRcdFx0XHR2IC09IDE7XG5cdFx0XHRcdFx0XHR3aGlsZSAodiA8IDApIHYgKz0gMTI7XG5cdFx0XHRcdFx0XHR2ICU9IDEyO1xuXHRcdFx0XHRcdFx0ZC5zZXRVVENNb250aCh2KTtcblx0XHRcdFx0XHRcdHdoaWxlIChkLmdldFVUQ01vbnRoKCkgIT09IHYpXG5cdFx0XHRcdFx0XHRcdGQuc2V0VVRDRGF0ZShkLmdldFVUQ0RhdGUoKS0xKTtcblx0XHRcdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZDogZnVuY3Rpb24oZCx2KXtcblx0XHRcdFx0XHRcdHJldHVybiBkLnNldFVUQ0RhdGUodik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR2YWwsIGZpbHRlcmVkO1xuXHRcdFx0c2V0dGVyc19tYXBbJ3l5J10gPSBzZXR0ZXJzX21hcFsneXl5eSddO1xuXHRcdFx0c2V0dGVyc19tYXBbJ00nXSA9IHNldHRlcnNfbWFwWydNTSddID0gc2V0dGVyc19tYXBbJ21tJ10gPSBzZXR0ZXJzX21hcFsnbSddO1xuXHRcdFx0c2V0dGVyc19tYXBbJ2RkJ10gPSBzZXR0ZXJzX21hcFsnZCddO1xuXHRcdFx0ZGF0ZSA9IFVUQ1RvZGF5KCk7XG5cdFx0XHR2YXIgZnBhcnRzID0gZm9ybWF0LnBhcnRzLnNsaWNlKCk7XG5cdFx0XHQvLyBSZW1vdmUgbm9vcCBwYXJ0c1xuXHRcdFx0aWYgKHBhcnRzLmxlbmd0aCAhPT0gZnBhcnRzLmxlbmd0aCl7XG5cdFx0XHRcdGZwYXJ0cyA9ICQoZnBhcnRzKS5maWx0ZXIoZnVuY3Rpb24oaSxwKXtcblx0XHRcdFx0XHRyZXR1cm4gJC5pbkFycmF5KHAsIHNldHRlcnNfb3JkZXIpICE9PSAtMTtcblx0XHRcdFx0fSkudG9BcnJheSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUHJvY2VzcyByZW1haW5kZXJcblx0XHRcdGZ1bmN0aW9uIG1hdGNoX3BhcnQoKXtcblx0XHRcdFx0dmFyIG0gPSB0aGlzLnNsaWNlKDAsIHBhcnRzW2ldLmxlbmd0aCksXG5cdFx0XHRcdFx0cCA9IHBhcnRzW2ldLnNsaWNlKDAsIG0ubGVuZ3RoKTtcblx0XHRcdFx0cmV0dXJuIG0udG9Mb3dlckNhc2UoKSA9PT0gcC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBhcnRzLmxlbmd0aCA9PT0gZnBhcnRzLmxlbmd0aCl7XG5cdFx0XHRcdHZhciBjbnQ7XG5cdFx0XHRcdGZvciAoaT0wLCBjbnQgPSBmcGFydHMubGVuZ3RoOyBpIDwgY250OyBpKyspe1xuXHRcdFx0XHRcdHZhbCA9IHBhcnNlSW50KHBhcnRzW2ldLCAxMCk7XG5cdFx0XHRcdFx0cGFydCA9IGZwYXJ0c1tpXTtcblx0XHRcdFx0XHRpZiAoaXNOYU4odmFsKSl7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKHBhcnQpe1xuXHRcdFx0XHRcdFx0XHRjYXNlICdNTSc6XG5cdFx0XHRcdFx0XHRcdFx0ZmlsdGVyZWQgPSAkKGRhdGVzW2xhbmd1YWdlXS5tb250aHMpLmZpbHRlcihtYXRjaF9wYXJ0KTtcblx0XHRcdFx0XHRcdFx0XHR2YWwgPSAkLmluQXJyYXkoZmlsdGVyZWRbMF0sIGRhdGVzW2xhbmd1YWdlXS5tb250aHMpICsgMTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAnTSc6XG5cdFx0XHRcdFx0XHRcdFx0ZmlsdGVyZWQgPSAkKGRhdGVzW2xhbmd1YWdlXS5tb250aHNTaG9ydCkuZmlsdGVyKG1hdGNoX3BhcnQpO1xuXHRcdFx0XHRcdFx0XHRcdHZhbCA9ICQuaW5BcnJheShmaWx0ZXJlZFswXSwgZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1Nob3J0KSArIDE7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlZFtwYXJ0XSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgX2RhdGUsIHM7XG5cdFx0XHRcdGZvciAoaT0wOyBpIDwgc2V0dGVyc19vcmRlci5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0cyA9IHNldHRlcnNfb3JkZXJbaV07XG5cdFx0XHRcdFx0aWYgKHMgaW4gcGFyc2VkICYmICFpc05hTihwYXJzZWRbc10pKXtcblx0XHRcdFx0XHRcdF9kYXRlID0gbmV3IERhdGUoZGF0ZSk7XG5cdFx0XHRcdFx0XHRzZXR0ZXJzX21hcFtzXShfZGF0ZSwgcGFyc2VkW3NdKTtcblx0XHRcdFx0XHRcdGlmICghaXNOYU4oX2RhdGUpKVxuXHRcdFx0XHRcdFx0XHRkYXRlID0gX2RhdGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0ZTtcblx0XHR9LFxuXHRcdGZvcm1hdERhdGU6IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCwgbGFuZ3VhZ2Upe1xuXHRcdFx0aWYgKCFkYXRlKVxuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGZvcm1hdCA9IERQR2xvYmFsLnBhcnNlRm9ybWF0KGZvcm1hdCk7XG5cdFx0XHRpZiAoZm9ybWF0LnRvRGlzcGxheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0LnRvRGlzcGxheShkYXRlLCBmb3JtYXQsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIHZhciB2YWwgPSB7XG5cdFx0XHRcdGQ6IGRhdGUuZ2V0VVRDRGF0ZSgpLFxuXHRcdFx0XHREOiBkYXRlc1tsYW5ndWFnZV0uZGF5c1Nob3J0W2RhdGUuZ2V0VVRDRGF5KCldLFxuXHRcdFx0XHRERDogZGF0ZXNbbGFuZ3VhZ2VdLmRheXNbZGF0ZS5nZXRVVENEYXkoKV0sXG5cdFx0XHRcdG06IGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsXG5cdFx0XHRcdE06IGRhdGVzW2xhbmd1YWdlXS5tb250aHNTaG9ydFtkYXRlLmdldFVUQ01vbnRoKCldLFxuXHRcdFx0XHRNTTogZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1tkYXRlLmdldFVUQ01vbnRoKCldLFxuXHRcdFx0XHR5eTogZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFxuXHRcdFx0XHR5eXl5OiBkYXRlLmdldFVUQ0Z1bGxZZWFyKClcblx0XHRcdH07XG5cdFx0XHR2YWwuZGQgPSAodmFsLmQgPCAxMCA/ICcwJyA6ICcnKSArIHZhbC5kO1xuXHRcdFx0dmFsLm1tID0gKHZhbC5tIDwgMTAgPyAnMCcgOiAnJykgKyB2YWwubTtcblx0XHRcdGRhdGUgPSBbXTtcblx0XHRcdHZhciBzZXBzID0gJC5leHRlbmQoW10sIGZvcm1hdC5zZXBhcmF0b3JzKTtcblx0XHRcdGZvciAodmFyIGk9MCwgY250ID0gZm9ybWF0LnBhcnRzLmxlbmd0aDsgaSA8PSBjbnQ7IGkrKyl7XG5cdFx0XHRcdGlmIChzZXBzLmxlbmd0aClcblx0XHRcdFx0XHRkYXRlLnB1c2goc2Vwcy5zaGlmdCgpKTtcblx0XHRcdFx0ZGF0ZS5wdXNoKHZhbFtmb3JtYXQucGFydHNbaV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRlLmpvaW4oJycpO1xuXHRcdH0sXG5cdFx0aGVhZFRlbXBsYXRlOiAnPHRoZWFkPicrXG5cdFx0XHQgICAgICAgICAgICAgICc8dHI+Jytcblx0XHRcdCAgICAgICAgICAgICAgICAnPHRoIGNvbHNwYW49XCI3XCIgY2xhc3M9XCJkYXRlcGlja2VyLXRpdGxlXCI+PC90aD4nK1xuXHRcdFx0ICAgICAgICAgICAgICAnPC90cj4nK1xuXHRcdFx0XHRcdFx0XHQnPHRyPicrXG5cdFx0XHRcdFx0XHRcdFx0Jzx0aCBjbGFzcz1cInByZXZcIj4nK2RlZmF1bHRzLnRlbXBsYXRlcy5sZWZ0QXJyb3crJzwvdGg+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNvbHNwYW49XCI1XCIgY2xhc3M9XCJkYXRlcGlja2VyLXN3aXRjaFwiPjwvdGg+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNsYXNzPVwibmV4dFwiPicrZGVmYXVsdHMudGVtcGxhdGVzLnJpZ2h0QXJyb3crJzwvdGg+Jytcblx0XHRcdFx0XHRcdFx0JzwvdHI+Jytcblx0XHRcdFx0XHRcdCc8L3RoZWFkPicsXG5cdFx0Y29udFRlbXBsYXRlOiAnPHRib2R5Pjx0cj48dGQgY29sc3Bhbj1cIjdcIj48L3RkPjwvdHI+PC90Ym9keT4nLFxuXHRcdGZvb3RUZW1wbGF0ZTogJzx0Zm9vdD4nK1xuXHRcdFx0XHRcdFx0XHQnPHRyPicrXG5cdFx0XHRcdFx0XHRcdFx0Jzx0aCBjb2xzcGFuPVwiN1wiIGNsYXNzPVwidG9kYXlcIj48L3RoPicrXG5cdFx0XHRcdFx0XHRcdCc8L3RyPicrXG5cdFx0XHRcdFx0XHRcdCc8dHI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNvbHNwYW49XCI3XCIgY2xhc3M9XCJjbGVhclwiPjwvdGg+Jytcblx0XHRcdFx0XHRcdFx0JzwvdHI+Jytcblx0XHRcdFx0XHRcdCc8L3Rmb290Pidcblx0fTtcblx0RFBHbG9iYWwudGVtcGxhdGUgPSAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXJcIj4nK1xuXHRcdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItZGF5c1wiPicrXG5cdFx0XHRcdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5oZWFkVGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0XHQnPHRib2R5PjwvdGJvZHk+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xuXHRcdFx0XHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLW1vbnRoc1wiPicrXG5cdFx0XHRcdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5oZWFkVGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5jb250VGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5mb290VGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0JzwvdGFibGU+Jytcblx0XHRcdFx0XHRcdFx0JzwvZGl2PicrXG5cdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci15ZWFyc1wiPicrXG5cdFx0XHRcdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5oZWFkVGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5jb250VGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5mb290VGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0JzwvdGFibGU+Jytcblx0XHRcdFx0XHRcdFx0JzwvZGl2PicrXG5cdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1kZWNhZGVzXCI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmNvbnRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xuXHRcdFx0XHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWNlbnR1cmllc1wiPicrXG5cdFx0XHRcdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5oZWFkVGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5jb250VGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5mb290VGVtcGxhdGUrXG5cdFx0XHRcdFx0XHRcdFx0JzwvdGFibGU+Jytcblx0XHRcdFx0XHRcdFx0JzwvZGl2PicrXG5cdFx0XHRcdFx0XHQnPC9kaXY+JztcblxuXHQkLmZuLmRhdGVwaWNrZXIuRFBHbG9iYWwgPSBEUEdsb2JhbDtcblxuXG5cdC8qIERBVEVQSUNLRVIgTk8gQ09ORkxJQ1Rcblx0KiA9PT09PT09PT09PT09PT09PT09ICovXG5cblx0JC5mbi5kYXRlcGlja2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpe1xuXHRcdCQuZm4uZGF0ZXBpY2tlciA9IG9sZDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKiBEQVRFUElDS0VSIFZFUlNJT05cblx0ICogPT09PT09PT09PT09PT09PT09PSAqL1xuXHQkLmZuLmRhdGVwaWNrZXIudmVyc2lvbiA9ICcxLjguMCc7XG5cblx0JC5mbi5kYXRlcGlja2VyLmRlcHJlY2F0ZWQgPSBmdW5jdGlvbihtc2cpe1xuXHRcdHZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XG5cdFx0aWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0RFUFJFQ0FURUQ6ICcgKyBtc2cpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qIERBVEVQSUNLRVIgREFUQS1BUElcblx0KiA9PT09PT09PT09PT09PT09PT0gKi9cblxuXHQkKGRvY3VtZW50KS5vbihcblx0XHQnZm9jdXMuZGF0ZXBpY2tlci5kYXRhLWFwaSBjbGljay5kYXRlcGlja2VyLmRhdGEtYXBpJyxcblx0XHQnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXJcIl0nLFxuXHRcdGZ1bmN0aW9uKGUpe1xuXHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKTtcblx0XHRcdGlmICgkdGhpcy5kYXRhKCdkYXRlcGlja2VyJykpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdC8vIGNvbXBvbmVudCBjbGljayByZXF1aXJlcyB1cyB0byBleHBsaWNpdGx5IHNob3cgaXRcblx0XHRcdGRhdGVwaWNrZXJQbHVnaW4uY2FsbCgkdGhpcywgJ3Nob3cnKTtcblx0XHR9XG5cdCk7XG5cdCQoZnVuY3Rpb24oKXtcblx0XHRkYXRlcGlja2VyUGx1Z2luLmNhbGwoJCgnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXItaW5saW5lXCJdJykpO1xuXHR9KTtcblxufSkpO1xuIiwiLyoqXG4gKiBTbG92YWsgdHJhbnNsYXRpb24gZm9yIGJvb3RzdHJhcC1kYXRlcGlja2VyXG4gKiBNYXJlayBMaWNodG5lciA8bWFyZWtAbGljaHQuc2s+XG4gKiBGaXhlcyBieSBNaWNoYWwgUmVtacWhIDxtaWNoYWwucmVtaXNAZ21haWwuY29tPlxuICovXG47KGZ1bmN0aW9uKCQpe1xuXHQkLmZuLmRhdGVwaWNrZXIuZGF0ZXNbXCJza1wiXSA9IHtcblx0XHRkYXlzOiBbXCJOZWRlxL5hXCIsIFwiUG9uZGVsb2tcIiwgXCJVdG9yb2tcIiwgXCJTdHJlZGFcIiwgXCLFoHR2cnRva1wiLCBcIlBpYXRva1wiLCBcIlNvYm90YVwiXSxcblx0XHRkYXlzU2hvcnQ6IFtcIk5lZFwiLCBcIlBvblwiLCBcIlV0b1wiLCBcIlN0clwiLCBcIsWgdHZcIiwgXCJQaWFcIiwgXCJTb2JcIl0sXG5cdFx0ZGF5c01pbjogW1wiTmVcIiwgXCJQb1wiLCBcIlV0XCIsIFwiU3RcIiwgXCLFoHRcIiwgXCJQaWFcIiwgXCJTb1wiXSxcblx0XHRtb250aHM6IFtcIkphbnXDoXJcIiwgXCJGZWJydcOhclwiLCBcIk1hcmVjXCIsIFwiQXByw61sXCIsIFwiTcOhalwiLCBcIkrDum5cIiwgXCJKw7psXCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2t0w7NiZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuXHRcdG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNw6FqXCIsIFwiSsO6blwiLCBcIkrDumxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPa3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXG5cdFx0dG9kYXk6IFwiRG5lc1wiLFxuXHRcdGNsZWFyOiBcIlZ5bWF6YcWlXCIsXG5cdFx0d2Vla1N0YXJ0OiAxLFxuXHRcdGZvcm1hdDogXCJkLm0ueXl5eVwiXG5cdH07XG59KGpRdWVyeSkpO1xuIiwiLyoqXG4gKiBTeW50YXhIaWdobGlnaHRlclxuICogaHR0cDovL2FsZXhnb3JiYXRjaGV2LmNvbS9TeW50YXhIaWdobGlnaHRlclxuICpcbiAqIFN5bnRheEhpZ2hsaWdodGVyIGlzIGRvbmF0aW9ud2FyZS4gSWYgeW91IGFyZSB1c2luZyBpdCwgcGxlYXNlIGRvbmF0ZS5cbiAqIGh0dHA6Ly9hbGV4Z29yYmF0Y2hldi5jb20vU3ludGF4SGlnaGxpZ2h0ZXIvZG9uYXRlLmh0bWxcbiAqXG4gKiBAdmVyc2lvblxuICogMy4wLjgzIChKdWx5IDAyIDIwMTApXG4gKiBcbiAqIEBjb3B5cmlnaHRcbiAqIENvcHlyaWdodCAoQykgMjAwNC0yMDEwIEFsZXggR29yYmF0Y2hldi5cbiAqXG4gKiBAbGljZW5zZVxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXMuXG4gKi9cbmV2YWwoZnVuY3Rpb24ocCxhLGMsayxlLGQpe2U9ZnVuY3Rpb24oYyl7cmV0dXJuKGM8YT8nJzplKHBhcnNlSW50KGMvYSkpKSsoKGM9YyVhKT4zNT9TdHJpbmcuZnJvbUNoYXJDb2RlKGMrMjkpOmMudG9TdHJpbmcoMzYpKX07aWYoIScnLnJlcGxhY2UoL14vLFN0cmluZykpe3doaWxlKGMtLSl7ZFtlKGMpXT1rW2NdfHxlKGMpfWs9W2Z1bmN0aW9uKGUpe3JldHVybiBkW2VdfV07ZT1mdW5jdGlvbigpe3JldHVybidcXFxcdysnfTtjPTF9O3doaWxlKGMtLSl7aWYoa1tjXSl7cD1wLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGInK2UoYykrJ1xcXFxiJywnZycpLGtbY10pfX1yZXR1cm4gcH0oJ0sgTTtJKE0pMVMgMlUoXCIyYVxcJ3QgNGsgTSA0SyAyZyAzbCA0RyA0SFwiKTsoNigpezYgcihmLGUpe0koIU0uMVIoZikpMVMgM20oXCIzcyAxNSA0UlwiKTtLIGE9Zi4xdztmPU0oZi4xbSx0KGYpKyhlfHxcIlwiKSk7SShhKWYuMXc9ezFtOmEuMW0sMTk6YS4xOT9hLjE5LjFhKDApOk59O0ggZn02IHQoZil7SChmLjFKP1wiZ1wiOlwiXCIpKyhmLjRzP1wiaVwiOlwiXCIpKyhmLjRwP1wibVwiOlwiXCIpKyhmLjR2P1wieFwiOlwiXCIpKyhmLjNuP1wieVwiOlwiXCIpfTYgQihmLGUsYSxiKXtLIGM9dS5MLGQsaCxnO3Y9Ujs1S3tPKDtjLS07KXtnPXVbY107SShhJmcuM3ImJighZy4ycHx8Zy4ycC5XKGIpKSl7Zy4ycS4xMj1lO0koKGg9Zy4ycS5YKGYpKSYmaC5QPT09ZSl7ZD17M2s6Zy4yYi5XKGIsaCxhKSwxQzpofTsxTn19fX01dihpKXsxUyBpfTVxe3Y9MTF9SCBkfTYgcChmLGUsYSl7SSgzYi5aLjFpKUggZi4xaShlLGEpO08oYT1hfHwwO2E8Zi5MO2ErKylJKGZbYV09PT1lKUggYTtILTF9TT02KGYsZSl7SyBhPVtdLGI9TS4xQixjPTAsZCxoO0koTS4xUihmKSl7SShlIT09MWQpMVMgM20oXCIyYVxcJ3QgNXIgNUkgNUYgNUIgNUMgMTUgNUUgNXBcIik7SCByKGYpfUkodikxUyAyVShcIjJhXFwndCBXIDNsIE0gNTkgNW0gNWcgNXggNWlcIik7ZT1lfHxcIlwiO08oZD17Mk46MTEsMTk6W10sMks6NihnKXtIIGUuMWkoZyk+LTF9LDNkOjYoZyl7ZSs9Z319O2M8Zi5MOylJKGg9QihmLGMsYixkKSl7YS5VKGguM2spO2MrPWguMUNbMF0uTHx8MX1ZIEkoaD1uLlguVyh6W2JdLGYuMWEoYykpKXthLlUoaFswXSk7Yys9aFswXS5MfVl7aD1mLjNhKGMpO0koaD09PVwiW1wiKWI9TS4ySTtZIEkoaD09PVwiXVwiKWI9TS4xQjthLlUoaCk7YysrfWE9MTUoYS4xSyhcIlwiKSxuLlEuVyhlLHcsXCJcIikpO2EuMXc9ezFtOmYsMTk6ZC4yTj9kLjE5Ok59O0ggYX07TS4zdj1cIjEuNS4wXCI7TS4yST0xO00uMUI9MjtLIEM9L1xcXFwkKD86KFxcXFxkXFxcXGQ/fFskJmBcXCddKXx7KFskXFxcXHddKyl9KS9nLHc9L1teNWhdK3woW1xcXFxzXFxcXFNdKSg/PVtcXFxcc1xcXFxTXSpcXFxcMSkvZyxBPS9eKD86Wz8qK118e1xcXFxkKyg/OixcXFxcZCopP30pXFxcXD8/Lyx2PTExLHU9W10sbj17WDoxNS5aLlgsMUE6MTUuWi4xQSwxQzoxci5aLjFDLFE6MXIuWi5RLDFlOjFyLlouMWV9LHg9bi5YLlcoLygpPz8vLFwiXCIpWzFdPT09MWQsRD02KCl7SyBmPS9eL2c7bi4xQS5XKGYsXCJcIik7SCFmLjEyfSgpLHk9Nigpe0sgZj0veC9nO24uUS5XKFwieFwiLGYsXCJcIik7SCFmLjEyfSgpLEU9MTUuWi4zbiE9PTFkLHo9e307eltNLjJJXT0vXig/OlxcXFxcXFxcKD86WzAtM11bMC03XXswLDJ9fFs0LTddWzAtN10/fHhbXFxcXDI5LTI2LWZdezJ9fHVbXFxcXDI5LTI2LWZdezR9fGNbQS0zby16XXxbXFxcXHNcXFxcU10pKS87eltNLjFCXT0vXig/OlxcXFxcXFxcKD86MCg/OlswLTNdWzAtN117MCwyfXxbNC03XVswLTddPyk/fFsxLTldXFxcXGQqfHhbXFxcXDI5LTI2LWZdezJ9fHVbXFxcXDI5LTI2LWZdezR9fGNbQS0zby16XXxbXFxcXHNcXFxcU10pfFxcXFwoXFxcXD9bOj0hXXxbPyorXVxcXFw/fHtcXFxcZCsoPzosXFxcXGQqKT99XFxcXD8/KS87TS4xaD02KGYsZSxhLGIpe3UuVSh7MnE6cihmLFwiZ1wiKyhFP1wieVwiOlwiXCIpKSwyYjplLDNyOmF8fE0uMUIsMnA6Ynx8Tn0pfTtNLjJuPTYoZixlKXtLIGE9ZitcIi9cIisoZXx8XCJcIik7SCBNLjJuW2FdfHwoTS4yblthXT1NKGYsZSkpfTtNLjNjPTYoZil7SCByKGYsXCJnXCIpfTtNLjVsPTYoZil7SCBmLlEoL1stW1xcXFxde30oKSorPy4sXFxcXFxcXFxeJHwjXFxcXHNdL2csXCJcXFxcXFxcXCQmXCIpfTtNLjVlPTYoZixlLGEsYil7ZT1yKGUsXCJnXCIrKGImJkU/XCJ5XCI6XCJcIikpO2UuMTI9YT1hfHwwO2Y9ZS5YKGYpO0ggYj9mJiZmLlA9PT1hP2Y6TjpmfTtNLjNxPTYoKXtNLjFoPTYoKXsxUyAyVShcIjJhXFwndCA1NSAxaCA1NCAzcVwiKX19O00uMVI9NihmKXtIIDUzLlouMXEuVyhmKT09PVwiWzJtIDE1XVwifTtNLjNwPTYoZixlLGEsYil7TyhLIGM9cihlLFwiZ1wiKSxkPS0xLGg7aD1jLlgoZik7KXthLlcoYixoLCsrZCxmLGMpO2MuMTI9PT1oLlAmJmMuMTIrK31JKGUuMUopZS4xMj0wfTtNLjU3PTYoZixlKXtIIDYgYShiLGMpe0sgZD1lW2NdLjFJP2VbY106ezFJOmVbY119LGg9cihkLjFJLFwiZ1wiKSxnPVtdLGk7TyhpPTA7aTxiLkw7aSsrKU0uM3AoYltpXSxoLDYoayl7Zy5VKGQuM2o/a1tkLjNqXXx8XCJcIjprWzBdKX0pO0ggYz09PWUuTC0xfHwhZy5MP2c6YShnLGMrMSl9KFtmXSwwKX07MTUuWi4xcD02KGYsZSl7SCBKLlgoZVswXSl9OzE1LlouVz02KGYsZSl7SCBKLlgoZSl9OzE1LlouWD02KGYpe0sgZT1uLlguMXAoSiwxNCksYTtJKGUpe0koIXgmJmUuTD4xJiZwKGUsXCJcIik+LTEpe2E9MTUoSi4xbSxuLlEuVyh0KEopLFwiZ1wiLFwiXCIpKTtuLlEuVyhmLjFhKGUuUCksYSw2KCl7TyhLIGM9MTtjPDE0LkwtMjtjKyspSSgxNFtjXT09PTFkKWVbY109MWR9KX1JKEouMXcmJkouMXcuMTkpTyhLIGI9MTtiPGUuTDtiKyspSShhPUouMXcuMTlbYi0xXSllW2FdPWVbYl07IUQmJkouMUomJiFlWzBdLkwmJkouMTI+ZS5QJiZKLjEyLS19SCBlfTtJKCFEKTE1LlouMUE9NihmKXsoZj1uLlguVyhKLGYpKSYmSi4xSiYmIWZbMF0uTCYmSi4xMj5mLlAmJkouMTItLTtIISFmfTsxci5aLjFDPTYoZil7TS4xUihmKXx8KGY9MTUoZikpO0koZi4xSil7SyBlPW4uMUMuMXAoSiwxNCk7Zi4xMj0wO0ggZX1IIGYuWChKKX07MXIuWi5RPTYoZixlKXtLIGE9TS4xUihmKSxiLGM7SShhJiYxaiBlLjU4KCk9PT1cIjNmXCImJmUuMWkoXCIke1wiKT09PS0xJiZ5KUggbi5RLjFwKEosMTQpO0koYSl7SShmLjF3KWI9Zi4xdy4xOX1ZIGYrPVwiXCI7SSgxaiBlPT09XCI2XCIpYz1uLlEuVyhKLGYsNigpe0koYil7MTRbMF09MWYgMXIoMTRbMF0pO08oSyBkPTA7ZDxiLkw7ZCsrKUkoYltkXSkxNFswXVtiW2RdXT0xNFtkKzFdfUkoYSYmZi4xSilmLjEyPTE0WzE0LkwtMl0rMTRbMF0uTDtIIGUuMXAoTiwxNCl9KTtZe2M9SitcIlwiO2M9bi5RLlcoYyxmLDYoKXtLIGQ9MTQ7SCBuLlEuVyhlLEMsNihoLGcsaSl7SShnKTViKGcpezI0XCIkXCI6SFwiJFwiOzI0XCImXCI6SCBkWzBdOzI0XCJgXCI6SCBkW2QuTC0xXS4xYSgwLGRbZC5MLTJdKTsyNFwiXFwnXCI6SCBkW2QuTC0xXS4xYShkW2QuTC0yXStkWzBdLkwpOzVhOmk9XCJcIjtnPStnO0koIWcpSCBoO08oO2c+ZC5MLTM7KXtpPTFyLlouMWEuVyhnLC0xKStpO2c9MVEuM2koZy8xMCl9SChnP2RbZ118fFwiXCI6XCIkXCIpK2l9WXtnPStpO0koZzw9ZC5MLTMpSCBkW2ddO2c9Yj9wKGIsaSk6LTE7SCBnPi0xP2RbZysxXTpofX0pfSl9SShhJiZmLjFKKWYuMTI9MDtIIGN9OzFyLlouMWU9NihmLGUpe0koIU0uMVIoZikpSCBuLjFlLjFwKEosMTQpO0sgYT1KK1wiXCIsYj1bXSxjPTAsZCxoO0koZT09PTFkfHwrZTwwKWU9NUQ7WXtlPTFRLjNpKCtlKTtJKCFlKUhbXX1PKGY9TS4zYyhmKTtkPWYuWChhKTspe0koZi4xMj5jKXtiLlUoYS4xYShjLGQuUCkpO2QuTD4xJiZkLlA8YS5MJiYzYi5aLlUuMXAoYixkLjFhKDEpKTtoPWRbMF0uTDtjPWYuMTI7SShiLkw+PWUpMU59Zi4xMj09PWQuUCYmZi4xMisrfUkoYz09PWEuTCl7SSghbi4xQS5XKGYsXCJcIil8fGgpYi5VKFwiXCIpfVkgYi5VKGEuMWEoYykpO0ggYi5MPmU/Yi4xYSgwLGUpOmJ9O00uMWgoL1xcXFwoXFxcXD8jW14pXSpcXFxcKS8sNihmKXtIIG4uMUEuVyhBLGYuMlMuMWEoZi5QK2ZbMF0uTCkpP1wiXCI6XCIoPzopXCJ9KTtNLjFoKC9cXFxcKCg/IVxcXFw/KS8sNigpe0ouMTkuVShOKTtIXCIoXCJ9KTtNLjFoKC9cXFxcKFxcXFw/PChbJFxcXFx3XSspPi8sNihmKXtKLjE5LlUoZlsxXSk7Si4yTj1SO0hcIihcIn0pO00uMWgoL1xcXFxcXFxcazwoW1xcXFx3JF0rKT4vLDYoZil7SyBlPXAoSi4xOSxmWzFdKTtIIGU+LTE/XCJcXFxcXFxcXFwiKyhlKzEpKygzUihmLjJTLjNhKGYuUCtmWzBdLkwpKT9cIlwiOlwiKD86KVwiKTpmWzBdfSk7TS4xaCgvXFxcXFtcXFxcXj9dLyw2KGYpe0ggZlswXT09PVwiW11cIj9cIlxcXFxcXFxcYlxcXFxcXFxcQlwiOlwiW1xcXFxcXFxcc1xcXFxcXFxcU11cIn0pO00uMWgoL15cXFxcKFxcXFw/KFs1QV0rKVxcXFwpLyw2KGYpe0ouM2QoZlsxXSk7SFwiXCJ9KTtNLjFoKC8oPzpcXFxccyt8Iy4qKSsvLDYoZil7SCBuLjFBLlcoQSxmLjJTLjFhKGYuUCtmWzBdLkwpKT9cIlwiOlwiKD86KVwifSxNLjFCLDYoKXtIIEouMksoXCJ4XCIpfSk7TS4xaCgvXFxcXC4vLDYoKXtIXCJbXFxcXFxcXFxzXFxcXFxcXFxTXVwifSxNLjFCLDYoKXtIIEouMksoXCJzXCIpfSl9KSgpOzFqIDJlIT1cIjFkXCImJigyZS5NPU0pO0sgMXY9NigpezYgcihhLGIpe2EuMWwuMWkoYikhPS0xfHwoYS4xbCs9XCIgXCIrYil9NiB0KGEpe0ggYS4xaShcIjNlXCIpPT0wP2E6XCIzZVwiK2F9NiBCKGEpe0ggZS4xWS4yQVt0KGEpXX02IHAoYSxiLGMpe0koYT09TilIIE47SyBkPWMhPVI/YS4zRzpbYS4yR10saD17XCIjXCI6XCIxY1wiLFwiLlwiOlwiMWxcIn1bYi4xbygwLDEpXXx8XCIzaFwiLGcsaTtnPWghPVwiM2hcIj9iLjFvKDEpOmIuNXUoKTtJKChhW2hdfHxcIlwiKS4xaShnKSE9LTEpSCBhO08oYT0wO2QmJmE8ZC5MJiZpPT1OO2ErKylpPXAoZFthXSxiLGMpO0ggaX02IEMoYSxiKXtLIGM9e30sZDtPKGQgMmcgYSljW2RdPWFbZF07TyhkIDJnIGIpY1tkXT1iW2RdO0ggY302IHcoYSxiLGMsZCl7NiBoKGcpe2c9Z3x8MVAuNXk7SSghZy4xRil7Zy4xRj1nLjUyO2cuM049Nigpe0ouNXc9MTF9fWMuVyhkfHwxUCxnKX1hLjNnP2EuM2coXCI0VVwiK2IsaCk6YS40eShiLGgsMTEpfTYgQShhLGIpe0sgYz1lLjFZLjJqLGQ9TjtJKGM9PU4pe2M9e307TyhLIGggMmcgZS4xVSl7SyBnPWUuMVVbaF07ZD1nLjR4O0koZCE9Til7Zy4xVj1oLjR3KCk7TyhnPTA7ZzxkLkw7ZysrKWNbZFtnXV09aH19ZS4xWS4yaj1jfWQ9ZS4xVVtjW2FdXTtkPT1OJiZiIT0xMSYmMVAuMVgoZS4xMy4xeC4xWCsoZS4xMy4xeC4zRSthKSk7SCBkfTYgdihhLGIpe08oSyBjPWEuMWUoXCJcXFxcblwiKSxkPTA7ZDxjLkw7ZCsrKWNbZF09YihjW2RdLGQpO0ggYy4xSyhcIlxcXFxuXCIpfTYgdShhLGIpe0koYT09Tnx8YS5MPT0wfHxhPT1cIlxcXFxuXCIpSCBhO2E9YS5RKC88L2csXCImMXk7XCIpO2E9YS5RKC8gezIsfS9nLDYoYyl7TyhLIGQ9XCJcIixoPTA7aDxjLkwtMTtoKyspZCs9ZS4xMy4xVztIIGQrXCIgXCJ9KTtJKGIhPU4pYT12KGEsNihjKXtJKGMuTD09MClIXCJcIjtLIGQ9XCJcIjtjPWMuUSgvXigmMnM7fCApKy8sNihoKXtkPWg7SFwiXCJ9KTtJKGMuTD09MClIIGQ7SCBkK1xcJzwxNyAxZz1cIlxcJytiK1xcJ1wiPlxcJytjK1wiPC8xNz5cIn0pO0ggYX02IG4oYSxiKXthLjFlKFwiXFxcXG5cIik7TyhLIGM9XCJcIixkPTA7ZDw1MDtkKyspYys9XCIgICAgICAgICAgICAgICAgICAgIFwiO0ggYT12KGEsNihoKXtJKGguMWkoXCJcXFxcdFwiKT09LTEpSCBoO08oSyBnPTA7KGc9aC4xaShcIlxcXFx0XCIpKSE9LTE7KWg9aC4xbygwLGcpK2MuMW8oMCxiLWclYikraC4xbyhnKzEsaC5MKTtIIGh9KX02IHgoYSl7SCBhLlEoL15cXFxccyt8XFxcXHMrJC9nLFwiXCIpfTYgRChhLGIpe0koYS5QPGIuUClILTE7WSBJKGEuUD5iLlApSCAxO1kgSShhLkw8Yi5MKUgtMTtZIEkoYS5MPmIuTClIIDE7SCAwfTYgeShhLGIpezYgYyhrKXtIIGtbMF19TyhLIGQ9TixoPVtdLGc9Yi4yRD9iLjJEOmM7KGQ9Yi4xSS5YKGEpKSE9Tjspe0sgaT1nKGQsYik7SSgxaiBpPT1cIjNmXCIpaT1bMWYgZS4yTChpLGQuUCxiLjIzKV07aD1oLjFPKGkpfUggaH02IEUoYSl7SyBiPS8oLiopKCgmMUc7fCYxeTspLiopLztIIGEuUShlLjNBLjNNLDYoYyl7SyBkPVwiXCIsaD1OO0koaD1iLlgoYykpe2M9aFsxXTtkPWhbMl19SFxcJzxhIDJoPVwiXFwnK2MrXFwnXCI+XFwnK2MrXCI8L2E+XCIrZH0pfTYgeigpe08oSyBhPTFFLjM2KFwiMWtcIiksYj1bXSxjPTA7YzxhLkw7YysrKWFbY10uM3M9PVwiMjBcIiYmYi5VKGFbY10pO0ggYn02IGYoYSl7YT1hLjFGO0sgYj1wKGEsXCIuMjBcIixSKTthPXAoYSxcIi4zT1wiLFIpO0sgYz0xRS40aShcIjN0XCIpO0koISghYXx8IWJ8fHAoYSxcIjN0XCIpKSl7QihiLjFjKTtyKGIsXCIxbVwiKTtPKEsgZD1hLjNHLGg9W10sZz0wO2c8ZC5MO2crKyloLlUoZFtnXS40enx8ZFtnXS40QSk7aD1oLjFLKFwiXFxcXHJcIik7Yy4zOSgxRS40RChoKSk7YS4zOShjKTtjLjJDKCk7Yy40QygpO3coYyxcIjR1XCIsNigpe2MuMkcuNEUoYyk7Yi4xbD1iLjFsLlEoXCIxbVwiLFwiXCIpfSl9fUkoMWogM0YhPVwiMWRcIiYmMWogTT09XCIxZFwiKU09M0YoXCJNXCIpLk07SyBlPXsydjp7XCIxZy0yN1wiOlwiXCIsXCIyaS0xc1wiOjEsXCIyei0xcy0ydFwiOjExLDFNOk4sMXQ6TixcIjQyLTQ1XCI6UixcIjQzLTIyXCI6NCwxdTpSLDE2OlIsXCIzVi0xN1wiOlIsMmw6MTEsXCI0MS00MFwiOlIsMms6MTEsXCIxei0xa1wiOjExfSwxMzp7MVc6XCImMnM7XCIsMk06Uiw0NjoxMSw0NDoxMSwzNDpcIjRuXCIsMXg6ezIxOlwiNG8gMW1cIiwyUDpcIj9cIiwxWDpcIjF2XFxcXG5cXFxcblwiLDNFOlwiNHJcXCd0IDR0IDFEIE86IFwiLDRnOlwiNG0gNEJcXCd0IDUxIE8gMXotMWsgNEY6IFwiLDM3OlxcJzwhNFQgMXogNFMgXCItLy80Vi8vM0ggNFcgMS4wIDRaLy80WVwiIFwiMVo6Ly8yeS4zTC4zSy80WC8zSS8zSC8zSS00UC40SlwiPjwxeiA0ST1cIjFaOi8vMnkuM0wuM0svNEwvNUxcIj48M0o+PDROIDFaLTRNPVwiNUctNU1cIiA2Sz1cIjJPLzF6OyA2Sj02SS04XCIgLz48MXQ+NkwgMXY8LzF0PjwvM0o+PDNCIDFMPVwiMjUtNk06NlEsNlAsNk8sNk4tNkY7NnktMmY6IzZ4OzJmOiM2dzsyNS0yMjo2djsyTy0zRDozQztcIj48VCAxTD1cIjJPLTNEOjNDOzN3LTMyOjEuNno7XCI+PFQgMUw9XCIyNS0yMjo2QS02RTtcIj4xdjwvVD48VCAxTD1cIjI1LTIyOi42Qzszdy02Qjo2UjtcIj48VD4zdiAzLjAuNzYgKDcyIDczIDN4KTwvVD48VD48YSAyaD1cIjFaOi8vM3UuMncvMXZcIiAxRj1cIjM4XCIgMUw9XCIyZjojM3lcIj4xWjovLzN1LjJ3LzF2PC9hPjwvVD48VD43MCAxNyA2VSA3MS48L1Q+PFQ+NlQgNlgtM3ggNlkgNkQuPC9UPjwvVD48VD42dCA2MSA2MCBKIDFrLCA1WiA8YSAyaD1cIjZ1Oi8vMnkuNjIuMncvNjMtNjYvNjU/NjQ9NVgtNVcmNVA9NU9cIiAxTD1cIjJmOiMzeVwiPjVSPC9hPiA1ViA8MlIvPjVVIDVUIDVTITwvVD48L1Q+PC8zQj48LzF6PlxcJ319LDFZOnsyajpOLDJBOnt9fSwxVTp7fSwzQTp7Nm46L1xcXFwvXFxcXCpbXFxcXHNcXFxcU10qP1xcXFwqXFxcXC8vMmMsNm06L1xcXFwvXFxcXC8uKiQvMmMsNmw6LyMuKiQvMmMsNms6L1wiKFteXFxcXFxcXFxcIlxcXFxuXXxcXFxcXFxcXC4pKlwiL2csNm86L1xcJyhbXlxcXFxcXFxcXFwnXFxcXG5dfFxcXFxcXFxcLikqXFwnL2csNnA6MWYgTShcXCdcIihbXlxcXFxcXFxcXFxcXFxcXFxcIl18XFxcXFxcXFxcXFxcXFxcXC4pKlwiXFwnLFwiM3pcIiksNnM6MWYgTShcIlxcJyhbXlxcXFxcXFxcXFxcXFxcXFxcXCddfFxcXFxcXFxcXFxcXFxcXFwuKSpcXCdcIixcIjN6XCIpLDZxOi8oJjF5O3w8KSEtLVtcXFxcc1xcXFxTXSo/LS0oJjFHO3w+KS8yYywzTTovXFxcXHcrOlxcXFwvXFxcXC9bXFxcXHctLlxcXFwvPyUmPTpAO10qL2csNmE6ezE4Oi8oJjF5O3w8KVxcXFw/PT8vZywxYjovXFxcXD8oJjFHO3w+KS9nfSw2OTp7MTg6LygmMXk7fDwpJT0/L2csMWI6LyUoJjFHO3w+KS9nfSw2ZDp7MTg6LygmMXk7fDwpXFxcXHMqMWsuKj8oJjFHO3w+KS8yVCwxYjovKCYxeTt8PClcXFxcL1xcXFxzKjFrXFxcXHMqKCYxRzt8PikvMlR9fSwxNjp7MUg6NihhKXs2IGIoaSxrKXtIIGUuMTYuMm8oaSxrLGUuMTMuMXhba10pfU8oSyBjPVxcJzxUIDFnPVwiMTZcIj5cXCcsZD1lLjE2LjJ4LGg9ZC4yWCxnPTA7ZzxoLkw7ZysrKWMrPShkW2hbZ11dLjFIfHxiKShhLGhbZ10pO2MrPVwiPC9UPlwiO0ggY30sMm86NihhLGIsYyl7SFxcJzwyVz48YSAyaD1cIiNcIiAxZz1cIjZlIDZoXFwnK2IrXCIgXCIrYitcXCdcIj5cXCcrYytcIjwvYT48LzJXPlwifSwyYjo2KGEpe0sgYj1hLjFGLGM9Yi4xbHx8XCJcIjtiPUIocChiLFwiLjIwXCIsUikuMWMpO0sgZD02KGgpe0goaD0xNShoK1wiNmYoXFxcXFxcXFx3KylcIikuWChjKSk/aFsxXTpOfShcIjZnXCIpO2ImJmQmJmUuMTYuMnhbZF0uMkIoYik7YS4zTigpfSwyeDp7Mlg6W1wiMjFcIixcIjJQXCJdLDIxOnsxSDo2KGEpe0koYS5WKFwiMmxcIikhPVIpSFwiXCI7SyBiPWEuVihcIjF0XCIpO0ggZS4xNi4ybyhhLFwiMjFcIixiP2I6ZS4xMy4xeC4yMSl9LDJCOjYoYSl7YT0xRS42aih0KGEuMWMpKTthLjFsPWEuMWwuUShcIjQ3XCIsXCJcIil9fSwyUDp7MkI6Nigpe0sgYT1cIjY4PTBcIjthKz1cIiwgMTg9XCIrKDMxLjMwLTMzKS8yK1wiLCAzMj1cIisoMzEuMlotMlkpLzIrXCIsIDMwPTMzLCAyWj0yWVwiO2E9YS5RKC9eLC8sXCJcIik7YT0xUC42WihcIlwiLFwiMzhcIixhKTthLjJDKCk7SyBiPWEuMUU7Yi42VyhlLjEzLjF4LjM3KTtiLjZWKCk7YS4yQygpfX19fSwzNTo2KGEsYil7SyBjO0koYiljPVtiXTtZe2M9MUUuMzYoZS4xMy4zNCk7TyhLIGQ9W10saD0wO2g8Yy5MO2grKylkLlUoY1toXSk7Yz1kfWM9YztkPVtdO0koZS4xMy4yTSljPWMuMU8oeigpKTtJKGMuTD09PTApSCBkO08oaD0wO2g8Yy5MO2grKyl7TyhLIGc9Y1toXSxpPWEsaz1jW2hdLjFsLGo9M1cgMCxsPXt9LG09MWYgTShcIl5cXFxcXFxcXFsoPzwyVj4oLio/KSlcXFxcXFxcXF0kXCIpLHM9MWYgTShcIig/PDI3PltcXFxcXFxcXHctXSspXFxcXFxcXFxzKjpcXFxcXFxcXHMqKD88MVQ+W1xcXFxcXFxcdy0lI10rfFxcXFxcXFxcWy4qP1xcXFxcXFxcXXxcXFxcXCIuKj9cXFxcXCJ8XFwnLio/XFwnKVxcXFxcXFxccyo7P1wiLFwiZ1wiKTsoaj1zLlgoaykpIT1OOyl7SyBvPWouMVQuUSgvXltcXCdcIl18W1xcJ1wiXSQvZyxcIlwiKTtJKG8hPU4mJm0uMUEobykpe289bS5YKG8pO289by4yVi5MPjA/by4yVi4xZSgvXFxcXHMqLFxcXFxzKi8pOltdfWxbai4yN109b31nPXsxRjpnLDFuOkMoaSxsKX07Zy4xbi4xRCE9TiYmZC5VKGcpfUggZH0sMU06NihhLGIpe0sgYz1KLjM1KGEsYiksZD1OLGg9ZS4xMztJKGMuTCE9PTApTyhLIGc9MDtnPGMuTDtnKyspe2I9Y1tnXTtLIGk9Yi4xRixrPWIuMW4saj1rLjFELGw7SShqIT1OKXtJKGtbXCIxei0xa1wiXT09XCJSXCJ8fGUuMnZbXCIxei0xa1wiXT09Uil7ZD0xZiBlLjRsKGopO2o9XCI0T1wifVkgSShkPUEoaikpZD0xZiBkO1kgNkg7bD1pLjNYO0koaC4yTSl7bD1sO0sgbT14KGwpLHM9MTE7SShtLjFpKFwiPCFbNkdbXCIpPT0wKXttPW0uNGgoOSk7cz1SfUsgbz1tLkw7SShtLjFpKFwiXV1cXFxcPlwiKT09by0zKXttPW0uNGgoMCxvLTMpO3M9Un1sPXM/bTpsfUkoKGkuMXR8fFwiXCIpIT1cIlwiKWsuMXQ9aS4xdDtrLjFEPWo7ZC4yUShrKTtiPWQuMkYobCk7SSgoaS4xY3x8XCJcIikhPVwiXCIpYi4xYz1pLjFjO2kuMkcuNzQoYixpKX19fSwyRTo2KGEpe3coMVAsXCI0a1wiLDYoKXtlLjFNKGEpfSl9fTtlLjJFPWUuMkU7ZS4xTT1lLjFNO2UuMkw9NihhLGIsYyl7Si4xVD1hO0ouUD1iO0ouTD1hLkw7Si4yMz1jO0ouMVY9Tn07ZS4yTC5aLjFxPTYoKXtIIEouMVR9O2UuNGw9NihhKXs2IGIoaixsKXtPKEsgbT0wO208ai5MO20rKylqW21dLlArPWx9SyBjPUEoYSksZCxoPTFmIGUuMVUuNVksZz1KLGk9XCIyRiAxSCAyUVwiLjFlKFwiIFwiKTtJKGMhPU4pe2Q9MWYgYztPKEsgaz0wO2s8aS5MO2srKykoNigpe0sgaj1pW2tdO2dbal09Nigpe0ggaFtqXS4xcChoLDE0KX19KSgpO2QuMjg9PU4/MVAuMVgoZS4xMy4xeC4xWCsoZS4xMy4xeC40ZythKSk6aC4ySi5VKHsxSTpkLjI4LjE3LDJEOjYoail7TyhLIGw9ai4xNyxtPVtdLHM9ZC4ySixvPWouUCtqLjE4LkwsRj1kLjI4LHEsRz0wO0c8cy5MO0crKyl7cT15KGwsc1tHXSk7YihxLG8pO209bS4xTyhxKX1JKEYuMTghPU4mJmouMTghPU4pe3E9eShqLjE4LEYuMTgpO2IocSxqLlApO209bS4xTyhxKX1JKEYuMWIhPU4mJmouMWIhPU4pe3E9eShqLjFiLEYuMWIpO2IocSxqLlAralswXS41UShqLjFiKSk7bT1tLjFPKHEpfU8oaj0wO2o8bS5MO2orKyltW2pdLjFWPWMuMVY7SCBtfX0pfX07ZS40aj02KCl7fTtlLjRqLlo9e1Y6NihhLGIpe0sgYz1KLjFuW2FdO2M9Yz09Tj9iOmM7SyBkPXtcIlJcIjpSLFwiMTFcIjoxMX1bY107SCBkPT1OP2M6ZH0sM1k6NihhKXtIIDFFLjRpKGEpfSw0Yzo2KGEsYil7SyBjPVtdO0koYSE9TilPKEsgZD0wO2Q8YS5MO2QrKylJKDFqIGFbZF09PVwiMm1cIiljPWMuMU8oeShiLGFbZF0pKTtIIEouNGUoYy42YihEKSl9LDRlOjYoYSl7TyhLIGI9MDtiPGEuTDtiKyspSShhW2JdIT09TilPKEsgYz1hW2JdLGQ9Yy5QK2MuTCxoPWIrMTtoPGEuTCYmYVtiXSE9PU47aCsrKXtLIGc9YVtoXTtJKGchPT1OKUkoZy5QPmQpMU47WSBJKGcuUD09Yy5QJiZnLkw+Yy5MKWFbYl09TjtZIEkoZy5QPj1jLlAmJmcuUDxkKWFbaF09Tn1IIGF9LDRkOjYoYSl7SyBiPVtdLGM9MnUoSi5WKFwiMmktMXNcIikpO3YoYSw2KGQsaCl7Yi5VKGgrYyl9KTtIIGJ9LDNVOjYoYSl7SyBiPUouVihcIjFNXCIsW10pO0koMWogYiE9XCIybVwiJiZiLlU9PU4pYj1bYl07YTp7YT1hLjFxKCk7SyBjPTNXIDA7TyhjPWM9MVEuNmMoY3x8MCwwKTtjPGIuTDtjKyspSShiW2NdPT1hKXtiPWM7MU4gYX1iPS0xfUggYiE9LTF9LDJyOjYoYSxiLGMpe2E9W1wiMXNcIixcIjZpXCIrYixcIlBcIithLFwiNnJcIisoYiUyPT0wPzE6MikuMXEoKV07Si4zVShiKSYmYS5VKFwiNjdcIik7Yj09MCYmYS5VKFwiMU5cIik7SFxcJzxUIDFnPVwiXFwnK2EuMUsoXCIgXCIpK1xcJ1wiPlxcJytjK1wiPC9UPlwifSwzUTo2KGEsYil7SyBjPVwiXCIsZD1hLjFlKFwiXFxcXG5cIikuTCxoPTJ1KEouVihcIjJpLTFzXCIpKSxnPUouVihcIjJ6LTFzLTJ0XCIpO0koZz09UilnPShoK2QtMSkuMXEoKS5MO1kgSSgzUihnKT09UilnPTA7TyhLIGk9MDtpPGQ7aSsrKXtLIGs9Yj9iW2ldOmgraSxqO0koaz09MClqPWUuMTMuMVc7WXtqPWc7TyhLIGw9ay4xcSgpO2wuTDxqOylsPVwiMFwiK2w7aj1sfWE9ajtjKz1KLjJyKGksayxhKX1IIGN9LDQ5OjYoYSxiKXthPXgoYSk7SyBjPWEuMWUoXCJcXFxcblwiKTtKLlYoXCIyei0xcy0ydFwiKTtLIGQ9MnUoSi5WKFwiMmktMXNcIikpO2E9XCJcIjtPKEsgaD1KLlYoXCIxRFwiKSxnPTA7ZzxjLkw7ZysrKXtLIGk9Y1tnXSxrPS9eKCYyczt8XFxcXHMpKy8uWChpKSxqPU4sbD1iP2JbZ106ZCtnO0koayE9Til7aj1rWzBdLjFxKCk7aT1pLjFvKGouTCk7aj1qLlEoXCIgXCIsZS4xMy4xVyl9aT14KGkpO0koaS5MPT0wKWk9ZS4xMy4xVzthKz1KLjJyKGcsbCwoaiE9Tj9cXCc8MTcgMWc9XCJcXCcraCtcXCcgNU5cIj5cXCcraitcIjwvMTc+XCI6XCJcIikraSl9SCBhfSw0Zjo2KGEpe0ggYT9cIjw0YT5cIithK1wiPC80YT5cIjpcIlwifSw0Yjo2KGEsYil7NiBjKGwpe0gobD1sP2wuMVZ8fGc6Zyk/bCtcIiBcIjpcIlwifU8oSyBkPTAsaD1cIlwiLGc9Si5WKFwiMURcIixcIlwiKSxpPTA7aTxiLkw7aSsrKXtLIGs9YltpXSxqO0koIShrPT09Tnx8ay5MPT09MCkpe2o9YyhrKTtoKz11KGEuMW8oZCxrLlAtZCksaitcIjQ4XCIpK3Uoay4xVCxqK2suMjMpO2Q9ay5QK2suTCsoay43NXx8MCl9fWgrPXUoYS4xbyhkKSxjKCkrXCI0OFwiKTtIIGh9LDFIOjYoYSl7SyBiPVwiXCIsYz1bXCIyMFwiXSxkO0koSi5WKFwiMmtcIik9PVIpSi4xbi4xNj1KLjFuLjF1PTExOzFsPVwiMjBcIjtKLlYoXCIybFwiKT09UiYmYy5VKFwiNDdcIik7SSgoMXU9Si5WKFwiMXVcIikpPT0xMSljLlUoXCI2U1wiKTtjLlUoSi5WKFwiMWctMjdcIikpO2MuVShKLlYoXCIxRFwiKSk7YT1hLlEoL15bIF0qW1xcXFxuXSt8W1xcXFxuXSpbIF0qJC9nLFwiXCIpLlEoL1xcXFxyL2csXCIgXCIpO2I9Si5WKFwiNDMtMjJcIik7SShKLlYoXCI0Mi00NVwiKT09UilhPW4oYSxiKTtZe08oSyBoPVwiXCIsZz0wO2c8YjtnKyspaCs9XCIgXCI7YT1hLlEoL1xcXFx0L2csaCl9YT1hO2E6e2I9YT1hO2g9LzwyUlxcXFxzKlxcXFwvPz58JjF5OzJSXFxcXHMqXFxcXC8/JjFHOy8yVDtJKGUuMTMuNDY9PVIpYj1iLlEoaCxcIlxcXFxuXCIpO0koZS4xMy40ND09UiliPWIuUShoLFwiXCIpO2I9Yi4xZShcIlxcXFxuXCIpO2g9L15cXFxccyovO2c9NFE7TyhLIGk9MDtpPGIuTCYmZz4wO2krKyl7SyBrPWJbaV07SSh4KGspLkwhPTApe2s9aC5YKGspO0koaz09Til7YT1hOzFOIGF9Zz0xUS40cShrWzBdLkwsZyl9fUkoZz4wKU8oaT0wO2k8Yi5MO2krKyliW2ldPWJbaV0uMW8oZyk7YT1iLjFLKFwiXFxcXG5cIil9SSgxdSlkPUouNGQoYSk7Yj1KLjRjKEouMkosYSk7Yj1KLjRiKGEsYik7Yj1KLjQ5KGIsZCk7SShKLlYoXCI0MS00MFwiKSliPUUoYik7MWogMkghPVwiMWRcIiYmMkguM1MmJjJILjNTLjFDKC81cy8pJiZjLlUoXCI1dFwiKTtIIGI9XFwnPFQgMWM9XCJcXCcrdChKLjFjKStcXCdcIiAxZz1cIlxcJytjLjFLKFwiIFwiKStcXCdcIj5cXCcrKEouVihcIjE2XCIpP2UuMTYuMUgoSik6XCJcIikrXFwnPDNaIDV6PVwiMFwiIDVIPVwiMFwiIDVKPVwiMFwiPlxcJytKLjRmKEouVihcIjF0XCIpKStcIjwzVD48M1A+XCIrKDF1P1xcJzwyZCAxZz1cIjF1XCI+XFwnK0ouM1EoYSkrXCI8LzJkPlwiOlwiXCIpK1xcJzwyZCAxZz1cIjE3XCI+PFQgMWc9XCIzT1wiPlxcJytiK1wiPC9UPjwvMmQ+PC8zUD48LzNUPjwvM1o+PC9UPlwifSwyRjo2KGEpe0koYT09PU4pYT1cIlwiO0ouMTc9YTtLIGI9Si4zWShcIlRcIik7Yi4zWD1KLjFIKGEpO0ouVihcIjE2XCIpJiZ3KHAoYixcIi4xNlwiKSxcIjVjXCIsZS4xNi4yYik7Si5WKFwiM1YtMTdcIikmJncocChiLFwiLjE3XCIpLFwiNTZcIixmKTtIIGJ9LDJROjYoYSl7Si4xYz1cIlwiKzFRLjVkKDFRLjVuKCkqNWspLjFxKCk7ZS4xWS4yQVt0KEouMWMpXT1KO0ouMW49QyhlLjJ2LGF8fHt9KTtJKEouVihcIjJrXCIpPT1SKUouMW4uMTY9Si4xbi4xdT0xMX0sNWo6NihhKXthPWEuUSgvXlxcXFxzK3xcXFxccyskL2csXCJcIikuUSgvXFxcXHMrL2csXCJ8XCIpO0hcIlxcXFxcXFxcYig/OlwiK2ErXCIpXFxcXFxcXFxiXCJ9LDVmOjYoYSl7Si4yOD17MTg6ezFJOmEuMTgsMjM6XCIxa1wifSwxYjp7MUk6YS4xYiwyMzpcIjFrXCJ9LDE3OjFmIE0oXCIoPzwxOD5cIithLjE4LjFtK1wiKSg/PDE3Pi4qPykoPzwxYj5cIithLjFiLjFtK1wiKVwiLFwiNW9cIil9fX07SCBlfSgpOzFqIDJlIT1cIjFkXCImJigyZS4xdj0xdik7Jyw2Miw0NDEsJ3x8fHx8fGZ1bmN0aW9ufHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHJldHVybnxpZnx0aGlzfHZhcnxsZW5ndGh8WFJlZ0V4cHxudWxsfGZvcnxpbmRleHxyZXBsYWNlfHRydWV8fGRpdnxwdXNofGdldFBhcmFtfGNhbGx8ZXhlY3xlbHNlfHByb3RvdHlwZXx8ZmFsc2V8bGFzdEluZGV4fGNvbmZpZ3xhcmd1bWVudHN8UmVnRXhwfHRvb2xiYXJ8Y29kZXxsZWZ0fGNhcHR1cmVOYW1lc3xzbGljZXxyaWdodHxpZHx1bmRlZmluZWR8c3BsaXR8bmV3fGNsYXNzfGFkZFRva2VufGluZGV4T2Z8dHlwZW9mfHNjcmlwdHxjbGFzc05hbWV8c291cmNlfHBhcmFtc3xzdWJzdHJ8YXBwbHl8dG9TdHJpbmd8U3RyaW5nfGxpbmV8dGl0bGV8Z3V0dGVyfFN5bnRheEhpZ2hsaWdodGVyfF94cmVnZXhwfHN0cmluZ3N8bHR8aHRtbHx0ZXN0fE9VVFNJREVfQ0xBU1N8bWF0Y2h8YnJ1c2h8ZG9jdW1lbnR8dGFyZ2V0fGd0fGdldEh0bWx8cmVnZXh8Z2xvYmFsfGpvaW58c3R5bGV8aGlnaGxpZ2h0fGJyZWFrfGNvbmNhdHx3aW5kb3d8TWF0aHxpc1JlZ0V4cHx0aHJvd3x2YWx1ZXxicnVzaGVzfGJydXNoTmFtZXxzcGFjZXxhbGVydHx2YXJzfGh0dHB8c3ludGF4aGlnaGxpZ2h0ZXJ8ZXhwYW5kU291cmNlfHNpemV8Y3NzfGNhc2V8Zm9udHxGYXxuYW1lfGh0bWxTY3JpcHR8ZEF8Y2FufGhhbmRsZXJ8Z218dGR8ZXhwb3J0c3xjb2xvcnxpbnxocmVmfGZpcnN0fGRpc2NvdmVyZWRCcnVzaGVzfGxpZ2h0fGNvbGxhcHNlfG9iamVjdHxjYWNoZXxnZXRCdXR0b25IdG1sfHRyaWdnZXJ8cGF0dGVybnxnZXRMaW5lSHRtbHxuYnNwfG51bWJlcnN8cGFyc2VJbnR8ZGVmYXVsdHN8Y29tfGl0ZW1zfHd3d3xwYWR8aGlnaGxpZ2h0ZXJzfGV4ZWN1dGV8Zm9jdXN8ZnVuY3xhbGx8Z2V0RGl2fHBhcmVudE5vZGV8bmF2aWdhdG9yfElOU0lERV9DTEFTU3xyZWdleExpc3R8aGFzRmxhZ3xNYXRjaHx1c2VTY3JpcHRUYWdzfGhhc05hbWVkQ2FwdHVyZXx0ZXh0fGhlbHB8aW5pdHxicnxpbnB1dHxnaXxFcnJvcnx2YWx1ZXN8c3BhbnxsaXN0fDI1MHxoZWlnaHR8d2lkdGh8c2NyZWVufHRvcHw1MDB8dGFnTmFtZXxmaW5kRWxlbWVudHN8Z2V0RWxlbWVudHNCeVRhZ05hbWV8YWJvdXREaWFsb2d8X2JsYW5rfGFwcGVuZENoaWxkfGNoYXJBdHxBcnJheXxjb3B5QXNHbG9iYWx8c2V0RmxhZ3xoaWdobGlnaHRlcl98c3RyaW5nfGF0dGFjaEV2ZW50fG5vZGVOYW1lfGZsb29yfGJhY2tyZWZ8b3V0cHV0fHRoZXxUeXBlRXJyb3J8c3RpY2t5fFphfGl0ZXJhdGV8ZnJlZXplVG9rZW5zfHNjb3BlfHR5cGV8dGV4dGFyZWF8YWxleGdvcmJhdGNoZXZ8dmVyc2lvbnxtYXJnaW58MjAxMHwwMDU4OTZ8Z3N8cmVnZXhMaWJ8Ym9keXxjZW50ZXJ8YWxpZ258bm9CcnVzaHxyZXF1aXJlfGNoaWxkTm9kZXN8RFREfHhodG1sMXxoZWFkfG9yZ3x3M3x1cmx8cHJldmVudERlZmF1bHR8Y29udGFpbmVyfHRyfGdldExpbmVOdW1iZXJzSHRtbHxpc05hTnx1c2VyQWdlbnR8dGJvZHl8aXNMaW5lSGlnaGxpZ2h0ZWR8cXVpY2t8dm9pZHxpbm5lckhUTUx8Y3JlYXRlfHRhYmxlfGxpbmtzfGF1dG98c21hcnR8dGFifHN0cmlwQnJzfHRhYnN8YmxvZ2dlck1vZGV8Y29sbGFwc2VkfHBsYWlufGdldENvZGVMaW5lc0h0bWx8Y2FwdGlvbnxnZXRNYXRjaGVzSHRtbHxmaW5kTWF0Y2hlc3xmaWd1cmVPdXRMaW5lTnVtYmVyc3xyZW1vdmVOZXN0ZWRNYXRjaGVzfGdldFRpdGxlSHRtbHxicnVzaE5vdEh0bWxTY3JpcHR8c3Vic3RyaW5nfGNyZWF0ZUVsZW1lbnR8SGlnaGxpZ2h0ZXJ8bG9hZHxIdG1sU2NyaXB0fEJydXNofHByZXxleHBhbmR8bXVsdGlsaW5lfG1pbnxDYW58aWdub3JlQ2FzZXxmaW5kfGJsdXJ8ZXh0ZW5kZWR8dG9Mb3dlckNhc2V8YWxpYXNlc3xhZGRFdmVudExpc3RlbmVyfGlubmVyVGV4dHx0ZXh0Q29udGVudHx3YXNufHNlbGVjdHxjcmVhdGVUZXh0Tm9kZXxyZW1vdmVDaGlsZHxvcHRpb258c2FtZXxmcmFtZXx4bWxuc3xkdGR8dHdpY2V8MTk5OXxlcXVpdnxtZXRhfGh0bWxzY3JpcHR8dHJhbnNpdGlvbmFsfDFFM3xleHBlY3RlZHxQVUJMSUN8RE9DVFlQRXxvbnxXM0N8WEhUTUx8VFJ8RU58VHJhbnNpdGlvbmFsfHxjb25maWd1cmVkfHNyY0VsZW1lbnR8T2JqZWN0fGFmdGVyfHJ1bnxkYmxjbGlja3xtYXRjaENoYWlufHZhbHVlT2Z8Y29uc3RydWN0b3J8ZGVmYXVsdHxzd2l0Y2h8Y2xpY2t8cm91bmR8ZXhlY0F0fGZvckh0bWxTY3JpcHR8dG9rZW58Z2lteXxmdW5jdGlvbnN8Z2V0S2V5d29yZHN8MUU2fGVzY2FwZXx3aXRoaW58cmFuZG9tfHNnaXxhbm90aGVyfGZpbmFsbHl8c3VwcGx5fE1TSUV8aWV8dG9VcHBlckNhc2V8Y2F0Y2h8cmV0dXJuVmFsdWV8ZGVmaW5pdGlvbnxldmVudHxib3JkZXJ8aW1zeHxjb25zdHJ1Y3Rpbmd8b25lfEluZmluaXR5fGZyb218d2hlbnxDb250ZW50fGNlbGxwYWRkaW5nfGZsYWdzfGNlbGxzcGFjaW5nfHRyeXx4aHRtbHxUeXBlfHNwYWNlc3wyOTMwNDAyfGhvc3RlZF9idXR0b25faWR8bGFzdEluZGV4T2Z8ZG9uYXRlfGFjdGl2ZXxkZXZlbG9wbWVudHxrZWVwfHRvfHhjbGlja3xfc3xYbWx8cGxlYXNlfGxpa2V8eW91fHBheXBhbHxjZ2l8Y21kfHdlYnNjcnxiaW58aGlnaGxpZ2h0ZWR8c2Nyb2xsYmFyc3xhc3BTY3JpcHRUYWdzfHBocFNjcmlwdFRhZ3N8c29ydHxtYXh8c2NyaXB0U2NyaXB0VGFnc3x0b29sYmFyX2l0ZW18X3xjb21tYW5kfGNvbW1hbmRffG51bWJlcnxnZXRFbGVtZW50QnlJZHxkb3VibGVRdW90ZWRTdHJpbmd8c2luZ2xlTGluZVBlcmxDb21tZW50c3xzaW5nbGVMaW5lQ0NvbW1lbnRzfG11bHRpTGluZUNDb21tZW50c3xzaW5nbGVRdW90ZWRTdHJpbmd8bXVsdGlMaW5lRG91YmxlUXVvdGVkU3RyaW5nfHhtbENvbW1lbnRzfGFsdHxtdWx0aUxpbmVTaW5nbGVRdW90ZWRTdHJpbmd8SWZ8aHR0cHN8MWVtfDAwMHxmZmZ8YmFja2dyb3VuZHw1ZW18eHh8Ym90dG9tfDc1ZW18R29yYmF0Y2hldnxsYXJnZXxzZXJpZnxDREFUQXxjb250aW51ZXx1dGZ8Y2hhcnNldHxjb250ZW50fEFib3V0fGZhbWlseXxzYW5zfEhlbHZldGljYXxBcmlhbHxHZW5ldmF8M2VtfG5vZ3V0dGVyfENvcHlyaWdodHxzeW50YXh8Y2xvc2V8d3JpdGV8MjAwNHxBbGV4fG9wZW58SmF2YVNjcmlwdHxoaWdobGlnaHRlcnxKdWx5fDAyfHJlcGxhY2VDaGlsZHxvZmZzZXR8ODMnLnNwbGl0KCd8JyksMCx7fSkpXG4iLCIvKipcbiAqIFN5bnRheEhpZ2hsaWdodGVyXG4gKiBodHRwOi8vYWxleGdvcmJhdGNoZXYuY29tL1N5bnRheEhpZ2hsaWdodGVyXG4gKlxuICogU3ludGF4SGlnaGxpZ2h0ZXIgaXMgZG9uYXRpb253YXJlLiBJZiB5b3UgYXJlIHVzaW5nIGl0LCBwbGVhc2UgZG9uYXRlLlxuICogaHR0cDovL2FsZXhnb3JiYXRjaGV2LmNvbS9TeW50YXhIaWdobGlnaHRlci9kb25hdGUuaHRtbFxuICpcbiAqIEB2ZXJzaW9uXG4gKiAzLjAuODMgKEp1bHkgMDIgMjAxMClcbiAqIFxuICogQGNvcHlyaWdodFxuICogQ29weXJpZ2h0IChDKSAyMDA0LTIwMTAgQWxleCBHb3JiYXRjaGV2LlxuICpcbiAqIEBsaWNlbnNlXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlcy5cbiAqL1xuOyhmdW5jdGlvbigpXG57XG5cdC8vIENvbW1vbkpTXG5cdHR5cGVvZihyZXF1aXJlKSAhPSAndW5kZWZpbmVkJyA/IFN5bnRheEhpZ2hsaWdodGVyID0gcmVxdWlyZSgnc2hDb3JlJykuU3ludGF4SGlnaGxpZ2h0ZXIgOiBudWxsO1xuXG5cdGZ1bmN0aW9uIEJydXNoKClcblx0e1xuXHRcdC8vIENvcHlyaWdodCAyMDA2IFNoaW4sIFlvdW5nSmluXG5cdFxuXHRcdHZhciBkYXRhdHlwZXMgPVx0J0FUT00gQk9PTCBCT09MRUFOIEJZVEUgQ0hBUiBDT0xPUlJFRiBEV09SRCBEV09SRExPTkcgRFdPUkRfUFRSICcgK1xuXHRcdFx0XHRcdFx0J0RXT1JEMzIgRFdPUkQ2NCBGTE9BVCBIQUNDRUwgSEFMRl9QVFIgSEFORExFIEhCSVRNQVAgSEJSVVNIICcgK1xuXHRcdFx0XHRcdFx0J0hDT0xPUlNQQUNFIEhDT05WIEhDT05WTElTVCBIQ1VSU09SIEhEQyBIRERFREFUQSBIREVTSyBIRFJPUCBIRFdQICcgK1xuXHRcdFx0XHRcdFx0J0hFTkhNRVRBRklMRSBIRklMRSBIRk9OVCBIR0RJT0JKIEhHTE9CQUwgSEhPT0sgSElDT04gSElOU1RBTkNFIEhLRVkgJyArXG5cdFx0XHRcdFx0XHQnSEtMIEhMT0NBTCBITUVOVSBITUVUQUZJTEUgSE1PRFVMRSBITU9OSVRPUiBIUEFMRVRURSBIUEVOIEhSRVNVTFQgJyArXG5cdFx0XHRcdFx0XHQnSFJHTiBIUlNSQyBIU1ogSFdJTlNUQSBIV05EIElOVCBJTlRfUFRSIElOVDMyIElOVDY0IExBTkdJRCBMQ0lEIExDVFlQRSAnICtcblx0XHRcdFx0XHRcdCdMR1JQSUQgTE9ORyBMT05HTE9ORyBMT05HX1BUUiBMT05HMzIgTE9ORzY0IExQQVJBTSBMUEJPT0wgTFBCWVRFIExQQ09MT1JSRUYgJyArXG5cdFx0XHRcdFx0XHQnTFBDU1RSIExQQ1RTVFIgTFBDVk9JRCBMUENXU1RSIExQRFdPUkQgTFBIQU5ETEUgTFBJTlQgTFBMT05HIExQU1RSIExQVFNUUiAnICtcblx0XHRcdFx0XHRcdCdMUFZPSUQgTFBXT1JEIExQV1NUUiBMUkVTVUxUIFBCT09MIFBCT09MRUFOIFBCWVRFIFBDSEFSIFBDU1RSIFBDVFNUUiBQQ1dTVFIgJyArXG5cdFx0XHRcdFx0XHQnUERXT1JETE9ORyBQRFdPUkRfUFRSIFBEV09SRDMyIFBEV09SRDY0IFBGTE9BVCBQSEFMRl9QVFIgUEhBTkRMRSBQSEtFWSBQSU5UICcgK1xuXHRcdFx0XHRcdFx0J1BJTlRfUFRSIFBJTlQzMiBQSU5UNjQgUExDSUQgUExPTkcgUExPTkdMT05HIFBMT05HX1BUUiBQTE9ORzMyIFBMT05HNjQgUE9JTlRFUl8zMiAnICtcblx0XHRcdFx0XHRcdCdQT0lOVEVSXzY0IFBTSE9SVCBQU0laRV9UIFBTU0laRV9UIFBTVFIgUFRCWVRFIFBUQ0hBUiBQVFNUUiBQVUNIQVIgUFVIQUxGX1BUUiAnICtcblx0XHRcdFx0XHRcdCdQVUlOVCBQVUlOVF9QVFIgUFVJTlQzMiBQVUlOVDY0IFBVTE9ORyBQVUxPTkdMT05HIFBVTE9OR19QVFIgUFVMT05HMzIgUFVMT05HNjQgJyArXG5cdFx0XHRcdFx0XHQnUFVTSE9SVCBQVk9JRCBQV0NIQVIgUFdPUkQgUFdTVFIgU0NfSEFORExFIFNDX0xPQ0sgU0VSVklDRV9TVEFUVVNfSEFORExFIFNIT1JUICcgK1xuXHRcdFx0XHRcdFx0J1NJWkVfVCBTU0laRV9UIFRCWVRFIFRDSEFSIFVDSEFSIFVIQUxGX1BUUiBVSU5UIFVJTlRfUFRSIFVJTlQzMiBVSU5UNjQgVUxPTkcgJyArXG5cdFx0XHRcdFx0XHQnVUxPTkdMT05HIFVMT05HX1BUUiBVTE9ORzMyIFVMT05HNjQgVVNIT1JUIFVTTiBWT0lEIFdDSEFSIFdPUkQgV1BBUkFNIFdQQVJBTSBXUEFSQU0gJyArXG5cdFx0XHRcdFx0XHQnY2hhciBib29sIHNob3J0IGludCBfX2ludDMyIF9faW50NjQgX19pbnQ4IF9faW50MTYgbG9uZyBmbG9hdCBkb3VibGUgX193Y2hhcl90ICcgK1xuXHRcdFx0XHRcdFx0J2Nsb2NrX3QgX2NvbXBsZXggX2Rldl90IF9kaXNrZnJlZV90IGRpdl90IGxkaXZfdCBfZXhjZXB0aW9uIF9FWENFUFRJT05fUE9JTlRFUlMgJyArXG5cdFx0XHRcdFx0XHQnRklMRSBfZmluZGRhdGFfdCBfZmluZGRhdGFpNjRfdCBfd2ZpbmRkYXRhX3QgX3dmaW5kZGF0YWk2NF90IF9fZmluZGRhdGE2NF90ICcgK1xuXHRcdFx0XHRcdFx0J19fd2ZpbmRkYXRhNjRfdCBfRlBJRUVFX1JFQ09SRCBmcG9zX3QgX0hFQVBJTkZPIF9IRklMRSBsY29udiBpbnRwdHJfdCAnICtcblx0XHRcdFx0XHRcdCdqbXBfYnVmIG1ic3RhdGVfdCBfb2ZmX3QgX29uZXhpdF90IF9QTkggcHRyZGlmZl90IF9wdXJlY2FsbF9oYW5kbGVyICcgK1xuXHRcdFx0XHRcdFx0J3NpZ19hdG9taWNfdCBzaXplX3QgX3N0YXQgX19zdGF0NjQgX3N0YXRpNjQgdGVybWluYXRlX2Z1bmN0aW9uICcgK1xuXHRcdFx0XHRcdFx0J3RpbWVfdCBfX3RpbWU2NF90IF90aW1lYiBfX3RpbWViNjQgdG0gdWludHB0cl90IF91dGltYnVmICcgK1xuXHRcdFx0XHRcdFx0J3ZhX2xpc3Qgd2NoYXJfdCB3Y3RyYW5zX3Qgd2N0eXBlX3Qgd2ludF90IHNpZ25lZCc7XG5cblx0XHR2YXIga2V5d29yZHMgPVx0J2JyZWFrIGNhc2UgY2F0Y2ggY2xhc3MgY29uc3QgX19maW5hbGx5IF9fZXhjZXB0aW9uIF9fdHJ5ICcgK1xuXHRcdFx0XHRcdFx0J2NvbnN0X2Nhc3QgY29udGludWUgcHJpdmF0ZSBwdWJsaWMgcHJvdGVjdGVkIF9fZGVjbHNwZWMgJyArXG5cdFx0XHRcdFx0XHQnZGVmYXVsdCBkZWxldGUgZGVwcmVjYXRlZCBkbGxleHBvcnQgZGxsaW1wb3J0IGRvIGR5bmFtaWNfY2FzdCAnICtcblx0XHRcdFx0XHRcdCdlbHNlIGVudW0gZXhwbGljaXQgZXh0ZXJuIGlmIGZvciBmcmllbmQgZ290byBpbmxpbmUgJyArXG5cdFx0XHRcdFx0XHQnbXV0YWJsZSBuYWtlZCBuYW1lc3BhY2UgbmV3IG5vaW5saW5lIG5vcmV0dXJuIG5vdGhyb3cgJyArXG5cdFx0XHRcdFx0XHQncmVnaXN0ZXIgcmVpbnRlcnByZXRfY2FzdCByZXR1cm4gc2VsZWN0YW55ICcgK1xuXHRcdFx0XHRcdFx0J3NpemVvZiBzdGF0aWMgc3RhdGljX2Nhc3Qgc3RydWN0IHN3aXRjaCB0ZW1wbGF0ZSB0aGlzICcgK1xuXHRcdFx0XHRcdFx0J3RocmVhZCB0aHJvdyB0cnVlIGZhbHNlIHRyeSB0eXBlZGVmIHR5cGVpZCB0eXBlbmFtZSB1bmlvbiAnICtcblx0XHRcdFx0XHRcdCd1c2luZyB1dWlkIHZpcnR1YWwgdm9pZCB2b2xhdGlsZSB3aGNhcl90IHdoaWxlJztcblx0XHRcdFx0XHRcblx0XHR2YXIgZnVuY3Rpb25zID1cdCdhc3NlcnQgaXNhbG51bSBpc2FscGhhIGlzY250cmwgaXNkaWdpdCBpc2dyYXBoIGlzbG93ZXIgaXNwcmludCcgK1xuXHRcdFx0XHRcdFx0J2lzcHVuY3QgaXNzcGFjZSBpc3VwcGVyIGlzeGRpZ2l0IHRvbG93ZXIgdG91cHBlciBlcnJubyBsb2NhbGVjb252ICcgK1xuXHRcdFx0XHRcdFx0J3NldGxvY2FsZSBhY29zIGFzaW4gYXRhbiBhdGFuMiBjZWlsIGNvcyBjb3NoIGV4cCBmYWJzIGZsb29yIGZtb2QgJyArXG5cdFx0XHRcdFx0XHQnZnJleHAgbGRleHAgbG9nIGxvZzEwIG1vZGYgcG93IHNpbiBzaW5oIHNxcnQgdGFuIHRhbmggam1wX2J1ZiAnICtcblx0XHRcdFx0XHRcdCdsb25nam1wIHNldGptcCByYWlzZSBzaWduYWwgc2lnX2F0b21pY190IHZhX2FyZyB2YV9lbmQgdmFfc3RhcnQgJyArXG5cdFx0XHRcdFx0XHQnY2xlYXJlcnIgZmNsb3NlIGZlb2YgZmVycm9yIGZmbHVzaCBmZ2V0YyBmZ2V0cG9zIGZnZXRzIGZvcGVuICcgK1xuXHRcdFx0XHRcdFx0J2ZwcmludGYgZnB1dGMgZnB1dHMgZnJlYWQgZnJlb3BlbiBmc2NhbmYgZnNlZWsgZnNldHBvcyBmdGVsbCAnICtcblx0XHRcdFx0XHRcdCdmd3JpdGUgZ2V0YyBnZXRjaGFyIGdldHMgcGVycm9yIHByaW50ZiBwdXRjIHB1dGNoYXIgcHV0cyByZW1vdmUgJyArXG5cdFx0XHRcdFx0XHQncmVuYW1lIHJld2luZCBzY2FuZiBzZXRidWYgc2V0dmJ1ZiBzcHJpbnRmIHNzY2FuZiB0bXBmaWxlIHRtcG5hbSAnICtcblx0XHRcdFx0XHRcdCd1bmdldGMgdmZwcmludGYgdnByaW50ZiB2c3ByaW50ZiBhYm9ydCBhYnMgYXRleGl0IGF0b2YgYXRvaSBhdG9sICcgK1xuXHRcdFx0XHRcdFx0J2JzZWFyY2ggY2FsbG9jIGRpdiBleGl0IGZyZWUgZ2V0ZW52IGxhYnMgbGRpdiBtYWxsb2MgbWJsZW4gbWJzdG93Y3MgJyArXG5cdFx0XHRcdFx0XHQnbWJ0b3djIHFzb3J0IHJhbmQgcmVhbGxvYyBzcmFuZCBzdHJ0b2Qgc3RydG9sIHN0cnRvdWwgc3lzdGVtICcgK1xuXHRcdFx0XHRcdFx0J3djc3RvbWJzIHdjdG9tYiBtZW1jaHIgbWVtY21wIG1lbWNweSBtZW1tb3ZlIG1lbXNldCBzdHJjYXQgc3RyY2hyICcgK1xuXHRcdFx0XHRcdFx0J3N0cmNtcCBzdHJjb2xsIHN0cmNweSBzdHJjc3BuIHN0cmVycm9yIHN0cmxlbiBzdHJuY2F0IHN0cm5jbXAgJyArXG5cdFx0XHRcdFx0XHQnc3RybmNweSBzdHJwYnJrIHN0cnJjaHIgc3Ryc3BuIHN0cnN0ciBzdHJ0b2sgc3RyeGZybSBhc2N0aW1lICcgK1xuXHRcdFx0XHRcdFx0J2Nsb2NrIGN0aW1lIGRpZmZ0aW1lIGdtdGltZSBsb2NhbHRpbWUgbWt0aW1lIHN0cmZ0aW1lIHRpbWUnO1xuXG5cdFx0dGhpcy5yZWdleExpc3QgPSBbXG5cdFx0XHR7IHJlZ2V4OiBTeW50YXhIaWdobGlnaHRlci5yZWdleExpYi5zaW5nbGVMaW5lQ0NvbW1lbnRzLFx0Y3NzOiAnY29tbWVudHMnIH0sXHRcdFx0Ly8gb25lIGxpbmUgY29tbWVudHNcblx0XHRcdHsgcmVnZXg6IFN5bnRheEhpZ2hsaWdodGVyLnJlZ2V4TGliLm11bHRpTGluZUNDb21tZW50cyxcdFx0Y3NzOiAnY29tbWVudHMnIH0sXHRcdFx0Ly8gbXVsdGlsaW5lIGNvbW1lbnRzXG5cdFx0XHR7IHJlZ2V4OiBTeW50YXhIaWdobGlnaHRlci5yZWdleExpYi5kb3VibGVRdW90ZWRTdHJpbmcsXHRcdGNzczogJ3N0cmluZycgfSxcdFx0XHQvLyBzdHJpbmdzXG5cdFx0XHR7IHJlZ2V4OiBTeW50YXhIaWdobGlnaHRlci5yZWdleExpYi5zaW5nbGVRdW90ZWRTdHJpbmcsXHRcdGNzczogJ3N0cmluZycgfSxcdFx0XHQvLyBzdHJpbmdzXG5cdFx0XHR7IHJlZ2V4OiAvXiAqIy4qL2dtLFx0XHRcdFx0XHRcdFx0XHRcdFx0Y3NzOiAncHJlcHJvY2Vzc29yJyB9LFxuXHRcdFx0eyByZWdleDogbmV3IFJlZ0V4cCh0aGlzLmdldEtleXdvcmRzKGRhdGF0eXBlcyksICdnbScpLFx0XHRjc3M6ICdjb2xvcjEgYm9sZCcgfSxcblx0XHRcdHsgcmVnZXg6IG5ldyBSZWdFeHAodGhpcy5nZXRLZXl3b3JkcyhmdW5jdGlvbnMpLCAnZ20nKSxcdFx0Y3NzOiAnZnVuY3Rpb25zIGJvbGQnIH0sXG5cdFx0XHR7IHJlZ2V4OiBuZXcgUmVnRXhwKHRoaXMuZ2V0S2V5d29yZHMoa2V5d29yZHMpLCAnZ20nKSxcdFx0Y3NzOiAna2V5d29yZCBib2xkJyB9XG5cdFx0XHRdO1xuXHR9O1xuXG5cdEJydXNoLnByb3RvdHlwZVx0PSBuZXcgU3ludGF4SGlnaGxpZ2h0ZXIuSGlnaGxpZ2h0ZXIoKTtcblx0QnJ1c2guYWxpYXNlc1x0PSBbJ2NwcCcsICdjJ107XG5cblx0U3ludGF4SGlnaGxpZ2h0ZXIuYnJ1c2hlcy5DcHAgPSBCcnVzaDtcblxuXHQvLyBDb21tb25KU1xuXHR0eXBlb2YoZXhwb3J0cykgIT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzLkJydXNoID0gQnJ1c2ggOiBudWxsO1xufSkoKTtcbiIsIi8qKlxuICogU3ludGF4SGlnaGxpZ2h0ZXJcbiAqIGh0dHA6Ly9hbGV4Z29yYmF0Y2hldi5jb20vU3ludGF4SGlnaGxpZ2h0ZXJcbiAqXG4gKiBTeW50YXhIaWdobGlnaHRlciBpcyBkb25hdGlvbndhcmUuIElmIHlvdSBhcmUgdXNpbmcgaXQsIHBsZWFzZSBkb25hdGUuXG4gKiBodHRwOi8vYWxleGdvcmJhdGNoZXYuY29tL1N5bnRheEhpZ2hsaWdodGVyL2RvbmF0ZS5odG1sXG4gKlxuICogQHZlcnNpb25cbiAqIDMuMC44MyAoSnVseSAwMiAyMDEwKVxuICogXG4gKiBAY29weXJpZ2h0XG4gKiBDb3B5cmlnaHQgKEMpIDIwMDQtMjAxMCBBbGV4IEdvcmJhdGNoZXYuXG4gKlxuICogQGxpY2Vuc2VcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzLlxuICovXG47KGZ1bmN0aW9uKClcbntcblx0Ly8gQ29tbW9uSlNcblx0dHlwZW9mKHJlcXVpcmUpICE9ICd1bmRlZmluZWQnID8gU3ludGF4SGlnaGxpZ2h0ZXIgPSByZXF1aXJlKCdzaENvcmUnKS5TeW50YXhIaWdobGlnaHRlciA6IG51bGw7XG5cblx0ZnVuY3Rpb24gQnJ1c2goKVxuXHR7XG5cdFx0dmFyIGtleXdvcmRzID1cdCdhYnN0cmFjdCBhc3NlcnQgYm9vbGVhbiBicmVhayBieXRlIGNhc2UgY2F0Y2ggY2hhciBjbGFzcyBjb25zdCAnICtcblx0XHRcdFx0XHRcdCdjb250aW51ZSBkZWZhdWx0IGRvIGRvdWJsZSBlbHNlIGVudW0gZXh0ZW5kcyAnICtcblx0XHRcdFx0XHRcdCdmYWxzZSBmaW5hbCBmaW5hbGx5IGZsb2F0IGZvciBnb3RvIGlmIGltcGxlbWVudHMgaW1wb3J0ICcgK1xuXHRcdFx0XHRcdFx0J2luc3RhbmNlb2YgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBuZXcgbnVsbCAnICtcblx0XHRcdFx0XHRcdCdwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyByZXR1cm4gJyArXG5cdFx0XHRcdFx0XHQnc2hvcnQgc3RhdGljIHN0cmljdGZwIHN1cGVyIHN3aXRjaCBzeW5jaHJvbml6ZWQgdGhpcyB0aHJvdyB0aHJvd3MgdHJ1ZSAnICtcblx0XHRcdFx0XHRcdCd0cmFuc2llbnQgdHJ5IHZvaWQgdm9sYXRpbGUgd2hpbGUnO1xuXG5cdFx0dGhpcy5yZWdleExpc3QgPSBbXG5cdFx0XHR7IHJlZ2V4OiBTeW50YXhIaWdobGlnaHRlci5yZWdleExpYi5zaW5nbGVMaW5lQ0NvbW1lbnRzLFx0Y3NzOiAnY29tbWVudHMnIH0sXHRcdC8vIG9uZSBsaW5lIGNvbW1lbnRzXG5cdFx0XHR7IHJlZ2V4OiAvXFwvXFwqKFteXFwqXVtcXHNcXFNdKik/XFwqXFwvL2dtLFx0XHRcdFx0XHRcdGNzczogJ2NvbW1lbnRzJyB9LFx0IFx0Ly8gbXVsdGlsaW5lIGNvbW1lbnRzXG5cdFx0XHR7IHJlZ2V4OiAvXFwvXFwqKD8hXFwqXFwvKVxcKltcXHNcXFNdKj9cXCpcXC8vZ20sXHRcdFx0XHRcdGNzczogJ3ByZXByb2Nlc3NvcicgfSxcdC8vIGRvY3VtZW50YXRpb24gY29tbWVudHNcblx0XHRcdHsgcmVnZXg6IFN5bnRheEhpZ2hsaWdodGVyLnJlZ2V4TGliLmRvdWJsZVF1b3RlZFN0cmluZyxcdFx0Y3NzOiAnc3RyaW5nJyB9LFx0XHQvLyBzdHJpbmdzXG5cdFx0XHR7IHJlZ2V4OiBTeW50YXhIaWdobGlnaHRlci5yZWdleExpYi5zaW5nbGVRdW90ZWRTdHJpbmcsXHRcdGNzczogJ3N0cmluZycgfSxcdFx0Ly8gc3RyaW5nc1xuXHRcdFx0eyByZWdleDogL1xcYihbXFxkXSsoXFwuW1xcZF0rKT98MHhbYS1mMC05XSspXFxiL2dpLFx0XHRcdFx0Y3NzOiAndmFsdWUnIH0sXHRcdFx0Ly8gbnVtYmVyc1xuXHRcdFx0eyByZWdleDogLyg/IVxcQGludGVyZmFjZVxcYilcXEBbXFwkXFx3XStcXGIvZyxcdFx0XHRcdFx0Y3NzOiAnY29sb3IxJyB9LFx0XHQvLyBhbm5vdGF0aW9uIEBhbm5vXG5cdFx0XHR7IHJlZ2V4OiAvXFxAaW50ZXJmYWNlXFxiL2csXHRcdFx0XHRcdFx0XHRcdFx0Y3NzOiAnY29sb3IyJyB9LFx0XHQvLyBAaW50ZXJmYWNlIGtleXdvcmRcblx0XHRcdHsgcmVnZXg6IG5ldyBSZWdFeHAodGhpcy5nZXRLZXl3b3JkcyhrZXl3b3JkcyksICdnbScpLFx0XHRjc3M6ICdrZXl3b3JkJyB9XHRcdC8vIGphdmEga2V5d29yZFxuXHRcdFx0XTtcblxuXHRcdHRoaXMuZm9ySHRtbFNjcmlwdCh7XG5cdFx0XHRsZWZ0XHQ6IC8oJmx0O3w8KSVbQCE9XT8vZywgXG5cdFx0XHRyaWdodFx0OiAvJSgmZ3Q7fD4pL2cgXG5cdFx0fSk7XG5cdH07XG5cblx0QnJ1c2gucHJvdG90eXBlXHQ9IG5ldyBTeW50YXhIaWdobGlnaHRlci5IaWdobGlnaHRlcigpO1xuXHRCcnVzaC5hbGlhc2VzXHQ9IFsnamF2YSddO1xuXG5cdFN5bnRheEhpZ2hsaWdodGVyLmJydXNoZXMuSmF2YSA9IEJydXNoO1xuXG5cdC8vIENvbW1vbkpTXG5cdHR5cGVvZihleHBvcnRzKSAhPSAndW5kZWZpbmVkJyA/IGV4cG9ydHMuQnJ1c2ggPSBCcnVzaCA6IG51bGw7XG59KSgpO1xuIiwiJChmdW5jdGlvbigpIHtcblxuICAgIGlmKCQoJy5tZC1lZGl0b3InKS5sZW5ndGggPT0gMCkgcmV0dXJuO1xuXG4gICAgdmFyIHNpbXBsZW1kZSA9IG5ldyBTaW1wbGVNREUoe1xuICAgICAgICBlbGVtZW50OiAkY29udGVudFswXSxcbiAgICAgICAgc3BlbGxDaGVja2VyOiBmYWxzZSxcbiAgICAgICAgaW1hZ2VzTW9kYWxVcmw6IGltYWdlc01vZGFsVXJsLFxuICAgICAgICBpbWFnZXNNb2RhbEluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQoJyNpbWFnZXMtdXBsb2FkIGEnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2tsaWsgdXBsb2FkJyk7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5maW5kKCdpbnB1dCcpLmNsaWNrKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJCgnI2ltYWdlcy1yb3cgPiBkaXYnKS5ub3QoJyNpbWFnZXMtZW1wdHknKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xuXG4gICAgICAgICAgICAgICAgaW5pdEltYWdlU2VsZWN0b3IoJChlbGVtZW50KSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkKCcjaW1hZ2VzLXVwbG9hZCcpLmZpbGV1cGxvYWQoe1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBlbGVtZW50IHdpbGwgYWNjZXB0IGZpbGUgZHJhZy9kcm9wIHVwbG9hZGluZ1xuICAgICAgICAgICAgICAgIC8vIGRyb3Bab25lOiAkKCcjdXBsb2FkLWRyb3AnKSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIGF1dG9VcGxvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbWF4Q2h1bmtTaXplOiAxMDAwMDAwLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgc2VxdWVudGlhbFVwbG9hZHM6IHRydWUsXG4gICAgICAgICAgICAgICAgbG9hZGVyOiBmYWxzZSxcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gYSBmaWxlIGlzIGFkZGVkIHRvIHRoZSBxdWV1ZTtcbiAgICAgICAgICAgICAgICAvLyBlaXRoZXIgdmlhIHRoZSBicm93c2UgYnV0dG9uLCBvciB2aWEgZHJhZy9kcm9wOlxuICAgICAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJpbWFnZXMtcHJvZ3Jlc3MtYmFyXCIgY2xhc3M9XCJwcm9ncmVzc1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJcIiByb2xlPVwicHJvZ3Jlc3NiYXJcIiBhcmlhLXZhbHVlbm93PVwiMFwiIGFyaWEtdmFsdWVtaW49XCIwXCIgYXJpYS12YWx1ZW1heD1cIjEwMFwiIHN0eWxlPVwid2lkdGg6MCVcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj4wJTwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiaW1hZ2VzLXByb2dyZXNzLXZhbFwiPjAlPC9kaXY+JztcblxuICAgICAgICAgICAgICAgICAgICAkKCcjaW1hZ2VzLXVwbG9hZCcpLmFmdGVyKHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAoZSwgZGF0YSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBqcVhIUiA9IGRhdGEuc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZG9uZTogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGFsVXJsID0gaW1hZ2VNb2RhbFRodW1iLnJlcGxhY2UoJz8nLCBkYXRhLnJlc3VsdC5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFydGljbGVVcmwgPSBpbWFnZUFydGljbGVUaHVtYi5yZXBsYWNlKCc/JywgZGF0YS5yZXN1bHQuY29kZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogbW9kYWxVcmxcbiAgICAgICAgICAgICAgICAgICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQgPSAkKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLm1lZGlhLWZpbGUtbG9hZGVyJykubGFzdCgpLnJlcGxhY2VXaXRoKCRlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2ltYWdlcy1lbXB0eScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2ltYWdlcy1yb3cnKS5hcHBlbmQoJGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0SW1hZ2VTZWxlY3RvcigkZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmVycm9yKGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2h5YmEgcG9jYXMgem9icmF6b3ZhbmllIHVwbG9hZG51dGVobyBzdWJvcnVcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYXJ0aWNsZVVybFxuICAgICAgICAgICAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZWxlbWVudCA9ICQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjYXJ0aWNsZUltYWdlcyB1bCcpLmFwcGVuZCgkZWxlbWVudCk7XG5cblxuICAgICAgICAgICAgICAgICAgICB9KS5lcnJvcihmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNoeWJhIHBvY2FzIHpvYnJhem92YW5pZSB1cGxvYWRudXRlaG8gc3Vib3J1XCIpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBwcm9ncmVzc2FsbDogZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gcGFyc2VJbnQoZGF0YS5sb2FkZWQgLyBkYXRhLnRvdGFsICogMTAwLCAxMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHByb2dyZXNzQmFyID0gJCgnI2ltYWdlcy1wcm9ncmVzcy1iYXInKTtcbiAgICAgICAgICAgICAgICAgICAgJHByb2dyZXNzVmFsID0gJCgnI2ltYWdlcy1wcm9ncmVzcy12YWwnKTtcblxuICAgICAgICAgICAgICAgICAgICAkcHJvZ3Jlc3NCYXIuY3NzKHt3aWR0aDogcHJvZ3Jlc3MgKyAnJSd9KS5maW5kKCcuc3Itb25seScpLmh0bWwocHJvZ3Jlc3MgKyAnJScpO1xuICAgICAgICAgICAgICAgICAgICAkcHJvZ3Jlc3NWYWwuaHRtbChwcm9ncmVzcyArICclJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzID09IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHByb2dyZXNzQmFyLmFkZENsYXNzKCdwcm9ncmVzcy1iYXItc3VjY2VzcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRwcm9ncmVzc0Jhci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcHJvZ3Jlc3NWYWwucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbiB3aGVuIGEgZmlsZSBpcyBkcm9wcGVkIG9uIHRoZSB3aW5kb3dcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdkcm9wIGRyYWdvdmVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgIH0pO1xuXG4gICAgc2ltcGxlbWRlLmNvZGVtaXJyb3Iub24oJ3JlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgkKHNpbXBsZW1kZS5lbGVtZW50KS5jbG9zZXN0KCcuZm9ybS1ncm91cCcpLmZpbmQoJy5Db2RlTWlycm9yJykuaGFzQ2xhc3MoJ0NvZGVNaXJyb3ItZnVsbHNjcmVlbicpKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSAkKCcjY29udGVudC1uYXZpZ2F0aW9uJykud2lkdGgoKTtcbiAgICAgICAgICAgICQoJyNjb250ZW50LW5hdmlnYXRpb24nKS5jc3Moe1xuICAgICAgICAgICAgICAgICdwb3NpdGlvbic6ICdmaXhlZCcsXG4gICAgICAgICAgICAgICAgJ3RvcCc6ICc5MHB4JyxcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiB3aWR0aCArICdweCcsXG4gICAgICAgICAgICAgICAgJ21hcmdpbic6IDBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkKCcubmF2YmFyJykuYWRkQ2xhc3MoJ25hdmJhci1iZycpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkKCcjY29udGVudC1uYXZpZ2F0aW9uJykucmVtb3ZlQXR0cignc3R5bGUnKTtcblxuICAgICAgICAgICAgaWYgKCQod2luZG93KS5zY3JvbGxUb3AoKSA+IDIwKSB7XG4gICAgICAgICAgICAgICAgJCgnLm5hdmJhcicpLmFkZENsYXNzKCduYXZiYXItYmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICQoJy5uYXZiYXInKS5yZW1vdmVDbGFzcygnbmF2YmFyLWJnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHNpbXBsZW1kZS5jb2RlbWlycm9yLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCRub0Rlc2NDaGVjay5pcygnOmNoZWNrZWQnKSkge1xuICAgICAgICAgICAgJGRlc2NUZXh0LnZhbChzaW1wbGVtZGUudmFsdWUoKS5zdWJzdHJpbmcoMCwgZGVzY0xlbmd0aCkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkbm9EZXNjQ2hlY2suY2hhbmdlKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBpZiAoJG5vRGVzY0NoZWNrLmlzKCc6Y2hlY2tlZCcpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY2hlY2tlZCcpO1xuICAgICAgICAgICAgJGRlc2NUZXh0LmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSlcblxuICAgICAgICAgICAgJGRlc2NUZXh0LnZhbChzaW1wbGVtZGUudmFsdWUoKS50cmltKCkuc3Vic3RyaW5nKDAsIGRlc2NMZW5ndGgpKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ25vdCBjaGVja2VkJyk7XG4gICAgICAgICAgICAkZGVzY1RleHQucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gaW5pdEltYWdlU2VsZWN0b3IoJGVsZW1lbnQpIHtcbiAgICAgICAgJGVsZW1lbnQuZmluZCgnLmltYWdlcy1zcXVhcmUnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkaW1hZ2UgPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICAkaW1hZ2UuY2xvc2VzdCgnI2ltYWdlcy1yb3cnKS5maW5kKCcuaW1hZ2VzLXNxdWFyZScpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuXG4gICAgICAgICAgICAkaW1hZ2UuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcuaW1hZ2UtZGVsZXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIHZhciAkbGluayA9ICQodGhpcyk7XG5cbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHVybDogJGxpbmsuYXR0cignaHJlZicpLFxuICAgICAgICAgICAgbWV0aG9kOiAnZGVsZXRlJ1xuICAgICAgICB9KS5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgICRsaW5rLmNsb3Nlc3QoJ2xpJykucmVtb3ZlKCk7XG5cbiAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24gKGpxWEhSKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhqcVhIUik7XG4gICAgICAgIH0pXG5cblxuICAgIH0pXG5cblxufSk7IiwiJChmdW5jdGlvbigpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCgnI2ZsYXNoIGRpdi5hbGVydCcpLm5vdCgnLmFsZXJ0LWltcG9ydGFudCcpLmhpZGUoXCJzbGlkZVwiLCB7IGRpcmVjdGlvbjogXCJyaWdodFwiIH0sIDEwMDApO1xuICAgIH0sMzAwMCk7XG59KTtcblxuXG5cbiQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcuYnRuLW1vZGFsJywgZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHZhciAkbGluayA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ2EnKTtcblxuICAgICQuYWpheCh7XG4gICAgICAgIHVybDogJGxpbmsuYXR0cignaHJlZicpXG4gICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgJG1vZGFsID0gJChkYXRhKTtcblxuICAgICAgICAkKCdib2R5JykuYXBwZW5kKCRtb2RhbCk7XG4gICAgICAgICRtb2RhbC5tb2RhbCgpO1xuXG4gICAgICAgICRtb2RhbC5maW5kKCcuYnRuLmNhbmNlbCcpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMuY2FuY2VsLmNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FuY2VsLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRtb2RhbC5maW5kKCcuYnRuLnN1Y2Nlc3MnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zLnN1Y2Nlc3MuY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRtb2RhbC5tb2RhbCgnaGlkZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkbW9kYWwub24oJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAkbW9kYWwucmVtb3ZlKCk7XG4gICAgICAgICAgICAkKCcubW9kYWwtYmFja2Ryb3AnKS5yZW1vdmUoKTtcbiAgICAgICAgfSlcbiAgICB9KS5lcnJvcihmdW5jdGlvbiAoKSB7XG5cbiAgICB9KTtcbn0pO1xuXG5cbmZ1bmN0aW9uIGFsZXJ0KG9wdGlvbnMpIHtcbiAgICB2YXIgJG1vZGFsID1cbiAgICAgICAgJCgnPGRpdiBjbGFzcz1cIm1vZGFsIGZhZGVcIiB0YWJpbmRleD1cIi0xXCIgcm9sZT1cImRpYWxvZ1wiPicgK1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJtb2RhbC1kaWFsb2dcIiByb2xlPVwiZG9jdW1lbnRcIj4nICtcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudFwiPicgK1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj4nICtcbiAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNsb3NlXCIgZGF0YS1kaXNtaXNzPVwibW9kYWxcIiBhcmlhLWxhYmVsPVwiQ2xvc2VcIj48c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPjwvYnV0dG9uPicgK1xuICAgICAgICAgICAgJzxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+JyArIG9wdGlvbnMudGl0bGUgKyAnPC9oND4nICtcbiAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPicgKyBvcHRpb25zLmJvZHkgKyAnPC9kaXY+JyArXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPicgK1xuICAgICAgICAgICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGNhbmNlbCBidG4tJyArIG9wdGlvbnMuY2FuY2VsLmNsYXNzICsgJ1wiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCI+JyArIG9wdGlvbnMuY2FuY2VsLnRpdGxlICsgJzwvYnV0dG9uPicgK1xuICAgICAgICAgICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIHN1Y2Nlc3MgYnRuLScgKyBvcHRpb25zLnN1Y2Nlc3MuY2xhc3MgKyAnXCI+JyArIG9wdGlvbnMuc3VjY2Vzcy50aXRsZSArICc8L2J1dHRvbj4nICtcbiAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICc8L2Rpdj4nKTtcblxuXG4gICAgJCgnYm9keScpLmFwcGVuZCgkbW9kYWwpO1xuICAgICRtb2RhbC5tb2RhbCgpO1xuXG4gICAgJG1vZGFsLmZpbmQoJy5idG4uY2FuY2VsJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zLmNhbmNlbC5jYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FuY2VsLmNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgO1xuXG4gICAgfSk7XG5cbiAgICAkbW9kYWwuZmluZCgnLmJ0bi5zdWNjZXNzJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zLnN1Y2Nlc3MuY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MuY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgICRtb2RhbC5tb2RhbCgnaGlkZScpO1xuICAgIH0pO1xuXG4gICAgJG1vZGFsLm9uKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAkbW9kYWwucmVtb3ZlKCk7XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gbW9kYWwob3B0aW9ucykge1xuICAgICQuYWpheCh7XG4gICAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgJG1vZGFsID0gJChkYXRhKTtcblxuICAgICAgICAkKCdib2R5JykuYXBwZW5kKCRtb2RhbCk7XG4gICAgICAgICRtb2RhbC5tb2RhbCgnc2hvdycpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMuaW5pdCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaW5pdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgJG1vZGFsLmZpbmQoJy5idG4uY2FuY2VsJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucy5jYW5jZWwuY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jYW5jZWwuY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcblxuICAgICAgICB9KTtcblxuICAgICAgICAkbW9kYWwuZmluZCgnLmJ0bi5zdWNjZXNzJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucy5zdWNjZXNzLmNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3VjY2Vzcy5jYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgJG1vZGFsLm1vZGFsKCdoaWRlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRtb2RhbC5vbignaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICRtb2RhbC5yZW1vdmUoKTtcbiAgICAgICAgICAgICQoJy5tb2RhbC1iYWNrZHJvcCcpLnJlbW92ZSgpO1xuICAgICAgICB9KVxuICAgIH0pLmVycm9yKGZ1bmN0aW9uICgpIHtcblxuICAgIH0pO1xuXG5cbn0iLCIkKHdpbmRvdykuc2Nyb2xsKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2Nyb2xsICAgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG4gICAgdmFyICRzaWRlYmFyID0gJCgnLnNpZGViYXItd3JhcHBlcicpO1xuXG4gICAgaWYgKHNjcm9sbCA+IDIwKSB7XG4gICAgICAgICQoJy5uYXZiYXInKS5hZGRDbGFzcygnbmF2YmFyLWJnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAkKCcubmF2YmFyJykucmVtb3ZlQ2xhc3MoJ25hdmJhci1iZycpO1xuICAgIH1cblxufSk7XG4kKHdpbmRvdykubG9hZChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcm9sbCA9ICQod2luZG93KS5zY3JvbGxUb3AoKTtcbiAgICBpZiAoc2Nyb2xsID4gMjApIHtcbiAgICAgICAgJCgnLm5hdmJhcicpLmFkZENsYXNzKCduYXZiYXItYmcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICQoJy5uYXZiYXInKS5yZW1vdmVDbGFzcygnbmF2YmFyLWJnJyk7XG4gICAgfVxuXG59KTtcbiIsIiQuYWpheFNldHVwKHtcblx0aGVhZGVyczogeydYLUNTUkYtVG9rZW4nOiAkKCdtZXRhW25hbWU9X3Rva2VuXScpLmF0dHIoJ2NvbnRlbnQnKX1cbn0pO1xuXG4kKCcuanMtc2VsZWN0Jykuc2VsZWN0MigpO1xuXG4kKCcuZGF0ZXBpY2tlcicpLmRhdGVwaWNrZXIoe1xuICAgIGxhbmd1YWdlOiAnc2snLFxuICAgIGZvcm1hdDogJ2RkLiBtbS4geXl5eScsXG59KTtcbiJdfQ==
